{
	"repo": "https://github.com/javaparser/javaparser.git",
	"file": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
	"method": {
		"longName": "JavaParserFacade::convertToUsage(com.github.javaparser.ast.type.Type type, Context context)",
		"startLine": 519,
		"methodName": "convertToUsage",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "protected"
	},
	"history": {
		"427dd53b9ebedcb0bdb687007eb0faf2de734df4": {
			"type": "Ybodychange",
			"commitMessage": "Better error handling for \"var\" inferrer.\n",
			"commitDate": "2018-02-14, 11:49 AM",
			"commitName": "427dd53b9ebedcb0bdb687007eb0faf2de734df4",
			"commitAuthor": "Danny van Bruggen",
			"commitDateOld": "2018-02-14, 10:42 AM",
			"commitNameOld": "6d59e3083ed82de3490c2f5ca35a07bb73806fea",
			"commitAuthorOld": "Danny van Bruggen",
			"daysBetweenCommits": 0.05,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,54 +1,60 @@\n     protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (context == null) {\n             throw new NullPointerException(\"Context should not be null\");\n         }\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<ResolvedType> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                     return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                 return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n                 return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                 return ResolvedWildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return ResolvedVoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else if (type instanceof UnionType) {\n             UnionType unionType = (UnionType) type;\n             return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n         } else if (type instanceof VarType) {\n-            final VariableDeclarator variableDeclarator = (VariableDeclarator)type.getParentNode().get();\n-            return variableDeclarator.getInitializer().get().calculateResolvedType();\n+            Node parent = type.getParentNode().get();\n+            if (!(parent instanceof VariableDeclarator)) {\n+                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n+            }\n+            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n+            return variableDeclarator.getInitializer()\n+                    .map(Expression::calculateResolvedType)\n+                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6d59e3083ed82de3490c2f5ca35a07bb73806fea": {
			"type": "Ybodychange",
			"commitMessage": "Make a simple \"var\" inferrer.\n",
			"commitDate": "2018-02-14, 10:42 AM",
			"commitName": "6d59e3083ed82de3490c2f5ca35a07bb73806fea",
			"commitAuthor": "Danny van Bruggen",
			"commitDateOld": "2018-02-03, 11:46 AM",
			"commitNameOld": "b54617e765d73b3ce0d187cf12ad8da382bce439",
			"commitAuthorOld": "Danny van Bruggen",
			"daysBetweenCommits": 10.96,
			"commitsBetweenForRepo": 19,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,51 +1,54 @@\n     protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (context == null) {\n             throw new NullPointerException(\"Context should not be null\");\n         }\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<ResolvedType> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                     return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                 return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n                 return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                 return ResolvedWildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return ResolvedVoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else if (type instanceof UnionType) {\n             UnionType unionType = (UnionType) type;\n             return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n+        } else if (type instanceof VarType) {\n+            final VariableDeclarator variableDeclarator = (VariableDeclarator)type.getParentNode().get();\n+            return variableDeclarator.getInitializer().get().calculateResolvedType();\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b54617e765d73b3ce0d187cf12ad8da382bce439": {
			"type": "Ybodychange",
			"commitMessage": "Cleaning up JSS code\n",
			"commitDate": "2018-02-03, 11:46 AM",
			"commitName": "b54617e765d73b3ce0d187cf12ad8da382bce439",
			"commitAuthor": "Danny van Bruggen",
			"commitDateOld": "2018-01-10, 5:52 AM",
			"commitNameOld": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 24.25,
			"commitsBetweenForRepo": 68,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,51 +1,51 @@\n     protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (context == null) {\n             throw new NullPointerException(\"Context should not be null\");\n         }\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<ResolvedType> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                     return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n-            if (wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n-                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n-            } else if (!wildcardType.getExtendedTypes().isPresent() && wildcardType.getSuperTypes().isPresent()) {\n-                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n-            } else if (!wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n+            if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n+                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n+            } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n+                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n+            } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                 return ResolvedWildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return ResolvedVoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else if (type instanceof UnionType) {\n-            UnionType unionType = (UnionType)type;\n+            UnionType unionType = (UnionType) type;\n             return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"09232ff6b0ea19e850482f3a87ac6ef1c063c759": {
			"type": "Yfilerename",
			"commitMessage": "rename JSS modules\n",
			"commitDate": "2018-01-10, 5:52 AM",
			"commitName": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2018-01-10, 1:01 AM",
			"commitNameOld": "30c04db173cc439556df2a238c99cd81ada320ff",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.2,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
				"newPath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java"
			}
		},
		"f63811a47591d89b25a1de78686bdc6dfcaf42b9": {
			"type": "Ybodychange",
			"commitMessage": "adding support to resolve union types\n",
			"commitDate": "2017-11-25, 4:15 AM",
			"commitName": "f63811a47591d89b25a1de78686bdc6dfcaf42b9",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-11-25, 1:49 AM",
			"commitNameOld": "478a9ba268137913d67438b1e3c8f61e5e0976a5",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.1,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,48 +1,51 @@\n     protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (context == null) {\n             throw new NullPointerException(\"Context should not be null\");\n         }\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<ResolvedType> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                     return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n                 return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() && wildcardType.getSuperTypes().isPresent()) {\n                 return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n                 return ResolvedWildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return ResolvedVoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n+        } else if (type instanceof UnionType) {\n+            UnionType unionType = (UnionType)type;\n+            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"478a9ba268137913d67438b1e3c8f61e5e0976a5": {
			"type": "Ybodychange",
			"commitMessage": "adding tests for #343 and improving error messages for nodes outside the AST\n",
			"commitDate": "2017-11-25, 1:49 AM",
			"commitName": "478a9ba268137913d67438b1e3c8f61e5e0976a5",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-11-07, 1:09 PM",
			"commitNameOld": "23a829996b5393fc6697d51b1d3ec332157b1279",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 17.53,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,48 @@\n     protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+        if (context == null) {\n+            throw new NullPointerException(\"Context should not be null\");\n+        }\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<ResolvedType> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                     return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n                 return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() && wildcardType.getSuperTypes().isPresent()) {\n                 return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n                 return ResolvedWildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return ResolvedVoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"198ba6cbe49832ac09ca84c6920e9be661a3b56a": {
			"type": "Ybodychange",
			"commitMessage": "issue1154: correct most compilation errors in the jp model\n",
			"commitDate": "2017-09-29, 12:30 AM",
			"commitName": "198ba6cbe49832ac09ca84c6920e9be661a3b56a",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-09-28, 2:36 PM",
			"commitNameOld": "5d8d0cb7947efcf2282f7d056302dd905f348532",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.41,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,45 @@\n     protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n-            SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n+            SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n-            TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n+            ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<ResolvedType> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n-                if (typeDeclaration instanceof TypeParameterDeclaration) {\n-                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n+                if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n+                    return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n+                    return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n-                return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n+                return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n-            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n+            return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n                 return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() && wildcardType.getSuperTypes().isPresent()) {\n                 return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n                 return ResolvedWildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return ResolvedVoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5d8d0cb7947efcf2282f7d056302dd905f348532": {
			"type": "Ymultichange(Yreturntypechange,Ybodychange)",
			"commitMessage": "more work on converting to moved classes\n",
			"commitDate": "2017-09-28, 2:36 PM",
			"commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
			"commitAuthor": "Federico Tomassetti",
			"subchanges": [
				{
					"type": "Yreturntypechange",
					"commitMessage": "more work on converting to moved classes\n",
					"commitDate": "2017-09-28, 2:36 PM",
					"commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2017-09-28, 1:35 PM",
					"commitNameOld": "c3dc3669e86f005080c02e62162356022eafaac1",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.04,
					"commitsBetweenForRepo": 2,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,45 +1,45 @@\n-    protected Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+    protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n-            List<Type> typeParameters = Collections.emptyList();\n+            List<ResolvedType> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n-                return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n+                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() && wildcardType.getSuperTypes().isPresent()) {\n-                return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n+                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n-                return Wildcard.UNBOUNDED;\n+                return ResolvedWildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n-            return VoidType.INSTANCE;\n+            return ResolvedVoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n-            return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n+            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "Type",
						"newValue": "ResolvedType"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "more work on converting to moved classes\n",
					"commitDate": "2017-09-28, 2:36 PM",
					"commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2017-09-28, 1:35 PM",
					"commitNameOld": "c3dc3669e86f005080c02e62162356022eafaac1",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.04,
					"commitsBetweenForRepo": 2,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,45 +1,45 @@\n-    protected Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+    protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n-            List<Type> typeParameters = Collections.emptyList();\n+            List<ResolvedType> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n-                return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n+                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() && wildcardType.getSuperTypes().isPresent()) {\n-                return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n+                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n-                return Wildcard.UNBOUNDED;\n+                return ResolvedWildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n-            return VoidType.INSTANCE;\n+            return ResolvedVoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n-            return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n+            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"56377a22d552f0880ceccacf1aca1eafbc7094e4": {
			"type": "Ymodifierchange",
			"commitMessage": "Switch method to protected as it wasn't originally public\n",
			"commitDate": "2017-02-13, 4:59 PM",
			"commitName": "56377a22d552f0880ceccacf1aca1eafbc7094e4",
			"commitAuthor": "xdrop",
			"commitDateOld": "2017-02-13, 4:49 PM",
			"commitNameOld": "0f40221492b47df25615a1b5909fefa6f2d6fa0e",
			"commitAuthorOld": "xdrop",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,45 @@\n-    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+    protected Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<Type> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() && wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[public]",
				"newValue": "[protected]"
			}
		},
		"0f40221492b47df25615a1b5909fefa6f2d6fa0e": {
			"type": "Ymodifierchange",
			"commitMessage": "Refactored out huge method from facade to visitor\n",
			"commitDate": "2017-02-13, 4:49 PM",
			"commitName": "0f40221492b47df25615a1b5909fefa6f2d6fa0e",
			"commitAuthor": "xdrop",
			"commitDateOld": "2017-02-01, 5:04 PM",
			"commitNameOld": "a12a91a78591323403230d5654879a44ab4afb20",
			"commitAuthorOld": "Brandon Fergerson",
			"daysBetweenCommits": 11.99,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,45 @@\n-    private Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<Type> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() && wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[private]",
				"newValue": "[public]"
			}
		},
		"33d37d1089463ba9af543996a05cac5955c46251": {
			"type": "Ybodychange",
			"commitMessage": "Fixed issue when converting wildcard type with super bound\n",
			"commitDate": "2017-01-12, 10:17 AM",
			"commitName": "33d37d1089463ba9af543996a05cac5955c46251",
			"commitAuthor": "xdrop",
			"commitDateOld": "2017-01-11, 5:45 PM",
			"commitNameOld": "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
			"commitAuthorOld": "xdrop",
			"daysBetweenCommits": 0.69,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,45 @@\n     private Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<Type> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() && wildcardType.getSuperTypes().isPresent()) {\n-                return Wildcard.extendsBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n+                return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"90c22f84a61e12130a8750d235acf7ed06305796": {
			"type": "Yparameterchange",
			"commitMessage": "migration to JavaParser 3.0.0-RC.3\n",
			"commitDate": "2016-12-19, 9:01 AM",
			"commitName": "90c22f84a61e12130a8750d235acf7ed06305796",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-12-13, 12:42 PM",
			"commitNameOld": "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 5.85,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,45 @@\n-    private Type convertToUsage(com.github.javaparser.ast.type.Type<?> type, Context context) {\n+    private Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<Type> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() && wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.extendsBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n             } else if (!wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[type-com.github.javaparser.ast.type.Type<?>, context-Context]",
				"newValue": "[type-com.github.javaparser.ast.type.Type, context-Context]"
			}
		},
		"52b60cf471dc9d7b53d8f22018d9c4e4fcc15923": {
			"type": "Ybodychange",
			"commitMessage": "porting to JavaParser 3.0.0 RC2\n",
			"commitDate": "2016-12-13, 12:42 PM",
			"commitName": "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-12-13, 9:45 AM",
			"commitNameOld": "cb5ffb7fdd56f1b768d25da330fa3b29ecb74eaf",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.12,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,45 @@\n     private Type convertToUsage(com.github.javaparser.ast.type.Type<?> type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<Type> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n-            if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n-                return Wildcard.extendsBound(convertToUsage(wildcardType.getExtends().get(), context)); // removed (ReferenceTypeImpl) \n-            } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n-                return Wildcard.extendsBound(convertToUsage(wildcardType.getSuper().get(), context)); // removed (ReferenceTypeImpl) \n-            } else if (!wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n+            if (wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n+                return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context)); // removed (ReferenceTypeImpl)\n+            } else if (!wildcardType.getExtendedTypes().isPresent() && wildcardType.getSuperTypes().isPresent()) {\n+                return Wildcard.extendsBound(convertToUsage(wildcardType.getSuperTypes().get(), context)); // removed (ReferenceTypeImpl)\n+            } else if (!wildcardType.getExtendedTypes().isPresent() && !wildcardType.getSuperTypes().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"07782fbbe149055d495e0c358da844734c08641f": {
			"type": "Ymodifierchange",
			"commitMessage": "reformat JavaParserFacade\n",
			"commitDate": "2016-12-13, 9:41 AM",
			"commitName": "07782fbbe149055d495e0c358da844734c08641f",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-12-13, 6:10 AM",
			"commitNameOld": "c990d23490f5c4ac4322119b03d5951b63eef055",
			"commitAuthorOld": "Fred Lefvre-Laoide",
			"daysBetweenCommits": 0.15,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,45 @@\n-    public Type convertToUsage(com.github.javaparser.ast.type.Type<?> type, Context context) {\n+    private Type convertToUsage(com.github.javaparser.ast.type.Type<?> type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<Type> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound(convertToUsage(wildcardType.getExtends().get(), context)); // removed (ReferenceTypeImpl) \n             } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound(convertToUsage(wildcardType.getSuper().get(), context)); // removed (ReferenceTypeImpl) \n             } else if (!wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[public]",
				"newValue": "[private]"
			}
		},
		"c990d23490f5c4ac4322119b03d5951b63eef055": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "loads of changes to support our code",
			"commitDate": "2016-12-13, 6:10 AM",
			"commitName": "c990d23490f5c4ac4322119b03d5951b63eef055",
			"commitAuthor": "Fred Lefvre-Laoide",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "loads of changes to support our code",
					"commitDate": "2016-12-13, 6:10 AM",
					"commitName": "c990d23490f5c4ac4322119b03d5951b63eef055",
					"commitAuthor": "Fred Lefvre-Laoide",
					"commitDateOld": "2016-11-21, 1:52 PM",
					"commitNameOld": "dfebf682a440aa48a8a444562f7fdfc1819b9a1e",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 21.68,
					"commitsBetweenForRepo": 3,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,45 +1,45 @@\n-    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+    public Type convertToUsage(com.github.javaparser.ast.type.Type<?> type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<Type> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n-                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n+                return Wildcard.extendsBound(convertToUsage(wildcardType.getExtends().get(), context)); // removed (ReferenceTypeImpl) \n             } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n-                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n+                return Wildcard.extendsBound(convertToUsage(wildcardType.getSuper().get(), context)); // removed (ReferenceTypeImpl) \n             } else if (!wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[type-com.github.javaparser.ast.type.Type, context-Context]",
						"newValue": "[type-com.github.javaparser.ast.type.Type<?>, context-Context]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "loads of changes to support our code",
					"commitDate": "2016-12-13, 6:10 AM",
					"commitName": "c990d23490f5c4ac4322119b03d5951b63eef055",
					"commitAuthor": "Fred Lefvre-Laoide",
					"commitDateOld": "2016-11-21, 1:52 PM",
					"commitNameOld": "dfebf682a440aa48a8a444562f7fdfc1819b9a1e",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 21.68,
					"commitsBetweenForRepo": 3,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,45 +1,45 @@\n-    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+    public Type convertToUsage(com.github.javaparser.ast.type.Type<?> type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<Type> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n-                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n+                return Wildcard.extendsBound(convertToUsage(wildcardType.getExtends().get(), context)); // removed (ReferenceTypeImpl) \n             } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n-                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n+                return Wildcard.extendsBound(convertToUsage(wildcardType.getSuper().get(), context)); // removed (ReferenceTypeImpl) \n             } else if (!wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"6e1380f412d334f1c887d15edf0b4610c3cf0da2": {
			"type": "Ybodychange",
			"commitMessage": "adapt to alpha.10\n",
			"commitDate": "2016-11-21, 11:58 AM",
			"commitName": "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-11-09, 10:15 AM",
			"commitNameOld": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 12.07,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,45 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<Type> typeParameters = Collections.emptyList();\n-            if (classOrInterfaceType.getTypeArguments() != null) {\n-                typeParameters = classOrInterfaceType.getTypeArguments().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n+            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n+                typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n-            if (wildcardType.getExtends() !=null && wildcardType.getSuper() == null) {\n-                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n-            } else if (wildcardType.getExtends() ==null && wildcardType.getSuper() != null) {\n-                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n-            } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n+            if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n+            } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n+            } else if (!wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5": {
			"type": "Ybodychange",
			"commitMessage": "changes necessary to support jpalpha8\n",
			"commitDate": "2016-11-09, 10:15 AM",
			"commitName": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-11-06, 1:40 AM",
			"commitNameOld": "c746c4ef7711a05c27827ab749d96155046a4f91",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 3.36,
			"commitsBetweenForRepo": 18,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,45 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<Type> typeParameters = Collections.emptyList();\n-            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n-                typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n+            if (classOrInterfaceType.getTypeArguments() != null) {\n+                typeParameters = classOrInterfaceType.getTypeArguments().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n-            if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n-                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n-            } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n-                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n-            } else if (!wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n+            if (wildcardType.getExtends() !=null && wildcardType.getSuper() == null) {\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n+            } else if (wildcardType.getExtends() ==null && wildcardType.getSuper() != null) {\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n+            } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a1c7c58143a592965f8378767adc69709e4c0043": {
			"type": "Ybodychange",
			"commitMessage": "more refactoring for ReferenceTypeDeclaration\n",
			"commitDate": "2016-11-05, 9:22 AM",
			"commitName": "a1c7c58143a592965f8378767adc69709e4c0043",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-11-05, 9:08 AM",
			"commitNameOld": "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,45 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n-            SymbolReference<ReferenceTypeDeclaration> ref = context.solveType(name, typeSolver);\n+            SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n-            ReferenceTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n+            TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<Type> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n-                return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n+                return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n             } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n             } else if (!wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6df1aa26f75ff0d716a1290007e2b63cc05001ae": {
			"type": "Ybodychange",
			"commitMessage": "creating ReferenceTypeDeclaration\n",
			"commitDate": "2016-11-05, 9:08 AM",
			"commitName": "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-11-05, 1:58 AM",
			"commitNameOld": "2fde8a6409906ab1e0b5e846f2e54b82da7878b7",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.3,
			"commitsBetweenForRepo": 16,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,45 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n-            SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n+            SymbolReference<ReferenceTypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n-            TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n+            ReferenceTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<Type> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n             } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n             } else if (!wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b32947e8c85bc21fe533173f50d4a0a91036fdaf": {
			"type": "Ybodychange",
			"commitMessage": "adding more comments in model declarations\n",
			"commitDate": "2016-10-21, 12:55 AM",
			"commitName": "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-20, 2:06 PM",
			"commitNameOld": "1e7780e554428a10c73de88ca64e5933b2291593",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.45,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,45 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<Type> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n-            if (typeDeclaration.isTypeVariable()) {\n+            if (typeDeclaration.isTypeParameter()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n             } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n             } else if (!wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n             com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType) type;\n             return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9c53c2cbc607ea694438ade8630be0c155a33162": {
			"type": "Yfilerename",
			"commitMessage": "renamed packages to com.github.javapaerser\n",
			"commitDate": "2016-10-20, 12:39 AM",
			"commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-20, 12:32 AM",
			"commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
				"newPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java"
			}
		},
		"4601dfb9d1acf7f564948b7ddbb9201d62849ad7": {
			"type": "Ybodychange",
			"commitMessage": "revision of modified code to use Navigator.getParentNode\n",
			"commitDate": "2016-10-19, 11:35 AM",
			"commitName": "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-19, 11:34 AM",
			"commitNameOld": "03e407957d600a18ef0a4a83224c17d155ef8645",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,42 +1,45 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<Type> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n             } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n             } else if (!wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n+        } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n+            com.github.javaparser.ast.type.ArrayType jpArrayType = (com.github.javaparser.ast.type.ArrayType)type;\n+            return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3fcd7b41f404d112b13d3bfe732b26eceec0dbfe": {
			"type": "Ybodychange",
			"commitMessage": "issue91: JavaParserClassDeclarationTest passing\n",
			"commitDate": "2016-10-19, 11:33 AM",
			"commitName": "3fcd7b41f404d112b13d3bfe732b26eceec0dbfe",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-19, 11:33 AM",
			"commitNameOld": "33753cab1604a44d43215ba4055b435606a7a71b",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,42 +1,42 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<Type> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n-            if (wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n+            if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n             } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n-            } else if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n+            } else if (!wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n-                throw new UnsupportedOperationException();\n+                throw new UnsupportedOperationException(wildcardType.toString());\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"33753cab1604a44d43215ba4055b435606a7a71b": {
			"type": "Ybodychange",
			"commitMessage": "issue91: first fixes\n",
			"commitDate": "2016-10-19, 11:33 AM",
			"commitName": "33753cab1604a44d43215ba4055b435606a7a71b",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-19, 11:33 AM",
			"commitNameOld": "341e081a5f8909a3a467671befcca2941b786d3d",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,46 +1,42 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n-        if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n-            com.github.javaparser.ast.type.ReferenceType referenceType = (com.github.javaparser.ast.type.ReferenceType) type;\n-            Type typeUsage = convertToUsage(referenceType, context);\n-            return typeUsage;\n-        } else if (type instanceof ClassOrInterfaceType) {\n+        if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<Type> typeParameters = Collections.emptyList();\n-            if (classOrInterfaceType.getTypeArguments() != null) {\n+            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n             } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n             } else if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"341e081a5f8909a3a467671befcca2941b786d3d": {
			"type": "Ybodychange",
			"commitMessage": "issue91: solve compilation issues\n",
			"commitDate": "2016-10-19, 11:33 AM",
			"commitName": "341e081a5f8909a3a467671befcca2941b786d3d",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-19, 9:04 AM",
			"commitNameOld": "683012de2a3a28358e848f8b145d462eb8b322ba",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.1,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,49 +1,46 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n             com.github.javaparser.ast.type.ReferenceType referenceType = (com.github.javaparser.ast.type.ReferenceType) type;\n-            Type typeUsage = convertToUsage(referenceType.getType(), context);\n-            for (int i = 0; i < referenceType.getArrayCount(); i++) {\n-                typeUsage = new ArrayType(typeUsage);\n-            }\n+            Type typeUsage = convertToUsage(referenceType, context);\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<Type> typeParameters = Collections.emptyList();\n-            if (classOrInterfaceType.getTypeArgs() != null) {\n-                typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n+            if (classOrInterfaceType.getTypeArguments() != null) {\n+                typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n                     return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n-            if (wildcardType.getExtends() != null && wildcardType.getSuper() == null) {\n-                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n-            } else if (wildcardType.getExtends() == null && wildcardType.getSuper() != null) {\n-                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n-            } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n+            if (wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n+            } else if (!wildcardType.getExtends().isPresent() && wildcardType.getSuper().isPresent()) {\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n+            } else if (wildcardType.getExtends().isPresent() && !wildcardType.getSuper().isPresent()) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d6a1f32f00bd513d6bc56fbbfefcb9ae9c706492": {
			"type": "Ybodychange",
			"commitMessage": "rename to typevariable and add comment\n",
			"commitDate": "2016-10-17, 2:00 PM",
			"commitName": "d6a1f32f00bd513d6bc56fbbfefcb9ae9c706492",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-16, 10:48 AM",
			"commitNameOld": "f271890077d290431fd7cdc45e3bf172fb2f834c",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 1.13,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,49 +1,49 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n             com.github.javaparser.ast.type.ReferenceType referenceType = (com.github.javaparser.ast.type.ReferenceType) type;\n             Type typeUsage = convertToUsage(referenceType.getType(), context);\n             for (int i = 0; i < referenceType.getArrayCount(); i++) {\n                 typeUsage = new ArrayType(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<Type> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameterDeclaration) {\n-                    return new TypeParameter((TypeParameterDeclaration) typeDeclaration);\n+                    return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                    return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n+                    return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtends() != null && wildcardType.getSuper() == null) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n             } else if (wildcardType.getExtends() == null && wildcardType.getSuper() != null) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n             } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ecc78c8b480ceb41019f764c983aaa69c2dabfe3": {
			"type": "Ybodychange",
			"commitMessage": "reorganize packages in model\n",
			"commitDate": "2016-10-14, 10:51 AM",
			"commitName": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-14, 12:19 AM",
			"commitNameOld": "6b50c90daa764492e074198460c807d83d52325e",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.44,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,49 +1,49 @@\n     public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n         if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n             com.github.javaparser.ast.type.ReferenceType referenceType = (com.github.javaparser.ast.type.ReferenceType) type;\n             Type typeUsage = convertToUsage(referenceType.getType(), context);\n             for (int i = 0; i < referenceType.getArrayCount(); i++) {\n                 typeUsage = new ArrayType(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<Type> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n-                if (typeDeclaration instanceof me.tomassetti.symbolsolver.model.resolution.TypeParameter) {\n-                    return new TypeParameter((me.tomassetti.symbolsolver.model.resolution.TypeParameter) typeDeclaration);\n+                if (typeDeclaration instanceof TypeParameterDeclaration) {\n+                    return new TypeParameter((TypeParameterDeclaration) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n             return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtends() != null && wildcardType.getSuper() == null) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n             } else if (wildcardType.getExtends() == null && wildcardType.getSuper() != null) {\n                 return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n             } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n                 return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n         } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n             return VoidType.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"82eb44707b620803d424188a1eb8708fcaf093cb": {
			"type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
			"commitMessage": "rename TypeUsage into Type\n",
			"commitDate": "2016-10-13, 2:11 PM",
			"commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
			"commitAuthor": "Federico Tomassetti",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "rename TypeUsage into Type\n",
					"commitDate": "2016-10-13, 2:11 PM",
					"commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-13, 6:20 AM",
					"commitNameOld": "14c9305d49885a12acdb7c09d2e35ad29b5403cf",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.33,
					"commitsBetweenForRepo": 13,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,49 +1,49 @@\n-    public TypeUsage convertToUsage(Type type, Context context) {\n-        if (type instanceof ReferenceType) {\n-            ReferenceType referenceType = (ReferenceType) type;\n-            TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n+    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+        if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n+            com.github.javaparser.ast.type.ReferenceType referenceType = (com.github.javaparser.ast.type.ReferenceType) type;\n+            Type typeUsage = convertToUsage(referenceType.getType(), context);\n             for (int i = 0; i < referenceType.getArrayCount(); i++) {\n-                typeUsage = new ArrayTypeUsage(typeUsage);\n+                typeUsage = new ArrayType(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n-            List<TypeUsage> typeParameters = Collections.emptyList();\n+            List<Type> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n-                if (typeDeclaration instanceof TypeParameter) {\n-                    return new TypeParameterUsage((TypeParameter) typeDeclaration);\n+                if (typeDeclaration instanceof me.tomassetti.symbolsolver.model.resolution.TypeParameter) {\n+                    return new TypeParameter((me.tomassetti.symbolsolver.model.resolution.TypeParameter) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n+                    return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n-                return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n+                return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n-        } else if (type instanceof PrimitiveType) {\n-            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n+        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n+            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtends() != null && wildcardType.getSuper() == null) {\n-                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n             } else if (wildcardType.getExtends() == null && wildcardType.getSuper() != null) {\n-                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n             } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n-                return WildcardUsage.UNBOUNDED;\n+                return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n-        } else if (type instanceof VoidType) {\n-            return VoidTypeUsage.INSTANCE;\n+        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n+            return VoidType.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[type-Type, context-Context]",
						"newValue": "[type-com.github.javaparser.ast.type.Type, context-Context]"
					}
				},
				{
					"type": "Yreturntypechange",
					"commitMessage": "rename TypeUsage into Type\n",
					"commitDate": "2016-10-13, 2:11 PM",
					"commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-13, 6:20 AM",
					"commitNameOld": "14c9305d49885a12acdb7c09d2e35ad29b5403cf",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.33,
					"commitsBetweenForRepo": 13,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,49 +1,49 @@\n-    public TypeUsage convertToUsage(Type type, Context context) {\n-        if (type instanceof ReferenceType) {\n-            ReferenceType referenceType = (ReferenceType) type;\n-            TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n+    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+        if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n+            com.github.javaparser.ast.type.ReferenceType referenceType = (com.github.javaparser.ast.type.ReferenceType) type;\n+            Type typeUsage = convertToUsage(referenceType.getType(), context);\n             for (int i = 0; i < referenceType.getArrayCount(); i++) {\n-                typeUsage = new ArrayTypeUsage(typeUsage);\n+                typeUsage = new ArrayType(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n-            List<TypeUsage> typeParameters = Collections.emptyList();\n+            List<Type> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n-                if (typeDeclaration instanceof TypeParameter) {\n-                    return new TypeParameterUsage((TypeParameter) typeDeclaration);\n+                if (typeDeclaration instanceof me.tomassetti.symbolsolver.model.resolution.TypeParameter) {\n+                    return new TypeParameter((me.tomassetti.symbolsolver.model.resolution.TypeParameter) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n+                    return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n-                return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n+                return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n-        } else if (type instanceof PrimitiveType) {\n-            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n+        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n+            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtends() != null && wildcardType.getSuper() == null) {\n-                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n             } else if (wildcardType.getExtends() == null && wildcardType.getSuper() != null) {\n-                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n             } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n-                return WildcardUsage.UNBOUNDED;\n+                return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n-        } else if (type instanceof VoidType) {\n-            return VoidTypeUsage.INSTANCE;\n+        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n+            return VoidType.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "TypeUsage",
						"newValue": "Type"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "rename TypeUsage into Type\n",
					"commitDate": "2016-10-13, 2:11 PM",
					"commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-13, 6:20 AM",
					"commitNameOld": "14c9305d49885a12acdb7c09d2e35ad29b5403cf",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.33,
					"commitsBetweenForRepo": 13,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,49 +1,49 @@\n-    public TypeUsage convertToUsage(Type type, Context context) {\n-        if (type instanceof ReferenceType) {\n-            ReferenceType referenceType = (ReferenceType) type;\n-            TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n+    public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+        if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n+            com.github.javaparser.ast.type.ReferenceType referenceType = (com.github.javaparser.ast.type.ReferenceType) type;\n+            Type typeUsage = convertToUsage(referenceType.getType(), context);\n             for (int i = 0; i < referenceType.getArrayCount(); i++) {\n-                typeUsage = new ArrayTypeUsage(typeUsage);\n+                typeUsage = new ArrayType(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n-            List<TypeUsage> typeParameters = Collections.emptyList();\n+            List<Type> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n-                if (typeDeclaration instanceof TypeParameter) {\n-                    return new TypeParameterUsage((TypeParameter) typeDeclaration);\n+                if (typeDeclaration instanceof me.tomassetti.symbolsolver.model.resolution.TypeParameter) {\n+                    return new TypeParameter((me.tomassetti.symbolsolver.model.resolution.TypeParameter) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n+                    return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n-                return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n+                return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n-        } else if (type instanceof PrimitiveType) {\n-            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n+        } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n+            return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtends() != null && wildcardType.getSuper() == null) {\n-                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n             } else if (wildcardType.getExtends() == null && wildcardType.getSuper() != null) {\n-                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n+                return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n             } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n-                return WildcardUsage.UNBOUNDED;\n+                return Wildcard.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n-        } else if (type instanceof VoidType) {\n-            return VoidTypeUsage.INSTANCE;\n+        } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n+            return VoidType.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"14c9305d49885a12acdb7c09d2e35ad29b5403cf": {
			"type": "Ybodychange",
			"commitMessage": "Revert \"issue80: improve TypeParameter.describe\"\n\nThis reverts commit e581ddb297f5a1da9790adaeadbb6d0f43c8432f.\n",
			"commitDate": "2016-10-13, 6:20 AM",
			"commitName": "14c9305d49885a12acdb7c09d2e35ad29b5403cf",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-13, 6:12 AM",
			"commitNameOld": "e581ddb297f5a1da9790adaeadbb6d0f43c8432f",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,49 +1,49 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType = (ReferenceType) type;\n             TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n             for (int i = 0; i < referenceType.getArrayCount(); i++) {\n                 typeUsage = new ArrayTypeUsage(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<TypeUsage> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameter) {\n-                    return new TypeParameterUsage((TypeParameter) typeDeclaration, typeSolver);\n+                    return new TypeParameterUsage((TypeParameter) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter(), typeSolver);\n+                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtends() != null && wildcardType.getSuper() == null) {\n                 return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n             } else if (wildcardType.getExtends() == null && wildcardType.getSuper() != null) {\n                 return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n             } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n                 return WildcardUsage.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n         } else if (type instanceof VoidType) {\n             return VoidTypeUsage.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e581ddb297f5a1da9790adaeadbb6d0f43c8432f": {
			"type": "Ybodychange",
			"commitMessage": "issue80: improve TypeParameter.describe\n",
			"commitDate": "2016-10-13, 6:12 AM",
			"commitName": "e581ddb297f5a1da9790adaeadbb6d0f43c8432f",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-11, 11:37 AM",
			"commitNameOld": "acf74024c2d341bf4009af7173c9b1b972f19c32",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 1.77,
			"commitsBetweenForRepo": 11,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,49 +1,49 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType = (ReferenceType) type;\n             TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n             for (int i = 0; i < referenceType.getArrayCount(); i++) {\n                 typeUsage = new ArrayTypeUsage(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<TypeUsage> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameter) {\n-                    return new TypeParameterUsage((TypeParameter) typeDeclaration);\n+                    return new TypeParameterUsage((TypeParameter) typeDeclaration, typeSolver);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n+                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter(), typeSolver);\n                 }\n             } else {\n                 return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtends() != null && wildcardType.getSuper() == null) {\n                 return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n             } else if (wildcardType.getExtends() == null && wildcardType.getSuper() != null) {\n                 return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n             } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n                 return WildcardUsage.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n         } else if (type instanceof VoidType) {\n             return VoidTypeUsage.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8e655d386a595ea1927ebeded58939d7b8a7ce0c": {
			"type": "Yfilerename",
			"commitMessage": "test JavaParserClassDeclaration\n",
			"commitDate": "2015-11-22, 3:45 AM",
			"commitName": "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-22, 3:03 AM",
			"commitNameOld": "68d87977d826a8c48711297732b7ae10f3dc1f1f",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
				"newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java"
			}
		},
		"4a18b1ee8ed716d6e32e190f728f1eee57148872": {
			"type": "Ybodychange",
			"commitMessage": "modules: extraction of the model module\n",
			"commitDate": "2015-11-13, 2:59 AM",
			"commitName": "4a18b1ee8ed716d6e32e190f728f1eee57148872",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-13, 2:12 AM",
			"commitNameOld": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,49 +1,49 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType = (ReferenceType) type;\n             TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n             for (int i = 0; i < referenceType.getArrayCount(); i++) {\n                 typeUsage = new ArrayTypeUsage(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<TypeUsage> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameter) {\n                     return new TypeParameterUsage((TypeParameter) typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n-                return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n+                return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getExtends() != null && wildcardType.getSuper() == null) {\n-                return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getExtends(), context));\n+                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n             } else if (wildcardType.getExtends() == null && wildcardType.getSuper() != null) {\n-                return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getSuper(), context));\n+                return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n             } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n                 return WildcardUsage.UNBOUNDED;\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n         } else if (type instanceof VoidType) {\n             return VoidTypeUsage.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f4b07b1a2deac6d1b562424ac2380b92cec77a90": {
			"type": "Yfilerename",
			"commitMessage": "modules: organization in modules\n",
			"commitDate": "2015-11-13, 2:12 AM",
			"commitName": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-13, 1:53 AM",
			"commitNameOld": "d96a8ff67d857a2988488f1fc31202f0e2ed8061",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
				"newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java"
			}
		},
		"03ec309bba14eaf50a32b05353fa9711b831de7f": {
			"type": "Ybodychange",
			"commitMessage": "reimplement WildcardUsage\n",
			"commitDate": "2015-10-31, 9:01 AM",
			"commitName": "03ec309bba14eaf50a32b05353fa9711b831de7f",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-10-31, 5:11 AM",
			"commitNameOld": "fb388c36c0045c50744cf215521e5c280036aa70",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.16,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,40 +1,49 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType = (ReferenceType) type;\n             TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n             for (int i=0;i<referenceType.getArrayCount();i++){\n                 typeUsage = new ArrayTypeUsage(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<TypeUsage> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameter) {\n                     return new TypeParameterUsage((TypeParameter)typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n-            return new WildcardUsage((WildcardType)type);\n+            WildcardType wildcardType = (WildcardType)type;\n+            if (wildcardType.getExtends() != null && wildcardType.getSuper() == null) {\n+                return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getExtends(), context));\n+            } else if (wildcardType.getExtends() == null && wildcardType.getSuper() != null) {\n+                return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getSuper(), context));\n+            } else if (wildcardType.getExtends() == null && wildcardType.getSuper() == null) {\n+                return WildcardUsage.UNBOUNDED;\n+            } else {\n+                throw new UnsupportedOperationException();\n+            }\n         } else if (type instanceof VoidType) {\n             return VoidTypeUsage.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fb388c36c0045c50744cf215521e5c280036aa70": {
			"type": "Yfilerename",
			"commitMessage": "move JavaParser specific code to specific package\n",
			"commitDate": "2015-10-31, 5:11 AM",
			"commitName": "fb388c36c0045c50744cf215521e5c280036aa70",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-10-31, 3:57 AM",
			"commitNameOld": "b2bf624be5d1ef59480250e66224aeaa1886df36",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.05,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
				"newPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java"
			}
		},
		"1613b8d9cc00da012539ea3db05cdb0cc8153358": {
			"type": "Ybodychange",
			"commitMessage": "renaming\n",
			"commitDate": "2015-10-31, 3:01 AM",
			"commitName": "1613b8d9cc00da012539ea3db05cdb0cc8153358",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-10-30, 4:51 PM",
			"commitNameOld": "adb02497ed443e836ae552e20bcb11ab8c1ab623",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.42,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,40 +1,40 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType = (ReferenceType) type;\n             TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n             for (int i=0;i<referenceType.getArrayCount();i++){\n                 typeUsage = new ArrayTypeUsage(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<TypeUsage> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameter) {\n-                    return new TypeUsageOfTypeParameter((TypeParameter)typeDeclaration);\n+                    return new TypeParameterUsage((TypeParameter)typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                    return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n+                    return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             return new WildcardUsage((WildcardType)type);\n         } else if (type instanceof VoidType) {\n             return VoidTypeUsage.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0e81f51c40996b42cb262dc2397126cee8f60965": {
			"type": "Ybodychange",
			"commitMessage": "embedding TypeSolver\n",
			"commitDate": "2015-10-30, 4:37 PM",
			"commitName": "0e81f51c40996b42cb262dc2397126cee8f60965",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-10-30, 9:43 AM",
			"commitNameOld": "005ec580724781a825aaf08a496ad7f8f667b27f",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.29,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,40 +1,40 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType = (ReferenceType) type;\n             TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n             for (int i=0;i<referenceType.getArrayCount();i++){\n                 typeUsage = new ArrayTypeUsage(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<TypeUsage> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameter) {\n                     return new TypeUsageOfTypeParameter((TypeParameter)typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n-                return new ReferenceTypeUsage(typeDeclaration, typeParameters);\n+                return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             return new WildcardUsage((WildcardType)type);\n         } else if (type instanceof VoidType) {\n             return VoidTypeUsage.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"68aeb576ccb2b44e436d13d0be2660f85dc9ee4b": {
			"type": "Ybodychange",
			"commitMessage": "renaming\n",
			"commitDate": "2015-10-28, 9:18 AM",
			"commitName": "68aeb576ccb2b44e436d13d0be2660f85dc9ee4b",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-27, 8:40 AM",
			"commitNameOld": "bed91989f7354552d72b2b7f0c28fcbd24fee003",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 62.03,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,40 +1,40 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType = (ReferenceType) type;\n             TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n             for (int i=0;i<referenceType.getArrayCount();i++){\n                 typeUsage = new ArrayTypeUsage(typeUsage);\n             }\n             return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<TypeUsage> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameter) {\n                     return new TypeUsageOfTypeParameter((TypeParameter)typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n-                return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n+                return new ReferenceTypeUsage(typeDeclaration, typeParameters);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             return new WildcardUsage((WildcardType)type);\n         } else if (type instanceof VoidType) {\n             return VoidTypeUsage.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"eec165d9e3ef0ab1d93f69a231964984a3379762": {
			"type": "Ybodychange",
			"commitMessage": "consider array modifiers\n",
			"commitDate": "2015-08-25, 3:57 AM",
			"commitName": "eec165d9e3ef0ab1d93f69a231964984a3379762",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-24, 3:05 PM",
			"commitNameOld": "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.54,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,37 +1,40 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType = (ReferenceType) type;\n-            // TODO consider array modifiers\n-            return convertToUsage(referenceType.getType(), context);\n+            TypeUsage typeUsage = convertToUsage(referenceType.getType(), context);\n+            for (int i=0;i<referenceType.getArrayCount();i++){\n+                typeUsage = new ArrayTypeUsage(typeUsage);\n+            }\n+            return typeUsage;\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             String name = qName(classOrInterfaceType);\n             SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<TypeUsage> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameter) {\n                     return new TypeUsageOfTypeParameter((TypeParameter)typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             return new WildcardUsage((WildcardType)type);\n         } else if (type instanceof VoidType) {\n             return VoidTypeUsage.INSTANCE;\n         } else {\n-            throw new UnsupportedOperationException(\"FOO \" +type.getClass().getCanonicalName());\n+            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ee58eb8363ecd8fad15a63eb2fdc94a387b58807": {
			"type": "Ybodychange",
			"commitMessage": "use qualified name when solving types\n",
			"commitDate": "2015-08-24, 1:57 PM",
			"commitName": "ee58eb8363ecd8fad15a63eb2fdc94a387b58807",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-24, 1:37 PM",
			"commitNameOld": "1ae290f6f5e0c7ba62eab797aba22308957b9257",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,36 +1,37 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType = (ReferenceType) type;\n             // TODO consider array modifiers\n             return convertToUsage(referenceType.getType(), context);\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n-            SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n+            String name = qName(classOrInterfaceType);\n+            SymbolReference<TypeDeclaration> ref = context.solveType(name, typeSolver);\n             if (!ref.isSolved()) {\n-                throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n+                throw new UnsolvedSymbolException(name);\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<TypeUsage> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameter) {\n                     return new TypeUsageOfTypeParameter((TypeParameter)typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             return new WildcardUsage((WildcardType)type);\n         } else if (type instanceof VoidType) {\n             return VoidTypeUsage.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(\"FOO \" +type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"283204dd5840cb11dd6c73dbbb196e80db79c9a4": {
			"type": "Ybodychange",
			"commitMessage": "consider method override\n",
			"commitDate": "2015-08-24, 1:19 PM",
			"commitName": "283204dd5840cb11dd6c73dbbb196e80db79c9a4",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-24, 12:45 PM",
			"commitNameOld": "d0348de241a6cf6be9c51500870ee1fb26172101",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,36 +1,36 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType = (ReferenceType) type;\n             // TODO consider array modifiers\n             return convertToUsage(referenceType.getType(), context);\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<TypeUsage> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 if (typeDeclaration instanceof TypeParameter) {\n                     return new TypeUsageOfTypeParameter((TypeParameter)typeDeclaration);\n                 } else {\n                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                     return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n                 }\n             } else {\n                 return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n         } else if (type instanceof WildcardType) {\n             return new WildcardUsage((WildcardType)type);\n         } else if (type instanceof VoidType) {\n-            return new VoidTypeUsage();\n+            return VoidTypeUsage.INSTANCE;\n         } else {\n             throw new UnsupportedOperationException(\"FOO \" +type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f77a169eec5a2e0fdeea1b9d67641426af0e1176": {
			"type": "Ybodychange",
			"commitMessage": "remove JavaParserFacade.convert\n",
			"commitDate": "2015-08-24, 8:22 AM",
			"commitName": "f77a169eec5a2e0fdeea1b9d67641426af0e1176",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-24, 8:06 AM",
			"commitNameOld": "416e7b16f820700af08a94e4b38a2b4c24ef6a2c",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,28 +1,36 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType = (ReferenceType) type;\n             // TODO consider array modifiers\n             return convertToUsage(referenceType.getType(), context);\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<TypeUsage> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n-                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration)typeDeclaration;\n-                return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n+                if (typeDeclaration instanceof TypeParameter) {\n+                    return new TypeUsageOfTypeParameter((TypeParameter)typeDeclaration);\n+                } else {\n+                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n+                    return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n+                }\n             } else {\n                 return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n             }\n         } else if (type instanceof PrimitiveType) {\n-            return PrimitiveTypeUsage.byName(((PrimitiveType)type).getType().name());\n+            return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n+        } else if (type instanceof WildcardType) {\n+            return new WildcardUsage((WildcardType)type);\n+        } else if (type instanceof VoidType) {\n+            return new VoidTypeUsage();\n         } else {\n             throw new UnsupportedOperationException(\"FOO \" +type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"416e7b16f820700af08a94e4b38a2b4c24ef6a2c": {
			"type": "Ybodychange",
			"commitMessage": "minor corrections for enums\n",
			"commitDate": "2015-08-24, 8:06 AM",
			"commitName": "416e7b16f820700af08a94e4b38a2b4c24ef6a2c",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-24, 7:58 AM",
			"commitNameOld": "1829d9560d37efd59722aaa2f1f22e392918429b",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,28 +1,28 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType = (ReferenceType) type;\n             // TODO consider array modifiers\n             return convertToUsage(referenceType.getType(), context);\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<TypeUsage> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             if (typeDeclaration.isTypeVariable()) {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration)typeDeclaration;\n                 return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n             } else {\n                 return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n             }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType)type).getType().name());\n         } else {\n-            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n+            throw new UnsupportedOperationException(\"FOO \" +type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1829d9560d37efd59722aaa2f1f22e392918429b": {
			"type": "Ybodychange",
			"commitMessage": "calculate if type variable are assignable\n",
			"commitDate": "2015-08-24, 7:58 AM",
			"commitName": "1829d9560d37efd59722aaa2f1f22e392918429b",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-24, 7:26 AM",
			"commitNameOld": "00f005b38e8b83eb1d60db9070c6e9e3beffe403",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,23 +1,28 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType = (ReferenceType) type;\n             // TODO consider array modifiers\n             return convertToUsage(referenceType.getType(), context);\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<TypeUsage> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n-            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n+            if (typeDeclaration.isTypeVariable()) {\n+                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration)typeDeclaration;\n+                return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n+            } else {\n+                return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n+            }\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType)type).getType().name());\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0c4c859f472f7243919f1af7a0871cf8155af1ba": {
			"type": "Ybodychange",
			"commitMessage": "add tests for static field access\n",
			"commitDate": "2015-08-21, 3:00 PM",
			"commitName": "0c4c859f472f7243919f1af7a0871cf8155af1ba",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-21, 12:45 PM",
			"commitNameOld": "7b6c27e95fef9e725fbf9e15afb852bb952dfa34",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.09,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,23 +1,23 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType = (ReferenceType) type;\n             // TODO consider array modifiers\n             return convertToUsage(referenceType.getType(), context);\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n             if (!ref.isSolved()) {\n-                throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n+                throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<TypeUsage> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n         } else if (type instanceof PrimitiveType) {\n             return PrimitiveTypeUsage.byName(((PrimitiveType)type).getType().name());\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7b6c27e95fef9e725fbf9e15afb852bb952dfa34": {
			"type": "Ybodychange",
			"commitMessage": "first round of cleaning the API\n",
			"commitDate": "2015-08-21, 12:45 PM",
			"commitName": "7b6c27e95fef9e725fbf9e15afb852bb952dfa34",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-21, 4:03 AM",
			"commitNameOld": "6d60a91b5d0d29dde1c081d82781fc60011d926d",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.36,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,23 +1,23 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType = (ReferenceType) type;\n             // TODO consider array modifiers\n             return convertToUsage(referenceType.getType(), context);\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<TypeUsage> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n         } else if (type instanceof PrimitiveType) {\n-            return new TypeUsageOfTypeDeclaration(new PrimitiveTypeDeclaration((PrimitiveType)type), Collections.emptyList());\n+            return PrimitiveTypeUsage.byName(((PrimitiveType)type).getType().name());\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1d5332815b543d569be3d7ec672a65b7efc39a04": {
			"type": "Ybodychange",
			"commitMessage": "test ClassOrInterfaceDeclarationContext.solveSymbolAsValue\n",
			"commitDate": "2015-08-18, 3:15 AM",
			"commitName": "1d5332815b543d569be3d7ec672a65b7efc39a04",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-18, 1:14 AM",
			"commitNameOld": "3117fab4797fa9aba8b5f8dc596ab70c90c7d548",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.08,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,21 +1,23 @@\n     public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType = (ReferenceType) type;\n             // TODO consider array modifiers\n             return convertToUsage(referenceType.getType(), context);\n         } else if (type instanceof ClassOrInterfaceType) {\n-            ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType)type;\n+            ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n             SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<TypeUsage> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n-                typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt)->convertToUsage(pt, context)).collect(Collectors.toList());\n+                typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n+        } else if (type instanceof PrimitiveType) {\n+            return new TypeUsageOfTypeDeclaration(new PrimitiveTypeDeclaration((PrimitiveType)type), Collections.emptyList());\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6650e5a3818c15de2883b71cd41524b0337e26f6": {
			"type": "Ymodifierchange",
			"commitMessage": "add test resolveUsageOfGenericFieldAdvancedCase\n",
			"commitDate": "2015-08-05, 2:09 AM",
			"commitName": "6650e5a3818c15de2883b71cd41524b0337e26f6",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-04, 7:54 AM",
			"commitNameOld": "80f951258992f75441239c79e0f31eda7d47e107",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.76,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,21 +1,21 @@\n-    private TypeUsage convertToUsage(Type type, Context context) {\n+    public TypeUsage convertToUsage(Type type, Context context) {\n         if (type instanceof ReferenceType) {\n             ReferenceType referenceType = (ReferenceType) type;\n             // TODO consider array modifiers\n             return convertToUsage(referenceType.getType(), context);\n         } else if (type instanceof ClassOrInterfaceType) {\n             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType)type;\n             SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n             }\n             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n             List<TypeUsage> typeParameters = Collections.emptyList();\n             if (classOrInterfaceType.getTypeArgs() != null) {\n                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt)->convertToUsage(pt, context)).collect(Collectors.toList());\n             }\n             return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n         } else {\n             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[private]",
				"newValue": "[public]"
			}
		},
		"2568d9ebe91ceb0a13c98b16f99593cd22084efa": {
			"type": "Yintroduced",
			"commitMessage": "solving first case of generic type\n",
			"commitDate": "2015-08-04, 3:02 AM",
			"commitName": "2568d9ebe91ceb0a13c98b16f99593cd22084efa",
			"commitAuthor": "Federico Tomassetti"
		}
	},
	"sha": "97555053af3025556efe1a168fd7943dac28a2a6"
}