{
	"repo": "https://github.com/javaparser/javaparser.git",
	"file": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
	"method": {
		"longName": "MethodCallExprContext::solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver)",
		"startLine": 76,
		"methodName": "solveMethodAsUsage",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"791449a6ab0696f4c0109908a4a0925e514b10d9": {
			"type": "Ybodychange",
			"commitMessage": "fixing failing tests by considering the context of calls within ObjectCreationExpr\n",
			"commitDate": "2018-06-06, 7:52 AM",
			"commitName": "791449a6ab0696f4c0109908a4a0925e514b10d9",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2018-03-30, 7:12 AM",
			"commitNameOld": "7df79507310cc762c732281053961e6a89078f80",
			"commitAuthorOld": "daans",
			"daysBetweenCommits": 68.03,
			"commitsBetweenForRepo": 139,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,46 +1,46 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope = wrappedNode.getScope().get();\n             // Consider static method calls\n             if (scope instanceof NameExpr) {\n                 String className = ((NameExpr) scope).getName().getId();\n                 SymbolReference<ResolvedTypeDeclaration> ref = solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference<ResolvedMethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage = resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                         methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                 \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n             ResolvedType typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T=U with String because I know that T=String I can derive that also U equal String\n                 ResolvedType originalArgumentType = argumentsTypes.get(i);\n                 ResolvedType updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 ResolvedType updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext = getParent();\n-            while (parentContext instanceof MethodCallExprContext) {\n+            while (parentContext instanceof MethodCallExprContext || parentContext instanceof ObjectCreationContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"09232ff6b0ea19e850482f3a87ac6ef1c063c759": {
			"type": "Yfilerename",
			"commitMessage": "rename JSS modules\n",
			"commitDate": "2018-01-10, 5:52 AM",
			"commitName": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2018-01-10, 1:01 AM",
			"commitNameOld": "30c04db173cc439556df2a238c99cd81ada320ff",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.2,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
				"newPath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java"
			}
		},
		"5d8d0cb7947efcf2282f7d056302dd905f348532": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "more work on converting to moved classes\n",
			"commitDate": "2017-09-28, 2:36 PM",
			"commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
			"commitAuthor": "Federico Tomassetti",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "more work on converting to moved classes\n",
					"commitDate": "2017-09-28, 2:36 PM",
					"commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2017-08-28, 3:15 AM",
					"commitNameOld": "abec22a71cd36e52d79a4575c21294ffd48c7016",
					"commitAuthorOld": "mlangkabel",
					"daysBetweenCommits": 31.47,
					"commitsBetweenForRepo": 14,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,46 +1,46 @@\n-    public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n+    public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope = wrappedNode.getScope().get();\n             // Consider static method calls\n             if (scope instanceof NameExpr) {\n                 String className = ((NameExpr) scope).getName().getId();\n-                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n+                SymbolReference<ResolvedTypeDeclaration> ref = solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n-                    SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n+                    SymbolReference<ResolvedMethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage = resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                         methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                 \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n-            Type typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n+            ResolvedType typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n-            Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n+            Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T=U with String because I know that T=String I can derive that also U equal String\n-                Type originalArgumentType = argumentsTypes.get(i);\n-                Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n+                ResolvedType originalArgumentType = argumentsTypes.get(i);\n+                ResolvedType updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n-                Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n+                ResolvedType updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[name-String, argumentsTypes-List<Type>, typeSolver-TypeSolver]",
						"newValue": "[name-String, argumentsTypes-List<ResolvedType>, typeSolver-TypeSolver]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "more work on converting to moved classes\n",
					"commitDate": "2017-09-28, 2:36 PM",
					"commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2017-08-28, 3:15 AM",
					"commitNameOld": "abec22a71cd36e52d79a4575c21294ffd48c7016",
					"commitAuthorOld": "mlangkabel",
					"daysBetweenCommits": 31.47,
					"commitsBetweenForRepo": 14,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,46 +1,46 @@\n-    public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n+    public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope = wrappedNode.getScope().get();\n             // Consider static method calls\n             if (scope instanceof NameExpr) {\n                 String className = ((NameExpr) scope).getName().getId();\n-                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n+                SymbolReference<ResolvedTypeDeclaration> ref = solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n-                    SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n+                    SymbolReference<ResolvedMethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage = resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                         methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                 \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n-            Type typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n+            ResolvedType typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n-            Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n+            Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T=U with String because I know that T=String I can derive that also U equal String\n-                Type originalArgumentType = argumentsTypes.get(i);\n-                Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n+                ResolvedType originalArgumentType = argumentsTypes.get(i);\n+                ResolvedType updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n-                Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n+                ResolvedType updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"dd5c0a00fb9cbd9995d9141907848ec5a3342760": {
			"type": "Ybodychange",
			"commitMessage": "Make the MethodUsage type param map correct in more cases\n",
			"commitDate": "2017-04-17, 3:28 PM",
			"commitName": "dd5c0a00fb9cbd9995d9141907848ec5a3342760",
			"commitAuthor": "Max Bolingbroke",
			"commitDateOld": "2017-03-22, 7:31 PM",
			"commitNameOld": "63c7f0fb4247e490bdd05d2779c6983c892fe570",
			"commitAuthorOld": "xdrop",
			"daysBetweenCommits": 25.83,
			"commitsBetweenForRepo": 17,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,46 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope = wrappedNode.getScope().get();\n             // Consider static method calls\n             if (scope instanceof NameExpr) {\n                 String className = ((NameExpr) scope).getName().getId();\n                 SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n+                        methodUsage = resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                         methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                 \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n             Type typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T=U with String because I know that T=String I can derive that also U equal String\n                 Type originalArgumentType = argumentsTypes.get(i);\n                 Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"acdac6790f4424f8097b3aa6c888e825cac485f9": {
			"type": "Ybodychange",
			"commitMessage": "Fixes for type inference\n",
			"commitDate": "2017-03-09, 6:22 PM",
			"commitName": "acdac6790f4424f8097b3aa6c888e825cac485f9",
			"commitAuthor": "xdrop",
			"commitDateOld": "2017-03-08, 8:31 PM",
			"commitNameOld": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
			"commitAuthorOld": "xdrop",
			"daysBetweenCommits": 0.91,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,45 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope = wrappedNode.getScope().get();\n             // Consider static method calls\n             if (scope instanceof NameExpr) {\n                 String className = ((NameExpr) scope).getName().getId();\n                 SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n-                    SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver, false);\n+                    SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                 \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n             Type typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T=U with String because I know that T=String I can derive that also U equal String\n                 Type originalArgumentType = argumentsTypes.get(i);\n                 Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"17ac5ada0476c72aa79a2e0c39311e90bfa0fe60": {
			"type": "Ybodychange",
			"commitMessage": "Fix issues with inherited methods in interfaces not being resolved\n",
			"commitDate": "2017-03-08, 8:31 PM",
			"commitName": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
			"commitAuthor": "xdrop",
			"commitDateOld": "2017-03-08, 2:40 PM",
			"commitNameOld": "e5fe2b597be66d230f8824277c1d4167fa2bb609",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.24,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,45 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope = wrappedNode.getScope().get();\n             // Consider static method calls\n             if (scope instanceof NameExpr) {\n                 String className = ((NameExpr) scope).getName().getId();\n                 SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n-                    SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n+                    SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver, false);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                 \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n             Type typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T=U with String because I know that T=String I can derive that also U equal String\n                 Type originalArgumentType = argumentsTypes.get(i);\n                 Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"065875981b4d1ffa4bf3535d7c89319a4a3345f1": {
			"type": "Ybodychange",
			"commitMessage": "Update for JavaParser 3.0.0\n",
			"commitDate": "2017-01-11, 5:45 PM",
			"commitName": "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
			"commitAuthor": "xdrop",
			"commitDateOld": "2017-01-06, 2:11 AM",
			"commitNameOld": "860a4c0c034e1b8232e3d1ec17e7f11879850470",
			"commitAuthorOld": "",
			"daysBetweenCommits": 5.65,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,45 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n-        if (wrappedNode.getScope() != null) {\n-\n+        if (wrappedNode.getScope().isPresent()) {\n+            Expression scope = wrappedNode.getScope().get();\n             // Consider static method calls\n-            if (wrappedNode.getScope() instanceof NameExpr) {\n-                String className = ((NameExpr) wrappedNode.getScope()).getName().getId();\n+            if (scope instanceof NameExpr) {\n+                String className = ((NameExpr) scope).getName().getId();\n                 SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                 \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n-            Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+            Type typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T=U with String because I know that T=String I can derive that also U equal String\n                 Type originalArgumentType = argumentsTypes.get(i);\n                 Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6e1380f412d334f1c887d15edf0b4610c3cf0da2": {
			"type": "Ybodychange",
			"commitMessage": "adapt to alpha.10\n",
			"commitDate": "2016-11-21, 11:58 AM",
			"commitName": "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-11-09, 10:15 AM",
			"commitNameOld": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 12.07,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,45 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n \n             // Consider static method calls\n             if (wrappedNode.getScope() instanceof NameExpr) {\n-                String className = ((NameExpr) wrappedNode.getScope()).getName();\n+                String className = ((NameExpr) wrappedNode.getScope()).getName().getId();\n                 SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                 \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n             Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T=U with String because I know that T=String I can derive that also U equal String\n                 Type originalArgumentType = argumentsTypes.get(i);\n                 Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5": {
			"type": "Ybodychange",
			"commitMessage": "changes necessary to support jpalpha8\n",
			"commitDate": "2016-11-09, 10:15 AM",
			"commitName": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-11-06, 6:49 AM",
			"commitNameOld": "03055f925053b3970b9d14cce3a3b9a0d002366d",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 3.14,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,45 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n-        if (wrappedNode.getScope().isPresent()) {\n+        if (wrappedNode.getScope() != null) {\n \n             // Consider static method calls\n-            if (wrappedNode.getScope().get() instanceof NameExpr) {\n-                String className = ((NameExpr) wrappedNode.getScope().get()).getName();\n+            if (wrappedNode.getScope() instanceof NameExpr) {\n+                String className = ((NameExpr) wrappedNode.getScope()).getName();\n                 SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                 \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n-            Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n+            Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T=U with String because I know that T=String I can derive that also U equal String\n                 Type originalArgumentType = argumentsTypes.get(i);\n                 Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"03055f925053b3970b9d14cce3a3b9a0d002366d": {
			"type": "Ybodychange",
			"commitMessage": "add AbstractMethodLikeDeclarationContext\n",
			"commitDate": "2016-11-06, 6:49 AM",
			"commitName": "03055f925053b3970b9d14cce3a3b9a0d002366d",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-11-06, 1:57 AM",
			"commitNameOld": "27f0f20ee38a85d0d7a476f9a49d15325d4d660e",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.2,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,44 +1,45 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n-        // TODO consider call of static methods\n         if (wrappedNode.getScope().isPresent()) {\n \n+            // Consider static method calls\n             if (wrappedNode.getScope().get() instanceof NameExpr) {\n                 String className = ((NameExpr) wrappedNode.getScope().get()).getName();\n                 SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n-                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n+                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n+                                \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n             Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T=U with String because I know that T=String I can derive that also U equal String\n                 Type originalArgumentType = argumentsTypes.get(i);\n                 Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a1c7c58143a592965f8378767adc69709e4c0043": {
			"type": "Ybodychange",
			"commitMessage": "more refactoring for ReferenceTypeDeclaration\n",
			"commitDate": "2016-11-05, 9:22 AM",
			"commitName": "a1c7c58143a592965f8378767adc69709e4c0043",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-11-05, 9:08 AM",
			"commitNameOld": "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,44 +1,44 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope().isPresent()) {\n \n             if (wrappedNode.getScope().get() instanceof NameExpr) {\n                 String className = ((NameExpr) wrappedNode.getScope().get()).getName();\n-                SymbolReference<ReferenceTypeDeclaration> ref = solveType(className, typeSolver);\n+                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n             Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T=U with String because I know that T=String I can derive that also U equal String\n                 Type originalArgumentType = argumentsTypes.get(i);\n                 Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6df1aa26f75ff0d716a1290007e2b63cc05001ae": {
			"type": "Ybodychange",
			"commitMessage": "creating ReferenceTypeDeclaration\n",
			"commitDate": "2016-11-05, 9:08 AM",
			"commitName": "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-11-02, 2:08 PM",
			"commitNameOld": "effd4c172ad6e4d60d68a749121a0960040edd63",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 2.79,
			"commitsBetweenForRepo": 31,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,44 +1,44 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope().isPresent()) {\n \n             if (wrappedNode.getScope().get() instanceof NameExpr) {\n                 String className = ((NameExpr) wrappedNode.getScope().get()).getName();\n-                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n+                SymbolReference<ReferenceTypeDeclaration> ref = solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n             Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T=U with String because I know that T=String I can derive that also U equal String\n                 Type originalArgumentType = argumentsTypes.get(i);\n                 Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d017fb8caf6ccb3343da0062eb2c85262712772c": {
			"type": "Ybodychange",
			"commitMessage": "avoid issue with recursive generic type replacement\n",
			"commitDate": "2016-10-27, 11:31 AM",
			"commitName": "d017fb8caf6ccb3343da0062eb2c85262712772c",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-26, 11:53 PM",
			"commitNameOld": "901bca148f3256e176bd7c22b159917b6926b5b7",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.48,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,41 +1,44 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope().isPresent()) {\n \n             if (wrappedNode.getScope().get() instanceof NameExpr) {\n                 String className = ((NameExpr) wrappedNode.getScope().get()).getName();\n                 SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n             Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T=U with String because I know that T=String I can derive that also U equal String\n-                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i), inferredTypes));\n+                Type originalArgumentType = argumentsTypes.get(i);\n+                Type updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n+                argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n-                argumentsTypes.set(i, applyInferredTypes(argumentsTypes.get(i), inferredTypes));\n+                Type updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n+                argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2082034e8c3eb434e3df25dd420c98cae5a6d518": {
			"type": "Ybodychange",
			"commitMessage": "type inference\n",
			"commitDate": "2016-10-24, 11:19 AM",
			"commitName": "2082034e8c3eb434e3df25dd420c98cae5a6d518",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-23, 12:00 PM",
			"commitNameOld": "cf0045ad73d15502e16c6de02334d39383dfee78",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.97,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,35 +1,41 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope().isPresent()) {\n \n             if (wrappedNode.getScope().get() instanceof NameExpr) {\n                 String className = ((NameExpr) wrappedNode.getScope().get()).getName();\n                 SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n             Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n+            Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n             for (int i = 0; i < argumentsTypes.size(); i++) {\n-                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n+                // by replacing types I can also find new equivalences\n+                // for example if I replace T=U with String because I know that T=String I can derive that also U equal String\n+                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i), inferredTypes));\n+            }\n+            for (int i = 0; i < argumentsTypes.size(); i++) {\n+                argumentsTypes.set(i, applyInferredTypes(argumentsTypes.get(i), inferredTypes));\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"13d789de30e6c3d29efb17a2acdff443f8c48db1": {
			"type": "Ybodychange",
			"commitMessage": "handling static calls\n",
			"commitDate": "2016-10-23, 2:58 AM",
			"commitName": "13d789de30e6c3d29efb17a2acdff443f8c48db1",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-22, 10:40 AM",
			"commitNameOld": "b26a4c591ec4cf8e25847b987610c65a22f60589",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.68,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,41 +1,35 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope().isPresent()) {\n-            try {\n-                Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n-                // we can replace the parameter types from the scope into the typeParametersValues\n \n-                for (int i = 0; i < argumentsTypes.size(); i++) {\n-                    argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n-                }\n-\n-                return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n-            } catch (UnsolvedSymbolException e) {\n-                // ok, maybe it was instead a static access, so let's look for a type\n-                if (wrappedNode.getScope().get() instanceof NameExpr) {\n-                    String className = ((NameExpr) wrappedNode.getScope().get()).getName();\n-                    SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n-                    if (ref.isSolved()) {\n-                        SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n-                        if (m.isSolved()) {\n-                            MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n-                            methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n-                            return Optional.of(methodUsage);\n-                        } else {\n-                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n-                        }\n+            if (wrappedNode.getScope().get() instanceof NameExpr) {\n+                String className = ((NameExpr) wrappedNode.getScope().get()).getName();\n+                SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n+                if (ref.isSolved()) {\n+                    SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n+                    if (m.isSolved()) {\n+                        MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n+                        methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n+                        return Optional.of(methodUsage);\n                     } else {\n-                        throw e;\n+                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                     }\n-                } else {\n-                    throw e;\n                 }\n             }\n+\n+            Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n+            // we can replace the parameter types from the scope into the typeParametersValues\n+\n+            for (int i = 0; i < argumentsTypes.size(); i++) {\n+                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n+            }\n+\n+            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9c53c2cbc607ea694438ade8630be0c155a33162": {
			"type": "Yfilerename",
			"commitMessage": "renamed packages to com.github.javapaerser\n",
			"commitDate": "2016-10-20, 12:39 AM",
			"commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-20, 12:32 AM",
			"commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
				"newPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java"
			}
		},
		"03e407957d600a18ef0a4a83224c17d155ef8645": {
			"type": "Ybodychange",
			"commitMessage": "fixing a few more tests\n",
			"commitDate": "2016-10-19, 11:34 AM",
			"commitName": "03e407957d600a18ef0a4a83224c17d155ef8645",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-19, 11:33 AM",
			"commitNameOld": "341e081a5f8909a3a467671befcca2941b786d3d",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,41 +1,41 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n-        if (wrappedNode.getScope() != null) {\n+        if (wrappedNode.getScope().isPresent()) {\n             try {\n                 Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n                 // we can replace the parameter types from the scope into the typeParametersValues\n \n                 for (int i = 0; i< argumentsTypes.size(); i++) {\n                     argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n                 }\n \n                 return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let's look for a type\n                 if (wrappedNode.getScope().get() instanceof NameExpr) {\n                     String className = ((NameExpr) wrappedNode.getScope().get()).getName();\n                     SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                         if (m.isSolved()) {\n                             MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                             methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                             return Optional.of(methodUsage);\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"341e081a5f8909a3a467671befcca2941b786d3d": {
			"type": "Ybodychange",
			"commitMessage": "issue91: solve compilation issues\n",
			"commitDate": "2016-10-19, 11:33 AM",
			"commitName": "341e081a5f8909a3a467671befcca2941b786d3d",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-19, 9:04 AM",
			"commitNameOld": "683012de2a3a28358e848f8b145d462eb8b322ba",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.1,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,41 +1,41 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() != null) {\n             try {\n-                Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+                Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n                 // we can replace the parameter types from the scope into the typeParametersValues\n \n                 for (int i = 0; i< argumentsTypes.size(); i++) {\n                     argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n                 }\n \n                 return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let's look for a type\n-                if (wrappedNode.getScope() instanceof NameExpr) {\n-                    String className = ((NameExpr) wrappedNode.getScope()).getName();\n+                if (wrappedNode.getScope().get() instanceof NameExpr) {\n+                    String className = ((NameExpr) wrappedNode.getScope().get()).getName();\n                     SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                         if (m.isSolved()) {\n                             MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                             methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                             return Optional.of(methodUsage);\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "issue90: using the right terminology for parameters and arguments\n",
			"commitDate": "2016-10-17, 11:25 AM",
			"commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
			"commitAuthor": "Federico Tomassetti",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "issue90: using the right terminology for parameters and arguments\n",
					"commitDate": "2016-10-17, 11:25 AM",
					"commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-16, 10:48 AM",
					"commitNameOld": "f271890077d290431fd7cdc45e3bf172fb2f834c",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 1.03,
					"commitsBetweenForRepo": 4,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,41 +1,41 @@\n-    public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> parameterTypes, TypeSolver typeSolver) {\n+    public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() != null) {\n             try {\n                 Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 // we can replace the parameter types from the scope into the typeParametersValues\n \n-                for (int i=0;i<parameterTypes.size();i++) {\n-                    parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n+                for (int i = 0; i< argumentsTypes.size(); i++) {\n+                    argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n                 }\n \n-                return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n+                return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let's look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr) {\n                     String className = ((NameExpr) wrappedNode.getScope()).getName();\n                     SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n-                        SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, parameterTypes, typeSolver);\n+                        SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                         if (m.isSolved()) {\n                             MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n-                            methodUsage = resolveMethodTypeParameters(methodUsage, parameterTypes);\n+                            methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                             return Optional.of(methodUsage);\n                         } else {\n-                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n+                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n-            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n+            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[name-String, parameterTypes-List<Type>, typeSolver-TypeSolver]",
						"newValue": "[name-String, argumentsTypes-List<Type>, typeSolver-TypeSolver]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "issue90: using the right terminology for parameters and arguments\n",
					"commitDate": "2016-10-17, 11:25 AM",
					"commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-16, 10:48 AM",
					"commitNameOld": "f271890077d290431fd7cdc45e3bf172fb2f834c",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 1.03,
					"commitsBetweenForRepo": 4,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,41 +1,41 @@\n-    public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> parameterTypes, TypeSolver typeSolver) {\n+    public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() != null) {\n             try {\n                 Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 // we can replace the parameter types from the scope into the typeParametersValues\n \n-                for (int i=0;i<parameterTypes.size();i++) {\n-                    parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n+                for (int i = 0; i< argumentsTypes.size(); i++) {\n+                    argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n                 }\n \n-                return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n+                return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let's look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr) {\n                     String className = ((NameExpr) wrappedNode.getScope()).getName();\n                     SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n-                        SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, parameterTypes, typeSolver);\n+                        SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                         if (m.isSolved()) {\n                             MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n-                            methodUsage = resolveMethodTypeParameters(methodUsage, parameterTypes);\n+                            methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                             return Optional.of(methodUsage);\n                         } else {\n-                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n+                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n-            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n+            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"656bb37a1dba87d61d24e69f2346f35dbc73d81d": {
			"type": "Ybodychange",
			"commitMessage": "remove TypeDeclaration.solveMethod\n",
			"commitDate": "2016-10-16, 10:13 AM",
			"commitName": "656bb37a1dba87d61d24e69f2346f35dbc73d81d",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-14, 2:57 PM",
			"commitNameOld": "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 1.8,
			"commitsBetweenForRepo": 18,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,41 +1,41 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() != null) {\n             try {\n                 Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 // we can replace the parameter types from the scope into the typeParametersValues\n \n                 for (int i=0;i<parameterTypes.size();i++) {\n                     parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n                 }\n \n                 return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let's look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr) {\n                     String className = ((NameExpr) wrappedNode.getScope()).getName();\n                     SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n-                        SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n+                        SymbolReference<MethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, parameterTypes, typeSolver);\n                         if (m.isSolved()) {\n                             MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                             methodUsage = resolveMethodTypeParameters(methodUsage, parameterTypes);\n                             return Optional.of(methodUsage);\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8d234965b572759181da7787fead07b225e9e5ca": {
			"type": "Ybodychange",
			"commitMessage": "remove TypeSolver from MethodUsage\n",
			"commitDate": "2016-10-14, 12:36 AM",
			"commitName": "8d234965b572759181da7787fead07b225e9e5ca",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-14, 12:19 AM",
			"commitNameOld": "6b50c90daa764492e074198460c807d83d52325e",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,41 +1,41 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() != null) {\n             try {\n                 Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 // we can replace the parameter types from the scope into the parameters\n \n                 for (int i=0;i<parameterTypes.size();i++) {\n                     parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n                 }\n \n                 return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let's look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr) {\n                     String className = ((NameExpr) wrappedNode.getScope()).getName();\n                     SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                         if (m.isSolved()) {\n-                            MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n+                            MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                             methodUsage = resolveMethodTypeParameters(methodUsage, parameterTypes);\n                             return Optional.of(methodUsage);\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"82eb44707b620803d424188a1eb8708fcaf093cb": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "rename TypeUsage into Type\n",
			"commitDate": "2016-10-13, 2:11 PM",
			"commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
			"commitAuthor": "Federico Tomassetti",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "rename TypeUsage into Type\n",
					"commitDate": "2016-10-13, 2:11 PM",
					"commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-12, 3:43 PM",
					"commitNameOld": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.94,
					"commitsBetweenForRepo": 21,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,41 +1,41 @@\n-    public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n+    public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() != null) {\n             try {\n-                TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+                Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 // we can replace the parameter types from the scope into the parameters\n \n                 for (int i=0;i<parameterTypes.size();i++) {\n                     parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n                 }\n \n                 return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let's look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr) {\n                     String className = ((NameExpr) wrappedNode.getScope()).getName();\n                     SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                         if (m.isSolved()) {\n                             MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                             methodUsage = resolveMethodTypeParameters(methodUsage, parameterTypes);\n                             return Optional.of(methodUsage);\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[name-String, parameterTypes-List<TypeUsage>, typeSolver-TypeSolver]",
						"newValue": "[name-String, parameterTypes-List<Type>, typeSolver-TypeSolver]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "rename TypeUsage into Type\n",
					"commitDate": "2016-10-13, 2:11 PM",
					"commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-12, 3:43 PM",
					"commitNameOld": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.94,
					"commitsBetweenForRepo": 21,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,41 +1,41 @@\n-    public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n+    public Optional<MethodUsage> solveMethodAsUsage(String name, List<Type> parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() != null) {\n             try {\n-                TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+                Type typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 // we can replace the parameter types from the scope into the parameters\n \n                 for (int i=0;i<parameterTypes.size();i++) {\n                     parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n                 }\n \n                 return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let's look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr) {\n                     String className = ((NameExpr) wrappedNode.getScope()).getName();\n                     SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                         if (m.isSolved()) {\n                             MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                             methodUsage = resolveMethodTypeParameters(methodUsage, parameterTypes);\n                             return Optional.of(methodUsage);\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"38d780df85a22c9baffb1f772a45b063cad73aab": {
			"type": "Ybodychange",
			"commitMessage": "issue80: replace type parameters in parameters using values from scope\n",
			"commitDate": "2016-10-12, 2:53 PM",
			"commitName": "38d780df85a22c9baffb1f772a45b063cad73aab",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-11, 11:37 AM",
			"commitNameOld": "acf74024c2d341bf4009af7173c9b1b972f19c32",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 1.14,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,35 +1,41 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() != null) {\n             try {\n                 TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+                // we can replace the parameter types from the scope into the parameters\n+\n+                for (int i=0;i<parameterTypes.size();i++) {\n+                    parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n+                }\n+\n                 return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let's look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr) {\n                     String className = ((NameExpr) wrappedNode.getScope()).getName();\n                     SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                         if (m.isSolved()) {\n                             MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                             methodUsage = resolveMethodTypeParameters(methodUsage, parameterTypes);\n                             return Optional.of(methodUsage);\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             Context parentContext = getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext = parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d36b028172c0a183a0f32f66d2c5dff6f4b1dd76": {
			"type": "Ybodychange",
			"commitMessage": "fixed StackOverflowError when solving call on method return type as described in issue #43 and implemented test for this case.\n",
			"commitDate": "2016-09-26, 11:15 AM",
			"commitName": "d36b028172c0a183a0f32f66d2c5dff6f4b1dd76",
			"commitAuthor": "malte_langkabel",
			"commitDateOld": "2016-09-23, 4:10 AM",
			"commitNameOld": "2c3f615e6b24358b86d6453e24dac35849ffde26",
			"commitAuthorOld": "malte_langkabel",
			"daysBetweenCommits": 3.29,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,39 +1,35 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() != null) {\n             try {\n                 TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let's look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr) {\n                     String className = ((NameExpr) wrappedNode.getScope()).getName();\n                     SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                         if (m.isSolved()) {\n                             MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                             methodUsage = resolveMethodTypeParameters(methodUsage, parameterTypes);\n                             return Optional.of(methodUsage);\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n-\n                 }\n             }\n         } else {\n-            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n-                MethodCallExpr parent = (MethodCallExpr) wrappedNode.getParentNode();\n-                if (parent.getScope() == wrappedNode) {\n-                    return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n-                }\n-            }\n             Context parentContext = getParent();\n+            while (parentContext instanceof MethodCallExprContext) {\n+                parentContext = parentContext.getParent();\n+            }\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8e655d386a595ea1927ebeded58939d7b8a7ce0c": {
			"type": "Yfilerename",
			"commitMessage": "test JavaParserClassDeclaration\n",
			"commitDate": "2015-11-22, 3:45 AM",
			"commitName": "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-22, 3:03 AM",
			"commitNameOld": "68d87977d826a8c48711297732b7ae10f3dc1f1f",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
				"newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java"
			}
		},
		"ead147279ca0b84d2f479a714943b20cd689e7c7": {
			"type": "Ybodychange",
			"commitMessage": "issue7: consider type parameters and varargs combinations\n",
			"commitDate": "2015-11-20, 9:04 AM",
			"commitName": "ead147279ca0b84d2f479a714943b20cd689e7c7",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-13, 6:55 AM",
			"commitNameOld": "5aca9bfacfba18bfd16d17b16c8e5ef5c7609af4",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 7.09,
			"commitsBetweenForRepo": 17,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,36 +1,39 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() != null) {\n             try {\n                 TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let's look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr) {\n                     String className = ((NameExpr) wrappedNode.getScope()).getName();\n                     SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                         if (m.isSolved()) {\n-                            return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n+                            MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n+                            methodUsage = resolveMethodTypeParameters(methodUsage, parameterTypes);\n+                            return Optional.of(methodUsage);\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n+\n                 }\n             }\n         } else {\n             if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr parent = (MethodCallExpr) wrappedNode.getParentNode();\n                 if (parent.getScope() == wrappedNode) {\n                     return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                 }\n             }\n             Context parentContext = getParent();\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f4b07b1a2deac6d1b562424ac2380b92cec77a90": {
			"type": "Yfilerename",
			"commitMessage": "modules: organization in modules\n",
			"commitDate": "2015-11-13, 2:12 AM",
			"commitName": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-13, 1:53 AM",
			"commitNameOld": "d96a8ff67d857a2988488f1fc31202f0e2ed8061",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
				"newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java"
			}
		},
		"e21fca16e413a8bf31d613aa97a744d075c374dd": {
			"type": "Ybodychange",
			"commitMessage": "add AbstractTypeDeclaration\n",
			"commitDate": "2015-11-02, 1:11 PM",
			"commitName": "e21fca16e413a8bf31d613aa97a744d075c374dd",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-01, 7:57 AM",
			"commitNameOld": "965ab8585c3e8be1dff784e749e37dad31151ec8",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 1.22,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,36 +1,36 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() != null) {\n             try {\n                 TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e){\n                 // ok, maybe it was instead a static access, so let's look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr){\n                     String className = ((NameExpr)wrappedNode.getScope()).getName();\n                     SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n-                        SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n+                        SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                         if (m.isSolved()) {\n                             return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\"+name+\"' with parameterTypes \"+parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr parent = (MethodCallExpr)wrappedNode.getParentNode();\n                 if (parent.getScope() == wrappedNode) {\n                     return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                 }\n             }\n             Context parentContext = getParent();\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0e81f51c40996b42cb262dc2397126cee8f60965": {
			"type": "Ybodychange",
			"commitMessage": "embedding TypeSolver\n",
			"commitDate": "2015-10-30, 4:37 PM",
			"commitName": "0e81f51c40996b42cb262dc2397126cee8f60965",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-10-30, 7:30 AM",
			"commitNameOld": "362cdf49fd4c7ea6d60f3172fd2804f8aa765f4c",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.38,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,36 +1,36 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() != null) {\n             try {\n                 TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n-                return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n+                return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e){\n                 // ok, maybe it was instead a static access, so let's look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr){\n                     String className = ((NameExpr)wrappedNode.getScope()).getName();\n                     SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                         if (m.isSolved()) {\n                             return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\"+name+\"' with parameterTypes \"+parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr parent = (MethodCallExpr)wrappedNode.getParentNode();\n                 if (parent.getScope() == wrappedNode) {\n                     return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                 }\n             }\n             Context parentContext = getParent();\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b36f33050149a62a5b3c8c7451ae93f736715029": {
			"type": "Yfilerename",
			"commitMessage": "reorganize packages\n",
			"commitDate": "2015-10-30, 3:53 AM",
			"commitName": "b36f33050149a62a5b3c8c7451ae93f736715029",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-10-30, 3:29 AM",
			"commitNameOld": "90999800bdc73eacb5ef25dafcd36c8518af3072",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
				"newPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java"
			}
		},
		"640eb2479a4e05bb8ee0d95f74172be9dfa283f6": {
			"type": "Ybodychange",
			"commitMessage": "remove noise\n",
			"commitDate": "2015-08-24, 3:05 PM",
			"commitName": "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-24, 2:42 PM",
			"commitNameOld": "f821be8dfe72fcd3f4e14f75420617b87ddb8689",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,42 +1,36 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n-        if (name.equals(\"cloneNodes\")) {\n-            System.out.println(\"FOO\");\n-        }\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() != null) {\n             try {\n                 TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e){\n                 // ok, maybe it was instead a static access, so let's look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr){\n                     String className = ((NameExpr)wrappedNode.getScope()).getName();\n                     SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                         if (m.isSolved()) {\n                             return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\"+name+\"' with parameterTypes \"+parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr parent = (MethodCallExpr)wrappedNode.getParentNode();\n                 if (parent.getScope() == wrappedNode) {\n                     return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                 }\n             }\n-            //TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            //return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             Context parentContext = getParent();\n-            //System.out.println(\"NAME \"+name);\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f821be8dfe72fcd3f4e14f75420617b87ddb8689": {
			"type": "Ybodychange",
			"commitMessage": "considering method type parameters\n",
			"commitDate": "2015-08-24, 2:42 PM",
			"commitName": "f821be8dfe72fcd3f4e14f75420617b87ddb8689",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-24, 1:37 PM",
			"commitNameOld": "1ae290f6f5e0c7ba62eab797aba22308957b9257",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,42 +1,42 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n+        if (name.equals(\"cloneNodes\")) {\n+            System.out.println(\"FOO\");\n+        }\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() != null) {\n             try {\n                 TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e){\n                 // ok, maybe it was instead a static access, so let's look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr){\n                     String className = ((NameExpr)wrappedNode.getScope()).getName();\n                     SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n-                        if (name.equals(\"getModifiers\") && !ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver).isSolved()){\n-                            System.out.println(\"FOO\");\n-                        }\n                         SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                         if (m.isSolved()) {\n                             return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\"+name+\"' with parameterTypes \"+parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr parent = (MethodCallExpr)wrappedNode.getParentNode();\n                 if (parent.getScope() == wrappedNode) {\n                     return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                 }\n             }\n             //TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             //return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             Context parentContext = getParent();\n             //System.out.println(\"NAME \"+name);\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1ae290f6f5e0c7ba62eab797aba22308957b9257": {
			"type": "Ybodychange",
			"commitMessage": "consider method values of Enum\n",
			"commitDate": "2015-08-24, 1:37 PM",
			"commitName": "1ae290f6f5e0c7ba62eab797aba22308957b9257",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-24, 12:56 PM",
			"commitNameOld": "c08a0391fd27b2ecc75a264cce9eb4606d0f7b30",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,42 +1,42 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() != null) {\n             try {\n                 TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e){\n                 // ok, maybe it was instead a static access, so let's look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr){\n                     String className = ((NameExpr)wrappedNode.getScope()).getName();\n                     SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         if (name.equals(\"getModifiers\") && !ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver).isSolved()){\n                             System.out.println(\"FOO\");\n                         }\n                         SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                         if (m.isSolved()) {\n                             return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                         } else {\n-                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \"+name+\" with parameterTypes \"+parameterTypes);\n+                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\"+name+\"' with parameterTypes \"+parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr parent = (MethodCallExpr)wrappedNode.getParentNode();\n                 if (parent.getScope() == wrappedNode) {\n                     return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                 }\n             }\n             //TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             //return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             Context parentContext = getParent();\n             //System.out.println(\"NAME \"+name);\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c08a0391fd27b2ecc75a264cce9eb4606d0f7b30": {
			"type": "Ybodychange",
			"commitMessage": "improving how the parent context is determined\n",
			"commitDate": "2015-08-24, 12:56 PM",
			"commitName": "c08a0391fd27b2ecc75a264cce9eb4606d0f7b30",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-24, 12:45 PM",
			"commitNameOld": "d0348de241a6cf6be9c51500870ee1fb26172101",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,39 +1,42 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() != null) {\n             try {\n                 TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e){\n                 // ok, maybe it was instead a static access, so let's look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr){\n                     String className = ((NameExpr)wrappedNode.getScope()).getName();\n                     SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n+                        if (name.equals(\"getModifiers\") && !ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver).isSolved()){\n+                            System.out.println(\"FOO\");\n+                        }\n                         SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                         if (m.isSolved()) {\n                             return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \"+name+\" with parameterTypes \"+parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr parent = (MethodCallExpr)wrappedNode.getParentNode();\n                 if (parent.getScope() == wrappedNode) {\n                     return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                 }\n             }\n             //TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             //return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             Context parentContext = getParent();\n             //System.out.println(\"NAME \"+name);\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6a15cd55028fc9b7c73158d05f5ee335cab1f481": {
			"type": "Ybodychange",
			"commitMessage": "add test on switch on enum value\n",
			"commitDate": "2015-08-24, 10:29 AM",
			"commitName": "6a15cd55028fc9b7c73158d05f5ee335cab1f481",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-23, 4:34 AM",
			"commitNameOld": "46aefdd68f2f2597a19b72da36681123cb3090e6",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 1.25,
			"commitsBetweenForRepo": 14,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,34 +1,39 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() != null) {\n             try {\n                 TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e){\n                 // ok, maybe it was instead a static access, so let's look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr){\n                     String className = ((NameExpr)wrappedNode.getScope()).getName();\n                     SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                         if (m.isSolved()) {\n                             return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n+                        } else {\n+                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \"+name+\" with parameterTypes \"+parameterTypes);\n                         }\n+                    } else {\n+                        throw e;\n                     }\n+                } else {\n+                    throw e;\n                 }\n-                throw e;\n             }\n         } else {\n             if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr parent = (MethodCallExpr)wrappedNode.getParentNode();\n                 if (parent.getScope() == wrappedNode) {\n                     return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                 }\n             }\n             //TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             //return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             Context parentContext = getParent();\n             //System.out.println(\"NAME \"+name);\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"46aefdd68f2f2597a19b72da36681123cb3090e6": {
			"type": "Ybodychange",
			"commitMessage": "improve resolution of calls to static methods\n",
			"commitDate": "2015-08-23, 4:34 AM",
			"commitName": "46aefdd68f2f2597a19b72da36681123cb3090e6",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-23, 3:38 AM",
			"commitNameOld": "6c297529e31036058837adbaa57cee652d4cc918",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,26 +1,34 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() != null) {\n             try {\n                 TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e){\n                 // ok, maybe it was instead a static access, so let's look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr){\n                     String className = ((NameExpr)wrappedNode.getScope()).getName();\n                     SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                         if (m.isSolved()) {\n                             return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                         }\n                     }\n                 }\n                 throw e;\n             }\n         } else {\n+            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n+                MethodCallExpr parent = (MethodCallExpr)wrappedNode.getParentNode();\n+                if (parent.getScope() == wrappedNode) {\n+                    return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n+                }\n+            }\n             //TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             //return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n-            return getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n+            Context parentContext = getParent();\n+            //System.out.println(\"NAME \"+name);\n+            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6c297529e31036058837adbaa57cee652d4cc918": {
			"type": "Ybodychange",
			"commitMessage": "wip\n",
			"commitDate": "2015-08-23, 3:38 AM",
			"commitName": "6c297529e31036058837adbaa57cee652d4cc918",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-23, 2:24 AM",
			"commitNameOld": "7b2a0b366461674aa6320b11a38a17909d8a74a3",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.05,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,25 +1,26 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() != null) {\n             try {\n                 TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e){\n                 // ok, maybe it was instead a static access, so let's look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr){\n                     String className = ((NameExpr)wrappedNode.getScope()).getName();\n                     SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                         if (m.isSolved()) {\n                             return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                         }\n                     }\n                 }\n                 throw e;\n             }\n         } else {\n-            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n+            //TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+            //return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n+            return getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7b2a0b366461674aa6320b11a38a17909d8a74a3": {
			"type": "Ybodychange",
			"commitMessage": "wip\n",
			"commitDate": "2015-08-23, 2:24 AM",
			"commitName": "7b2a0b366461674aa6320b11a38a17909d8a74a3",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-23, 1:50 AM",
			"commitNameOld": "be64d2e61b56eafd01abc7236a7a0dcd6ce6dafd",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,10 +1,25 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() != null) {\n-            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n-            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n+            try {\n+                TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+                return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n+            } catch (UnsolvedSymbolException e){\n+                // ok, maybe it was instead a static access, so let's look for a type\n+                if (wrappedNode.getScope() instanceof NameExpr){\n+                    String className = ((NameExpr)wrappedNode.getScope()).getName();\n+                    SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n+                    if (ref.isSolved()) {\n+                        SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n+                        if (m.isSolved()) {\n+                            return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n+                        }\n+                    }\n+                }\n+                throw e;\n+            }\n         } else {\n             TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"be64d2e61b56eafd01abc7236a7a0dcd6ce6dafd": {
			"type": "Ybodychange",
			"commitMessage": "wip\n",
			"commitDate": "2015-08-23, 1:50 AM",
			"commitName": "be64d2e61b56eafd01abc7236a7a0dcd6ce6dafd",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-19, 3:58 AM",
			"commitNameOld": "c1e95efcb4b0a373530aa107edb2164bf6c21ac7",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 3.91,
			"commitsBetweenForRepo": 21,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,9 +1,10 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n+        // TODO consider call of static methods\n         if (wrappedNode.getScope() != null) {\n             TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n         } else {\n             TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"850c0caa4c64df32d5fc44a5512d6d41f4534a08": {
			"type": "Ybodychange",
			"commitMessage": "wip\n",
			"commitDate": "2015-08-17, 10:43 AM",
			"commitName": "850c0caa4c64df32d5fc44a5512d6d41f4534a08",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-17, 10:43 AM",
			"commitNameOld": "d393205e2ee874242b73e4fe819d1bc874587d8a",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,9 +1,9 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n             TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n         } else {\n-            throw new UnsupportedOperationException();\n-            //return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n+            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"df3e1a46a12fcc1ecafc00e59e7b7481c28ce731": {
			"type": "Ybodychange",
			"commitMessage": "playing with passing the invokation context\n",
			"commitDate": "2015-08-14, 9:16 AM",
			"commitName": "df3e1a46a12fcc1ecafc00e59e7b7481c28ce731",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-05, 8:25 AM",
			"commitNameOld": "627b56302d259409e9bc50b20d77803484f18b5c",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 9.04,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,9 +1,9 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n             TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n-            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver);\n+            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n         } else {\n             throw new UnsupportedOperationException();\n             //return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"627b56302d259409e9bc50b20d77803484f18b5c": {
			"type": "Ybodychange",
			"commitMessage": "introduce cache in JavaParserFacade\n",
			"commitDate": "2015-08-05, 8:25 AM",
			"commitName": "627b56302d259409e9bc50b20d77803484f18b5c",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-05, 7:30 AM",
			"commitNameOld": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,9 +1,9 @@\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n-            TypeUsage typeOfScope = new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n+            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         } else {\n             throw new UnsupportedOperationException();\n             //return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fd2e083224d3ee0e9ccca4431d63a84601e0d606": {
			"type": "Yintroduced",
			"commitMessage": "fix resolveReferenceToMethodWithLambda\n",
			"commitDate": "2015-08-05, 7:30 AM",
			"commitName": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
			"commitAuthor": "Federico Tomassetti"
		}
	},
	"sha": "97555053af3025556efe1a168fd7943dac28a2a6"
}