{
	"repo": "https://github.com/square/okhttp.git",
	"file": "okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java",
	"method": {
		"longName": "Http2Connection$ReaderRunnable::headers(boolean inFinished, int streamId, int associatedStreamId, List<Header> headerBlock)",
		"startLine": 644,
		"methodName": "headers",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"abb0a790802996d1039c35424b70b0f3f06b94b7": {
			"type": "Ybodychange",
			"commitMessage": "First step towards HTTP/2 automatic pings. (#3874)\n\nThis changes the executor services in HTTP/2 connection to split up\r\nlistener executors (of which there may be many threads) from writer\r\nexecutors (of which there is one per connection).\r\n\r\nThis adds a scheduled executor job to send pings on an interval. We\r\ndon't yet fail the connection if pongs are not received.\r\n\r\nFor follow-up there's some work to remove exising APIs to send pings\r\nthrough the HTTP/2 APIs. These are unused and make it awkard to\r\nconfirm that only the automatic pings are being replied to.\r\n\r\nSee https://github.com/square/okhttp/issues/3261",
			"commitDate": "2018-02-21, 6:17 PM",
			"commitName": "abb0a790802996d1039c35424b70b0f3f06b94b7",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2018-02-19, 4:04 PM",
			"commitNameOld": "64df3922164136ac4587df235222d564b016ce25",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 2.09,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,46 +1,46 @@\n     @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,\n         List<Header> headerBlock) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       Http2Stream stream;\n       synchronized (Http2Connection.this) {\n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // If we're shutdown, don't bother with this stream.\n           if (shutdown) return;\n \n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n           final Http2Stream newStream = new Http2Stream(streamId, Http2Connection.this,\n               false, inFinished, headerBlock);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n-          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n+          listenerExecutor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n             @Override public void execute() {\n               try {\n                 listener.onStream(newStream);\n               } catch (IOException e) {\n                 Platform.get().log(INFO, \"Http2Connection.Listener failure for \" + hostname, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cd22113332cdeeedac8d6bda3297194f983b4aaf": {
			"type": "Ybodychange",
			"commitMessage": "Fix occasional hang with http2 goaway frames\n\nHttp2Connection was dropping headers of healthy streams\nafter GOAWAY frame.\n\nFixes #3422\n\nSigned-off-by: Igor Fedorenko <ifedorenko@salesforce.com>\n",
			"commitDate": "2017-08-14, 8:43 AM",
			"commitName": "cd22113332cdeeedac8d6bda3297194f983b4aaf",
			"commitAuthor": "Igor Fedorenko",
			"commitDateOld": "2017-06-20, 7:14 AM",
			"commitNameOld": "5fb5ab50a77efc761489493d4a0b8b9de85feec7",
			"commitAuthorOld": "Dave Roberge",
			"daysBetweenCommits": 55.06,
			"commitsBetweenForRepo": 30,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,46 +1,46 @@\n     @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,\n         List<Header> headerBlock) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       Http2Stream stream;\n       synchronized (Http2Connection.this) {\n-        // If we're shutdown, don't bother with this stream.\n-        if (shutdown) return;\n-\n         stream = getStream(streamId);\n \n         if (stream == null) {\n+          // If we're shutdown, don't bother with this stream.\n+          if (shutdown) return;\n+\n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n           final Http2Stream newStream = new Http2Stream(streamId, Http2Connection.this,\n               false, inFinished, headerBlock);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n             @Override public void execute() {\n               try {\n                 listener.onStream(newStream);\n               } catch (IOException e) {\n                 Platform.get().log(INFO, \"Http2Connection.Listener failure for \" + hostname, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3931dc8df0c57c7f50d23f8de532da0a51434f26": {
			"type": "Ybodychange",
			"commitMessage": "Fix some classnames to use Http2 instead of Framed\n",
			"commitDate": "2017-01-29, 10:09 AM",
			"commitName": "3931dc8df0c57c7f50d23f8de532da0a51434f26",
			"commitAuthor": "jwilson",
			"commitDateOld": "2016-12-26, 6:24 PM",
			"commitNameOld": "a589b8170333476233d48476587a1d4363c90bd0",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 33.66,
			"commitsBetweenForRepo": 24,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,46 +1,46 @@\n     @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,\n         List<Header> headerBlock) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       Http2Stream stream;\n       synchronized (Http2Connection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n           final Http2Stream newStream = new Http2Stream(streamId, Http2Connection.this,\n               false, inFinished, headerBlock);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n             @Override public void execute() {\n               try {\n                 listener.onStream(newStream);\n               } catch (IOException e) {\n-                Platform.get().log(INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n+                Platform.get().log(INFO, \"Http2Connection.Listener failure for \" + hostname, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3d43a8dba89ccd7333c3ebcf74928e441790d943": {
			"type": "Ymultichange(Yfilerename,Ybodychange)",
			"commitMessage": "Rename FramedConnection to Http2Connection.\n\nAlso rename HttpStream to HttpCodec. This is the interface implemented\nfor both HTTP/1.1 and HTTP/2. The HTTP/2 codec creates a stream when\nit is used.\n",
			"commitDate": "2016-07-09, 4:09 PM",
			"commitName": "3d43a8dba89ccd7333c3ebcf74928e441790d943",
			"commitAuthor": "jwilson",
			"subchanges": [
				{
					"type": "Yfilerename",
					"commitMessage": "Rename FramedConnection to Http2Connection.\n\nAlso rename HttpStream to HttpCodec. This is the interface implemented\nfor both HTTP/1.1 and HTTP/2. The HTTP/2 codec creates a stream when\nit is used.\n",
					"commitDate": "2016-07-09, 4:09 PM",
					"commitName": "3d43a8dba89ccd7333c3ebcf74928e441790d943",
					"commitAuthor": "jwilson",
					"commitDateOld": "2016-07-09, 3:27 PM",
					"commitNameOld": "33660bf58babd09521d19ef0ed1b09c15a5e27bb",
					"commitAuthorOld": "Jesse Wilson",
					"daysBetweenCommits": 0.03,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,46 +1,46 @@\n     @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,\n         List<Header> headerBlock) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n-      FramedStream stream;\n-      synchronized (FramedConnection.this) {\n+      Http2Stream stream;\n+      synchronized (Http2Connection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n-          final FramedStream newStream = new FramedStream(streamId, FramedConnection.this,\n+          final Http2Stream newStream = new Http2Stream(streamId, Http2Connection.this,\n               false, inFinished, headerBlock);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n             @Override public void execute() {\n               try {\n                 listener.onStream(newStream);\n               } catch (IOException e) {\n                 Platform.get().log(INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldPath": "okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java",
						"newPath": "okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Rename FramedConnection to Http2Connection.\n\nAlso rename HttpStream to HttpCodec. This is the interface implemented\nfor both HTTP/1.1 and HTTP/2. The HTTP/2 codec creates a stream when\nit is used.\n",
					"commitDate": "2016-07-09, 4:09 PM",
					"commitName": "3d43a8dba89ccd7333c3ebcf74928e441790d943",
					"commitAuthor": "jwilson",
					"commitDateOld": "2016-07-09, 3:27 PM",
					"commitNameOld": "33660bf58babd09521d19ef0ed1b09c15a5e27bb",
					"commitAuthorOld": "Jesse Wilson",
					"daysBetweenCommits": 0.03,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,46 +1,46 @@\n     @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,\n         List<Header> headerBlock) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n-      FramedStream stream;\n-      synchronized (FramedConnection.this) {\n+      Http2Stream stream;\n+      synchronized (Http2Connection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n-          final FramedStream newStream = new FramedStream(streamId, FramedConnection.this,\n+          final Http2Stream newStream = new Http2Stream(streamId, Http2Connection.this,\n               false, inFinished, headerBlock);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n             @Override public void execute() {\n               try {\n                 listener.onStream(newStream);\n               } catch (IOException e) {\n                 Platform.get().log(INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"0c04821a25c83fddebb29e8cd590609142ba20a2": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Drop support for SPDY/3.\n\nIt's redundant with HTTP/2.\n",
			"commitDate": "2016-07-09, 3:19 PM",
			"commitName": "0c04821a25c83fddebb29e8cd590609142ba20a2",
			"commitAuthor": "jwilson",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Drop support for SPDY/3.\n\nIt's redundant with HTTP/2.\n",
					"commitDate": "2016-07-09, 3:19 PM",
					"commitName": "0c04821a25c83fddebb29e8cd590609142ba20a2",
					"commitAuthor": "jwilson",
					"commitDateOld": "2016-07-06, 8:02 PM",
					"commitNameOld": "1267cb958c507f123ab135cac638768009dc84b5",
					"commitAuthorOld": "Dave Roberge",
					"daysBetweenCommits": 2.8,
					"commitsBetweenForRepo": 7,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,60 +1,46 @@\n-    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n-        int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {\n+    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,\n+        List<Header> headerBlock) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       FramedStream stream;\n       synchronized (FramedConnection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n-          // The headers claim to be for an existing stream, but we don't have one.\n-          if (headersMode.failIfStreamAbsent()) {\n-            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n-            return;\n-          }\n-\n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n-          final FramedStream\n-              newStream = new FramedStream(streamId, FramedConnection.this, outFinished,\n-              inFinished, headerBlock);\n+          final FramedStream newStream = new FramedStream(streamId, FramedConnection.this,\n+              false, inFinished, headerBlock);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n             @Override public void execute() {\n               try {\n                 listener.onStream(newStream);\n               } catch (IOException e) {\n                 Platform.get().log(INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n-      // The headers claim to be for a new stream, but we already have one.\n-      if (headersMode.failIfStreamPresent()) {\n-        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n-        removeStream(streamId);\n-        return;\n-      }\n-\n       // Update an existing stream.\n-      stream.receiveHeaders(headerBlock, headersMode);\n+      stream.receiveHeaders(headerBlock);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[outFinished-boolean, inFinished-boolean, streamId-int, associatedStreamId-int, headerBlock-List<Header>, headersMode-HeadersMode]",
						"newValue": "[inFinished-boolean, streamId-int, associatedStreamId-int, headerBlock-List<Header>]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Drop support for SPDY/3.\n\nIt's redundant with HTTP/2.\n",
					"commitDate": "2016-07-09, 3:19 PM",
					"commitName": "0c04821a25c83fddebb29e8cd590609142ba20a2",
					"commitAuthor": "jwilson",
					"commitDateOld": "2016-07-06, 8:02 PM",
					"commitNameOld": "1267cb958c507f123ab135cac638768009dc84b5",
					"commitAuthorOld": "Dave Roberge",
					"daysBetweenCommits": 2.8,
					"commitsBetweenForRepo": 7,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,60 +1,46 @@\n-    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n-        int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {\n+    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,\n+        List<Header> headerBlock) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       FramedStream stream;\n       synchronized (FramedConnection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n-          // The headers claim to be for an existing stream, but we don't have one.\n-          if (headersMode.failIfStreamAbsent()) {\n-            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n-            return;\n-          }\n-\n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n-          final FramedStream\n-              newStream = new FramedStream(streamId, FramedConnection.this, outFinished,\n-              inFinished, headerBlock);\n+          final FramedStream newStream = new FramedStream(streamId, FramedConnection.this,\n+              false, inFinished, headerBlock);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n             @Override public void execute() {\n               try {\n                 listener.onStream(newStream);\n               } catch (IOException e) {\n                 Platform.get().log(INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n-      // The headers claim to be for a new stream, but we already have one.\n-      if (headersMode.failIfStreamPresent()) {\n-        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n-        removeStream(streamId);\n-        return;\n-      }\n-\n       // Update an existing stream.\n-      stream.receiveHeaders(headerBlock, headersMode);\n+      stream.receiveHeaders(headerBlock);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"4f24a30c12032b7033884a630696014afd3e77cb": {
			"type": "Ybodychange",
			"commitMessage": "Make logging more consistent throughout OkHttp.\n\nAvoid using System.out.\n\nUse the best logging implementation on the host platform. On Java this is\njava.util.logging. On Android it's Android.util.Log.\n\nCloses https://github.com/square/okhttp/issues/2505\n",
			"commitDate": "2016-05-07, 7:08 PM",
			"commitName": "4f24a30c12032b7033884a630696014afd3e77cb",
			"commitAuthor": "jwilson",
			"commitDateOld": "2016-04-28, 8:35 PM",
			"commitNameOld": "4b0c09eb6f931c7ba9a5735c81af115a302ed336",
			"commitAuthorOld": "Venil Noronha",
			"daysBetweenCommits": 8.94,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,60 +1,60 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       FramedStream stream;\n       synchronized (FramedConnection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // The headers claim to be for an existing stream, but we don't have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n           final FramedStream\n               newStream = new FramedStream(streamId, FramedConnection.this, outFinished,\n               inFinished, headerBlock);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n             @Override public void execute() {\n               try {\n                 listener.onStream(newStream);\n               } catch (IOException e) {\n-                logger.log(Level.INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n+                Platform.get().log(INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2dade17682071a3e1d60df4113795117e5c1833c": {
			"type": "Ybodychange",
			"commitMessage": "Prefer hostname over hostName.\n\nUnfortunately MockWebServer exposes a method getHostName() so I can't\nfix it everywhere without breaking the API. But that's a mistake, we\nreally want it to be hostname going forward.\n\nAlso fix some missing copyright statements.\n",
			"commitDate": "2016-02-06, 10:38 AM",
			"commitName": "2dade17682071a3e1d60df4113795117e5c1833c",
			"commitAuthor": "jwilson",
			"commitDateOld": "2015-12-23, 5:34 PM",
			"commitNameOld": "98ae0fb92c9335ec17f8710376183e18f5edd355",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 44.71,
			"commitsBetweenForRepo": 72,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,60 +1,60 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       FramedStream stream;\n       synchronized (FramedConnection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // The headers claim to be for an existing stream, but we don't have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n           final FramedStream\n               newStream = new FramedStream(streamId, FramedConnection.this, outFinished,\n               inFinished, headerBlock);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n-          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n+          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostname, streamId) {\n             @Override public void execute() {\n               try {\n                 listener.onStream(newStream);\n               } catch (IOException e) {\n-                logger.log(Level.INFO, \"FramedConnection.Listener failure for \" + hostName, e);\n+                logger.log(Level.INFO, \"FramedConnection.Listener failure for \" + hostname, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c9a89876de476983f273edbf108c365127c18c5e": {
			"type": "Ymovefromfile",
			"commitMessage": "Rename com.squareup.okhttp to okhttp3\n\nMaven group changes will come in follow up.\n",
			"commitDate": "2015-12-15, 11:34 PM",
			"commitName": "c9a89876de476983f273edbf108c365127c18c5e",
			"commitAuthor": "jwilson",
			"commitDateOld": "2015-12-15, 7:36 PM",
			"commitNameOld": "54dc2df914f2aae37fb48cc2c2f7560ee664bc2b",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 0.17,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedConnection.java",
				"newPath": "okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java",
				"oldMethodName": "headers",
				"newMethodName": "headers"
			}
		},
		"38aaf7bca6d998d0d1a1839d2b8816735f9b8914": {
			"type": "Ybodychange",
			"commitMessage": "Turn IncomingStreamHandler into FramedConnection.Listener.\n\nAdd a callback invoked on settings changes. The concurrency here\nis a little awkward because the calls into the listener are not\nserialized.\n\nThis is going to be used in a follow up change to keep the\nconnection's allocation limit in sync.\n",
			"commitDate": "2015-12-06, 7:59 AM",
			"commitName": "38aaf7bca6d998d0d1a1839d2b8816735f9b8914",
			"commitAuthor": "jwilson",
			"commitDateOld": "2015-12-02, 10:44 AM",
			"commitNameOld": "c5f58e45454d1ffc621c65e377cb91345018e087",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 3.89,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,60 +1,60 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       FramedStream stream;\n       synchronized (FramedConnection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // The headers claim to be for an existing stream, but we don't have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n           final FramedStream\n               newStream = new FramedStream(streamId, FramedConnection.this, outFinished,\n               inFinished, headerBlock);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n-                handler.receive(newStream);\n+                listener.onStream(newStream);\n               } catch (IOException e) {\n-                logger.log(Level.INFO, \"StreamHandler failure for \" + hostName, e);\n+                logger.log(Level.INFO, \"FramedConnection.Listener failure for \" + hostName, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c753d2e41ba667f9b5a31451a16ecbaecdc65d80": {
			"type": "Ymultichange(Yfilerename,Ybodychange)",
			"commitMessage": "Rename 'spdy' references to 'framed' where appropriate.\n",
			"commitDate": "2015-06-17, 4:40 PM",
			"commitName": "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
			"commitAuthor": "Jake Wharton",
			"subchanges": [
				{
					"type": "Yfilerename",
					"commitMessage": "Rename 'spdy' references to 'framed' where appropriate.\n",
					"commitDate": "2015-06-17, 4:40 PM",
					"commitName": "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
					"commitAuthor": "Jake Wharton",
					"commitDateOld": "2015-06-16, 10:46 AM",
					"commitNameOld": "b262f2a03001cd990568b929b2739dd3c7adb75f",
					"commitAuthorOld": "Jesse Wilson",
					"daysBetweenCommits": 1.25,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,59 +1,60 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n-      SpdyStream stream;\n-      synchronized (SpdyConnection.this) {\n+      FramedStream stream;\n+      synchronized (FramedConnection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // The headers claim to be for an existing stream, but we don't have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n-          final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,\n+          final FramedStream\n+              newStream = new FramedStream(streamId, FramedConnection.this, outFinished,\n               inFinished, headerBlock);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 logger.log(Level.INFO, \"StreamHandler failure for \" + hostName, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldPath": "okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
						"newPath": "okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedConnection.java"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Rename 'spdy' references to 'framed' where appropriate.\n",
					"commitDate": "2015-06-17, 4:40 PM",
					"commitName": "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
					"commitAuthor": "Jake Wharton",
					"commitDateOld": "2015-06-16, 10:46 AM",
					"commitNameOld": "b262f2a03001cd990568b929b2739dd3c7adb75f",
					"commitAuthorOld": "Jesse Wilson",
					"daysBetweenCommits": 1.25,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,59 +1,60 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n-      SpdyStream stream;\n-      synchronized (SpdyConnection.this) {\n+      FramedStream stream;\n+      synchronized (FramedConnection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // The headers claim to be for an existing stream, but we don't have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n-          final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,\n+          final FramedStream\n+              newStream = new FramedStream(streamId, FramedConnection.this, outFinished,\n               inFinished, headerBlock);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 logger.log(Level.INFO, \"StreamHandler failure for \" + hostName, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"8fe27a50c2c88d382e6dc6600836bcc57fc7b0cf": {
			"type": "Ybodychange",
			"commitMessage": "Crash on unexpected RuntimeExceptions.\n\nCurrently we're sweeping these under the rug.\n",
			"commitDate": "2015-05-17, 4:05 PM",
			"commitName": "8fe27a50c2c88d382e6dc6600836bcc57fc7b0cf",
			"commitAuthor": "jwilson",
			"commitDateOld": "2015-05-01, 8:54 AM",
			"commitNameOld": "c8bd6f834d848c0a51245e263f81a7b2f6c7c11c",
			"commitAuthorOld": "",
			"daysBetweenCommits": 16.3,
			"commitsBetweenForRepo": 37,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,58 +1,59 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // The headers claim to be for an existing stream, but we don't have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,\n               inFinished, headerBlock);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n-              } catch (RuntimeException | IOException e) {\n+              } catch (IOException e) {\n+                logger.log(Level.INFO, \"StreamHandler failure for \" + hostName, e);\n                 try {\n                   newStream.close(ErrorCode.PROTOCOL_ERROR);\n                 } catch (IOException ignored) {\n                 }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fb155c47661ede5da395dfb4e620867263b8c8e7": {
			"type": "Ybodychange",
			"commitMessage": "Fix MockWebServer with SPDY on Android.\n\nFix for issue #1552\nRelated to commit f78f74f from issue #1294\n\nBefore this change:\nSpdyConnection creates threads to handle the reading and writing. If\nthose threads die from a RuntimeException it triggers Android's default\nUncaughtExceptionHandler, which kills the test process. Previously exceptions\nwere being swallowed, but commit f78f74f caused the exceptions to be\npropagated.\n\nThis change adds extra handling for RuntimeException to stop them escaping.\n",
			"commitDate": "2015-04-14, 9:54 AM",
			"commitName": "fb155c47661ede5da395dfb4e620867263b8c8e7",
			"commitAuthor": "Neil Fuller",
			"commitDateOld": "2015-03-11, 9:18 AM",
			"commitNameOld": "60b1dfc169156f300045fd0e01e89b890661b5a7",
			"commitAuthorOld": "Adrian Cole",
			"daysBetweenCommits": 34.03,
			"commitsBetweenForRepo": 28,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,55 +1,58 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // The headers claim to be for an existing stream, but we don't have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,\n               inFinished, headerBlock);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n-              } catch (IOException e) {\n-                throw new RuntimeException(e);\n+              } catch (RuntimeException | IOException e) {\n+                try {\n+                  newStream.close(ErrorCode.PROTOCOL_ERROR);\n+                } catch (IOException ignored) {\n+                }\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f78f74f5a2cf1f73f974487816f998a6e37a9cf1": {
			"type": "Ybodychange",
			"commitMessage": "Use ExecutorService.execute, not ExecutorService.submit.\n\nThe latter returns a Future that we never call get() on, and\nnever get the exception from.\n\nFixes: https://github.com/square/okhttp/issues/1294\n",
			"commitDate": "2015-03-10, 8:01 PM",
			"commitName": "f78f74f5a2cf1f73f974487816f998a6e37a9cf1",
			"commitAuthor": "jwilson",
			"commitDateOld": "2014-12-26, 4:12 PM",
			"commitNameOld": "955934836fc466d93d6e41d1ff9391d9e5b3f09a",
			"commitAuthorOld": "",
			"daysBetweenCommits": 74.12,
			"commitsBetweenForRepo": 94,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,55 +1,55 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // The headers claim to be for an existing stream, but we don't have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,\n               inFinished, headerBlock);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n-          executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n+          executor.execute(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cc38140be4c7e41330cf7749c3eeba23c85f9522": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Added support for http/2 draft 12, which is incompatible with previous priority schemes.\n",
			"commitDate": "2014-05-04, 12:53 PM",
			"commitName": "cc38140be4c7e41330cf7749c3eeba23c85f9522",
			"commitAuthor": "Adrian Cole",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Added support for http/2 draft 12, which is incompatible with previous priority schemes.\n",
					"commitDate": "2014-05-04, 12:53 PM",
					"commitName": "cc38140be4c7e41330cf7749c3eeba23c85f9522",
					"commitAuthor": "Adrian Cole",
					"commitDateOld": "2014-04-18, 9:58 AM",
					"commitNameOld": "889bc764a5f1627090a69e6e100bcd18474dfb86",
					"commitAuthorOld": "Jesse Wilson",
					"daysBetweenCommits": 16.12,
					"commitsBetweenForRepo": 65,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,55 +1,55 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n-        int associatedStreamId, int priority, List<Header> headerBlock, HeadersMode headersMode) {\n+        int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // The headers claim to be for an existing stream, but we don't have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,\n-              inFinished, priority, headerBlock);\n+              inFinished, headerBlock);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[outFinished-boolean, inFinished-boolean, streamId-int, associatedStreamId-int, priority-int, headerBlock-List<Header>, headersMode-HeadersMode]",
						"newValue": "[outFinished-boolean, inFinished-boolean, streamId-int, associatedStreamId-int, headerBlock-List<Header>, headersMode-HeadersMode]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Added support for http/2 draft 12, which is incompatible with previous priority schemes.\n",
					"commitDate": "2014-05-04, 12:53 PM",
					"commitName": "cc38140be4c7e41330cf7749c3eeba23c85f9522",
					"commitAuthor": "Adrian Cole",
					"commitDateOld": "2014-04-18, 9:58 AM",
					"commitNameOld": "889bc764a5f1627090a69e6e100bcd18474dfb86",
					"commitAuthorOld": "Jesse Wilson",
					"daysBetweenCommits": 16.12,
					"commitsBetweenForRepo": 65,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,55 +1,55 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n-        int associatedStreamId, int priority, List<Header> headerBlock, HeadersMode headersMode) {\n+        int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {\n       if (pushedStream(streamId)) {\n         pushHeadersLater(streamId, headerBlock, inFinished);\n         return;\n       }\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // The headers claim to be for an existing stream, but we don't have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,\n-              inFinished, priority, headerBlock);\n+              inFinished, headerBlock);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"a5ba3e9062f3bde4bb6896f1db433a2408119e94": {
			"type": "Ybodychange",
			"commitMessage": "Add HTTP/2 PushObserver.\n",
			"commitDate": "2014-03-01, 10:23 PM",
			"commitName": "a5ba3e9062f3bde4bb6896f1db433a2408119e94",
			"commitAuthor": "Adrian Cole",
			"commitDateOld": "2014-02-27, 9:28 PM",
			"commitNameOld": "110a4fac4257fe2df0e23149fbef76e750604cf4",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 2.04,
			"commitsBetweenForRepo": 10,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,52 +1,55 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n-        int associatedStreamId, int priority, List<Header> headerBlock,\n-        HeadersMode headersMode) {\n+        int associatedStreamId, int priority, List<Header> headerBlock, HeadersMode headersMode) {\n+      if (pushedStream(streamId)) {\n+        pushHeadersLater(streamId, headerBlock, inFinished);\n+        return;\n+      }\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // The headers claim to be for an existing stream, but we don't have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,\n               inFinished, priority, headerBlock);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"110a4fac4257fe2df0e23149fbef76e750604cf4": {
			"type": "Yfilerename",
			"commitMessage": "Rearrange OkHttp modules.\n\nThe HTTP client and SPDY code are now a single module that\nmockwebserver depends upon.\n\nThe tests are now in a separate module that depends on both\nOkHttp and mockwebserver.\n",
			"commitDate": "2014-02-27, 9:28 PM",
			"commitName": "110a4fac4257fe2df0e23149fbef76e750604cf4",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2014-02-25, 8:34 PM",
			"commitNameOld": "d5cbd0aebe090d956f54b6697068fcbff6d668e7",
			"commitAuthorOld": "Adrian Cole",
			"daysBetweenCommits": 2.04,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
				"newPath": "okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java"
			}
		},
		"358169b89f32c00bf229b4e42ccef756588da71f": {
			"type": "Ybodychange",
			"commitMessage": "Send window update after the peer sends half the limit on a stream or connection.\n",
			"commitDate": "2014-01-26, 10:54 PM",
			"commitName": "358169b89f32c00bf229b4e42ccef756588da71f",
			"commitAuthor": "Adrian Cole",
			"commitDateOld": "2014-01-26, 3:01 PM",
			"commitNameOld": "d990b5819cd6282923134564f3bcc59263eb0616",
			"commitAuthorOld": "Adrian Cole",
			"daysBetweenCommits": 0.33,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,52 +1,52 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, int priority, List<Header> headerBlock,\n         HeadersMode headersMode) {\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // The headers claim to be for an existing stream, but we don't have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,\n-              inFinished, priority, headerBlock, initialWindowSize);\n+              inFinished, priority, headerBlock);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d4508141fc9fa1b816c5a1ff3f39149d4dfb22de": {
			"type": "Ybodychange",
			"commitMessage": "Honor change in connection-level initial write window from peer settings.\n",
			"commitDate": "2014-01-26, 12:48 PM",
			"commitName": "d4508141fc9fa1b816c5a1ff3f39149d4dfb22de",
			"commitAuthor": "Adrian Cole",
			"commitDateOld": "2014-01-26, 10:36 AM",
			"commitNameOld": "b9b5c8462da2abe26dcf157d2df483ba61e3d379",
			"commitAuthorOld": "",
			"daysBetweenCommits": 0.09,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,52 +1,52 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, int priority, List<Header> headerBlock,\n         HeadersMode headersMode) {\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // The headers claim to be for an existing stream, but we don't have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,\n-              inFinished, priority, headerBlock, peerSettings);\n+              inFinished, priority, headerBlock, initialWindowSize);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f214cf9670339b850f97da4a2d4ad64758fd0e4d": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Framing of headers blocks happen after compression.\n",
			"commitDate": "2014-01-21, 9:27 AM",
			"commitName": "f214cf9670339b850f97da4a2d4ad64758fd0e4d",
			"commitAuthor": "Adrian Cole",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Framing of headers blocks happen after compression.\n",
					"commitDate": "2014-01-21, 9:27 AM",
					"commitName": "f214cf9670339b850f97da4a2d4ad64758fd0e4d",
					"commitAuthor": "Adrian Cole",
					"commitDateOld": "2014-01-20, 3:17 PM",
					"commitNameOld": "9110ef83bf35a006368ae251ccd170cd72ba6415",
					"commitAuthorOld": "Adrian Cole",
					"daysBetweenCommits": 0.76,
					"commitsBetweenForRepo": 2,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,52 +1,52 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n-        int associatedStreamId, int priority, List<Header> nameValueBlock,\n+        int associatedStreamId, int priority, List<Header> headerBlock,\n         HeadersMode headersMode) {\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // The headers claim to be for an existing stream, but we don't have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,\n-              inFinished, priority, nameValueBlock, peerSettings);\n+              inFinished, priority, headerBlock, peerSettings);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n-      stream.receiveHeaders(nameValueBlock, headersMode);\n+      stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[outFinished-boolean, inFinished-boolean, streamId-int, associatedStreamId-int, priority-int, nameValueBlock-List<Header>, headersMode-HeadersMode]",
						"newValue": "[outFinished-boolean, inFinished-boolean, streamId-int, associatedStreamId-int, priority-int, headerBlock-List<Header>, headersMode-HeadersMode]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Framing of headers blocks happen after compression.\n",
					"commitDate": "2014-01-21, 9:27 AM",
					"commitName": "f214cf9670339b850f97da4a2d4ad64758fd0e4d",
					"commitAuthor": "Adrian Cole",
					"commitDateOld": "2014-01-20, 3:17 PM",
					"commitNameOld": "9110ef83bf35a006368ae251ccd170cd72ba6415",
					"commitAuthorOld": "Adrian Cole",
					"daysBetweenCommits": 0.76,
					"commitsBetweenForRepo": 2,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,52 +1,52 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n-        int associatedStreamId, int priority, List<Header> nameValueBlock,\n+        int associatedStreamId, int priority, List<Header> headerBlock,\n         HeadersMode headersMode) {\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // The headers claim to be for an existing stream, but we don't have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,\n-              inFinished, priority, nameValueBlock, peerSettings);\n+              inFinished, priority, headerBlock, peerSettings);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n-      stream.receiveHeaders(nameValueBlock, headersMode);\n+      stream.receiveHeaders(headerBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"b95a0ccbcae50f92acc923d62fc6c9cecc6bbb63": {
			"type": "Yparameterchange",
			"commitMessage": "Top-level immutable, internal HeaderEntry class to reduce duplication around header names.  Do not emit :version in http/2.\n",
			"commitDate": "2014-01-19, 11:35 AM",
			"commitName": "b95a0ccbcae50f92acc923d62fc6c9cecc6bbb63",
			"commitAuthor": "Adrian Cole",
			"commitDateOld": "2014-01-18, 9:46 PM",
			"commitNameOld": "ef30f7efc61ac249c1a8b43e41dba03a2bf0bef8",
			"commitAuthorOld": "Adrian Cole",
			"daysBetweenCommits": 0.58,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,52 +1,52 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n-        int associatedStreamId, int priority, List<ByteString> nameValueBlock,\n+        int associatedStreamId, int priority, List<Header> nameValueBlock,\n         HeadersMode headersMode) {\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // The headers claim to be for an existing stream, but we don't have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,\n               inFinished, priority, nameValueBlock, peerSettings);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(nameValueBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[outFinished-boolean, inFinished-boolean, streamId-int, associatedStreamId-int, priority-int, nameValueBlock-List<ByteString>, headersMode-HeadersMode]",
				"newValue": "[outFinished-boolean, inFinished-boolean, streamId-int, associatedStreamId-int, priority-int, nameValueBlock-List<Header>, headersMode-HeadersMode]"
			}
		},
		"ef30f7efc61ac249c1a8b43e41dba03a2bf0bef8": {
			"type": "Ybodychange",
			"commitMessage": "Extract default settings to variants.  Read windowSize (spdy/3) and headerTableSize (http/2) from peer.\n",
			"commitDate": "2014-01-18, 9:46 PM",
			"commitName": "ef30f7efc61ac249c1a8b43e41dba03a2bf0bef8",
			"commitAuthor": "Adrian Cole",
			"commitDateOld": "2014-01-16, 9:39 AM",
			"commitNameOld": "9766de54dc8be4560b45d89452b016998277dae3",
			"commitAuthorOld": "Adrian Cole",
			"daysBetweenCommits": 2.51,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,52 +1,52 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, int priority, List<ByteString> nameValueBlock,\n         HeadersMode headersMode) {\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // The headers claim to be for an existing stream, but we don't have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,\n-              inFinished, priority, nameValueBlock, settings);\n+              inFinished, priority, nameValueBlock, peerSettings);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(nameValueBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"749a65b776c8fc4b39b6463695980275da34da51": {
			"type": "Ybodychange",
			"commitMessage": "Use thread names everywhere.\n\nSometimes we name a thread both via its ExecutorService\nand via a NamedRunnable. The ExecutorService thread needs\nto be named because threads are cached and will be visible\nin a thread dump even when no runnables are running.\n\nNamedRunnables are also used because they provide additional\ncontext: the host or URL being serviced by a thread.\n",
			"commitDate": "2014-01-12, 7:47 AM",
			"commitName": "749a65b776c8fc4b39b6463695980275da34da51",
			"commitAuthor": "jwilson",
			"commitDateOld": "2014-01-06, 7:51 PM",
			"commitNameOld": "5c787a0b9d5c83c764880da4b1503a65ee0ff267",
			"commitAuthorOld": "Adrian Cole",
			"daysBetweenCommits": 5.5,
			"commitsBetweenForRepo": 20,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,52 +1,52 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n         int associatedStreamId, int priority, List<ByteString> nameValueBlock,\n         HeadersMode headersMode) {\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // The headers claim to be for an existing stream, but we don't have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,\n               inFinished, priority, nameValueBlock, settings);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n-          executor.submit(new NamedRunnable(\"OkHttp Callback %s stream %d\", hostName, streamId) {\n+          executor.submit(new NamedRunnable(\"OkHttp %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(nameValueBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5c787a0b9d5c83c764880da4b1503a65ee0ff267": {
			"type": "Yparameterchange",
			"commitMessage": "Refactor SPDY code to use ByteString for headers.\n",
			"commitDate": "2014-01-06, 7:51 PM",
			"commitName": "5c787a0b9d5c83c764880da4b1503a65ee0ff267",
			"commitAuthor": "Adrian Cole",
			"commitDateOld": "2014-01-05, 5:53 PM",
			"commitNameOld": "d7444f5fc4414b51b2708606257381cc0de404e1",
			"commitAuthorOld": "Adrian Cole",
			"daysBetweenCommits": 1.08,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,52 +1,52 @@\n     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n-        int associatedStreamId, int priority, List<String> nameValueBlock,\n+        int associatedStreamId, int priority, List<ByteString> nameValueBlock,\n         HeadersMode headersMode) {\n       SpdyStream stream;\n       synchronized (SpdyConnection.this) {\n         // If we're shutdown, don't bother with this stream.\n         if (shutdown) return;\n \n         stream = getStream(streamId);\n \n         if (stream == null) {\n           // The headers claim to be for an existing stream, but we don't have one.\n           if (headersMode.failIfStreamAbsent()) {\n             writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n             return;\n           }\n \n           // If the stream ID is less than the last created ID, assume it's already closed.\n           if (streamId <= lastGoodStreamId) return;\n \n           // If the stream ID is in the client's namespace, assume it's already closed.\n           if (streamId % 2 == nextStreamId % 2) return;\n \n           // Create a stream.\n           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,\n               inFinished, priority, nameValueBlock, settings);\n           lastGoodStreamId = streamId;\n           streams.put(streamId, newStream);\n           executor.submit(new NamedRunnable(\"OkHttp Callback %s stream %d\", hostName, streamId) {\n             @Override public void execute() {\n               try {\n                 handler.receive(newStream);\n               } catch (IOException e) {\n                 throw new RuntimeException(e);\n               }\n             }\n           });\n           return;\n         }\n       }\n \n       // The headers claim to be for a new stream, but we already have one.\n       if (headersMode.failIfStreamPresent()) {\n         stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n         removeStream(streamId);\n         return;\n       }\n \n       // Update an existing stream.\n       stream.receiveHeaders(nameValueBlock, headersMode);\n       if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[outFinished-boolean, inFinished-boolean, streamId-int, associatedStreamId-int, priority-int, nameValueBlock-List<String>, headersMode-HeadersMode]",
				"newValue": "[outFinished-boolean, inFinished-boolean, streamId-int, associatedStreamId-int, priority-int, nameValueBlock-List<ByteString>, headersMode-HeadersMode]"
			}
		},
		"a91124b6d4e2eb1bb3c71a7a8ddff7d40b7db55a": {
			"type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
			"commitMessage": "Use one callback for SYN_STREAM, SYN_REPLY and HEADERS.\n\nThis is closer to the semantics of HTTP/2.0, which uses the HEADERS\nframe for all three types. SPDY is a bit more strict because it\nrelies on redundancy; it's an error to send a SYN_REPLY after a\nHEADERS frame. With HTTP/2.0, there's only one type so there's\nno error to detect.\n",
			"commitDate": "2013-09-01, 11:57 AM",
			"commitName": "a91124b6d4e2eb1bb3c71a7a8ddff7d40b7db55a",
			"commitAuthor": "jwilson",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Use one callback for SYN_STREAM, SYN_REPLY and HEADERS.\n\nThis is closer to the semantics of HTTP/2.0, which uses the HEADERS\nframe for all three types. SPDY is a bit more strict because it\nrelies on redundancy; it's an error to send a SYN_REPLY after a\nHEADERS frame. With HTTP/2.0, there's only one type so there's\nno error to detect.\n",
					"commitDate": "2013-09-01, 11:57 AM",
					"commitName": "a91124b6d4e2eb1bb3c71a7a8ddff7d40b7db55a",
					"commitAuthor": "jwilson",
					"commitDateOld": "2013-08-27, 8:25 AM",
					"commitNameOld": "5663f815af072160f344712d5b353439bd2066f1",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 5.15,
					"commitsBetweenForRepo": 4,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,7 +1,52 @@\n-    @Override public void headers(int streamId, List<String> nameValueBlock)\n-        throws IOException {\n-      SpdyStream replyStream = getStream(streamId);\n-      if (replyStream != null) {\n-        replyStream.receiveHeaders(nameValueBlock);\n+    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n+        int associatedStreamId, int priority, List<String> nameValueBlock,\n+        HeadersMode headersMode) {\n+      SpdyStream stream;\n+      synchronized (SpdyConnection.this) {\n+        // If we're shutdown, don't bother with this stream.\n+        if (shutdown) return;\n+\n+        stream = getStream(streamId);\n+\n+        if (stream == null) {\n+          // The headers claim to be for an existing stream, but we don't have one.\n+          if (headersMode.failIfStreamAbsent()) {\n+            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n+            return;\n+          }\n+\n+          // If the stream ID is less than the last created ID, assume it's already closed.\n+          if (streamId <= lastGoodStreamId) return;\n+\n+          // If the stream ID is in the client's namespace, assume it's already closed.\n+          if (streamId % 2 == nextStreamId % 2) return;\n+\n+          // Create a stream.\n+          final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,\n+              inFinished, priority, nameValueBlock, settings);\n+          lastGoodStreamId = streamId;\n+          streams.put(streamId, newStream);\n+          executor.submit(new NamedRunnable(\"OkHttp Callback %s stream %d\", hostName, streamId) {\n+            @Override public void execute() {\n+              try {\n+                handler.receive(newStream);\n+              } catch (IOException e) {\n+                throw new RuntimeException(e);\n+              }\n+            }\n+          });\n+          return;\n+        }\n       }\n+\n+      // The headers claim to be for a new stream, but we already have one.\n+      if (headersMode.failIfStreamPresent()) {\n+        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n+        removeStream(streamId);\n+        return;\n+      }\n+\n+      // Update an existing stream.\n+      stream.receiveHeaders(nameValueBlock, headersMode);\n+      if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[streamId-int, nameValueBlock-List<String>]",
						"newValue": "[outFinished-boolean, inFinished-boolean, streamId-int, associatedStreamId-int, priority-int, nameValueBlock-List<String>, headersMode-HeadersMode]"
					}
				},
				{
					"type": "Yexceptionschange",
					"commitMessage": "Use one callback for SYN_STREAM, SYN_REPLY and HEADERS.\n\nThis is closer to the semantics of HTTP/2.0, which uses the HEADERS\nframe for all three types. SPDY is a bit more strict because it\nrelies on redundancy; it's an error to send a SYN_REPLY after a\nHEADERS frame. With HTTP/2.0, there's only one type so there's\nno error to detect.\n",
					"commitDate": "2013-09-01, 11:57 AM",
					"commitName": "a91124b6d4e2eb1bb3c71a7a8ddff7d40b7db55a",
					"commitAuthor": "jwilson",
					"commitDateOld": "2013-08-27, 8:25 AM",
					"commitNameOld": "5663f815af072160f344712d5b353439bd2066f1",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 5.15,
					"commitsBetweenForRepo": 4,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,7 +1,52 @@\n-    @Override public void headers(int streamId, List<String> nameValueBlock)\n-        throws IOException {\n-      SpdyStream replyStream = getStream(streamId);\n-      if (replyStream != null) {\n-        replyStream.receiveHeaders(nameValueBlock);\n+    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n+        int associatedStreamId, int priority, List<String> nameValueBlock,\n+        HeadersMode headersMode) {\n+      SpdyStream stream;\n+      synchronized (SpdyConnection.this) {\n+        // If we're shutdown, don't bother with this stream.\n+        if (shutdown) return;\n+\n+        stream = getStream(streamId);\n+\n+        if (stream == null) {\n+          // The headers claim to be for an existing stream, but we don't have one.\n+          if (headersMode.failIfStreamAbsent()) {\n+            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n+            return;\n+          }\n+\n+          // If the stream ID is less than the last created ID, assume it's already closed.\n+          if (streamId <= lastGoodStreamId) return;\n+\n+          // If the stream ID is in the client's namespace, assume it's already closed.\n+          if (streamId % 2 == nextStreamId % 2) return;\n+\n+          // Create a stream.\n+          final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,\n+              inFinished, priority, nameValueBlock, settings);\n+          lastGoodStreamId = streamId;\n+          streams.put(streamId, newStream);\n+          executor.submit(new NamedRunnable(\"OkHttp Callback %s stream %d\", hostName, streamId) {\n+            @Override public void execute() {\n+              try {\n+                handler.receive(newStream);\n+              } catch (IOException e) {\n+                throw new RuntimeException(e);\n+              }\n+            }\n+          });\n+          return;\n+        }\n       }\n+\n+      // The headers claim to be for a new stream, but we already have one.\n+      if (headersMode.failIfStreamPresent()) {\n+        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n+        removeStream(streamId);\n+        return;\n+      }\n+\n+      // Update an existing stream.\n+      stream.receiveHeaders(nameValueBlock, headersMode);\n+      if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[IOException]",
						"newValue": "[]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Use one callback for SYN_STREAM, SYN_REPLY and HEADERS.\n\nThis is closer to the semantics of HTTP/2.0, which uses the HEADERS\nframe for all three types. SPDY is a bit more strict because it\nrelies on redundancy; it's an error to send a SYN_REPLY after a\nHEADERS frame. With HTTP/2.0, there's only one type so there's\nno error to detect.\n",
					"commitDate": "2013-09-01, 11:57 AM",
					"commitName": "a91124b6d4e2eb1bb3c71a7a8ddff7d40b7db55a",
					"commitAuthor": "jwilson",
					"commitDateOld": "2013-08-27, 8:25 AM",
					"commitNameOld": "5663f815af072160f344712d5b353439bd2066f1",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 5.15,
					"commitsBetweenForRepo": 4,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,7 +1,52 @@\n-    @Override public void headers(int streamId, List<String> nameValueBlock)\n-        throws IOException {\n-      SpdyStream replyStream = getStream(streamId);\n-      if (replyStream != null) {\n-        replyStream.receiveHeaders(nameValueBlock);\n+    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,\n+        int associatedStreamId, int priority, List<String> nameValueBlock,\n+        HeadersMode headersMode) {\n+      SpdyStream stream;\n+      synchronized (SpdyConnection.this) {\n+        // If we're shutdown, don't bother with this stream.\n+        if (shutdown) return;\n+\n+        stream = getStream(streamId);\n+\n+        if (stream == null) {\n+          // The headers claim to be for an existing stream, but we don't have one.\n+          if (headersMode.failIfStreamAbsent()) {\n+            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);\n+            return;\n+          }\n+\n+          // If the stream ID is less than the last created ID, assume it's already closed.\n+          if (streamId <= lastGoodStreamId) return;\n+\n+          // If the stream ID is in the client's namespace, assume it's already closed.\n+          if (streamId % 2 == nextStreamId % 2) return;\n+\n+          // Create a stream.\n+          final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,\n+              inFinished, priority, nameValueBlock, settings);\n+          lastGoodStreamId = streamId;\n+          streams.put(streamId, newStream);\n+          executor.submit(new NamedRunnable(\"OkHttp Callback %s stream %d\", hostName, streamId) {\n+            @Override public void execute() {\n+              try {\n+                handler.receive(newStream);\n+              } catch (IOException e) {\n+                throw new RuntimeException(e);\n+              }\n+            }\n+          });\n+          return;\n+        }\n       }\n+\n+      // The headers claim to be for a new stream, but we already have one.\n+      if (headersMode.failIfStreamPresent()) {\n+        stream.closeLater(ErrorCode.PROTOCOL_ERROR);\n+        removeStream(streamId);\n+        return;\n+      }\n+\n+      // Update an existing stream.\n+      stream.receiveHeaders(nameValueBlock, headersMode);\n+      if (inFinished) stream.receiveFin();\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"2f31d7122d8806b6c32d2d1e181ca635fb80bba7": {
			"type": "Yparameterchange",
			"commitMessage": "Hide more flags from SPDY APIs.\n\nFlags are not portable between SPDY/3 and HTTP/2.0,\nso hide them in the reader & writer code.\n\nAlso rename SpdyReader to FrameReader and SpdyWriter to\nFrameWriter. Other classes will be renamed as they become\nindependent of the underlying protocol.\n",
			"commitDate": "2013-08-14, 10:29 PM",
			"commitName": "2f31d7122d8806b6c32d2d1e181ca635fb80bba7",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-08-14, 5:25 AM",
			"commitNameOld": "39c0d7d56397ab14892db8032464cb8a9f983ff1",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 0.71,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,7 +1,7 @@\n-    @Override public void headers(int flags, int streamId, List<String> nameValueBlock)\n+    @Override public void headers(int streamId, List<String> nameValueBlock)\n         throws IOException {\n       SpdyStream replyStream = getStream(streamId);\n       if (replyStream != null) {\n         replyStream.receiveHeaders(nameValueBlock);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[flags-int, streamId-int, nameValueBlock-List<String>]",
				"newValue": "[streamId-int, nameValueBlock-List<String>]"
			}
		},
		"3c0faa9ca18de3be0a178e590086888f4f89612a": {
			"type": "Yfilerename",
			"commitMessage": "Make a home for MockWebServer in OkHttp.\n\nTo build HTTP/2.0 support into OkHttp I'm going to simultaneously\nbuild HTTP/2.0 support into MockWebServer. To make that possible,\nI'm first going to fork MockWebServer and then combine it with\nMockSpdyServer.\n",
			"commitDate": "2013-08-03, 10:50 AM",
			"commitName": "3c0faa9ca18de3be0a178e590086888f4f89612a",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-07-20, 12:14 PM",
			"commitNameOld": "cc4633943800572673c03b32d0b2bc9a08ae184d",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 13.94,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
				"newPath": "okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java"
			}
		},
		"7ccbf48838b7cfe42759c67790636d442ea5daa3": {
			"type": "Yfilerename",
			"commitMessage": "Move library into a module. Introduce sample module with simple GitHub client.\n",
			"commitDate": "2013-03-25, 9:04 PM",
			"commitName": "7ccbf48838b7cfe42759c67790636d442ea5daa3",
			"commitAuthor": "Jake Wharton",
			"commitDateOld": "2013-03-15, 8:39 AM",
			"commitNameOld": "ba2b7432cb9fabfc725b09a9f14878cb128ef208",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 10.52,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java",
				"newPath": "okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java"
			}
		},
		"b9580d68e9bc34eef397e9bc7f13091f1e3f1528": {
			"type": "Ybodychange",
			"commitMessage": "Be more careful around IOExceptions.\n\nThis adds a first test where a frame is truncated. That has some\nunpleasant consequences for the other tests because it means the\nMockSpdyPeer is more aggressive about closing the socket when all\nframes have been sent.\n\nIt also reduces the use of exceptions for flow control when handling\nbogus incoming frames. This is a bit worse and a bit better; my\ngoal is to make it easier to differentiate between protocol-level\nproblems (bogus frames) from transport-level problems (closed sockets\nand EOF streams).\n",
			"commitDate": "2013-01-21, 12:42 PM",
			"commitName": "b9580d68e9bc34eef397e9bc7f13091f1e3f1528",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-01-18, 1:50 PM",
			"commitNameOld": "1bd9fefb5199d1499c8dac6c82c18c82e0678428",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 2.95,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,11 +1,7 @@\n         @Override public void headers(int flags, int streamId, List<String> nameValueBlock)\n                 throws IOException {\n             SpdyStream replyStream = getStream(streamId);\n             if (replyStream != null) {\n-                try {\n-                    replyStream.receiveHeaders(nameValueBlock);\n-                } catch (ProtocolException e) {\n-                    replyStream.closeLater(SpdyStream.RST_PROTOCOL_ERROR);\n-                }\n+                replyStream.receiveHeaders(nameValueBlock);\n             }\n         }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"689f66222bd8984dd69229a4ee9caf8da528ae12": {
			"type": "Yfilerename",
			"commitMessage": "Flatten internal packages and utility classes.\n\nThe previous structure had hierarchy that was useful\nfor libcore but overkill for OkHttp.\n",
			"commitDate": "2013-01-01, 8:50 PM",
			"commitName": "689f66222bd8984dd69229a4ee9caf8da528ae12",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-01-01, 8:27 PM",
			"commitNameOld": "73516e6ab1d336ffd520e845e14f80cf08657bd0",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/com/squareup/okhttp/internal/net/spdy/SpdyConnection.java",
				"newPath": "src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java"
			}
		},
		"7a28500a72d6914c6be7d9d8ee47d23f92f35d64": {
			"type": "Yintroduced",
			"commitMessage": "Support the HEADERS frame.\n",
			"commitDate": "2013-01-01, 8:21 PM",
			"commitName": "7a28500a72d6914c6be7d9d8ee47d23f92f35d64",
			"commitAuthor": "jwilson"
		}
	},
	"sha": "5224f3045ba9b171fce521777edf389f9206173c"
}