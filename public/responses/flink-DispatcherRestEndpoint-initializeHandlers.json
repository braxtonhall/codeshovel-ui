{
	"repo": "https://github.com/apache/flink.git",
	"file": "flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/DispatcherRestEndpoint.java",
	"method": {
		"longName": "DispatcherRestEndpoint::initializeHandlers(CompletableFuture<String> restAddressFuture)",
		"startLine": 83,
		"methodName": "initializeHandlers",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "protected"
	},
	"history": {
		"0a5aebb0149d3660e549446a3d46df34ef1fb4d2": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-9842][rest] Pass actual configuration to BlobClient\n\nThis closes #6340.\n",
			"commitDate": "2018-07-16, 6:09 AM",
			"commitName": "0a5aebb0149d3660e549446a3d46df34ef1fb4d2",
			"commitAuthor": "zentol",
			"commitDateOld": "2018-07-03, 1:08 PM",
			"commitNameOld": "a25cd3feddd19e75456db32a704ee5509e85dd47",
			"commitAuthorOld": "zentol",
			"daysBetweenCommits": 12.71,
			"commitsBetweenForRepo": 118,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,43 +1,44 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = super.initializeHandlers(restAddressFuture);\n \n \t\t// Add the Dispatcher specific handlers\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n-\t\t\texecutor);\n+\t\t\texecutor,\n+\t\t\tclusterConfiguration);\n \n \t\tif (clusterConfiguration.getBoolean(WebOptions.SUBMIT_ENABLE)) {\n \t\t\ttry {\n \t\t\t\twebSubmissionExtension = WebMonitorUtils.loadWebSubmissionExtension(\n \t\t\t\t\tleaderRetriever,\n \t\t\t\t\trestAddressFuture,\n \t\t\t\t\ttimeout,\n \t\t\t\t\tresponseHeaders,\n \t\t\t\t\tuploadDir,\n \t\t\t\t\texecutor,\n \t\t\t\t\tclusterConfiguration);\n \n \t\t\t\t// register extension handlers\n \t\t\t\thandlers.addAll(webSubmissionExtension.getHandlers());\n \t\t\t} catch (FlinkException e) {\n \t\t\t\tif (log.isDebugEnabled()) {\n \t\t\t\t\tlog.debug(\"Failed to load web based job submission extension.\", e);\n \t\t\t\t} else {\n \t\t\t\t\tlog.info(\"Failed to load web based job submission extension. \" +\n \t\t\t\t\t\t\"Probable reason: flink-runtime-web is not in the classpath.\");\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tlog.info(\"Web-based job submission is not enabled.\");\n \t\t}\n \n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a25cd3feddd19e75456db32a704ee5509e85dd47": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-9280][rest] Rework JobSubmitHandler to accept jar/artifact files\n\nThis closes #6203.\n",
			"commitDate": "2018-07-03, 1:08 PM",
			"commitName": "a25cd3feddd19e75456db32a704ee5509e85dd47",
			"commitAuthor": "zentol",
			"commitDateOld": "2018-03-23, 5:32 AM",
			"commitNameOld": "8809185b0ea791c641babe382db2bb7e753100bb",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 102.32,
			"commitsBetweenForRepo": 631,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,49 +1,43 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = super.initializeHandlers(restAddressFuture);\n \n \t\t// Add the Dispatcher specific handlers\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \n-\t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders);\n-\n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n-\t\t\tresponseHeaders);\n+\t\t\tresponseHeaders,\n+\t\t\texecutor);\n \n \t\tif (clusterConfiguration.getBoolean(WebOptions.SUBMIT_ENABLE)) {\n \t\t\ttry {\n \t\t\t\twebSubmissionExtension = WebMonitorUtils.loadWebSubmissionExtension(\n \t\t\t\t\tleaderRetriever,\n \t\t\t\t\trestAddressFuture,\n \t\t\t\t\ttimeout,\n \t\t\t\t\tresponseHeaders,\n \t\t\t\t\tuploadDir,\n \t\t\t\t\texecutor,\n \t\t\t\t\tclusterConfiguration);\n \n \t\t\t\t// register extension handlers\n \t\t\t\thandlers.addAll(webSubmissionExtension.getHandlers());\n \t\t\t} catch (FlinkException e) {\n \t\t\t\tif (log.isDebugEnabled()) {\n \t\t\t\t\tlog.debug(\"Failed to load web based job submission extension.\", e);\n \t\t\t\t} else {\n \t\t\t\t\tlog.info(\"Failed to load web based job submission extension. \" +\n \t\t\t\t\t\t\"Probable reason: flink-runtime-web is not in the classpath.\");\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tlog.info(\"Web-based job submission is not enabled.\");\n \t\t}\n \n-\t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"da3fc4fde2796af262dd275f3ea87a5b7bc69c5a": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7521][flip6] Return HTTP 413 if request limit is exceeded.\n\nRemove unnecessary PipelineErrorHandler from RestClient.\nRename config keys for configuring request and response limits.\nSet response headers for all error responses.\n\nThis closes #5685.\n",
			"commitDate": "2018-03-14, 2:37 AM",
			"commitName": "da3fc4fde2796af262dd275f3ea87a5b7bc69c5a",
			"commitAuthor": "gyao",
			"commitDateOld": "2018-03-05, 4:22 AM",
			"commitNameOld": "fc0001c8585ff68f1d2568434727b29c8546d909",
			"commitAuthorOld": "Nico Kruber",
			"daysBetweenCommits": 8.89,
			"commitsBetweenForRepo": 65,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,50 +1,49 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = super.initializeHandlers(restAddressFuture);\n \n \t\t// Add the Dispatcher specific handlers\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n-\t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tif (clusterConfiguration.getBoolean(WebOptions.SUBMIT_ENABLE)) {\n \t\t\ttry {\n \t\t\t\twebSubmissionExtension = WebMonitorUtils.loadWebSubmissionExtension(\n \t\t\t\t\tleaderRetriever,\n \t\t\t\t\trestAddressFuture,\n \t\t\t\t\ttimeout,\n \t\t\t\t\tresponseHeaders,\n \t\t\t\t\tuploadDir,\n \t\t\t\t\texecutor,\n \t\t\t\t\tclusterConfiguration);\n \n \t\t\t\t// register extension handlers\n \t\t\t\thandlers.addAll(webSubmissionExtension.getHandlers());\n \t\t\t} catch (FlinkException e) {\n \t\t\t\tif (log.isDebugEnabled()) {\n \t\t\t\t\tlog.debug(\"Failed to load web based job submission extension.\", e);\n \t\t\t\t} else {\n \t\t\t\t\tlog.info(\"Failed to load web based job submission extension. \" +\n \t\t\t\t\t\t\"Probable reason: flink-runtime-web is not in the classpath.\");\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tlog.info(\"Web-based job submission is not enabled.\");\n \t\t}\n \n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fc0001c8585ff68f1d2568434727b29c8546d909": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-8769][flip6] do not print error causing exceptions without debugging\n\nIn DispatcherRestEndpoint and TaskExecutor, there were two places where without\nerrors (running a job inside an IDE) exceptions were logged. While for debugging\nthey may be useful, for normal operation it is enough to print the messages\nthemselves, especially since some more details were already logged before.\n\nThis closes #5611.\n",
			"commitDate": "2018-03-05, 4:22 AM",
			"commitName": "fc0001c8585ff68f1d2568434727b29c8546d909",
			"commitAuthor": "Nico Kruber",
			"commitDateOld": "2018-02-19, 9:27 AM",
			"commitNameOld": "ec752138b0d1352c6a18e116fd469bcc1ca4dd42",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 13.79,
			"commitsBetweenForRepo": 186,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,50 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = super.initializeHandlers(restAddressFuture);\n \n \t\t// Add the Dispatcher specific handlers\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tif (clusterConfiguration.getBoolean(WebOptions.SUBMIT_ENABLE)) {\n \t\t\ttry {\n \t\t\t\twebSubmissionExtension = WebMonitorUtils.loadWebSubmissionExtension(\n \t\t\t\t\tleaderRetriever,\n \t\t\t\t\trestAddressFuture,\n \t\t\t\t\ttimeout,\n \t\t\t\t\tresponseHeaders,\n \t\t\t\t\tuploadDir,\n \t\t\t\t\texecutor,\n \t\t\t\t\tclusterConfiguration);\n \n \t\t\t\t// register extension handlers\n \t\t\t\thandlers.addAll(webSubmissionExtension.getHandlers());\n \t\t\t} catch (FlinkException e) {\n-\t\t\t\tlog.info(\"Failed to load web based job submission extension.\", e);\n+\t\t\t\tif (log.isDebugEnabled()) {\n+\t\t\t\t\tlog.debug(\"Failed to load web based job submission extension.\", e);\n+\t\t\t\t} else {\n+\t\t\t\t\tlog.info(\"Failed to load web based job submission extension. \" +\n+\t\t\t\t\t\t\"Probable reason: flink-runtime-web is not in the classpath.\");\n+\t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tlog.info(\"Web-based job submission is not enabled.\");\n \t\t}\n \n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ec752138b0d1352c6a18e116fd469bcc1ca4dd42": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7715] [flip6] Introduce WebSubmissionExtension for web submission handlers\n\nIntroduce a WebMonitorExtension interface which can be used to dynamically load\nweb monitor extensions. Web monitor extension provide channel inbound handlers\nwhich are added to the WebMonitorEndpoint. Furthermore, they offer a close and\ncloseAsync method to close their resources. That way they can be integrated in\nthe lifecycle of the WebMonitorEndpoint.\n",
			"commitDate": "2018-02-19, 9:27 AM",
			"commitName": "ec752138b0d1352c6a18e116fd469bcc1ca4dd42",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2018-02-19, 8:04 AM",
			"commitNameOld": "ab8e9bdb8428b8c9b2c7a72ccd3f9e7b6e2dad58",
			"commitAuthorOld": "gyao",
			"daysBetweenCommits": 0.06,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,36 +1,45 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = super.initializeHandlers(restAddressFuture);\n \n \t\t// Add the Dispatcher specific handlers\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tif (clusterConfiguration.getBoolean(WebOptions.SUBMIT_ENABLE)) {\n-\t\t\thandlers.addAll(WebMonitorUtils.tryLoadJarHandlers(\n-\t\t\t\tleaderRetriever,\n-\t\t\t\trestAddressFuture,\n-\t\t\t\ttimeout,\n-\t\t\t\tresponseHeaders,\n-\t\t\t\tuploadDir,\n-\t\t\t\texecutor,\n-\t\t\t\tclusterConfiguration));\n+\t\t\ttry {\n+\t\t\t\twebSubmissionExtension = WebMonitorUtils.loadWebSubmissionExtension(\n+\t\t\t\t\tleaderRetriever,\n+\t\t\t\t\trestAddressFuture,\n+\t\t\t\t\ttimeout,\n+\t\t\t\t\tresponseHeaders,\n+\t\t\t\t\tuploadDir,\n+\t\t\t\t\texecutor,\n+\t\t\t\t\tclusterConfiguration);\n+\n+\t\t\t\t// register extension handlers\n+\t\t\t\thandlers.addAll(webSubmissionExtension.getHandlers());\n+\t\t\t} catch (FlinkException e) {\n+\t\t\t\tlog.info(\"Failed to load web based job submission extension.\", e);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tlog.info(\"Web-based job submission is not enabled.\");\n \t\t}\n \n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ab8e9bdb8428b8c9b2c7a72ccd3f9e7b6e2dad58": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7715][flip6] Implement JarRunHandler\n\nThis closes #5509.\n",
			"commitDate": "2018-02-19, 8:04 AM",
			"commitName": "ab8e9bdb8428b8c9b2c7a72ccd3f9e7b6e2dad58",
			"commitAuthor": "gyao",
			"commitDateOld": "2018-02-18, 2:12 AM",
			"commitNameOld": "ab8316f31a4de0648ab3ffa9f19fcd419aaa3bb9",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 1.24,
			"commitsBetweenForRepo": 53,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,35 +1,36 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = super.initializeHandlers(restAddressFuture);\n \n \t\t// Add the Dispatcher specific handlers\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tif (clusterConfiguration.getBoolean(WebOptions.SUBMIT_ENABLE)) {\n \t\t\thandlers.addAll(WebMonitorUtils.tryLoadJarHandlers(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\tresponseHeaders,\n \t\t\t\tuploadDir,\n-\t\t\t\texecutor));\n+\t\t\t\texecutor,\n+\t\t\t\tclusterConfiguration));\n \t\t}\n \n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"39df56d6aebb3911f19593dbf120d42789e8db5a": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7713][flip6] Implement JarUploadHandler\n\nThis closes #5442.\n",
			"commitDate": "2018-02-15, 12:44 AM",
			"commitName": "39df56d6aebb3911f19593dbf120d42789e8db5a",
			"commitAuthor": "gyao",
			"commitDateOld": "2018-02-15, 12:44 AM",
			"commitNameOld": "a5105894b981e67631145d1921cd8cbf79fb2308",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,25 +1,35 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = super.initializeHandlers(restAddressFuture);\n \n \t\t// Add the Dispatcher specific handlers\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n+\t\tif (clusterConfiguration.getBoolean(WebOptions.SUBMIT_ENABLE)) {\n+\t\t\thandlers.addAll(WebMonitorUtils.tryLoadJarHandlers(\n+\t\t\t\tleaderRetriever,\n+\t\t\t\trestAddressFuture,\n+\t\t\t\ttimeout,\n+\t\t\t\tresponseHeaders,\n+\t\t\t\tuploadDir,\n+\t\t\t\texecutor));\n+\t\t}\n+\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a5105894b981e67631145d1921cd8cbf79fb2308": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-8604] [rest] Move JobTerminationHandler into WebMonitorEndpoint\n\nRegister the JobTerminationHandler at the WebMonitorEndpoint to make it accessible to\nall REST endpoints.\n\nThis closes #5429.\n",
			"commitDate": "2018-02-15, 12:44 AM",
			"commitName": "a5105894b981e67631145d1921cd8cbf79fb2308",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2018-02-06, 5:36 AM",
			"commitNameOld": "c1280a5056196e2c20e50dc6c3631ca93c877e58",
			"commitAuthorOld": "gyao",
			"daysBetweenCommits": 8.8,
			"commitsBetweenForRepo": 101,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,33 +1,25 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = super.initializeHandlers(restAddressFuture);\n \n \t\t// Add the Dispatcher specific handlers\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n-\t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tJobTerminationHeaders.getInstance());\n-\n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n-\t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c1280a5056196e2c20e50dc6c3631ca93c877e58": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7856][flip6] Port JobVertexBackPressureHandler to REST endpoint\n\nThis closes #5397.\n",
			"commitDate": "2018-02-06, 5:36 AM",
			"commitName": "c1280a5056196e2c20e50dc6c3631ca93c877e58",
			"commitAuthor": "gyao",
			"commitDateOld": "2018-02-06, 5:34 AM",
			"commitNameOld": "7137d619456be401cb8a7b867daa98eb80f3838c",
			"commitAuthorOld": "zjureel",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,41 +1,33 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = super.initializeHandlers(restAddressFuture);\n \n \t\t// Add the Dispatcher specific handlers\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n-\t\tJobVertexBackPressureHandler jobVertexBackPressureHandler = new JobVertexBackPressureHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tJobVertexBackPressureHeaders.getInstance());\n-\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n-\t\thandlers.add(Tuple2.of(JobVertexBackPressureHeaders.getInstance(), jobVertexBackPressureHandler));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7137d619456be401cb8a7b867daa98eb80f3838c": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7856][flip6] Port JobVertexBackPressureHandler to REST endpoint\n",
			"commitDate": "2018-02-06, 5:34 AM",
			"commitName": "7137d619456be401cb8a7b867daa98eb80f3838c",
			"commitAuthor": "zjureel",
			"commitDateOld": "2018-02-06, 5:34 AM",
			"commitNameOld": "5f573804f0f486db7cc594ae678adff5ae7f217c",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,33 +1,41 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = super.initializeHandlers(restAddressFuture);\n \n \t\t// Add the Dispatcher specific handlers\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n+\t\tJobVertexBackPressureHandler jobVertexBackPressureHandler = new JobVertexBackPressureHandler(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tresponseHeaders,\n+\t\t\tJobVertexBackPressureHeaders.getInstance());\n+\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n+\t\thandlers.add(Tuple2.of(JobVertexBackPressureHeaders.getInstance(), jobVertexBackPressureHandler));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0e3027d4b87cb5aff5c640ec809f2968b64be732": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-8029] Create WebMonitorEndpoint\n\nThe WebMonitorEndpoint is the common rest endpoint used for serving\nthe web frontend REST calls. It will be used by the Dispatcher and\nthe JobMaster to fuel the web frontend.\n\nThis closes #4987.\n",
			"commitDate": "2017-12-13, 2:34 PM",
			"commitName": "0e3027d4b87cb5aff5c640ec809f2968b64be732",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-11-30, 9:57 AM",
			"commitNameOld": "b0bd65db9bb9d41ad85634d08dc8b9dae2cfa8dd",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 13.19,
			"commitsBetweenForRepo": 58,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,263 +1,33 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n-\t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n+\t\tList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = super.initializeHandlers(restAddressFuture);\n+\n+\t\t// Add the Dispatcher specific handlers\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n-\t\tClusterOverviewHandler clusterOverviewHandler = new ClusterOverviewHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tClusterOverviewHeaders.getInstance());\n-\n-\t\tDashboardConfigHandler dashboardConfigHandler = new DashboardConfigHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tDashboardConfigurationHeaders.getInstance(),\n-\t\t\trestConfiguration.getRefreshInterval());\n-\n-\t\tJobIdsHandler jobIdsHandler = new JobIdsHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tJobIdsWithStatusesOverviewHeaders.getInstance());\n-\n-\t\tJobsOverviewHandler jobsOverviewHandler = new JobsOverviewHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tJobsOverviewHeaders.getInstance());\n-\n-\t\tClusterConfigHandler clusterConfigurationHandler = new ClusterConfigHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tClusterConfigurationInfoHeaders.getInstance(),\n-\t\t\tclusterConfiguration);\n-\n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n-\t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tJobConfigHeaders.getInstance(),\n-\t\t\texecutionGraphCache,\n-\t\t\texecutor);\n-\n-\t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tCheckpointConfigHeaders.getInstance(),\n-\t\t\texecutionGraphCache,\n-\t\t\texecutor);\n-\n-\t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tCheckpointingStatisticsHeaders.getInstance(),\n-\t\t\texecutionGraphCache,\n-\t\t\texecutor);\n-\n-\t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n-\t\t\texecutionGraphCache,\n-\t\t\texecutor,\n-\t\t\tcheckpointStatsCache);\n-\n-\t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tJobPlanHeaders.getInstance(),\n-\t\t\texecutionGraphCache,\n-\t\t\texecutor);\n-\n-\t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n-\t\t\texecutionGraphCache,\n-\t\t\texecutor,\n-\t\t\tcheckpointStatsCache);\n-\n-\t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tJobExceptionsHeaders.getInstance(),\n-\t\t\texecutionGraphCache,\n-\t\t\texecutor);\n-\n-\t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n-\t\t\texecutionGraphCache,\n-\t\t\texecutor);\n-\n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n-\t\tTaskManagersHandler taskManagersHandler = new TaskManagersHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tTaskManagersHeaders.getInstance(),\n-\t\t\tresourceManagerRetriever);\n-\n-\t\tTaskManagerDetailsHandler taskManagerDetailsHandler = new TaskManagerDetailsHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tTaskManagerDetailsHeaders.getInstance(),\n-\t\t\tresourceManagerRetriever,\n-\t\t\tmetricFetcher);\n-\n-\t\tfinal JobDetailsHandler jobDetailsHandler = new JobDetailsHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tJobDetailsHeaders.getInstance(),\n-\t\t\texecutionGraphCache,\n-\t\t\texecutor,\n-\t\t\tmetricFetcher);\n-\n-\t\tJobAccumulatorsHandler jobAccumulatorsHandler = new JobAccumulatorsHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tJobAccumulatorsHeaders.getInstance(),\n-\t\t\texecutionGraphCache,\n-\t\t\texecutor);\n-\n-\t\tSubtasksTimesHandler subtasksTimesHandler = new SubtasksTimesHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tSubtasksTimesHeaders.getInstance(),\n-\t\t\texecutionGraphCache,\n-\t\t\texecutor);\n-\n-\t\tfinal JobVertexMetricsHandler jobVertexMetricsHandler = new JobVertexMetricsHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tmetricFetcher);\n-\n-\t\tfinal JobMetricsHandler jobMetricsHandler = new JobMetricsHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tmetricFetcher);\n-\n-\t\tfinal SubtaskMetricsHandler subtaskMetricsHandler = new SubtaskMetricsHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tmetricFetcher);\n-\n-\t\tfinal TaskManagerMetricsHandler taskManagerMetricsHandler = new TaskManagerMetricsHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tmetricFetcher);\n-\n-\t\tfinal JobManagerMetricsHandler jobManagerMetricsHandler = new JobManagerMetricsHandler(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tmetricFetcher);\n-\n-\t\tfinal File tmpDir = restConfiguration.getTmpDir();\n-\n-\t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n-\n-\t\ttry {\n-\t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n-\t\t\t\tleaderRetriever,\n-\t\t\t\trestAddressFuture,\n-\t\t\t\ttimeout,\n-\t\t\t\ttmpDir);\n-\t\t} catch (IOException e) {\n-\t\t\tlog.warn(\"Could not load web content handler.\", e);\n-\t\t\toptWebContent = Optional.empty();\n-\t\t}\n-\n-\t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n-\t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n-\t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigHandler));\n-\t\thandlers.add(Tuple2.of(JobIdsWithStatusesOverviewHeaders.getInstance(), jobIdsHandler));\n-\t\thandlers.add(Tuple2.of(JobsOverviewHeaders.getInstance(), jobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n-\t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n-\t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n-\t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n-\t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n-\t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n-\t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n-\t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n-\t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n-\t\thandlers.add(Tuple2.of(JobDetailsHeaders.getInstance(), jobDetailsHandler));\n-\t\thandlers.add(Tuple2.of(JobAccumulatorsHeaders.getInstance(), jobAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n-\t\thandlers.add(Tuple2.of(TaskManagersHeaders.getInstance(), taskManagersHandler));\n-\t\thandlers.add(Tuple2.of(TaskManagerDetailsHeaders.getInstance(), taskManagerDetailsHandler));\n-\t\thandlers.add(Tuple2.of(SubtasksTimesHeaders.getInstance(), subtasksTimesHandler));\n-\t\thandlers.add(Tuple2.of(JobVertexMetricsHeaders.getInstance(), jobVertexMetricsHandler));\n-\t\thandlers.add(Tuple2.of(JobMetricsHeaders.getInstance(), jobMetricsHandler));\n-\t\thandlers.add(Tuple2.of(SubtaskMetricsHeaders.getInstance(), subtaskMetricsHandler));\n-\t\thandlers.add(Tuple2.of(TaskManagerMetricsHeaders.getInstance(), taskManagerMetricsHandler));\n-\t\thandlers.add(Tuple2.of(JobManagerMetricsHeaders.getInstance(), jobManagerMetricsHandler));\n-\n-\t\toptWebContent.ifPresent(\n-\t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b0bd65db9bb9d41ad85634d08dc8b9dae2cfa8dd": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-8027] Generalize existing rest handlers to work with an arbitrary RestfulGateway\n\nBy letting the existing REST handlers work with an arbitrary RestfulGateway,\nthey can be used by the Dispatcher as well as the JobMaster, once it implements\nthe RestfulGateway.\n\nThis closes #4985.\n",
			"commitDate": "2017-11-30, 9:57 AM",
			"commitName": "b0bd65db9bb9d41ad85634d08dc8b9dae2cfa8dd",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-11-29, 10:03 AM",
			"commitNameOld": "9fc3c71f81a2728fd60c7ce26023c23fa2ced37a",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 1,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,263 +1,263 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n-\t\tClusterOverviewHandler<DispatcherGateway> clusterOverviewHandler = new ClusterOverviewHandler<>(\n+\t\tClusterOverviewHandler clusterOverviewHandler = new ClusterOverviewHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterOverviewHeaders.getInstance());\n \n-\t\tDashboardConfigHandler<DispatcherGateway> dashboardConfigHandler = new DashboardConfigHandler<>(\n+\t\tDashboardConfigHandler dashboardConfigHandler = new DashboardConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\trestConfiguration.getRefreshInterval());\n \n-\t\tJobIdsHandler<DispatcherGateway> jobIdsHandler = new JobIdsHandler<>(\n+\t\tJobIdsHandler jobIdsHandler = new JobIdsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobIdsWithStatusesOverviewHeaders.getInstance());\n \n-\t\tJobsOverviewHandler<DispatcherGateway> jobsOverviewHandler = new JobsOverviewHandler<>(\n+\t\tJobsOverviewHandler jobsOverviewHandler = new JobsOverviewHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobsOverviewHeaders.getInstance());\n \n-\t\tClusterConfigHandler<DispatcherGateway> clusterConfigurationHandler = new ClusterConfigHandler<>(\n+\t\tClusterConfigHandler clusterConfigurationHandler = new ClusterConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tclusterConfiguration);\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobExceptionsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n-\t\tTaskManagersHandler<DispatcherGateway> taskManagersHandler = new TaskManagersHandler<>(\n+\t\tTaskManagersHandler taskManagersHandler = new TaskManagersHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagersHeaders.getInstance(),\n \t\t\tresourceManagerRetriever);\n \n-\t\tTaskManagerDetailsHandler<DispatcherGateway> taskManagerDetailsHandler = new TaskManagerDetailsHandler<>(\n+\t\tTaskManagerDetailsHandler taskManagerDetailsHandler = new TaskManagerDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagerDetailsHeaders.getInstance(),\n \t\t\tresourceManagerRetriever,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobDetailsHandler jobDetailsHandler = new JobDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tmetricFetcher);\n \n \t\tJobAccumulatorsHandler jobAccumulatorsHandler = new JobAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tSubtasksTimesHandler subtasksTimesHandler = new SubtasksTimesHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tSubtasksTimesHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tfinal JobVertexMetricsHandler jobVertexMetricsHandler = new JobVertexMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobMetricsHandler jobMetricsHandler = new JobMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n \t\tfinal SubtaskMetricsHandler subtaskMetricsHandler = new SubtaskMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n \t\tfinal TaskManagerMetricsHandler taskManagerMetricsHandler = new TaskManagerMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobManagerMetricsHandler jobManagerMetricsHandler = new JobManagerMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigHandler));\n \t\thandlers.add(Tuple2.of(JobIdsWithStatusesOverviewHeaders.getInstance(), jobIdsHandler));\n \t\thandlers.add(Tuple2.of(JobsOverviewHeaders.getInstance(), jobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n \t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(JobDetailsHeaders.getInstance(), jobDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobAccumulatorsHeaders.getInstance(), jobAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \t\thandlers.add(Tuple2.of(TaskManagersHeaders.getInstance(), taskManagersHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerDetailsHeaders.getInstance(), taskManagerDetailsHandler));\n \t\thandlers.add(Tuple2.of(SubtasksTimesHeaders.getInstance(), subtasksTimesHandler));\n \t\thandlers.add(Tuple2.of(JobVertexMetricsHeaders.getInstance(), jobVertexMetricsHandler));\n \t\thandlers.add(Tuple2.of(JobMetricsHeaders.getInstance(), jobMetricsHandler));\n \t\thandlers.add(Tuple2.of(SubtaskMetricsHeaders.getInstance(), subtaskMetricsHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerMetricsHeaders.getInstance(), taskManagerMetricsHandler));\n \t\thandlers.add(Tuple2.of(JobManagerMetricsHeaders.getInstance(), jobManagerMetricsHandler));\n \n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9fc3c71f81a2728fd60c7ce26023c23fa2ced37a": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7652] [flip6] Introduce JobIdWithStatus type for JobIdsWithStatusOverview\n\nInstead of storing the JobID and the JobStatus in a Tuple2 which is serialized\nas an array of values in JSON, this commit introduces the JobIdWithStatus which\nis serialized as a proper JSON object with an id and a status field.\n",
			"commitDate": "2017-11-29, 10:03 AM",
			"commitName": "9fc3c71f81a2728fd60c7ce26023c23fa2ced37a",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-11-29, 10:03 AM",
			"commitNameOld": "67aad88ee025ce02053ab560f2504762f53b87d9",
			"commitAuthorOld": "Tzu-Li (Gordon) Tai",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,263 +1,263 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tClusterOverviewHandler<DispatcherGateway> clusterOverviewHandler = new ClusterOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterOverviewHeaders.getInstance());\n \n \t\tDashboardConfigHandler<DispatcherGateway> dashboardConfigHandler = new DashboardConfigHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\trestConfiguration.getRefreshInterval());\n \n-\t\tJobsOverviewHandler<DispatcherGateway> jobsOverviewHandler = new JobsOverviewHandler<>(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tresponseHeaders,\n-\t\t\tJobsOverviewHeaders.getInstance());\n-\n \t\tJobIdsHandler<DispatcherGateway> jobIdsHandler = new JobIdsHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobIdsWithStatusesOverviewHeaders.getInstance());\n \n+\t\tJobsOverviewHandler<DispatcherGateway> jobsOverviewHandler = new JobsOverviewHandler<>(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tresponseHeaders,\n+\t\t\tJobsOverviewHeaders.getInstance());\n+\n \t\tClusterConfigHandler<DispatcherGateway> clusterConfigurationHandler = new ClusterConfigHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tclusterConfiguration);\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobExceptionsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tTaskManagersHandler<DispatcherGateway> taskManagersHandler = new TaskManagersHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagersHeaders.getInstance(),\n \t\t\tresourceManagerRetriever);\n \n \t\tTaskManagerDetailsHandler<DispatcherGateway> taskManagerDetailsHandler = new TaskManagerDetailsHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagerDetailsHeaders.getInstance(),\n \t\t\tresourceManagerRetriever,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobDetailsHandler jobDetailsHandler = new JobDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tmetricFetcher);\n \n \t\tJobAccumulatorsHandler jobAccumulatorsHandler = new JobAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tSubtasksTimesHandler subtasksTimesHandler = new SubtasksTimesHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tSubtasksTimesHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tfinal JobVertexMetricsHandler jobVertexMetricsHandler = new JobVertexMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobMetricsHandler jobMetricsHandler = new JobMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n \t\tfinal SubtaskMetricsHandler subtaskMetricsHandler = new SubtaskMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n \t\tfinal TaskManagerMetricsHandler taskManagerMetricsHandler = new TaskManagerMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobManagerMetricsHandler jobManagerMetricsHandler = new JobManagerMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigHandler));\n-\t\thandlers.add(Tuple2.of(JobsOverviewHeaders.getInstance(), jobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobIdsWithStatusesOverviewHeaders.getInstance(), jobIdsHandler));\n+\t\thandlers.add(Tuple2.of(JobsOverviewHeaders.getInstance(), jobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n \t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(JobDetailsHeaders.getInstance(), jobDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobAccumulatorsHeaders.getInstance(), jobAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \t\thandlers.add(Tuple2.of(TaskManagersHeaders.getInstance(), taskManagersHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerDetailsHeaders.getInstance(), taskManagerDetailsHandler));\n \t\thandlers.add(Tuple2.of(SubtasksTimesHeaders.getInstance(), subtasksTimesHandler));\n \t\thandlers.add(Tuple2.of(JobVertexMetricsHeaders.getInstance(), jobVertexMetricsHandler));\n \t\thandlers.add(Tuple2.of(JobMetricsHeaders.getInstance(), jobMetricsHandler));\n \t\thandlers.add(Tuple2.of(SubtaskMetricsHeaders.getInstance(), subtaskMetricsHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerMetricsHeaders.getInstance(), taskManagerMetricsHandler));\n \t\thandlers.add(Tuple2.of(JobManagerMetricsHeaders.getInstance(), jobManagerMetricsHandler));\n \n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"67aad88ee025ce02053ab560f2504762f53b87d9": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7652] [flip6] Port CurrentJobIdsHandler to new REST endpoint\n\nThis closes #4734.\n",
			"commitDate": "2017-11-29, 10:03 AM",
			"commitName": "67aad88ee025ce02053ab560f2504762f53b87d9",
			"commitAuthor": "Tzu-Li (Gordon) Tai",
			"commitDateOld": "2017-11-29, 6:52 AM",
			"commitNameOld": "4daf9223a7b2ca8aec62fefd06b0152cbc2aa668",
			"commitAuthorOld": "gyao",
			"daysBetweenCommits": 0.13,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,255 +1,263 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tClusterOverviewHandler<DispatcherGateway> clusterOverviewHandler = new ClusterOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterOverviewHeaders.getInstance());\n \n \t\tDashboardConfigHandler<DispatcherGateway> dashboardConfigHandler = new DashboardConfigHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\trestConfiguration.getRefreshInterval());\n \n \t\tJobsOverviewHandler<DispatcherGateway> jobsOverviewHandler = new JobsOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobsOverviewHeaders.getInstance());\n \n+\t\tJobIdsHandler<DispatcherGateway> jobIdsHandler = new JobIdsHandler<>(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tresponseHeaders,\n+\t\t\tJobIdsWithStatusesOverviewHeaders.getInstance());\n+\n \t\tClusterConfigHandler<DispatcherGateway> clusterConfigurationHandler = new ClusterConfigHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tclusterConfiguration);\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobExceptionsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tTaskManagersHandler<DispatcherGateway> taskManagersHandler = new TaskManagersHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagersHeaders.getInstance(),\n \t\t\tresourceManagerRetriever);\n \n \t\tTaskManagerDetailsHandler<DispatcherGateway> taskManagerDetailsHandler = new TaskManagerDetailsHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagerDetailsHeaders.getInstance(),\n \t\t\tresourceManagerRetriever,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobDetailsHandler jobDetailsHandler = new JobDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tmetricFetcher);\n \n \t\tJobAccumulatorsHandler jobAccumulatorsHandler = new JobAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tSubtasksTimesHandler subtasksTimesHandler = new SubtasksTimesHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tSubtasksTimesHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tfinal JobVertexMetricsHandler jobVertexMetricsHandler = new JobVertexMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobMetricsHandler jobMetricsHandler = new JobMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n \t\tfinal SubtaskMetricsHandler subtaskMetricsHandler = new SubtaskMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n \t\tfinal TaskManagerMetricsHandler taskManagerMetricsHandler = new TaskManagerMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobManagerMetricsHandler jobManagerMetricsHandler = new JobManagerMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigHandler));\n \t\thandlers.add(Tuple2.of(JobsOverviewHeaders.getInstance(), jobsOverviewHandler));\n+\t\thandlers.add(Tuple2.of(JobIdsWithStatusesOverviewHeaders.getInstance(), jobIdsHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n \t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(JobDetailsHeaders.getInstance(), jobDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobAccumulatorsHeaders.getInstance(), jobAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \t\thandlers.add(Tuple2.of(TaskManagersHeaders.getInstance(), taskManagersHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerDetailsHeaders.getInstance(), taskManagerDetailsHandler));\n \t\thandlers.add(Tuple2.of(SubtasksTimesHeaders.getInstance(), subtasksTimesHandler));\n \t\thandlers.add(Tuple2.of(JobVertexMetricsHeaders.getInstance(), jobVertexMetricsHandler));\n \t\thandlers.add(Tuple2.of(JobMetricsHeaders.getInstance(), jobMetricsHandler));\n \t\thandlers.add(Tuple2.of(SubtaskMetricsHeaders.getInstance(), subtaskMetricsHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerMetricsHeaders.getInstance(), taskManagerMetricsHandler));\n \t\thandlers.add(Tuple2.of(JobManagerMetricsHeaders.getInstance(), jobManagerMetricsHandler));\n \n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4daf9223a7b2ca8aec62fefd06b0152cbc2aa668": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7694][flip6] Migrate JobMetricsHandler to new RestServerEndpoint\n\nMigrate logic in\norg.apache.flink.runtime.rest.handler.legacy.metrics.JobMetrisHandler to new\nhandler, and add new handler to DispatcherRestEndpoint.\n\n[FLINK-7694][flip6] Use jobid path parameter constant in JobMetricsHandlerTest\n\nThis closes #5084.\n",
			"commitDate": "2017-11-29, 6:52 AM",
			"commitName": "4daf9223a7b2ca8aec62fefd06b0152cbc2aa668",
			"commitAuthor": "gyao",
			"commitDateOld": "2017-11-29, 6:52 AM",
			"commitNameOld": "97f6b63b12ba9f3fab119e997c738b38d3adbef9",
			"commitAuthorOld": "gyao",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,247 +1,255 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tClusterOverviewHandler<DispatcherGateway> clusterOverviewHandler = new ClusterOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterOverviewHeaders.getInstance());\n \n \t\tDashboardConfigHandler<DispatcherGateway> dashboardConfigHandler = new DashboardConfigHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\trestConfiguration.getRefreshInterval());\n \n \t\tJobsOverviewHandler<DispatcherGateway> jobsOverviewHandler = new JobsOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobsOverviewHeaders.getInstance());\n \n \t\tClusterConfigHandler<DispatcherGateway> clusterConfigurationHandler = new ClusterConfigHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tclusterConfiguration);\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobExceptionsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tTaskManagersHandler<DispatcherGateway> taskManagersHandler = new TaskManagersHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagersHeaders.getInstance(),\n \t\t\tresourceManagerRetriever);\n \n \t\tTaskManagerDetailsHandler<DispatcherGateway> taskManagerDetailsHandler = new TaskManagerDetailsHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagerDetailsHeaders.getInstance(),\n \t\t\tresourceManagerRetriever,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobDetailsHandler jobDetailsHandler = new JobDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tmetricFetcher);\n \n \t\tJobAccumulatorsHandler jobAccumulatorsHandler = new JobAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tSubtasksTimesHandler subtasksTimesHandler = new SubtasksTimesHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tSubtasksTimesHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tfinal JobVertexMetricsHandler jobVertexMetricsHandler = new JobVertexMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n+\t\tfinal JobMetricsHandler jobMetricsHandler = new JobMetricsHandler(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tresponseHeaders,\n+\t\t\tmetricFetcher);\n+\n \t\tfinal SubtaskMetricsHandler subtaskMetricsHandler = new SubtaskMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n \t\tfinal TaskManagerMetricsHandler taskManagerMetricsHandler = new TaskManagerMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobManagerMetricsHandler jobManagerMetricsHandler = new JobManagerMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigHandler));\n \t\thandlers.add(Tuple2.of(JobsOverviewHeaders.getInstance(), jobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n \t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(JobDetailsHeaders.getInstance(), jobDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobAccumulatorsHeaders.getInstance(), jobAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \t\thandlers.add(Tuple2.of(TaskManagersHeaders.getInstance(), taskManagersHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerDetailsHeaders.getInstance(), taskManagerDetailsHandler));\n \t\thandlers.add(Tuple2.of(SubtasksTimesHeaders.getInstance(), subtasksTimesHandler));\n \t\thandlers.add(Tuple2.of(JobVertexMetricsHeaders.getInstance(), jobVertexMetricsHandler));\n+\t\thandlers.add(Tuple2.of(JobMetricsHeaders.getInstance(), jobMetricsHandler));\n \t\thandlers.add(Tuple2.of(SubtaskMetricsHeaders.getInstance(), subtaskMetricsHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerMetricsHeaders.getInstance(), taskManagerMetricsHandler));\n \t\thandlers.add(Tuple2.of(JobManagerMetricsHeaders.getInstance(), jobManagerMetricsHandler));\n \n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"97f6b63b12ba9f3fab119e997c738b38d3adbef9": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-8143][flip6] Migrate SubtaskMetricsHandler to new RestServerEndpoint\n\nMigrate logic from\norg.apache.flink.runtime.rest.handler.legacy.metrics.SubtaskMetricsHandler to\nnew handler. Add new handler to DispatcherRestEndpoint.\n\n[FLINK-8143][flip6] Assert that SubtaskIndexPathParameter is mandatory\n\n[FLINK-8143][flip6] Use path parameter constants in SubtaskMetricsHandlerTest\n\nThis closes #5082.\n",
			"commitDate": "2017-11-29, 6:52 AM",
			"commitName": "97f6b63b12ba9f3fab119e997c738b38d3adbef9",
			"commitAuthor": "gyao",
			"commitDateOld": "2017-11-29, 6:52 AM",
			"commitNameOld": "49a89960bc7010c6f5f9d28e7d7f26c94d517f16",
			"commitAuthorOld": "gyao",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,239 +1,247 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tClusterOverviewHandler<DispatcherGateway> clusterOverviewHandler = new ClusterOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterOverviewHeaders.getInstance());\n \n \t\tDashboardConfigHandler<DispatcherGateway> dashboardConfigHandler = new DashboardConfigHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\trestConfiguration.getRefreshInterval());\n \n \t\tJobsOverviewHandler<DispatcherGateway> jobsOverviewHandler = new JobsOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobsOverviewHeaders.getInstance());\n \n \t\tClusterConfigHandler<DispatcherGateway> clusterConfigurationHandler = new ClusterConfigHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tclusterConfiguration);\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobExceptionsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tTaskManagersHandler<DispatcherGateway> taskManagersHandler = new TaskManagersHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagersHeaders.getInstance(),\n \t\t\tresourceManagerRetriever);\n \n \t\tTaskManagerDetailsHandler<DispatcherGateway> taskManagerDetailsHandler = new TaskManagerDetailsHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagerDetailsHeaders.getInstance(),\n \t\t\tresourceManagerRetriever,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobDetailsHandler jobDetailsHandler = new JobDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tmetricFetcher);\n \n \t\tJobAccumulatorsHandler jobAccumulatorsHandler = new JobAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tSubtasksTimesHandler subtasksTimesHandler = new SubtasksTimesHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tSubtasksTimesHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tfinal JobVertexMetricsHandler jobVertexMetricsHandler = new JobVertexMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n+\t\tfinal SubtaskMetricsHandler subtaskMetricsHandler = new SubtaskMetricsHandler(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tresponseHeaders,\n+\t\t\tmetricFetcher);\n+\n \t\tfinal TaskManagerMetricsHandler taskManagerMetricsHandler = new TaskManagerMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobManagerMetricsHandler jobManagerMetricsHandler = new JobManagerMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigHandler));\n \t\thandlers.add(Tuple2.of(JobsOverviewHeaders.getInstance(), jobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n \t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(JobDetailsHeaders.getInstance(), jobDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobAccumulatorsHeaders.getInstance(), jobAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \t\thandlers.add(Tuple2.of(TaskManagersHeaders.getInstance(), taskManagersHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerDetailsHeaders.getInstance(), taskManagerDetailsHandler));\n \t\thandlers.add(Tuple2.of(SubtasksTimesHeaders.getInstance(), subtasksTimesHandler));\n \t\thandlers.add(Tuple2.of(JobVertexMetricsHeaders.getInstance(), jobVertexMetricsHandler));\n+\t\thandlers.add(Tuple2.of(SubtaskMetricsHeaders.getInstance(), subtaskMetricsHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerMetricsHeaders.getInstance(), taskManagerMetricsHandler));\n \t\thandlers.add(Tuple2.of(JobManagerMetricsHeaders.getInstance(), jobManagerMetricsHandler));\n \n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"49a89960bc7010c6f5f9d28e7d7f26c94d517f16": {
			"type": "Ybodychange",
			"commitMessage": "[FLIP-7716][flip6] Migrate JobManagerMetricsHandler to new RestServerEndpoint\n\nMigrate logic in\norg.apache.flink.runtime.rest.handler.legacy.metrics.JobManagerMetricsHandler\nto new handler and add new handler to DispatcherRestEndpoint.\n\n[FLINK-7716][Javadoc] Deprecate method MetricStore#getJobManager().\n\nThere is a semantically equivalent method in MetricStore.\n\nThis closes #5083.\n",
			"commitDate": "2017-11-29, 6:52 AM",
			"commitName": "49a89960bc7010c6f5f9d28e7d7f26c94d517f16",
			"commitAuthor": "gyao",
			"commitDateOld": "2017-11-29, 6:52 AM",
			"commitNameOld": "cb85640bb3da2e64eafbfc5c749aab7463702ebd",
			"commitAuthorOld": "gyao",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,231 +1,239 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tClusterOverviewHandler<DispatcherGateway> clusterOverviewHandler = new ClusterOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterOverviewHeaders.getInstance());\n \n \t\tDashboardConfigHandler<DispatcherGateway> dashboardConfigHandler = new DashboardConfigHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\trestConfiguration.getRefreshInterval());\n \n \t\tJobsOverviewHandler<DispatcherGateway> jobsOverviewHandler = new JobsOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobsOverviewHeaders.getInstance());\n \n \t\tClusterConfigHandler<DispatcherGateway> clusterConfigurationHandler = new ClusterConfigHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tclusterConfiguration);\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobExceptionsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tTaskManagersHandler<DispatcherGateway> taskManagersHandler = new TaskManagersHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagersHeaders.getInstance(),\n \t\t\tresourceManagerRetriever);\n \n \t\tTaskManagerDetailsHandler<DispatcherGateway> taskManagerDetailsHandler = new TaskManagerDetailsHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagerDetailsHeaders.getInstance(),\n \t\t\tresourceManagerRetriever,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobDetailsHandler jobDetailsHandler = new JobDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tmetricFetcher);\n \n \t\tJobAccumulatorsHandler jobAccumulatorsHandler = new JobAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tSubtasksTimesHandler subtasksTimesHandler = new SubtasksTimesHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tSubtasksTimesHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tfinal JobVertexMetricsHandler jobVertexMetricsHandler = new JobVertexMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n \t\tfinal TaskManagerMetricsHandler taskManagerMetricsHandler = new TaskManagerMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n+\t\tfinal JobManagerMetricsHandler jobManagerMetricsHandler = new JobManagerMetricsHandler(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tresponseHeaders,\n+\t\t\tmetricFetcher);\n+\n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigHandler));\n \t\thandlers.add(Tuple2.of(JobsOverviewHeaders.getInstance(), jobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n \t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(JobDetailsHeaders.getInstance(), jobDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobAccumulatorsHeaders.getInstance(), jobAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \t\thandlers.add(Tuple2.of(TaskManagersHeaders.getInstance(), taskManagersHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerDetailsHeaders.getInstance(), taskManagerDetailsHandler));\n \t\thandlers.add(Tuple2.of(SubtasksTimesHeaders.getInstance(), subtasksTimesHandler));\n \t\thandlers.add(Tuple2.of(JobVertexMetricsHeaders.getInstance(), jobVertexMetricsHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerMetricsHeaders.getInstance(), taskManagerMetricsHandler));\n+\t\thandlers.add(Tuple2.of(JobManagerMetricsHeaders.getInstance(), jobManagerMetricsHandler));\n \n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cb85640bb3da2e64eafbfc5c749aab7463702ebd": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7717][flip6] Migrate TaskManagerMetricsHandler to new RestServerEndpoint\n\nMigrate logic in\norg.apache.flink.runtime.rest.handler.legacy.metrics.TaskManagerMetricsHandler\nto new handler, and add new handler to DispatcherRestEndpoint.\n\n[FLINK-7717][flip6] Use taskmanagerid constant in TaskManagerMetricsHandlerTest\n\nThis closes #5081.\n",
			"commitDate": "2017-11-29, 6:52 AM",
			"commitName": "cb85640bb3da2e64eafbfc5c749aab7463702ebd",
			"commitAuthor": "gyao",
			"commitDateOld": "2017-11-24, 10:30 AM",
			"commitNameOld": "1119c48c2470e280aaf3441ce170245070dd0986",
			"commitAuthorOld": "gyao",
			"daysBetweenCommits": 4.85,
			"commitsBetweenForRepo": 20,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,223 +1,231 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tClusterOverviewHandler<DispatcherGateway> clusterOverviewHandler = new ClusterOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterOverviewHeaders.getInstance());\n \n \t\tDashboardConfigHandler<DispatcherGateway> dashboardConfigHandler = new DashboardConfigHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\trestConfiguration.getRefreshInterval());\n \n \t\tJobsOverviewHandler<DispatcherGateway> jobsOverviewHandler = new JobsOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobsOverviewHeaders.getInstance());\n \n \t\tClusterConfigHandler<DispatcherGateway> clusterConfigurationHandler = new ClusterConfigHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tclusterConfiguration);\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobExceptionsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tTaskManagersHandler<DispatcherGateway> taskManagersHandler = new TaskManagersHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagersHeaders.getInstance(),\n \t\t\tresourceManagerRetriever);\n \n \t\tTaskManagerDetailsHandler<DispatcherGateway> taskManagerDetailsHandler = new TaskManagerDetailsHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagerDetailsHeaders.getInstance(),\n \t\t\tresourceManagerRetriever,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobDetailsHandler jobDetailsHandler = new JobDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tmetricFetcher);\n \n \t\tJobAccumulatorsHandler jobAccumulatorsHandler = new JobAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tSubtasksTimesHandler subtasksTimesHandler = new SubtasksTimesHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tSubtasksTimesHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tfinal JobVertexMetricsHandler jobVertexMetricsHandler = new JobVertexMetricsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tmetricFetcher);\n \n+\t\tfinal TaskManagerMetricsHandler taskManagerMetricsHandler = new TaskManagerMetricsHandler(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tresponseHeaders,\n+\t\t\tmetricFetcher);\n+\n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigHandler));\n \t\thandlers.add(Tuple2.of(JobsOverviewHeaders.getInstance(), jobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n \t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(JobDetailsHeaders.getInstance(), jobDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobAccumulatorsHeaders.getInstance(), jobAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \t\thandlers.add(Tuple2.of(TaskManagersHeaders.getInstance(), taskManagersHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerDetailsHeaders.getInstance(), taskManagerDetailsHandler));\n \t\thandlers.add(Tuple2.of(SubtasksTimesHeaders.getInstance(), subtasksTimesHandler));\n \t\thandlers.add(Tuple2.of(JobVertexMetricsHeaders.getInstance(), jobVertexMetricsHandler));\n+\t\thandlers.add(Tuple2.of(TaskManagerMetricsHeaders.getInstance(), taskManagerMetricsHandler));\n \n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1119c48c2470e280aaf3441ce170245070dd0986": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7718] [flip6] Add JobVertexMetricsHandler to DispatcherRestEndpoint\n\nMigrate logic in\norg.apache.flink.runtime.rest.handler.legacy.metrics.JobVertexMetricsHandler to\nnew handler and add new handler to DispatcherRestEndpoint. Add common classes\nfor remaining implementations of\norg.apache.flink.runtime.rest.handler.legacy.metrics.AbstractMetricsHandler,\nwhich require migration as well.\n\n[FLINK-7718] [flip6] Clean up JobVertexMetricsHandlerHeaders\n\n[FLINK-7718] [flip6] Assert that HTTP code is 404 if metric is unknown\n\n[FLINK-7718] [flip6] Minor fixes in Javadocs\n\n[FLINK-7718] [flip6] Add unit test for AbstractMetricsHandlerHeaders\n\n[FLINK-7718] [flip6] Let unit tests inherit from TestLogger\n\n[FLINK-7718] [flip6] Re-format Metric constructor\n\n[FLINK-7718] [flip6] Fix mistake in Javadoc of AbstractMetricsHandlerHeaders\n\n[FLINK-7718] [flip6] Rename AbstractMetricsHandlerHeaders to AbstractMetricsHeaders\n\nStrip the term Handler from the Header class. Also rename its subclasses.\n\n[FLINK-7718] [flip6] No longer return HTTP 404 if metric is unknown\n\n[FLINK-7718] [flip6] Make JobVertexMetricsHeaders class final\n\n[FLINK-7718] [flip6] Introduce MetricsHandlerTestBase for future MetricHandlers\n\n[FLINK-7718] [flip6] Always return same MessageParameter objects in JobVertexMetricsMessageParameters\n\nThis closes #5055.\n",
			"commitDate": "2017-11-24, 10:30 AM",
			"commitName": "1119c48c2470e280aaf3441ce170245070dd0986",
			"commitAuthor": "gyao",
			"commitDateOld": "2017-11-09, 2:48 AM",
			"commitNameOld": "541fe43663d2a24b1ae66bc2b5228c49dfd43e7b",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 15.32,
			"commitsBetweenForRepo": 108,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,215 +1,223 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tClusterOverviewHandler<DispatcherGateway> clusterOverviewHandler = new ClusterOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterOverviewHeaders.getInstance());\n \n \t\tDashboardConfigHandler<DispatcherGateway> dashboardConfigHandler = new DashboardConfigHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\trestConfiguration.getRefreshInterval());\n \n \t\tJobsOverviewHandler<DispatcherGateway> jobsOverviewHandler = new JobsOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobsOverviewHeaders.getInstance());\n \n \t\tClusterConfigHandler<DispatcherGateway> clusterConfigurationHandler = new ClusterConfigHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tclusterConfiguration);\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobExceptionsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tTaskManagersHandler<DispatcherGateway> taskManagersHandler = new TaskManagersHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagersHeaders.getInstance(),\n \t\t\tresourceManagerRetriever);\n \n \t\tTaskManagerDetailsHandler<DispatcherGateway> taskManagerDetailsHandler = new TaskManagerDetailsHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagerDetailsHeaders.getInstance(),\n \t\t\tresourceManagerRetriever,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobDetailsHandler jobDetailsHandler = new JobDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tmetricFetcher);\n \n \t\tJobAccumulatorsHandler jobAccumulatorsHandler = new JobAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tSubtasksTimesHandler subtasksTimesHandler = new SubtasksTimesHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tSubtasksTimesHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n+\t\tfinal JobVertexMetricsHandler jobVertexMetricsHandler = new JobVertexMetricsHandler(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tresponseHeaders,\n+\t\t\tmetricFetcher);\n+\n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigHandler));\n \t\thandlers.add(Tuple2.of(JobsOverviewHeaders.getInstance(), jobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n \t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(JobDetailsHeaders.getInstance(), jobDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobAccumulatorsHeaders.getInstance(), jobAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \t\thandlers.add(Tuple2.of(TaskManagersHeaders.getInstance(), taskManagersHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerDetailsHeaders.getInstance(), taskManagerDetailsHandler));\n \t\thandlers.add(Tuple2.of(SubtasksTimesHeaders.getInstance(), subtasksTimesHandler));\n+\t\thandlers.add(Tuple2.of(JobVertexMetricsHeaders.getInstance(), jobVertexMetricsHandler));\n \n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"541fe43663d2a24b1ae66bc2b5228c49dfd43e7b": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-8026] Let ClusterConfigHandler directly extend AbstractRestHandler\n\nThis closes #4984.\n",
			"commitDate": "2017-11-09, 2:48 AM",
			"commitName": "541fe43663d2a24b1ae66bc2b5228c49dfd43e7b",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-11-09, 2:48 AM",
			"commitNameOld": "fa967dfc0cddec0a5d0c7d76e564a8307ec3fb35",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,217 +1,215 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tClusterOverviewHandler<DispatcherGateway> clusterOverviewHandler = new ClusterOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterOverviewHeaders.getInstance());\n \n \t\tDashboardConfigHandler<DispatcherGateway> dashboardConfigHandler = new DashboardConfigHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\trestConfiguration.getRefreshInterval());\n \n \t\tJobsOverviewHandler<DispatcherGateway> jobsOverviewHandler = new JobsOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobsOverviewHeaders.getInstance());\n \n-\t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n+\t\tClusterConfigHandler<DispatcherGateway> clusterConfigurationHandler = new ClusterConfigHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n-\t\t\tnew ClusterConfigHandler(\n-\t\t\t\texecutor,\n-\t\t\t\tclusterConfiguration));\n+\t\t\tclusterConfiguration);\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobExceptionsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tTaskManagersHandler<DispatcherGateway> taskManagersHandler = new TaskManagersHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagersHeaders.getInstance(),\n \t\t\tresourceManagerRetriever);\n \n \t\tTaskManagerDetailsHandler<DispatcherGateway> taskManagerDetailsHandler = new TaskManagerDetailsHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagerDetailsHeaders.getInstance(),\n \t\t\tresourceManagerRetriever,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobDetailsHandler jobDetailsHandler = new JobDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tmetricFetcher);\n \n \t\tJobAccumulatorsHandler jobAccumulatorsHandler = new JobAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tSubtasksTimesHandler subtasksTimesHandler = new SubtasksTimesHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tSubtasksTimesHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigHandler));\n \t\thandlers.add(Tuple2.of(JobsOverviewHeaders.getInstance(), jobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n \t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(JobDetailsHeaders.getInstance(), jobDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobAccumulatorsHeaders.getInstance(), jobAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \t\thandlers.add(Tuple2.of(TaskManagersHeaders.getInstance(), taskManagersHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerDetailsHeaders.getInstance(), taskManagerDetailsHandler));\n \t\thandlers.add(Tuple2.of(SubtasksTimesHeaders.getInstance(), subtasksTimesHandler));\n \n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fa967dfc0cddec0a5d0c7d76e564a8307ec3fb35": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-8025] Let DashboardConfigHandler directly extend AbstractRestHandler\n\nThis closes #4983.\n",
			"commitDate": "2017-11-09, 2:48 AM",
			"commitName": "fa967dfc0cddec0a5d0c7d76e564a8307ec3fb35",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-11-09, 2:48 AM",
			"commitNameOld": "f03393e807f51e6496f5bd54771987a64287b154",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,219 +1,217 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tClusterOverviewHandler<DispatcherGateway> clusterOverviewHandler = new ClusterOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterOverviewHeaders.getInstance());\n \n-\t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n+\t\tDashboardConfigHandler<DispatcherGateway> dashboardConfigHandler = new DashboardConfigHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n-\t\t\tnew DashboardConfigHandler(\n-\t\t\t\texecutor,\n-\t\t\t\trestConfiguration.getRefreshInterval()));\n+\t\t\trestConfiguration.getRefreshInterval());\n \n \t\tJobsOverviewHandler<DispatcherGateway> jobsOverviewHandler = new JobsOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobsOverviewHeaders.getInstance());\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobExceptionsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tTaskManagersHandler<DispatcherGateway> taskManagersHandler = new TaskManagersHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagersHeaders.getInstance(),\n \t\t\tresourceManagerRetriever);\n \n \t\tTaskManagerDetailsHandler<DispatcherGateway> taskManagerDetailsHandler = new TaskManagerDetailsHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagerDetailsHeaders.getInstance(),\n \t\t\tresourceManagerRetriever,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobDetailsHandler jobDetailsHandler = new JobDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tmetricFetcher);\n \n \t\tJobAccumulatorsHandler jobAccumulatorsHandler = new JobAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tSubtasksTimesHandler subtasksTimesHandler = new SubtasksTimesHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tSubtasksTimesHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n-\t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n+\t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigHandler));\n \t\thandlers.add(Tuple2.of(JobsOverviewHeaders.getInstance(), jobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n \t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(JobDetailsHeaders.getInstance(), jobDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobAccumulatorsHeaders.getInstance(), jobAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \t\thandlers.add(Tuple2.of(TaskManagersHeaders.getInstance(), taskManagersHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerDetailsHeaders.getInstance(), taskManagerDetailsHandler));\n \t\thandlers.add(Tuple2.of(SubtasksTimesHeaders.getInstance(), subtasksTimesHandler));\n \n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f03393e807f51e6496f5bd54771987a64287b154": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-8024] Let ClusterOverviewHandler directly extend from AbstractRestHandler\n\nThis closes #4982.\n",
			"commitDate": "2017-11-09, 2:48 AM",
			"commitName": "f03393e807f51e6496f5bd54771987a64287b154",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-11-09, 2:48 AM",
			"commitNameOld": "34fdf569d7defb4393849fb9ecb2763b14532cc6",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,222 +1,219 @@\n \tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n-\t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n+\t\tClusterOverviewHandler<DispatcherGateway> clusterOverviewHandler = new ClusterOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n-\t\t\tClusterOverviewHeaders.getInstance(),\n-\t\t\tnew ClusterOverviewHandler(\n-\t\t\t\texecutor,\n-\t\t\t\ttimeout));\n+\t\t\tClusterOverviewHeaders.getInstance());\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tJobsOverviewHandler<DispatcherGateway> jobsOverviewHandler = new JobsOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobsOverviewHeaders.getInstance());\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobExceptionsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tTaskManagersHandler<DispatcherGateway> taskManagersHandler = new TaskManagersHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagersHeaders.getInstance(),\n \t\t\tresourceManagerRetriever);\n \n \t\tTaskManagerDetailsHandler<DispatcherGateway> taskManagerDetailsHandler = new TaskManagerDetailsHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagerDetailsHeaders.getInstance(),\n \t\t\tresourceManagerRetriever,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobDetailsHandler jobDetailsHandler = new JobDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tmetricFetcher);\n \n \t\tJobAccumulatorsHandler jobAccumulatorsHandler = new JobAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tSubtasksTimesHandler subtasksTimesHandler = new SubtasksTimesHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tSubtasksTimesHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(JobsOverviewHeaders.getInstance(), jobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n \t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(JobDetailsHeaders.getInstance(), jobDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobAccumulatorsHeaders.getInstance(), jobAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \t\thandlers.add(Tuple2.of(TaskManagersHeaders.getInstance(), taskManagersHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerDetailsHeaders.getInstance(), taskManagerDetailsHandler));\n \t\thandlers.add(Tuple2.of(SubtasksTimesHeaders.getInstance(), subtasksTimesHandler));\n \n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"34fdf569d7defb4393849fb9ecb2763b14532cc6": {
			"type": "Ymultichange(Yreturntypechange,Ybodychange)",
			"commitMessage": "[FLINK-8000] Sort Rest handler URLS in RestServerEndpoint\n\nIntroduce special RestHandlerUrlComparator to sort REST URLs such that\nURLs with path parameters are sorted after those without or fewer.\n\nE.g. the following order would be established\n\n/jobs\n/jobs/overview\n/jobs/:jobid\n/jobs/:jobid/config\n/:*\n\nThis closes #4958.\n",
			"commitDate": "2017-11-09, 2:48 AM",
			"commitName": "34fdf569d7defb4393849fb9ecb2763b14532cc6",
			"commitAuthor": "Till Rohrmann",
			"subchanges": [
				{
					"type": "Yreturntypechange",
					"commitMessage": "[FLINK-8000] Sort Rest handler URLS in RestServerEndpoint\n\nIntroduce special RestHandlerUrlComparator to sort REST URLs such that\nURLs with path parameters are sorted after those without or fewer.\n\nE.g. the following order would be established\n\n/jobs\n/jobs/overview\n/jobs/:jobid\n/jobs/:jobid/config\n/:*\n\nThis closes #4958.\n",
					"commitDate": "2017-11-09, 2:48 AM",
					"commitName": "34fdf569d7defb4393849fb9ecb2763b14532cc6",
					"commitAuthor": "Till Rohrmann",
					"commitDateOld": "2017-11-07, 7:07 AM",
					"commitNameOld": "712d4cfc0fb8591fb6ab7d27baede158cd227c60",
					"commitAuthorOld": "Till Rohrmann",
					"daysBetweenCommits": 1.82,
					"commitsBetweenForRepo": 22,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,222 +1,222 @@\n-\tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n+\tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tJobsOverviewHandler<DispatcherGateway> jobsOverviewHandler = new JobsOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobsOverviewHeaders.getInstance());\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobExceptionsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tTaskManagersHandler<DispatcherGateway> taskManagersHandler = new TaskManagersHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagersHeaders.getInstance(),\n \t\t\tresourceManagerRetriever);\n \n \t\tTaskManagerDetailsHandler<DispatcherGateway> taskManagerDetailsHandler = new TaskManagerDetailsHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagerDetailsHeaders.getInstance(),\n \t\t\tresourceManagerRetriever,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobDetailsHandler jobDetailsHandler = new JobDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tmetricFetcher);\n \n \t\tJobAccumulatorsHandler jobAccumulatorsHandler = new JobAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tSubtasksTimesHandler subtasksTimesHandler = new SubtasksTimesHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tSubtasksTimesHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(JobsOverviewHeaders.getInstance(), jobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n \t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(JobDetailsHeaders.getInstance(), jobDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobAccumulatorsHeaders.getInstance(), jobAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \t\thandlers.add(Tuple2.of(TaskManagersHeaders.getInstance(), taskManagersHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerDetailsHeaders.getInstance(), taskManagerDetailsHandler));\n+\t\thandlers.add(Tuple2.of(SubtasksTimesHeaders.getInstance(), subtasksTimesHandler));\n \n-\t\t// This handler MUST be added last, as it otherwise masks all subsequent GET handlers\n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "Collection<Tuple2<RestHandlerSpecification,ChannelInboundHandler>>",
						"newValue": "List<Tuple2<RestHandlerSpecification,ChannelInboundHandler>>"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "[FLINK-8000] Sort Rest handler URLS in RestServerEndpoint\n\nIntroduce special RestHandlerUrlComparator to sort REST URLs such that\nURLs with path parameters are sorted after those without or fewer.\n\nE.g. the following order would be established\n\n/jobs\n/jobs/overview\n/jobs/:jobid\n/jobs/:jobid/config\n/:*\n\nThis closes #4958.\n",
					"commitDate": "2017-11-09, 2:48 AM",
					"commitName": "34fdf569d7defb4393849fb9ecb2763b14532cc6",
					"commitAuthor": "Till Rohrmann",
					"commitDateOld": "2017-11-07, 7:07 AM",
					"commitNameOld": "712d4cfc0fb8591fb6ab7d27baede158cd227c60",
					"commitAuthorOld": "Till Rohrmann",
					"daysBetweenCommits": 1.82,
					"commitsBetweenForRepo": 22,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,222 +1,222 @@\n-\tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n+\tprotected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tJobsOverviewHandler<DispatcherGateway> jobsOverviewHandler = new JobsOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobsOverviewHeaders.getInstance());\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobExceptionsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tTaskManagersHandler<DispatcherGateway> taskManagersHandler = new TaskManagersHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagersHeaders.getInstance(),\n \t\t\tresourceManagerRetriever);\n \n \t\tTaskManagerDetailsHandler<DispatcherGateway> taskManagerDetailsHandler = new TaskManagerDetailsHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagerDetailsHeaders.getInstance(),\n \t\t\tresourceManagerRetriever,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobDetailsHandler jobDetailsHandler = new JobDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tmetricFetcher);\n \n \t\tJobAccumulatorsHandler jobAccumulatorsHandler = new JobAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tSubtasksTimesHandler subtasksTimesHandler = new SubtasksTimesHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tSubtasksTimesHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(JobsOverviewHeaders.getInstance(), jobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n \t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(JobDetailsHeaders.getInstance(), jobDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobAccumulatorsHeaders.getInstance(), jobAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \t\thandlers.add(Tuple2.of(TaskManagersHeaders.getInstance(), taskManagersHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerDetailsHeaders.getInstance(), taskManagerDetailsHandler));\n+\t\thandlers.add(Tuple2.of(SubtasksTimesHeaders.getInstance(), subtasksTimesHandler));\n \n-\t\t// This handler MUST be added last, as it otherwise masks all subsequent GET handlers\n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"712d4cfc0fb8591fb6ab7d27baede158cd227c60": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7941][flip6] Port SubtasksTimesHandler to new REST endpoint\n\nThis closes #4930.\n",
			"commitDate": "2017-11-07, 7:07 AM",
			"commitName": "712d4cfc0fb8591fb6ab7d27baede158cd227c60",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-11-07, 7:07 AM",
			"commitNameOld": "8086e3bee8be4614359041c14786140edff19666",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,213 +1,222 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tJobsOverviewHandler<DispatcherGateway> jobsOverviewHandler = new JobsOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobsOverviewHeaders.getInstance());\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobExceptionsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tTaskManagersHandler<DispatcherGateway> taskManagersHandler = new TaskManagersHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagersHeaders.getInstance(),\n \t\t\tresourceManagerRetriever);\n \n \t\tTaskManagerDetailsHandler<DispatcherGateway> taskManagerDetailsHandler = new TaskManagerDetailsHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagerDetailsHeaders.getInstance(),\n \t\t\tresourceManagerRetriever,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobDetailsHandler jobDetailsHandler = new JobDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tmetricFetcher);\n \n \t\tJobAccumulatorsHandler jobAccumulatorsHandler = new JobAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n+\t\tSubtasksTimesHandler subtasksTimesHandler = new SubtasksTimesHandler(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tresponseHeaders,\n+\t\t\tSubtasksTimesHeaders.getInstance(),\n+\t\t\texecutionGraphCache,\n+\t\t\texecutor);\n+\n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(JobsOverviewHeaders.getInstance(), jobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n \t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(JobDetailsHeaders.getInstance(), jobDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobAccumulatorsHeaders.getInstance(), jobAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \t\thandlers.add(Tuple2.of(TaskManagersHeaders.getInstance(), taskManagersHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerDetailsHeaders.getInstance(), taskManagerDetailsHandler));\n \n \t\t// This handler MUST be added last, as it otherwise masks all subsequent GET handlers\n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8086e3bee8be4614359041c14786140edff19666": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7806] [flip6] Register CurrentJobsOverviewHandler under /jobs/overview\n\nRename CurrentJobsOverviewHandler to JobsOverviewHandler\n\nChange paths\n\nRemove joboverview/running and joboverview/completed from JobsOverviewHandler\n\nAdapt web ui files\n\nUpdate rest_api to reflect new REST call /jobs\n\nThis changes #4805.\n",
			"commitDate": "2017-11-07, 7:07 AM",
			"commitName": "8086e3bee8be4614359041c14786140edff19666",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-11-07, 7:07 AM",
			"commitNameOld": "0c62c5278fc5581ea3485977a562df4445cf9dc9",
			"commitAuthorOld": "yew1eb",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,218 +1,213 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n-\t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n+\t\tJobsOverviewHandler<DispatcherGateway> jobsOverviewHandler = new JobsOverviewHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n-\t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n-\t\t\tnew CurrentJobsOverviewHandler(\n-\t\t\t\texecutor,\n-\t\t\t\ttimeout,\n-\t\t\t\ttrue,\n-\t\t\t\ttrue));\n+\t\t\tJobsOverviewHeaders.getInstance());\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobExceptionsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tTaskManagersHandler<DispatcherGateway> taskManagersHandler = new TaskManagersHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagersHeaders.getInstance(),\n \t\t\tresourceManagerRetriever);\n \n \t\tTaskManagerDetailsHandler<DispatcherGateway> taskManagerDetailsHandler = new TaskManagerDetailsHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagerDetailsHeaders.getInstance(),\n \t\t\tresourceManagerRetriever,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobDetailsHandler jobDetailsHandler = new JobDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tmetricFetcher);\n \n \t\tJobAccumulatorsHandler jobAccumulatorsHandler = new JobAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n-\t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n+\t\thandlers.add(Tuple2.of(JobsOverviewHeaders.getInstance(), jobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n \t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(JobDetailsHeaders.getInstance(), jobDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobAccumulatorsHeaders.getInstance(), jobAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \t\thandlers.add(Tuple2.of(TaskManagersHeaders.getInstance(), taskManagersHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerDetailsHeaders.getInstance(), taskManagerDetailsHandler));\n \n \t\t// This handler MUST be added last, as it otherwise masks all subsequent GET handlers\n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0c62c5278fc5581ea3485977a562df4445cf9dc9": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7706] [flip6] Add JobAccumulatorsHandler for new REST endpoint\n\nThis closes #4898.\n",
			"commitDate": "2017-11-07, 7:07 AM",
			"commitName": "0c62c5278fc5581ea3485977a562df4445cf9dc9",
			"commitAuthor": "yew1eb",
			"commitDateOld": "2017-11-07, 7:07 AM",
			"commitNameOld": "de201a6c0f8739c12918817d2ef571abb2898f37",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,208 +1,218 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n \t\t\tnew CurrentJobsOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout,\n \t\t\t\ttrue,\n \t\t\t\ttrue));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobExceptionsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tTaskManagersHandler<DispatcherGateway> taskManagersHandler = new TaskManagersHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagersHeaders.getInstance(),\n \t\t\tresourceManagerRetriever);\n \n \t\tTaskManagerDetailsHandler<DispatcherGateway> taskManagerDetailsHandler = new TaskManagerDetailsHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagerDetailsHeaders.getInstance(),\n \t\t\tresourceManagerRetriever,\n \t\t\tmetricFetcher);\n \n \t\tfinal JobDetailsHandler jobDetailsHandler = new JobDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tmetricFetcher);\n \n+\t\tJobAccumulatorsHandler jobAccumulatorsHandler = new JobAccumulatorsHandler(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tresponseHeaders,\n+\t\t\tJobAccumulatorsHeaders.getInstance(),\n+\t\t\texecutionGraphCache,\n+\t\t\texecutor);\n+\n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n \t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(JobDetailsHeaders.getInstance(), jobDetailsHandler));\n+\t\thandlers.add(Tuple2.of(JobAccumulatorsHeaders.getInstance(), jobAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \t\thandlers.add(Tuple2.of(TaskManagersHeaders.getInstance(), taskManagersHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerDetailsHeaders.getInstance(), taskManagerDetailsHandler));\n \n \t\t// This handler MUST be added last, as it otherwise masks all subsequent GET handlers\n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"de201a6c0f8739c12918817d2ef571abb2898f37": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7705] Add JobDetailsHandler\n\nAdd JobID(De)Serializer and JobVertexID(De)Serializer for jackson\n\nThis closes #4884.\n",
			"commitDate": "2017-11-07, 7:07 AM",
			"commitName": "de201a6c0f8739c12918817d2ef571abb2898f37",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-11-07, 7:07 AM",
			"commitNameOld": "fdf684427165e8068d4229a340b8e03548e022ef",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,196 +1,208 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n \t\t\tnew CurrentJobsOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout,\n \t\t\t\ttrue,\n \t\t\t\ttrue));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobExceptionsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tTaskManagersHandler<DispatcherGateway> taskManagersHandler = new TaskManagersHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagersHeaders.getInstance(),\n \t\t\tresourceManagerRetriever);\n \n \t\tTaskManagerDetailsHandler<DispatcherGateway> taskManagerDetailsHandler = new TaskManagerDetailsHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagerDetailsHeaders.getInstance(),\n \t\t\tresourceManagerRetriever,\n \t\t\tmetricFetcher);\n+\n+\t\tfinal JobDetailsHandler jobDetailsHandler = new JobDetailsHandler(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tresponseHeaders,\n+\t\t\tJobDetailsHeaders.getInstance(),\n+\t\t\texecutionGraphCache,\n+\t\t\texecutor,\n+\t\t\tmetricFetcher);\n+\n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n \t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n+\t\thandlers.add(Tuple2.of(JobDetailsHeaders.getInstance(), jobDetailsHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \t\thandlers.add(Tuple2.of(TaskManagersHeaders.getInstance(), taskManagersHandler));\n \t\thandlers.add(Tuple2.of(TaskManagerDetailsHeaders.getInstance(), taskManagerDetailsHandler));\n \n \t\t// This handler MUST be added last, as it otherwise masks all subsequent GET handlers\n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fdf684427165e8068d4229a340b8e03548e022ef": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7862] [flip6] Add TaskManagerDetailsHandler\n\nPass MetricQueryServiceRetriever to DispatcherRestEndpoint\n\nThis closes #4862.\n",
			"commitDate": "2017-11-07, 7:07 AM",
			"commitName": "fdf684427165e8068d4229a340b8e03548e022ef",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-11-07, 7:07 AM",
			"commitNameOld": "3f7f04a995587f78185710ce8472d1b2e8a536f3",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,187 +1,196 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n \t\t\tnew CurrentJobsOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout,\n \t\t\t\ttrue,\n \t\t\t\ttrue));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobExceptionsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tTaskManagersHandler<DispatcherGateway> taskManagersHandler = new TaskManagersHandler<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskManagersHeaders.getInstance(),\n \t\t\tresourceManagerRetriever);\n \n+\t\tTaskManagerDetailsHandler<DispatcherGateway> taskManagerDetailsHandler = new TaskManagerDetailsHandler<>(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tresponseHeaders,\n+\t\t\tTaskManagerDetailsHeaders.getInstance(),\n+\t\t\tresourceManagerRetriever,\n+\t\t\tmetricFetcher);\n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n \t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \t\thandlers.add(Tuple2.of(TaskManagersHeaders.getInstance(), taskManagersHandler));\n+\t\thandlers.add(Tuple2.of(TaskManagerDetailsHeaders.getInstance(), taskManagerDetailsHandler));\n \n \t\t// This handler MUST be added last, as it otherwise masks all subsequent GET handlers\n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"def87816f376740902f0944a6aa5791a0a937e89": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7648] [flip6] Add TaskManagersHandler\n\nSend dataPort and HardwareDescription to RM\n\nInstantiate RM leader retriever\n",
			"commitDate": "2017-11-07, 7:07 AM",
			"commitName": "def87816f376740902f0944a6aa5791a0a937e89",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-11-07, 7:07 AM",
			"commitNameOld": "eddb5b0a4c44443acc5ec2a07686a50b088303f8",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,178 +1,187 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n \t\t\tnew CurrentJobsOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout,\n \t\t\t\ttrue,\n \t\t\t\ttrue));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n-\n+\t\t\t\n \t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobExceptionsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n-\n+\t\t\t\n \t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders,\n \t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tresponseHeaders);\n \n+\t\tTaskManagersHandler<DispatcherGateway> taskManagersHandler = new TaskManagersHandler<>(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tresponseHeaders,\n+\t\t\tTaskManagersHeaders.getInstance(),\n+\t\t\tresourceManagerRetriever);\n+\n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n \t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n+\t\thandlers.add(Tuple2.of(TaskManagersHeaders.getInstance(), taskManagersHandler));\n \n \t\t// This handler MUST be added last, as it otherwise masks all subsequent GET handlers\n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"eddb5b0a4c44443acc5ec2a07686a50b088303f8": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7872] Allow to pass in additional HTTP headers\n\nHandlerUtils#sendResponse now accepts a map of additional http response headers\nand their values. This allows to set additional headers such as the\nACCESS_CONTROL_ALLOW_ORIGIN header and its value.\n\nThis closes #4859.\n",
			"commitDate": "2017-11-07, 7:07 AM",
			"commitName": "eddb5b0a4c44443acc5ec2a07686a50b088303f8",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-10-20, 7:09 AM",
			"commitNameOld": "13488396f73f157373c576fc23d5c3fb12592215",
			"commitAuthorOld": "zjureel",
			"daysBetweenCommits": 18.04,
			"commitsBetweenForRepo": 185,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,156 +1,178 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n+\t\tfinal Map<String, String> responseHeaders = restConfiguration.getResponseHeaders();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n+\t\t\tresponseHeaders,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n+\t\t\tresponseHeaders,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n+\t\t\tresponseHeaders,\n \t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n \t\t\tnew CurrentJobsOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout,\n \t\t\t\ttrue,\n \t\t\t\ttrue));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n+\t\t\tresponseHeaders,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n+\t\t\tresponseHeaders,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n+\t\t\tresponseHeaders,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n+\t\t\tresponseHeaders,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n+\t\t\tresponseHeaders,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n+\t\t\tresponseHeaders,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n+\t\t\tresponseHeaders,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n+\t\t\tresponseHeaders,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n+\t\t\tresponseHeaders,\n \t\t\tJobExceptionsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n+\t\t\tresponseHeaders,\n \t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n+\t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tresponseHeaders);\n+\n+\t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tresponseHeaders);\n+\n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n \t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n-\n-\t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(restAddressFuture, leaderRetriever, timeout);\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n-\n-\t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(restAddressFuture, leaderRetriever, timeout);\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \n \t\t// This handler MUST be added last, as it otherwise masks all subsequent GET handlers\n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"13488396f73f157373c576fc23d5c3fb12592215": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7855] [flip6] Port JobVertexAccumulatorsHandler to REST endpoint\n",
			"commitDate": "2017-10-20, 7:09 AM",
			"commitName": "13488396f73f157373c576fc23d5c3fb12592215",
			"commitAuthor": "zjureel",
			"commitDateOld": "2017-10-18, 4:51 AM",
			"commitNameOld": "cb528a114b4f4bac04620f0dd6aeead773de0d0e",
			"commitAuthorOld": "zjureel",
			"daysBetweenCommits": 2.1,
			"commitsBetweenForRepo": 20,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,147 +1,156 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n \t\t\tnew CurrentJobsOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout,\n \t\t\t\ttrue,\n \t\t\t\ttrue));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobExceptionsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n+\t\tJobVertexAccumulatorsHandler jobVertexAccumulatorsHandler = new JobVertexAccumulatorsHandler(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tJobVertexAccumulatorsHeaders.getInstance(),\n+\t\t\texecutionGraphCache,\n+\t\t\texecutor);\n+\n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n+\t\thandlers.add(Tuple2.of(JobVertexAccumulatorsHeaders.getInstance(), jobVertexAccumulatorsHandler));\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(restAddressFuture, leaderRetriever, timeout);\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(restAddressFuture, leaderRetriever, timeout);\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \n \t\t// This handler MUST be added last, as it otherwise masks all subsequent GET handlers\n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cb528a114b4f4bac04620f0dd6aeead773de0d0e": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7703] Port JobExceptionsHandler to new REST endpoint\n\nThis closes #4834.\n",
			"commitDate": "2017-10-18, 4:51 AM",
			"commitName": "cb528a114b4f4bac04620f0dd6aeead773de0d0e",
			"commitAuthor": "zjureel",
			"commitDateOld": "2017-10-12, 10:30 AM",
			"commitNameOld": "660a45ca1a67ade234652482e8e41c79ab674d3d",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 5.76,
			"commitsBetweenForRepo": 42,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,138 +1,147 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n \t\t\tnew CurrentJobsOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout,\n \t\t\t\ttrue,\n \t\t\t\ttrue));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n+\t\tJobExceptionsHandler jobExceptionsHandler = new JobExceptionsHandler(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tJobExceptionsHeaders.getInstance(),\n+\t\t\texecutionGraphCache,\n+\t\t\texecutor);\n+\n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n+\t\thandlers.add(Tuple2.of(JobExceptionsHeaders.getInstance(), jobExceptionsHandler));\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(restAddressFuture, leaderRetriever, timeout);\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(restAddressFuture, leaderRetriever, timeout);\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \n \t\t// This handler MUST be added last, as it otherwise masks all subsequent GET handlers\n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"660a45ca1a67ade234652482e8e41c79ab674d3d": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7653] Properly implement Dispatcher#requestClusterOverview\n\nThis commit implements the ClusterOverview generation on the Dispatcher. In\norder to do this, the Dispatcher requests the ResourceOverview from the\nResourceManager and the job status from all JobMasters. After receiving all\ninformation, it is compiled into the ClusterOverview.\n\nNote: StatusOverview has been renamed to ClusterOverview\n\nThis closes #4793.\n",
			"commitDate": "2017-10-12, 10:30 AM",
			"commitName": "660a45ca1a67ade234652482e8e41c79ab674d3d",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-10-11, 6:41 AM",
			"commitNameOld": "bc4638a3c96049de3ef615159cf83bbd88019575",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 1.16,
			"commitsBetweenForRepo": 14,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,138 +1,138 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \n-\t\tLegacyRestHandlerAdapter<DispatcherGateway, StatusOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n+\t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n \t\t\tnew CurrentJobsOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout,\n \t\t\t\ttrue,\n \t\t\t\ttrue));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(restAddressFuture, leaderRetriever, timeout);\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(restAddressFuture, leaderRetriever, timeout);\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \n \t\t// This handler MUST be added last, as it otherwise masks all subsequent GET handlers\n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"bc4638a3c96049de3ef615159cf83bbd88019575": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7707] [flip6] Add TaskCheckpointStatisticDetailsHandler for new REST endpoint\n\nThis closes #4772.\n",
			"commitDate": "2017-10-11, 6:41 AM",
			"commitName": "bc4638a3c96049de3ef615159cf83bbd88019575",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-10-10, 10:44 AM",
			"commitNameOld": "9829ca00dff201879724847b498fe0432219cb53",
			"commitAuthorOld": "yew1eb",
			"daysBetweenCommits": 0.83,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,128 +1,138 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, StatusOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n \t\t\tnew CurrentJobsOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout,\n \t\t\t\ttrue,\n \t\t\t\ttrue));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n \t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobPlanHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n+\t\tTaskCheckpointStatisticDetailsHandler taskCheckpointStatisticDetailsHandler = new TaskCheckpointStatisticDetailsHandler(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tTaskCheckpointStatisticsHeaders.getInstance(),\n+\t\t\texecutionGraphCache,\n+\t\t\texecutor,\n+\t\t\tcheckpointStatsCache);\n+\n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n+\t\thandlers.add(Tuple2.of(TaskCheckpointStatisticsHeaders.getInstance(), taskCheckpointStatisticDetailsHandler));\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(restAddressFuture, leaderRetriever, timeout);\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(restAddressFuture, leaderRetriever, timeout);\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \n \t\t// This handler MUST be added last, as it otherwise masks all subsequent GET handlers\n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9829ca00dff201879724847b498fe0432219cb53": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7704] [flip6] Add JobPlanHandler for new RestServerEndpoint\n\nThis closes #4768.\n",
			"commitDate": "2017-10-10, 10:44 AM",
			"commitName": "9829ca00dff201879724847b498fe0432219cb53",
			"commitAuthor": "yew1eb",
			"commitDateOld": "2017-10-10, 9:34 AM",
			"commitNameOld": "0a286d0ff98afa68034daff4634f526eaaf97897",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 0.05,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,119 +1,128 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, StatusOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n \t\t\tnew CurrentJobsOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout,\n \t\t\t\ttrue,\n \t\t\t\ttrue));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor,\n \t\t\tcheckpointStatsCache);\n \n+\t\tJobPlanHandler jobPlanHandler = new JobPlanHandler(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tJobPlanHeaders.getInstance(),\n+\t\t\texecutionGraphCache,\n+\t\t\texecutor);\n+\n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n+\t\thandlers.add(Tuple2.of(JobPlanHeaders.getInstance(), jobPlanHandler));\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(restAddressFuture, leaderRetriever, timeout);\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(restAddressFuture, leaderRetriever, timeout);\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \n \t\t// This handler MUST be added last, as it otherwise masks all subsequent GET handlers\n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0a286d0ff98afa68034daff4634f526eaaf97897": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7709] Add CheckpointStatisticDetailsHandler for new REST endpoint\n\nDisable failing when not all creator properties are known\n\nMove CheckpointStatsCache out of legacy package; Remove unused CheckpointingStatistics#generateCheckpointStatistics method\n\nRemove JsonInclude.Include.NON_NULL from CheckpointStatistics; Pull null check out of CheckpointStatistics#generateCheckpointStatistics; Make CheckpointStatistics#checkpointStatisticcsPerTask non nullable; Add fail on missing creator property\n\nThis closes #4763.\n",
			"commitDate": "2017-10-10, 9:34 AM",
			"commitName": "0a286d0ff98afa68034daff4634f526eaaf97897",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-10-09, 11:11 AM",
			"commitNameOld": "ad380463d3d44cdd98302bf072bc5deba8696b5b",
			"commitAuthorOld": "zentol",
			"daysBetweenCommits": 0.93,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,109 +1,119 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, StatusOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n \t\t\tnew CurrentJobsOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout,\n \t\t\t\ttrue,\n \t\t\t\ttrue));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n-\t\tCheckpointStatisticsHandler checkpointStatisticsHandler = new CheckpointStatisticsHandler(\n+\t\tCheckpointingStatisticsHandler checkpointStatisticsHandler = new CheckpointingStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n-\t\t\tCheckpointStatisticsHeaders.getInstance(),\n+\t\t\tCheckpointingStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n+\t\tCheckpointStatisticDetailsHandler checkpointStatisticDetailsHandler = new CheckpointStatisticDetailsHandler(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tCheckpointStatisticDetailsHeaders.getInstance(),\n+\t\t\texecutionGraphCache,\n+\t\t\texecutor,\n+\t\t\tcheckpointStatsCache);\n+\n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n-\t\thandlers.add(Tuple2.of(CheckpointStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n+\t\thandlers.add(Tuple2.of(CheckpointingStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n+\t\thandlers.add(Tuple2.of(CheckpointStatisticDetailsHeaders.getInstance(), checkpointStatisticDetailsHandler));\n \n \t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(restAddressFuture, leaderRetriever, timeout);\n \t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n \n \t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(restAddressFuture, leaderRetriever, timeout);\n \t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n \n \t\t// This handler MUST be added last, as it otherwise masks all subsequent GET handlers\n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ad380463d3d44cdd98302bf072bc5deba8696b5b": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7072] [REST] Define protocol for job submit/cancel/stop\n\n[FLINK-7072] [REST] Extend Dispatcher\n\n[FLINK-7072] [REST] Add handlers for job submit/cancel/stop\n\n[FLINK-7072] [REST] CLI integration\n\nuse ExecutorThradFactory + rebase(blobKey fix)\n\nadd \"Flink\" prefix to RestCC threads\n\nshutdown client for cancel/shutdown\n\nRework CliFrontEnd Stop/Cancel tests\n\nThese tests verified that the CLI was sending the correct messages and\nparameters to the JM actor. This is now handled by the ClusterClient, so\nthe tests were adjusted to verify that the correct methods on the\nClusterClient are being called.\n\nAdditional tests were added to the ClusterClientTest class to verify\nthat the correct messages and parameters are being sent.\n\nThis closes #4742.\n",
			"commitDate": "2017-10-09, 11:11 AM",
			"commitName": "ad380463d3d44cdd98302bf072bc5deba8696b5b",
			"commitAuthor": "zentol",
			"commitDateOld": "2017-10-02, 11:59 AM",
			"commitNameOld": "ac82becd21b7766c18d16abfc7e08334c644507e",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 6.97,
			"commitsBetweenForRepo": 40,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,103 +1,109 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, StatusOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n \t\t\tnew CurrentJobsOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout,\n \t\t\t\ttrue,\n \t\t\t\ttrue));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointStatisticsHandler checkpointStatisticsHandler = new CheckpointStatisticsHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCheckpointStatisticsHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \n+\t\tBlobServerPortHandler blobServerPortHandler = new BlobServerPortHandler(restAddressFuture, leaderRetriever, timeout);\n+\t\thandlers.add(Tuple2.of(blobServerPortHandler.getMessageHeaders(), blobServerPortHandler));\n+\n+\t\tJobSubmitHandler jobSubmitHandler = new JobSubmitHandler(restAddressFuture, leaderRetriever, timeout);\n+\t\thandlers.add(Tuple2.of(jobSubmitHandler.getMessageHeaders(), jobSubmitHandler));\n+\n \t\t// This handler MUST be added last, as it otherwise masks all subsequent GET handlers\n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ac82becd21b7766c18d16abfc7e08334c644507e": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7710] [flip6] Add CheckpointStatisticsHandler for the new REST endpoint\n\nThis commit also makes the CheckpointStatsHistory object serializable by removing the\nCheckpointStatsHistoryIterable and replacing it with a static ArrayList.\n\nThis closes #4750.\n",
			"commitDate": "2017-10-02, 11:59 AM",
			"commitName": "ac82becd21b7766c18d16abfc7e08334c644507e",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-10-02, 11:58 AM",
			"commitNameOld": "b41f5a66cd6d62bf3c271f1d0bf9d8fa50a5d410",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,94 +1,103 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, StatusOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n \t\t\tnew CurrentJobsOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout,\n \t\t\t\ttrue,\n \t\t\t\ttrue));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n \t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCheckpointConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n+\t\tCheckpointStatisticsHandler checkpointStatisticsHandler = new CheckpointStatisticsHandler(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tCheckpointStatisticsHeaders.getInstance(),\n+\t\t\texecutionGraphCache,\n+\t\t\texecutor);\n+\n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n+\t\thandlers.add(Tuple2.of(CheckpointStatisticsHeaders.getInstance(), checkpointStatisticsHandler));\n \n \t\t// This handler MUST be added last, as it otherwise masks all subsequent GET handlers\n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b41f5a66cd6d62bf3c271f1d0bf9d8fa50a5d410": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7708] [flip6] Add CheckpointConfigHandler for new REST endpoint\n\nThis commit implements the CheckpointConfigHandler which now returns a\nCheckpointConfigInfo object if checkpointing is enabled. In case that\ncheckpointing is disabled for a job, it will return a 404 response.\n\nThis closes #4744.\n",
			"commitDate": "2017-10-02, 11:58 AM",
			"commitName": "b41f5a66cd6d62bf3c271f1d0bf9d8fa50a5d410",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-10-02, 11:58 AM",
			"commitNameOld": "172a64c1488bd6edda97473562c6871ae7f3364d",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,85 +1,94 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, StatusOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n \t\t\tnew CurrentJobsOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout,\n \t\t\t\ttrue,\n \t\t\t\ttrue));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobConfigHeaders.getInstance(),\n \t\t\texecutionGraphCache,\n \t\t\texecutor);\n \n+\t\tCheckpointConfigHandler checkpointConfigHandler = new CheckpointConfigHandler(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tCheckpointConfigHeaders.getInstance(),\n+\t\t\texecutionGraphCache,\n+\t\t\texecutor);\n+\n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n+\t\thandlers.add(Tuple2.of(CheckpointConfigHeaders.getInstance(), checkpointConfigHandler));\n \n \t\t// This handler MUST be added last, as it otherwise masks all subsequent GET handlers\n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"172a64c1488bd6edda97473562c6871ae7f3364d": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7695] [flip6] Add JobConfigHandler for new RestServerEndpoint\n\nThis closes #4737.\n",
			"commitDate": "2017-10-02, 11:58 AM",
			"commitName": "172a64c1488bd6edda97473562c6871ae7f3364d",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-09-28, 3:28 AM",
			"commitNameOld": "40948d332489081572258a6c4cf7cc043f97c645",
			"commitAuthorOld": "zentol",
			"daysBetweenCommits": 4.35,
			"commitsBetweenForRepo": 25,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,76 +1,85 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, StatusOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n \t\t\tnew CurrentJobsOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout,\n \t\t\t\ttrue,\n \t\t\t\ttrue));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobTerminationHeaders.getInstance());\n \n+\t\tJobConfigHandler jobConfigHandler = new JobConfigHandler(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tJobConfigHeaders.getInstance(),\n+\t\t\texecutionGraphCache,\n+\t\t\texecutor);\n+\n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n+\t\thandlers.add(Tuple2.of(JobConfigHeaders.getInstance(), jobConfigHandler));\n \n \t\t// This handler MUST be added last, as it otherwise masks all subsequent GET handlers\n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"40948d332489081572258a6c4cf7cc043f97c645": {
			"type": "Ybodychange",
			"commitMessage": "[hotfix] [REST] Add note about placement of FileServerHandler\n",
			"commitDate": "2017-09-28, 3:28 AM",
			"commitName": "40948d332489081572258a6c4cf7cc043f97c645",
			"commitAuthor": "zentol",
			"commitDateOld": "2017-09-27, 5:07 PM",
			"commitNameOld": "adeab64ea0abdc892e51c6f630aa56dabf7e2c98",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 0.43,
			"commitsBetweenForRepo": 10,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,75 +1,76 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, StatusOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n \t\t\tnew CurrentJobsOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout,\n \t\t\t\ttrue,\n \t\t\t\ttrue));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tJobTerminationHeaders.getInstance());\n \n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n \t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \n+\t\t// This handler MUST be added last, as it otherwise masks all subsequent GET handlers\n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"adeab64ea0abdc892e51c6f630aa56dabf7e2c98": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7649] [flip6] Extend JobTerminationHandler to support stop\n\nRename the JobCancellationHandler into JobTerminationHandler which is now responsible\nfor terminating jobs. Moreover, this commits adds two termination modes, cancel and stop,\nwhich are specified by providing a query parameter.\n\nThis closes #4700.\n",
			"commitDate": "2017-09-27, 5:07 PM",
			"commitName": "adeab64ea0abdc892e51c6f630aa56dabf7e2c98",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-09-27, 5:06 PM",
			"commitNameOld": "8ea4db1a8b368b4e00dd310c0d07405fd2142b34",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,78 +1,75 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, StatusOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n \t\t\tnew CurrentJobsOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout,\n \t\t\t\ttrue,\n \t\t\t\ttrue));\n \n-\t\tLegacyRestHandlerAdapter<DispatcherGateway, EmptyResponseBody, JobMessageParameters> jobCancellationHandler = new LegacyRestHandlerAdapter<>(\n-\t\t\trestAddressFuture,\n-\t\t\tleaderRetriever,\n-\t\t\ttimeout,\n-\t\t\tJobCancellationHeaders.getInstance(),\n-\t\t\tnew JobCancellationHandler(\n-\t\t\t\texecutor,\n-\t\t\t\ttimeout));\n-\n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n+\t\tJobTerminationHandler jobTerminationHandler = new JobTerminationHandler(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tJobTerminationHeaders.getInstance());\n+\n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n-\t\thandlers.add(Tuple2.of(JobCancellationHeaders.getInstance(), jobCancellationHandler));\n+\t\thandlers.add(Tuple2.of(JobTerminationHeaders.getInstance(), jobTerminationHandler));\n \n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8ea4db1a8b368b4e00dd310c0d07405fd2142b34": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7650] [flip6] Port JobCancellationHandler to new REST endpoint\n\nLet the JobCancellationHandler implement the LegacyRestHandler interface. Moreover,\nthis commit adds the DELETE method to HttpMethodWrapper and the\nRestServerEndpoint#registerHandler method.\n\nAdd PATCH method\n\nThis closes #4697.\n",
			"commitDate": "2017-09-27, 5:06 PM",
			"commitName": "8ea4db1a8b368b4e00dd310c0d07405fd2142b34",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-09-26, 10:04 AM",
			"commitNameOld": "2b0008c50d27640e5a8a8be491528f4c248fdf32",
			"commitAuthorOld": "Tzu-Li (Gordon) Tai",
			"daysBetweenCommits": 1.29,
			"commitsBetweenForRepo": 24,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,68 +1,78 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, StatusOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n \t\t\tnew CurrentJobsOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout,\n \t\t\t\ttrue,\n \t\t\t\ttrue));\n \n+\t\tLegacyRestHandlerAdapter<DispatcherGateway, EmptyResponseBody, JobMessageParameters> jobCancellationHandler = new LegacyRestHandlerAdapter<>(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tJobCancellationHeaders.getInstance(),\n+\t\t\tnew JobCancellationHandler(\n+\t\t\t\texecutor,\n+\t\t\t\ttimeout));\n+\n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n \t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n+\t\thandlers.add(Tuple2.of(JobCancellationHeaders.getInstance(), jobCancellationHandler));\n \n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2b0008c50d27640e5a8a8be491528f4c248fdf32": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7647] [flip6] Rename JobManagerConfigHandler to ClusterConfigHandler\n\nThe original naming wouldn't make sense for the FLIP-6 redesign, since\nwe would have multiple per-job JobManagers for each cluster, which\nshares the same configuration.\n\nThe REST path is still left untouched and not part of this commit, as\nthat would involve more changes in flink-runtime-web.\n",
			"commitDate": "2017-09-26, 10:04 AM",
			"commitName": "2b0008c50d27640e5a8a8be491528f4c248fdf32",
			"commitAuthor": "Tzu-Li (Gordon) Tai",
			"commitDateOld": "2017-09-26, 10:04 AM",
			"commitNameOld": "97ff043fda06147bfd6441495d893fce7baf882e",
			"commitAuthorOld": "Tzu-Li (Gordon) Tai",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,68 +1,68 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, StatusOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n \t\t\tnew CurrentJobsOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout,\n \t\t\t\ttrue,\n \t\t\t\ttrue));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterConfigurationInfoHeaders.getInstance(),\n-\t\t\tnew JobManagerConfigHandler(\n+\t\t\tnew ClusterConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\tclusterConfiguration));\n \n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n \n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"97ff043fda06147bfd6441495d893fce7baf882e": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7647] [flip6] Port JobManagerConfigHandler to new REST endpoint\n\nThis commit lets the JobManagerConfigHandler implement the\nLegacyRestHandler interface in order to be ported to the new REST\nendpoint. This includes the introduction of ClusterConfiguration\nresponse body and ClusterConfigurationHeaders.\n\nThe DispatcherRestEndpoint now also registers the\nJobManagerConfigHandler.\n",
			"commitDate": "2017-09-26, 10:04 AM",
			"commitName": "97ff043fda06147bfd6441495d893fce7baf882e",
			"commitAuthor": "Tzu-Li (Gordon) Tai",
			"commitDateOld": "2017-09-25, 3:47 PM",
			"commitNameOld": "e585aed8ce751d769b56054fc1ffd4be24350e91",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 0.76,
			"commitsBetweenForRepo": 11,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,58 +1,68 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, StatusOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n \t\t\tnew CurrentJobsOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout,\n \t\t\t\ttrue,\n \t\t\t\ttrue));\n \n+\t\tLegacyRestHandlerAdapter<DispatcherGateway, ClusterConfigurationInfo, EmptyMessageParameters> clusterConfigurationHandler = new LegacyRestHandlerAdapter<>(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tClusterConfigurationInfoHeaders.getInstance(),\n+\t\t\tnew JobManagerConfigHandler(\n+\t\t\t\texecutor,\n+\t\t\t\tclusterConfiguration));\n+\n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n+\t\thandlers.add(Tuple2.of(ClusterConfigurationInfoHeaders.getInstance(), clusterConfigurationHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n \t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n \n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e585aed8ce751d769b56054fc1ffd4be24350e91": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7638] [flip6] Port CurrentJobsOverviewHandler to new REST endpoint\n\nPorts the CurrentJobsOverviewHandler to the new REST endpoint by letting it implement\nthe LegacyRestHandler interface. This commit changes the JobDetails JSON such that it\nnow contains the number of tasks for each ExecutionState, including SCHEDULED,\nDEPLOYING, CREATED and RECONCILING. These state will now also be displayed in the\nweb frontend.\n\nChange MultipleJobsDetails to store a Collection<JobDetails> instead of JobDetails[]\n\nUse MultipleJobsDetails#FIELD_NAME_ for serialization in CurrentJobsOverviewHandler\n\nThis closes #4688.\n",
			"commitDate": "2017-09-25, 3:47 PM",
			"commitName": "e585aed8ce751d769b56054fc1ffd4be24350e91",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-09-21, 1:30 AM",
			"commitNameOld": "c6243b8b1de6117623d3c4255f47f062d10c4602",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 4.59,
			"commitsBetweenForRepo": 22,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,46 +1,58 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n \t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n \n \t\tfinal Time timeout = restConfiguration.getTimeout();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, StatusOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tDashboardConfigurationHeaders.getInstance(),\n \t\t\tnew DashboardConfigHandler(\n \t\t\t\texecutor,\n \t\t\t\trestConfiguration.getRefreshInterval()));\n \n+\t\tLegacyRestHandlerAdapter<DispatcherGateway, MultipleJobsDetails, EmptyMessageParameters> currentJobsOverviewHandler = new LegacyRestHandlerAdapter<>(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tCurrentJobsOverviewHandlerHeaders.getInstance(),\n+\t\t\tnew CurrentJobsOverviewHandler(\n+\t\t\t\texecutor,\n+\t\t\t\ttimeout,\n+\t\t\t\ttrue,\n+\t\t\t\ttrue));\n+\n \t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n \t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n \t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n+\t\thandlers.add(Tuple2.of(CurrentJobsOverviewHandlerHeaders.getInstance(), currentJobsOverviewHandler));\n \n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c6243b8b1de6117623d3c4255f47f062d10c4602": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7535] Port DashboardConfigHandler to new REST endpoint\n\nLets DashboardConfigHandler implement the LegacyRestHandler. Moreover, this\ncommit defines the appropriate DashboardConfigurationHeaders.\n\nThe DispatcherRestEndpoint registers the DashboardConfigHandler.\n\nThis closes #4604.\n",
			"commitDate": "2017-09-21, 1:30 AM",
			"commitName": "c6243b8b1de6117623d3c4255f47f062d10c4602",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-09-20, 9:50 AM",
			"commitNameOld": "dbabdb1cc2c122dbf1e83ffb9960491eaf4914bb",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 0.65,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,32 +1,46 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n-\t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(2);\n+\t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(3);\n+\n+\t\tfinal Time timeout = restConfiguration.getTimeout();\n \n \t\tLegacyRestHandlerAdapter<DispatcherGateway, StatusOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n \t\t\trestAddressFuture,\n \t\t\tleaderRetriever,\n \t\t\ttimeout,\n \t\t\tClusterOverviewHeaders.getInstance(),\n \t\t\tnew ClusterOverviewHandler(\n \t\t\t\texecutor,\n \t\t\t\ttimeout));\n \n-\t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n+\t\tLegacyRestHandlerAdapter<DispatcherGateway, DashboardConfiguration, EmptyMessageParameters> dashboardConfigurationHandler = new LegacyRestHandlerAdapter<>(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tDashboardConfigurationHeaders.getInstance(),\n+\t\t\tnew DashboardConfigHandler(\n+\t\t\t\texecutor,\n+\t\t\t\trestConfiguration.getRefreshInterval()));\n+\n+\t\tfinal File tmpDir = restConfiguration.getTmpDir();\n \n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n+\t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n+\t\thandlers.add(Tuple2.of(DashboardConfigurationHeaders.getInstance(), dashboardConfigurationHandler));\n+\n \t\toptWebContent.ifPresent(\n \t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n \n \t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dbabdb1cc2c122dbf1e83ffb9960491eaf4914bb": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7534] Create LegacyRestHandlerAdapter for old REST handlers\n\nIntroduce LegacyRestHandler interface which the old REST handler have to implement\nin order to make them usable for the RestServerEndpoint in combination with the\nLegacyRestHandlerAdapter. The LegacyRestHandlerAdapter extends the AbstractRestHandler\nand runs the LegacyRestHandler implementation.\n\nAs an example, this commit ports the ClusterOverviewHandler to the new interface. The\nDispatcher side still has to be properly implemented.\n\nThis closes #4603.\n",
			"commitDate": "2017-09-20, 9:50 AM",
			"commitName": "dbabdb1cc2c122dbf1e83ffb9960491eaf4914bb",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2017-09-20, 2:35 AM",
			"commitNameOld": "55b76d54f0dcc4bdaa96eaa463ce0bfcad23d239",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 0.3,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,20 +1,32 @@\n \tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n+\t\tArrayList<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = new ArrayList<>(2);\n+\n+\t\tLegacyRestHandlerAdapter<DispatcherGateway, StatusOverviewWithVersion, EmptyMessageParameters> clusterOverviewHandler = new LegacyRestHandlerAdapter<>(\n+\t\t\trestAddressFuture,\n+\t\t\tleaderRetriever,\n+\t\t\ttimeout,\n+\t\t\tClusterOverviewHeaders.getInstance(),\n+\t\t\tnew ClusterOverviewHandler(\n+\t\t\t\texecutor,\n+\t\t\t\ttimeout));\n+\n+\t\thandlers.add(Tuple2.of(ClusterOverviewHeaders.getInstance(), clusterOverviewHandler));\n+\n \t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n \n \t\ttry {\n \t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n \t\t\t\tleaderRetriever,\n \t\t\t\trestAddressFuture,\n \t\t\t\ttimeout,\n \t\t\t\ttmpDir);\n \t\t} catch (IOException e) {\n \t\t\tlog.warn(\"Could not load web content handler.\", e);\n \t\t\toptWebContent = Optional.empty();\n \t\t}\n \n-\t\treturn optWebContent\n-\t\t\t.map(webContent ->\n-\t\t\t\tCollections.singleton(\n-\t\t\t\t\tTuple2.<RestHandlerSpecification, ChannelInboundHandler>of(WebContentHandlerSpecification.getInstance(), webContent)))\n-\t\t\t.orElseGet(() -> Collections.emptySet());\n+\t\toptWebContent.ifPresent(\n+\t\t\twebContent -> handlers.add(Tuple2.of(WebContentHandlerSpecification.getInstance(), webContent)));\n+\n+\t\treturn handlers;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"55b76d54f0dcc4bdaa96eaa463ce0bfcad23d239": {
			"type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
			"commitMessage": "[FLINK-7532] Add web content handler to DispatcherRestEndpoint\n\nAdds the StaticFileContentHandler to the DispatcherRestEndpoint if the\nflink-runtime-web dependency is in the classpath. In order to setup the\nrespective channel handler, this commit introduces the setupChannelHandlers\nmethod to the RestServerEndpoint.\n\nRefactor RestServerEndpoint#initializeHandler to support StaticFileServerHandler registration\n\nThis closes #4601.\n",
			"commitDate": "2017-09-20, 2:35 AM",
			"commitName": "55b76d54f0dcc4bdaa96eaa463ce0bfcad23d239",
			"commitAuthor": "Till Rohrmann",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "[FLINK-7532] Add web content handler to DispatcherRestEndpoint\n\nAdds the StaticFileContentHandler to the DispatcherRestEndpoint if the\nflink-runtime-web dependency is in the classpath. In order to setup the\nrespective channel handler, this commit introduces the setupChannelHandlers\nmethod to the RestServerEndpoint.\n\nRefactor RestServerEndpoint#initializeHandler to support StaticFileServerHandler registration\n\nThis closes #4601.\n",
					"commitDate": "2017-09-20, 2:35 AM",
					"commitName": "55b76d54f0dcc4bdaa96eaa463ce0bfcad23d239",
					"commitAuthor": "Till Rohrmann",
					"commitDateOld": "2017-09-19, 4:34 PM",
					"commitNameOld": "6a62f1455313ee8fae0ff79945da61fb67ec8edb",
					"commitAuthorOld": "Till Rohrmann",
					"daysBetweenCommits": 0.42,
					"commitsBetweenForRepo": 7,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,3 +1,20 @@\n-\tprotected Collection<AbstractRestHandler<?, ?, ?, ?>> initializeHandlers() {\n-\t\treturn Collections.emptySet();\n+\tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n+\t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n+\n+\t\ttry {\n+\t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n+\t\t\t\tleaderRetriever,\n+\t\t\t\trestAddressFuture,\n+\t\t\t\ttimeout,\n+\t\t\t\ttmpDir);\n+\t\t} catch (IOException e) {\n+\t\t\tlog.warn(\"Could not load web content handler.\", e);\n+\t\t\toptWebContent = Optional.empty();\n+\t\t}\n+\n+\t\treturn optWebContent\n+\t\t\t.map(webContent ->\n+\t\t\t\tCollections.singleton(\n+\t\t\t\t\tTuple2.<RestHandlerSpecification, ChannelInboundHandler>of(WebContentHandlerSpecification.getInstance(), webContent)))\n+\t\t\t.orElseGet(() -> Collections.emptySet());\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[]",
						"newValue": "[restAddressFuture-CompletableFuture<String>]"
					}
				},
				{
					"type": "Yreturntypechange",
					"commitMessage": "[FLINK-7532] Add web content handler to DispatcherRestEndpoint\n\nAdds the StaticFileContentHandler to the DispatcherRestEndpoint if the\nflink-runtime-web dependency is in the classpath. In order to setup the\nrespective channel handler, this commit introduces the setupChannelHandlers\nmethod to the RestServerEndpoint.\n\nRefactor RestServerEndpoint#initializeHandler to support StaticFileServerHandler registration\n\nThis closes #4601.\n",
					"commitDate": "2017-09-20, 2:35 AM",
					"commitName": "55b76d54f0dcc4bdaa96eaa463ce0bfcad23d239",
					"commitAuthor": "Till Rohrmann",
					"commitDateOld": "2017-09-19, 4:34 PM",
					"commitNameOld": "6a62f1455313ee8fae0ff79945da61fb67ec8edb",
					"commitAuthorOld": "Till Rohrmann",
					"daysBetweenCommits": 0.42,
					"commitsBetweenForRepo": 7,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,3 +1,20 @@\n-\tprotected Collection<AbstractRestHandler<?, ?, ?, ?>> initializeHandlers() {\n-\t\treturn Collections.emptySet();\n+\tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n+\t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n+\n+\t\ttry {\n+\t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n+\t\t\t\tleaderRetriever,\n+\t\t\t\trestAddressFuture,\n+\t\t\t\ttimeout,\n+\t\t\t\ttmpDir);\n+\t\t} catch (IOException e) {\n+\t\t\tlog.warn(\"Could not load web content handler.\", e);\n+\t\t\toptWebContent = Optional.empty();\n+\t\t}\n+\n+\t\treturn optWebContent\n+\t\t\t.map(webContent ->\n+\t\t\t\tCollections.singleton(\n+\t\t\t\t\tTuple2.<RestHandlerSpecification, ChannelInboundHandler>of(WebContentHandlerSpecification.getInstance(), webContent)))\n+\t\t\t.orElseGet(() -> Collections.emptySet());\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "Collection<AbstractRestHandler<?,?,?,?>>",
						"newValue": "Collection<Tuple2<RestHandlerSpecification,ChannelInboundHandler>>"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "[FLINK-7532] Add web content handler to DispatcherRestEndpoint\n\nAdds the StaticFileContentHandler to the DispatcherRestEndpoint if the\nflink-runtime-web dependency is in the classpath. In order to setup the\nrespective channel handler, this commit introduces the setupChannelHandlers\nmethod to the RestServerEndpoint.\n\nRefactor RestServerEndpoint#initializeHandler to support StaticFileServerHandler registration\n\nThis closes #4601.\n",
					"commitDate": "2017-09-20, 2:35 AM",
					"commitName": "55b76d54f0dcc4bdaa96eaa463ce0bfcad23d239",
					"commitAuthor": "Till Rohrmann",
					"commitDateOld": "2017-09-19, 4:34 PM",
					"commitNameOld": "6a62f1455313ee8fae0ff79945da61fb67ec8edb",
					"commitAuthorOld": "Till Rohrmann",
					"daysBetweenCommits": 0.42,
					"commitsBetweenForRepo": 7,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,3 +1,20 @@\n-\tprotected Collection<AbstractRestHandler<?, ?, ?, ?>> initializeHandlers() {\n-\t\treturn Collections.emptySet();\n+\tprotected Collection<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(CompletableFuture<String> restAddressFuture) {\n+\t\tOptional<StaticFileServerHandler<DispatcherGateway>> optWebContent;\n+\n+\t\ttry {\n+\t\t\toptWebContent = WebMonitorUtils.tryLoadWebContent(\n+\t\t\t\tleaderRetriever,\n+\t\t\t\trestAddressFuture,\n+\t\t\t\ttimeout,\n+\t\t\t\ttmpDir);\n+\t\t} catch (IOException e) {\n+\t\t\tlog.warn(\"Could not load web content handler.\", e);\n+\t\t\toptWebContent = Optional.empty();\n+\t\t}\n+\n+\t\treturn optWebContent\n+\t\t\t.map(webContent ->\n+\t\t\t\tCollections.singleton(\n+\t\t\t\t\tTuple2.<RestHandlerSpecification, ChannelInboundHandler>of(WebContentHandlerSpecification.getInstance(), webContent)))\n+\t\t\t.orElseGet(() -> Collections.emptySet());\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"6a62f1455313ee8fae0ff79945da61fb67ec8edb": {
			"type": "Yintroduced",
			"commitMessage": "[FLINK-7528] Create DispatcherRestEndpoint and integrate with Dispatcher\n\nThis commit creates the DispatcherRestEndpoint and integrates it with the\nDispatcher. The DispatcherRestEndpoint is created in the SessionClusterEntrypoint\nand its address is passed to the Dispatcher such that it can answer the\nrequestRestAddress RPC.\n\nThis closes #4598.\n",
			"commitDate": "2017-09-19, 4:34 PM",
			"commitName": "6a62f1455313ee8fae0ff79945da61fb67ec8edb",
			"commitAuthor": "Till Rohrmann"
		}
	},
	"sha": "9e936a5f8198b0059e9b5fba33163c2bbe3efbdd"
}