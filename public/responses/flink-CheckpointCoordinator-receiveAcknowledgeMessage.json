{
	"repo": "https://github.com/apache/flink.git",
	"file": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
	"method": {
		"longName": "CheckpointCoordinator::receiveAcknowledgeMessage(AcknowledgeCheckpoint message)",
		"startLine": 726,
		"methodName": "receiveAcknowledgeMessage",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"aa21f853ab0380ec1f68ae1d0b7c8d9268da4533": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-6014] [checkpoint] Additional review changes\n",
			"commitDate": "2017-04-22, 7:25 AM",
			"commitName": "aa21f853ab0380ec1f68ae1d0b7c8d9268da4533",
			"commitAuthor": "Stefan Richter",
			"commitDateOld": "2017-04-22, 7:25 AM",
			"commitNameOld": "218bed8b8e49b0e4c61c61f696a8f010eafea1b7",
			"commitAuthorOld": "xiaogang.sxg",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,83 +1,83 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n \t\tif (shutdown || message == null) {\n \t\t\treturn false;\n \t\t}\n \n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId = message.getCheckpointId();\n \t\t\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tfinal PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \n \t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {\n \t\t\t\t\tcase SUCCESS:\n \t\t\t\t\t\tLOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\",\n \t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\t\tcompletePendingCheckpoint(checkpoint);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DUPLICATE:\n \t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase UNKNOWN:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\t\"because the task's execution attempt id was unknown. Discarding \" +\n \t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n \t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n \n-\t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n+\t\t\t\t\t\tdiscardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DISCARDED:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n \t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \n-\t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n+\t\t\t\t\t\tdiscardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \t\t\t\t}\n \n \t\t\t\treturn true;\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tboolean wasPendingCheckpoint;\n \n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\twasPendingCheckpoint = true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {} from \" +\n \t\t\t\t\t\t\"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\",\n \t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\twasPendingCheckpoint = false;\n \t\t\t\t}\n \n \t\t\t\t// try to discard the state so that we don't have lingering state lying around\n-\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n+\t\t\t\tdiscardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \n \t\t\t\treturn wasPendingCheckpoint;\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2edc97185700a5bdb3e181a71493d681c0f693e3": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-5763] [checkpoints] Acknowledge with explicit ID and CheckpointMetrics\n\nInstead of acknowledging checkpoints with the CheckpointMetaData make\nthe acknowledgement explicit by ID and CheckpointMetrics. The rest is\nnot needed.\n",
			"commitDate": "2017-02-22, 4:14 AM",
			"commitName": "2edc97185700a5bdb3e181a71493d681c0f693e3",
			"commitAuthor": "Ufuk Celebi",
			"commitDateOld": "2017-02-20, 11:43 AM",
			"commitNameOld": "f63426b0322e05fd0986ae5f224a69b1320724f6",
			"commitAuthorOld": "Stephan Ewen",
			"daysBetweenCommits": 1.69,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,83 +1,83 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n \t\tif (shutdown || message == null) {\n \t\t\treturn false;\n \t\t}\n \n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tfinal PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \n-\t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetaData())) {\n+\t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {\n \t\t\t\t\tcase SUCCESS:\n \t\t\t\t\t\tLOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\",\n \t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\t\tcompletePendingCheckpoint(checkpoint);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DUPLICATE:\n \t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase UNKNOWN:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\t\"because the task's execution attempt id was unknown. Discarding \" +\n \t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n \t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DISCARDED:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n \t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \t\t\t\t}\n \n \t\t\t\treturn true;\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tboolean wasPendingCheckpoint;\n \n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\twasPendingCheckpoint = true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {} from \" +\n \t\t\t\t\t\t\"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\",\n \t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\twasPendingCheckpoint = false;\n \t\t\t\t}\n \n \t\t\t\t// try to discard the state so that we don't have lingering state lying around\n \t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \n \t\t\t\treturn wasPendingCheckpoint;\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"579bc96446d598a2cfe8237b4ebd62d8c9df3483": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-4410] [runtime] Rework checkpoint stats tracking\n",
			"commitDate": "2017-01-10, 1:48 AM",
			"commitName": "579bc96446d598a2cfe8237b4ebd62d8c9df3483",
			"commitAuthor": "Ufuk Celebi",
			"commitDateOld": "2016-12-09, 8:05 AM",
			"commitNameOld": "0c42d258e9d9d30eeeee7d0f1487ef0ac8b90fa4",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 31.74,
			"commitsBetweenForRepo": 241,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,83 +1,83 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n \t\tif (shutdown || message == null) {\n \t\t\treturn false;\n \t\t}\n \n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tfinal PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \n-\t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n+\t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetaData())) {\n \t\t\t\t\tcase SUCCESS:\n \t\t\t\t\t\tLOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\",\n \t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\t\tcompletePendingCheckpoint(checkpoint);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DUPLICATE:\n \t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase UNKNOWN:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\t\"because the task's execution attempt id was unknown. Discarding \" +\n \t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n \t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DISCARDED:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n \t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \t\t\t\t}\n \n \t\t\t\treturn true;\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tboolean wasPendingCheckpoint;\n \n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\twasPendingCheckpoint = true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {} from \" +\n \t\t\t\t\t\t\"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\",\n \t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\twasPendingCheckpoint = false;\n \t\t\t\t}\n \n \t\t\t\t// try to discard the state so that we don't have lingering state lying around\n \t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \n \t\t\t\treturn wasPendingCheckpoint;\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0c42d258e9d9d30eeeee7d0f1487ef0ac8b90fa4": {
			"type": "Ymultichange(Yexceptionschange,Ybodychange)",
			"commitMessage": "[FLINK-5158] [ckPtCoord] Handle exceptions from CompletedCheckpointStore in CheckpointCoordinator\n\nHandle exceptions from the CompletedCheckpointStore properly in the CheckpointCoordinator. This\nmeans that in case of an exception, the completed checkpoint will be properly cleaned up and also\nthe triggering of subsequent checkpoints will be started.\n\nThis closes #2872.\n",
			"commitDate": "2016-12-09, 8:05 AM",
			"commitName": "0c42d258e9d9d30eeeee7d0f1487ef0ac8b90fa4",
			"commitAuthor": "Till Rohrmann",
			"subchanges": [
				{
					"type": "Yexceptionschange",
					"commitMessage": "[FLINK-5158] [ckPtCoord] Handle exceptions from CompletedCheckpointStore in CheckpointCoordinator\n\nHandle exceptions from the CompletedCheckpointStore properly in the CheckpointCoordinator. This\nmeans that in case of an exception, the completed checkpoint will be properly cleaned up and also\nthe triggering of subsequent checkpoints will be started.\n\nThis closes #2872.\n",
					"commitDate": "2016-12-09, 8:05 AM",
					"commitName": "0c42d258e9d9d30eeeee7d0f1487ef0ac8b90fa4",
					"commitAuthor": "Till Rohrmann",
					"commitDateOld": "2016-12-09, 6:42 AM",
					"commitNameOld": "ea7080712f2dcbdf125b806007c80aa3d120f30a",
					"commitAuthorOld": "Till Rohrmann",
					"daysBetweenCommits": 0.06,
					"commitsBetweenForRepo": 2,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,132 +1,83 @@\n-\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n+\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n \t\tif (shutdown || message == null) {\n \t\t\treturn false;\n \t\t}\n \n \t\tif (!job.equals(message.getJob())) {\n-\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n+\t\t\tLOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId = message.getCheckpointId();\n \n-\t\tCompletedCheckpoint completed = null;\n-\t\tPendingCheckpoint checkpoint;\n-\n-\t\t// Flag indicating whether the ack message was for a known pending\n-\t\t// checkpoint.\n-\t\tboolean isPendingCheckpoint;\n-\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n-\t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n+\t\t\tfinal PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n-\t\t\t\tisPendingCheckpoint = true;\n \n \t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n \t\t\t\t\tcase SUCCESS:\n \t\t\t\t\t\tLOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\",\n \t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n-\n-\t\t\t\t\t\t\t// record the time when this was completed, to calculate\n-\t\t\t\t\t\t\t// the 'min delay between checkpoints'\n-\t\t\t\t\t\t\tlastCheckpointCompletionNanos = System.nanoTime();\n-\n-\t\t\t\t\t\t\t// complete the checkpoint structure\n-\t\t\t\t\t\t\tcompleted = checkpoint.finalizeCheckpoint();\n-\t\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n-\n-\t\t\t\t\t\t\tLOG.info(\"Completed checkpoint {} ({} bytes in {} ms).\", checkpointId,\n-\t\t\t\t\t\t\t\tcompleted.getStateSize(), completed.getDuration());\n-\n-\t\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n-\t\t\t\t\t\t\t\tStringBuilder builder = new StringBuilder();\n-\t\t\t\t\t\t\t\tbuilder.append(\"Checkpoint state: \");\n-\t\t\t\t\t\t\t\tfor (TaskState state : completed.getTaskStates().values()) {\n-\t\t\t\t\t\t\t\t\tbuilder.append(state);\n-\t\t\t\t\t\t\t\t\tbuilder.append(\", \");\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t// Remove last two chars \", \"\n-\t\t\t\t\t\t\t\tbuilder.delete(builder.length() - 2, builder.length());\n-\n-\t\t\t\t\t\t\t\tLOG.debug(builder.toString());\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n-\t\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n-\n-\t\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n-\n-\t\t\t\t\t\t\ttriggerQueuedRequests();\n+\t\t\t\t\t\t\tcompletePendingCheckpoint(checkpoint);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DUPLICATE:\n \t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase UNKNOWN:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\t\"because the task's execution attempt id was unknown. Discarding \" +\n \t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n \t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DISCARDED:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n \t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \t\t\t\t}\n+\n+\t\t\t\treturn true;\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n+\t\t\t\tboolean wasPendingCheckpoint;\n+\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n-\t\t\t\t\tisPendingCheckpoint = true;\n+\t\t\t\t\twasPendingCheckpoint = true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {} from \" +\n \t\t\t\t\t\t\"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\",\n \t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n-\t\t\t\t\tisPendingCheckpoint = false;\n+\t\t\t\t\twasPendingCheckpoint = false;\n \t\t\t\t}\n \n \t\t\t\t// try to discard the state so that we don't have lingering state lying around\n \t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n+\n+\t\t\t\treturn wasPendingCheckpoint;\n \t\t\t}\n \t\t}\n-\n-\t\t// send the confirmation messages to the necessary targets. we do this here\n-\t\t// to be outside the lock scope\n-\t\tif (completed != null) {\n-\t\t\tfinal long timestamp = completed.getTimestamp();\n-\n-\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n-\t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n-\t\t\t\tif (ee != null) {\n-\t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n-\t\t}\n-\n-\t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[Exception]",
						"newValue": "[CheckpointException]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "[FLINK-5158] [ckPtCoord] Handle exceptions from CompletedCheckpointStore in CheckpointCoordinator\n\nHandle exceptions from the CompletedCheckpointStore properly in the CheckpointCoordinator. This\nmeans that in case of an exception, the completed checkpoint will be properly cleaned up and also\nthe triggering of subsequent checkpoints will be started.\n\nThis closes #2872.\n",
					"commitDate": "2016-12-09, 8:05 AM",
					"commitName": "0c42d258e9d9d30eeeee7d0f1487ef0ac8b90fa4",
					"commitAuthor": "Till Rohrmann",
					"commitDateOld": "2016-12-09, 6:42 AM",
					"commitNameOld": "ea7080712f2dcbdf125b806007c80aa3d120f30a",
					"commitAuthorOld": "Till Rohrmann",
					"daysBetweenCommits": 0.06,
					"commitsBetweenForRepo": 2,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,132 +1,83 @@\n-\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n+\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n \t\tif (shutdown || message == null) {\n \t\t\treturn false;\n \t\t}\n \n \t\tif (!job.equals(message.getJob())) {\n-\t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n+\t\t\tLOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId = message.getCheckpointId();\n \n-\t\tCompletedCheckpoint completed = null;\n-\t\tPendingCheckpoint checkpoint;\n-\n-\t\t// Flag indicating whether the ack message was for a known pending\n-\t\t// checkpoint.\n-\t\tboolean isPendingCheckpoint;\n-\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n-\t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n+\t\t\tfinal PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n-\t\t\t\tisPendingCheckpoint = true;\n \n \t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n \t\t\t\t\tcase SUCCESS:\n \t\t\t\t\t\tLOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\",\n \t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n-\n-\t\t\t\t\t\t\t// record the time when this was completed, to calculate\n-\t\t\t\t\t\t\t// the 'min delay between checkpoints'\n-\t\t\t\t\t\t\tlastCheckpointCompletionNanos = System.nanoTime();\n-\n-\t\t\t\t\t\t\t// complete the checkpoint structure\n-\t\t\t\t\t\t\tcompleted = checkpoint.finalizeCheckpoint();\n-\t\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n-\n-\t\t\t\t\t\t\tLOG.info(\"Completed checkpoint {} ({} bytes in {} ms).\", checkpointId,\n-\t\t\t\t\t\t\t\tcompleted.getStateSize(), completed.getDuration());\n-\n-\t\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n-\t\t\t\t\t\t\t\tStringBuilder builder = new StringBuilder();\n-\t\t\t\t\t\t\t\tbuilder.append(\"Checkpoint state: \");\n-\t\t\t\t\t\t\t\tfor (TaskState state : completed.getTaskStates().values()) {\n-\t\t\t\t\t\t\t\t\tbuilder.append(state);\n-\t\t\t\t\t\t\t\t\tbuilder.append(\", \");\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t// Remove last two chars \", \"\n-\t\t\t\t\t\t\t\tbuilder.delete(builder.length() - 2, builder.length());\n-\n-\t\t\t\t\t\t\t\tLOG.debug(builder.toString());\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n-\t\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n-\n-\t\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n-\n-\t\t\t\t\t\t\ttriggerQueuedRequests();\n+\t\t\t\t\t\t\tcompletePendingCheckpoint(checkpoint);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DUPLICATE:\n \t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase UNKNOWN:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\t\"because the task's execution attempt id was unknown. Discarding \" +\n \t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n \t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DISCARDED:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n \t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \t\t\t\t}\n+\n+\t\t\t\treturn true;\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n+\t\t\t\tboolean wasPendingCheckpoint;\n+\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n-\t\t\t\t\tisPendingCheckpoint = true;\n+\t\t\t\t\twasPendingCheckpoint = true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {} from \" +\n \t\t\t\t\t\t\"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\",\n \t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n-\t\t\t\t\tisPendingCheckpoint = false;\n+\t\t\t\t\twasPendingCheckpoint = false;\n \t\t\t\t}\n \n \t\t\t\t// try to discard the state so that we don't have lingering state lying around\n \t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n+\n+\t\t\t\treturn wasPendingCheckpoint;\n \t\t\t}\n \t\t}\n-\n-\t\t// send the confirmation messages to the necessary targets. we do this here\n-\t\t// to be outside the lock scope\n-\t\tif (completed != null) {\n-\t\t\tfinal long timestamp = completed.getTimestamp();\n-\n-\t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n-\t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n-\t\t\t\tif (ee != null) {\n-\t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n-\t\t}\n-\n-\t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"ea7080712f2dcbdf125b806007c80aa3d120f30a": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-5278] Improve task and checkpoint related logging\n\nAdd more logging\n\nThis closes #2959.\n",
			"commitDate": "2016-12-09, 6:42 AM",
			"commitName": "ea7080712f2dcbdf125b806007c80aa3d120f30a",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2016-12-01, 7:55 AM",
			"commitNameOld": "b181662be378652d6c4405841ccda6145968d145",
			"commitAuthorOld": "Stephan Ewen",
			"daysBetweenCommits": 7.95,
			"commitsBetweenForRepo": 53,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,126 +1,132 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message == null) {\n \t\t\treturn false;\n \t\t}\n+\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint = true;\n \n \t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n \t\t\t\t\tcase SUCCESS:\n+\t\t\t\t\t\tLOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\",\n+\t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n+\n \t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \n \t\t\t\t\t\t\t// record the time when this was completed, to calculate\n \t\t\t\t\t\t\t// the 'min delay between checkpoints'\n \t\t\t\t\t\t\tlastCheckpointCompletionNanos = System.nanoTime();\n \n \t\t\t\t\t\t\t// complete the checkpoint structure\n \t\t\t\t\t\t\tcompleted = checkpoint.finalizeCheckpoint();\n \t\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n-\t\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n-\t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n+\t\t\t\t\t\t\tLOG.info(\"Completed checkpoint {} ({} bytes in {} ms).\", checkpointId,\n+\t\t\t\t\t\t\t\tcompleted.getStateSize(), completed.getDuration());\n \n \t\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tStringBuilder builder = new StringBuilder();\n \t\t\t\t\t\t\t\tbuilder.append(\"Checkpoint state: \");\n \t\t\t\t\t\t\t\tfor (TaskState state : completed.getTaskStates().values()) {\n \t\t\t\t\t\t\t\t\tbuilder.append(state);\n \t\t\t\t\t\t\t\t\tbuilder.append(\", \");\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t// Remove last two chars \", \"\n \t\t\t\t\t\t\t\tbuilder.delete(builder.length() - 2, builder.length());\n \n \t\t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n \n \t\t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DUPLICATE:\n \t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase UNKNOWN:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\t\"because the task's execution attempt id was unknown. Discarding \" +\n \t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n \t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n \n-\t\t\t\t\t\tdiscardState(message.getSubtaskState());\n+\t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DISCARDED:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n \t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \n-\t\t\t\t\t\tdiscardState(message.getSubtaskState());\n+\t\t\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint = true;\n-\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n+\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {} from \" +\n+\t\t\t\t\t\t\"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n+\t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\",\n+\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\tisPendingCheckpoint = false;\n \t\t\t\t}\n \n \t\t\t\t// try to discard the state so that we don't have lingering state lying around\n-\t\t\t\tdiscardState(message.getSubtaskState());\n+\t\t\t\tdiscardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b181662be378652d6c4405841ccda6145968d145": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-5216] [checkpoints] 'Min Time Between Checkpoints' references timestamp after checkpoint\n",
			"commitDate": "2016-12-01, 7:55 AM",
			"commitName": "b181662be378652d6c4405841ccda6145968d145",
			"commitAuthor": "Stephan Ewen",
			"commitDateOld": "2016-12-01, 2:44 AM",
			"commitNameOld": "dc7d8ec2c4d03c42e3d582947a3fe39a274d7f4b",
			"commitAuthorOld": "Ufuk Celebi",
			"daysBetweenCommits": 0.22,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,121 +1,126 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message == null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint = true;\n \n \t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n \t\t\t\t\tcase SUCCESS:\n \t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n-\t\t\t\t\t\t\tcompleted = checkpoint.finalizeCheckpoint();\n \n+\t\t\t\t\t\t\t// record the time when this was completed, to calculate\n+\t\t\t\t\t\t\t// the 'min delay between checkpoints'\n+\t\t\t\t\t\t\tlastCheckpointCompletionNanos = System.nanoTime();\n+\n+\t\t\t\t\t\t\t// complete the checkpoint structure\n+\t\t\t\t\t\t\tcompleted = checkpoint.finalizeCheckpoint();\n \t\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tStringBuilder builder = new StringBuilder();\n \t\t\t\t\t\t\t\tbuilder.append(\"Checkpoint state: \");\n \t\t\t\t\t\t\t\tfor (TaskState state : completed.getTaskStates().values()) {\n \t\t\t\t\t\t\t\t\tbuilder.append(state);\n \t\t\t\t\t\t\t\t\tbuilder.append(\", \");\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t// Remove last two chars \", \"\n \t\t\t\t\t\t\t\tbuilder.delete(builder.length() - 2, builder.length());\n \n \t\t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n \n \t\t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DUPLICATE:\n \t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase UNKNOWN:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\t\"because the task's execution attempt id was unknown. Discarding \" +\n \t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n \t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getSubtaskState());\n \n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DISCARDED:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n \t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getSubtaskState());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint = true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n \t\t\t\t\tisPendingCheckpoint = false;\n \t\t\t\t}\n \n \t\t\t\t// try to discard the state so that we don't have lingering state lying around\n \t\t\t\tdiscardState(message.getSubtaskState());\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dc7d8ec2c4d03c42e3d582947a3fe39a274d7f4b": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-5198] [logging] Improve TaskState toString\n",
			"commitDate": "2016-12-01, 2:44 AM",
			"commitName": "dc7d8ec2c4d03c42e3d582947a3fe39a274d7f4b",
			"commitAuthor": "Ufuk Celebi",
			"commitDateOld": "2016-11-22, 3:00 PM",
			"commitNameOld": "c590912c93a4059b40452dfa6cffbdd4d58cac13",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 8.49,
			"commitsBetweenForRepo": 51,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,117 +1,121 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message == null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint = true;\n \n \t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n \t\t\t\t\tcase SUCCESS:\n \t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\t\tcompleted = checkpoint.finalizeCheckpoint();\n \n \t\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tStringBuilder builder = new StringBuilder();\n-\t\t\t\t\t\t\t\tfor (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {\n-\t\t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n+\t\t\t\t\t\t\t\tbuilder.append(\"Checkpoint state: \");\n+\t\t\t\t\t\t\t\tfor (TaskState state : completed.getTaskStates().values()) {\n+\t\t\t\t\t\t\t\t\tbuilder.append(state);\n+\t\t\t\t\t\t\t\t\tbuilder.append(\", \");\n \t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t// Remove last two chars \", \"\n+\t\t\t\t\t\t\t\tbuilder.delete(builder.length() - 2, builder.length());\n \n \t\t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n \n \t\t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DUPLICATE:\n \t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase UNKNOWN:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\t\"because the task's execution attempt id was unknown. Discarding \" +\n \t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n \t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getSubtaskState());\n \n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DISCARDED:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n \t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \n \t\t\t\t\t\tdiscardState(message.getSubtaskState());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint = true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n \t\t\t\t\tisPendingCheckpoint = false;\n \t\t\t\t}\n \n \t\t\t\t// try to discard the state so that we don't have lingering state lying around\n \t\t\t\tdiscardState(message.getSubtaskState());\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c590912c93a4059b40452dfa6cffbdd4d58cac13": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-5085] Execute CheckpointCoordinator's state discard calls asynchronously\n\nThe CheckpointCoordinator is now given an Executor which is used to execute the state discard\ncalls asynchronously. This will prevent blocking operations to be executed from within the\ncalling thread.\n\nShut down ExecutorServices gracefully\n\nThis closes #2825.\n",
			"commitDate": "2016-11-22, 3:00 PM",
			"commitName": "c590912c93a4059b40452dfa6cffbdd4d58cac13",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2016-11-16, 4:34 PM",
			"commitNameOld": "72b295b3b52dff2d0bc5b78881826e8936c370ff",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 5.93,
			"commitsBetweenForRepo": 16,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,131 +1,117 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message == null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint = true;\n \n \t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n \t\t\t\t\tcase SUCCESS:\n \t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\t\tcompleted = checkpoint.finalizeCheckpoint();\n \n \t\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tStringBuilder builder = new StringBuilder();\n \t\t\t\t\t\t\t\tfor (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {\n \t\t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n \t\t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n \n \t\t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DUPLICATE:\n \t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase UNKNOWN:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\t\"because the task's execution attempt id was unknown. Discarding \" +\n \t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n \t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n \n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tmessage.getSubtaskState().discardState();\n-\t\t\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\t\t\tLOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\",\n-\t\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n-\t\t\t\t\t\t}\n+\t\t\t\t\t\tdiscardState(message.getSubtaskState());\n+\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase DISCARDED:\n \t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n \t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n \t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n \t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tmessage.getSubtaskState().discardState();\n-\t\t\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\t\t\tLOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\",\n-\t\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n-\t\t\t\t\t\t}\n+\t\t\t\t\t\tdiscardState(message.getSubtaskState());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint = true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n \t\t\t\t\tisPendingCheckpoint = false;\n \t\t\t\t}\n \n-\t\t\t\ttry {\n-\t\t\t\t\t// try to discard the state so that we don't have lingering state lying around\n-\t\t\t\t\tmessage.getSubtaskState().discardState();\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tLOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\",\n-\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n-\t\t\t\t}\n+\t\t\t\t// try to discard the state so that we don't have lingering state lying around\n+\t\t\t\tdiscardState(message.getSubtaskState());\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"72b295b3b52dff2d0bc5b78881826e8936c370ff": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-5063] [checkpointing] Discard state handles of declined or expired state handles\n\nWhenever the checkpoint coordinator receives an acknowledge checkpoint message which belongs\nto the job maintained by the checkpoint coordinator, it should either record the state handles\nfor later processing or discard to free the resources. The latter case can happen if a\ncheckpoint has been expired and late acknowledge checkpoint messages arrive. Furthremore, it\ncan happen if a Task sent a decline checkpoint message while other Tasks where still drawing\na checkpoint. This PR changes the behaviour such that state handles belonging to the job of\nthe checkpoint coordinator are discarded if they could not be added to the PendingCheckpoint.\n\nThis closes #2812\n",
			"commitDate": "2016-11-16, 4:34 PM",
			"commitName": "72b295b3b52dff2d0bc5b78881826e8936c370ff",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2016-11-08, 1:15 PM",
			"commitNameOld": "48a48139172e86f548f3b2f1564bdc948c3fe76a",
			"commitAuthorOld": "Stephan Ewen",
			"daysBetweenCommits": 8.14,
			"commitsBetweenForRepo": 44,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,95 +1,131 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message == null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint = true;\n \n-\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n-\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n-\t\t\t\t\t\tcompleted = checkpoint.finalizeCheckpoint();\n+\t\t\t\tswitch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n+\t\t\t\t\tcase SUCCESS:\n+\t\t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n+\t\t\t\t\t\t\tcompleted = checkpoint.finalizeCheckpoint();\n \n-\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n+\t\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n-\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n+\t\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n-\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n-\t\t\t\t\t\t\tStringBuilder builder = new StringBuilder();\n-\t\t\t\t\t\t\tfor (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {\n-\t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n+\t\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n+\t\t\t\t\t\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\t\t\t\t\t\tfor (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {\n+\t\t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n+\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\tLOG.debug(builder.toString());\n+\t\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n+\t\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n+\n+\t\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n+\n+\t\t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase DUPLICATE:\n+\t\t\t\t\t\tLOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\",\n+\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase UNKNOWN:\n+\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n+\t\t\t\t\t\t\t\t\"because the task's execution attempt id was unknown. Discarding \" +\n+\t\t\t\t\t\t\t\t\"the state handle to avoid lingering state.\", message.getCheckpointId(),\n+\t\t\t\t\t\t\tmessage.getTaskExecutionId(), message.getJob());\n \n-\t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n-\t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tmessage.getSubtaskState().discardState();\n+\t\t\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t\t\tLOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\",\n+\t\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase DISCARDED:\n+\t\t\t\t\t\tLOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" +\n+\t\t\t\t\t\t\t\"because the pending checkpoint had been discarded. Discarding the \" +\n+\t\t\t\t\t\t\t\t\"state handle tp avoid lingering state.\",\n+\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n \n-\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n-\n-\t\t\t\t\t\ttriggerQueuedRequests();\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\t// checkpoint did not accept message\n-\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint {} , task {}\",\n-\t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId());\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tmessage.getSubtaskState().discardState();\n+\t\t\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t\t\tLOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\",\n+\t\t\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n+\t\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint = true;\n-\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n+\t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n+\t\t\t\t\tLOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n \t\t\t\t\tisPendingCheckpoint = false;\n \t\t\t\t}\n+\n+\t\t\t\ttry {\n+\t\t\t\t\t// try to discard the state so that we don't have lingering state lying around\n+\t\t\t\t\tmessage.getSubtaskState().discardState();\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tLOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\",\n+\t\t\t\t\t\tmessage.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"48a48139172e86f548f3b2f1564bdc948c3fe76a": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-4985] [checkpointing] Report canceled / declined checkpoints to the Checkpoint Coordinator\n",
			"commitDate": "2016-11-08, 1:15 PM",
			"commitName": "48a48139172e86f548f3b2f1564bdc948c3fe76a",
			"commitAuthor": "Stephan Ewen",
			"commitDateOld": "2016-11-02, 12:34 AM",
			"commitNameOld": "c0e620f0ace0aa3500a5642e7165cf9f05e81f6a",
			"commitAuthorOld": "Ufuk Celebi",
			"daysBetweenCommits": 6.57,
			"commitsBetweenForRepo": 42,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,97 +1,95 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message == null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint = true;\n \n-\t\t\t\tif (checkpoint.acknowledgeTask(\n-\t\t\t\t\t\tmessage.getTaskExecutionId(),\n-\t\t\t\t\t\tmessage.getSubtaskState())) {\n+\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted = checkpoint.finalizeCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\tStringBuilder builder = new StringBuilder();\n \t\t\t\t\t\t\tfor (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {\n \t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n \n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// checkpoint did not accept message\n-\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n-\t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n+\t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint {} , task {}\",\n+\t\t\t\t\t\t\tcheckpointId, message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint = true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tisPendingCheckpoint = false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cfb3790fb6feb6c771bccbd05d3b12c69f53657d": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-4887] [execution graph] Introduce TaskManagerGateway to encapsulate communcation logic\n\nAll task manager related logic is now encapsulated in the TaskManagerGateway. Consequently,\nthere is no direct use of the ActorGateway in the ExecutionGraph anymore.\n\nAdd PartitionInfo\n\n[FLINK-4887] Add FutureUtils#retry to automatically retry failed future operations\n\nAdapt job manager\n\n[FLINK-4887] Refactor StackTraceSampleCoordinator to work with TaskManagerGateway and Flink futures\n\n[FLINK-4887] Refactor CheckpointCoordinator to work with TaskManagerGateway\n\n[FLINK-4887] Fix test cases to work with the newly introduce TaskManagerGateway\n\n[FLINK-4887] Update FlinkFuture#handlyAsync to avoid second future operation\n\n[FLINK-4887] Remove TaskOpeartionResult message\n\nMake StackTrace and StackTraceSampleResponse serializable\n\nIncrease timeout of TaskStopTest\n\nThis closes #2699.\n",
			"commitDate": "2016-11-01, 2:36 AM",
			"commitName": "cfb3790fb6feb6c771bccbd05d3b12c69f53657d",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2016-10-28, 3:04 AM",
			"commitNameOld": "3bc9cad045b25d413f0b9f054fff12fac18a4f0e",
			"commitAuthorOld": "Ufuk Celebi",
			"daysBetweenCommits": 3.98,
			"commitsBetweenForRepo": 18,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,99 +1,97 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message == null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint = true;\n \n \t\t\t\tif (checkpoint.acknowledgeTask(\n \t\t\t\t\t\tmessage.getTaskExecutionId(),\n \t\t\t\t\t\tmessage.getSubtaskState())) {\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted = checkpoint.finalizeCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\tStringBuilder builder = new StringBuilder();\n \t\t\t\t\t\t\tfor (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {\n \t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n \n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint = true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tisPendingCheckpoint = false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n-\t\t\t\t\tExecutionAttemptID attemptId = ee.getAttemptId();\n-\t\t\t\t\tNotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n-\t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n+\t\t\t\t\tee.notifyCheckpointComplete(checkpointId, timestamp);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cab9cd44eca83ef8cbcd2a2d070d8c79cb037977": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-4844] Partitionable Raw Keyed/Operator State\n",
			"commitDate": "2016-10-20, 8:14 AM",
			"commitName": "cab9cd44eca83ef8cbcd2a2d070d8c79cb037977",
			"commitAuthor": "Stefan Richter",
			"commitDateOld": "2016-10-14, 2:07 AM",
			"commitNameOld": "5783671c2f30228a2d5b5b7bf09b762ae41db8e2",
			"commitAuthorOld": "Ufuk Celebi",
			"daysBetweenCommits": 6.25,
			"commitsBetweenForRepo": 26,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,99 +1,99 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message == null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint = true;\n \n \t\t\t\tif (checkpoint.acknowledgeTask(\n \t\t\t\t\t\tmessage.getTaskExecutionId(),\n-\t\t\t\t\t\tmessage.getCheckpointStateHandles())) {\n+\t\t\t\t\t\tmessage.getSubtaskState())) {\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted = checkpoint.finalizeCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\tStringBuilder builder = new StringBuilder();\n \t\t\t\t\t\t\tfor (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {\n \t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n \n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint = true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tisPendingCheckpoint = false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tExecutionAttemptID attemptId = ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"53ed6adac8cbe6b5dcb692dc9b94970f3ec5887c": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-4379] [checkpoints] Introduce rescalable operator state\n\nThis introduces the Operator State Backend, which stores state that is not partitioned\nby a key. It replaces the 'Checkpointed' interface.\n\nAdditionally, this introduces CheckpointStateHandles as container for all checkpoint related state handles\n\nThis closes #2512\n",
			"commitDate": "2016-09-30, 4:38 AM",
			"commitName": "53ed6adac8cbe6b5dcb692dc9b94970f3ec5887c",
			"commitAuthor": "Stefan Richter",
			"commitDateOld": "2016-09-26, 10:05 AM",
			"commitNameOld": "70e71c16177b40c2418e6a8ca0838bf117f6a926",
			"commitAuthorOld": "Stephan Ewen",
			"daysBetweenCommits": 3.77,
			"commitsBetweenForRepo": 20,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,101 +1,99 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message == null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint = true;\n \n \t\t\t\tif (checkpoint.acknowledgeTask(\n-\t\t\t\t\tmessage.getTaskExecutionId(),\n-\t\t\t\t\tmessage.getStateHandle(),\n-\t\t\t\t\tmessage.getKeyGroupsStateHandle())) {\n+\t\t\t\t\t\tmessage.getTaskExecutionId(),\n+\t\t\t\t\t\tmessage.getCheckpointStateHandles())) {\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted = checkpoint.finalizeCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\tStringBuilder builder = new StringBuilder();\n-\t\t\t\t\t\t\tfor (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {\n+\t\t\t\t\t\t\tfor (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {\n \t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n \n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse {\n+\t\t\t\t} else {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint = true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tisPendingCheckpoint = false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tExecutionAttemptID attemptId = ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"847ead01f2f0aaf318b2b1ba8501bc697d245900": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-4381] Refactor State to Prepare For Key-Group State Backends\n",
			"commitDate": "2016-08-31, 11:10 AM",
			"commitName": "847ead01f2f0aaf318b2b1ba8501bc697d245900",
			"commitAuthor": "Stefan Richter",
			"commitDateOld": "2016-08-31, 11:04 AM",
			"commitNameOld": "ec975aaba79449bd93020f296b05ea509ea57bdc",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,103 +1,101 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message == null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint = true;\n \n \t\t\t\tif (checkpoint.acknowledgeTask(\n \t\t\t\t\tmessage.getTaskExecutionId(),\n-\t\t\t\t\tmessage.getState(),\n-\t\t\t\t\tmessage.getStateSize(),\n-\t\t\t\t\tnull)) { // TODO: Give KV-state to the acknowledgeTask method\n-\t\t\t\t\t\n+\t\t\t\t\tmessage.getStateHandle(),\n+\t\t\t\t\tmessage.getKeyGroupsStateHandle())) {\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted = checkpoint.finalizeCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\tStringBuilder builder = new StringBuilder();\n \t\t\t\t\t\t\tfor (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {\n \t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n \n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint = true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tisPendingCheckpoint = false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tExecutionAttemptID attemptId = ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4e9d1775b5514c87981c78d55323cc2b17361867": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-4417] [checkpoints] Checkpoints are subsumed by CheckpointID not, by timestamp\n\nThis closes #2407\n",
			"commitDate": "2016-08-24, 11:56 AM",
			"commitName": "4e9d1775b5514c87981c78d55323cc2b17361867",
			"commitAuthor": "Ramkrishna",
			"commitDateOld": "2016-08-24, 11:56 AM",
			"commitNameOld": "4da40bcb9ea01cb0c5e6fd0d7472dc09397f648e",
			"commitAuthorOld": "Stephan Ewen",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,103 +1,103 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message == null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint = true;\n \n \t\t\t\tif (checkpoint.acknowledgeTask(\n \t\t\t\t\tmessage.getTaskExecutionId(),\n \t\t\t\t\tmessage.getState(),\n \t\t\t\t\tmessage.getStateSize(),\n \t\t\t\t\tnull)) { // TODO: Give KV-state to the acknowledgeTask method\n \t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted = checkpoint.finalizeCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\tStringBuilder builder = new StringBuilder();\n \t\t\t\t\t\t\tfor (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {\n \t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n-\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n+\t\t\t\t\t\tdropSubsumedCheckpoints(completed.getCheckpointID());\n \n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint = true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tisPendingCheckpoint = false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tExecutionAttemptID attemptId = ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"76ca1a7955fedd8583a0af12289a14d0f1bcf868": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-4322] [checkpointing] Unify CheckpointCoordinator and SavepointCoordinator\n\nThe CheckpointCoordinator now also takes over the role of the SavepointCoordinator.\nSavepoints are just like other checkpoints - they only store the metadata in addition.\nRestoring from a savepoint means loading it into the CheckpointStore at startup.\n",
			"commitDate": "2016-08-17, 11:06 AM",
			"commitName": "76ca1a7955fedd8583a0af12289a14d0f1bcf868",
			"commitAuthor": "Stephan Ewen",
			"commitDateOld": "2016-07-26, 3:30 AM",
			"commitNameOld": "f0ac261add2eb184358d5b89bc90b13aef7b267d",
			"commitAuthorOld": "Ufuk Celebi",
			"daysBetweenCommits": 22.32,
			"commitsBetweenForRepo": 109,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,104 +1,103 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message == null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint = true;\n \n \t\t\t\tif (checkpoint.acknowledgeTask(\n \t\t\t\t\tmessage.getTaskExecutionId(),\n \t\t\t\t\tmessage.getState(),\n \t\t\t\t\tmessage.getStateSize(),\n \t\t\t\t\tnull)) { // TODO: Give KV-state to the acknowledgeTask method\n+\t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted = checkpoint.finalizeCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\tStringBuilder builder = new StringBuilder();\n \t\t\t\t\t\t\tfor (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {\n \t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \n-\t\t\t\t\t\tonFullyAcknowledgedCheckpoint(completed);\n-\n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint = true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tisPendingCheckpoint = false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tExecutionAttemptID attemptId = ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f0ac261add2eb184358d5b89bc90b13aef7b267d": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-4067] [runtime] Add savepoint headers\n\nSavepoints were previously persisted without any meta data using default\nJava serialization of `CompletedCheckpoint`. This commit introduces a\nsavepoint interface with version-specific serializers and stores\nsavepoints with meta data.\n\nSavepoints expose a version number and a Collection<TaskState> for\nsavepoint restore.\n\nCurrently, there is only one savepoint version:\n\nSavepointV0 (Flink 1.1): This is the current savepoint version, which\nholds a reference to the Checkpoint task state collection, but is\nserialized with a custom serializater not relying on default Java\nserialization. Therefore, it should not happen again that we need to\nstick to certain classes in future Flink versions.\n\nThe savepoints are stored in `FsSavepointStore` with the following\nformat:\n\nMagicNumber SavepointVersion Savepoint\n  - MagicNumber => int\n  - SavepointVersion => int (returned by Savepoint#getVersion())\n  - Savepoint => bytes (serialized via version-specific SavepointSerializer)\n\nThe header is minimal (magic number, version). All savepoint-specific\nmeta data can be moved to the savepoint itself. This is also were we\nwould have to add new meta data in future versions, allowing us to\ndifferentiate between different savepoint versions when we change the\nserialization stack.\n\nAll savepoint related classes have been moved from checkpoint to a new\nsub package `checkpoint.savepoint`.\n\nThis closes #2194.\n",
			"commitDate": "2016-07-26, 3:30 AM",
			"commitName": "f0ac261add2eb184358d5b89bc90b13aef7b267d",
			"commitAuthor": "Ufuk Celebi",
			"commitDateOld": "2016-07-22, 6:26 AM",
			"commitNameOld": "54f02ec7bae56a0559a61b981d0c88885090b128",
			"commitAuthorOld": "Ufuk Celebi",
			"daysBetweenCommits": 3.88,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,104 +1,104 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message == null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint = true;\n \n \t\t\t\tif (checkpoint.acknowledgeTask(\n \t\t\t\t\tmessage.getTaskExecutionId(),\n \t\t\t\t\tmessage.getState(),\n \t\t\t\t\tmessage.getStateSize(),\n \t\t\t\t\tnull)) { // TODO: Give KV-state to the acknowledgeTask method\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n-\t\t\t\t\t\tcompleted = checkpoint.toCompletedCheckpoint();\n+\t\t\t\t\t\tcompleted = checkpoint.finalizeCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \n \t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\t\t\t\tStringBuilder builder = new StringBuilder();\n \t\t\t\t\t\t\tfor (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {\n \t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tLOG.debug(builder.toString());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \n \t\t\t\t\t\tonFullyAcknowledgedCheckpoint(completed);\n \n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint = true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tisPendingCheckpoint = false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tExecutionAttemptID attemptId = ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0cf04108f70375d41ebb7c39629db3a081bd2876": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-3756] [state] Add state hierarchy to CheckpointCoordinator\n\nThis commit introduces a state hierarchy for the StateForTask objects kept\nat the CheckpointCoordinator. Task states are now grouped together if they\nbelong to the same ExecutionJobVertex. The StateForTask objects are now\nstored in so called StateForTaskGroup objects. The StateForTaskGroup object\ncan also store the key group state handles associated to a ExecutionJobVertex.\n\nAdapt restore methods of CheckpointCoordinator and SavepointCoordinator\n\nAdd state size computation\n\nAdd comments to createKeyGroupPartitions; Add more information to StateForTask.toString\n\nRename StateForTaskGroup -> TaskState, StateForTask -> SubtaskState, KvStateForTasks -> KeyGroupState\n\nThis closes #1883.\n",
			"commitDate": "2016-04-26, 4:22 AM",
			"commitName": "0cf04108f70375d41ebb7c39629db3a081bd2876",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2016-04-11, 10:36 AM",
			"commitNameOld": "2e63d1afb2358760109ba0c90011ef565eaae0ff",
			"commitAuthorOld": "zentol",
			"daysBetweenCommits": 14.74,
			"commitsBetweenForRepo": 67,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,92 +1,104 @@\n \tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message == null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n \n \t\t// Flag indicating whether the ack message was for a known pending\n \t\t// checkpoint.\n \t\tboolean isPendingCheckpoint;\n \n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tisPendingCheckpoint = true;\n \n-\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n+\t\t\t\tif (checkpoint.acknowledgeTask(\n+\t\t\t\t\tmessage.getTaskExecutionId(),\n+\t\t\t\t\tmessage.getState(),\n+\t\t\t\t\tmessage.getStateSize(),\n+\t\t\t\t\tnull)) { // TODO: Give KV-state to the acknowledgeTask method\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted = checkpoint.toCompletedCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n-\t\t\t\t\t\tLOG.debug(completed.getStates().toString());\n+\n+\t\t\t\t\t\tif (LOG.isDebugEnabled()) {\n+\t\t\t\t\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\t\t\t\t\tfor (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {\n+\t\t\t\t\t\t\t\tbuilder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tLOG.debug(builder.toString());\n+\t\t\t\t\t\t}\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \n \t\t\t\t\t\tonFullyAcknowledgedCheckpoint(completed);\n \n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tisPendingCheckpoint = true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tisPendingCheckpoint = false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tExecutionAttemptID attemptId = ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \n \t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d739ee2532e0fd49ef37508b1c2e4a355473aaa5": {
			"type": "Ymultichange(Yreturntypechange,Ybodychange)",
			"commitMessage": "[FLINK-2976] [runtime, tests] Add SavepointCoordinator\n\n[comments] Rename config keys\n\n[comments] Fix docs and don't overload savepoint backend configuration with checkpoint backend configuration\n\n[comments] Use ConcurrentMap in HeapStateStore\n\n[comments] Fix typo and add missing serialVersionUID\n\n[comments] Fix Scala style\n\n[comments] Fix Scala style\n\n[docs] Emphasize dangers and recommended approaches\n\nAdd test to show inf restart loop on submission with unknown savepoint path\n\n[comments] Suppress resart of savepoint recovery failure\n\nThis closes #1434.\n",
			"commitDate": "2016-01-11, 8:30 AM",
			"commitName": "d739ee2532e0fd49ef37508b1c2e4a355473aaa5",
			"commitAuthor": "Ufuk Celebi",
			"subchanges": [
				{
					"type": "Yreturntypechange",
					"commitMessage": "[FLINK-2976] [runtime, tests] Add SavepointCoordinator\n\n[comments] Rename config keys\n\n[comments] Fix docs and don't overload savepoint backend configuration with checkpoint backend configuration\n\n[comments] Use ConcurrentMap in HeapStateStore\n\n[comments] Fix typo and add missing serialVersionUID\n\n[comments] Fix Scala style\n\n[comments] Fix Scala style\n\n[docs] Emphasize dangers and recommended approaches\n\nAdd test to show inf restart loop on submission with unknown savepoint path\n\n[comments] Suppress resart of savepoint recovery failure\n\nThis closes #1434.\n",
					"commitDate": "2016-01-11, 8:30 AM",
					"commitName": "d739ee2532e0fd49ef37508b1c2e4a355473aaa5",
					"commitAuthor": "Ufuk Celebi",
					"commitDateOld": "2015-12-30, 4:45 PM",
					"commitNameOld": "2c7e63ae9ecc38c33f0b45df21bd324c2e597ef2",
					"commitAuthorOld": "Ufuk Celebi",
					"daysBetweenCommits": 11.66,
					"commitsBetweenForRepo": 26,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,80 +1,92 @@\n-\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n+\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message == null) {\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n+\n+\t\t// Flag indicating whether the ack message was for a known pending\n+\t\t// checkpoint.\n+\t\tboolean isPendingCheckpoint;\n+\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n-\t\t\t\treturn;\n+\t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n+\t\t\t\tisPendingCheckpoint = true;\n+\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted = checkpoint.toCompletedCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \t\t\t\t\t\tLOG.debug(completed.getStates().toString());\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \n+\t\t\t\t\t\tonFullyAcknowledgedCheckpoint(completed);\n+\n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n+\t\t\t\t\tisPendingCheckpoint = true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n+\t\t\t\t\tisPendingCheckpoint = false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tExecutionAttemptID attemptId = ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n+\n+\t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "void",
						"newValue": "boolean"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "[FLINK-2976] [runtime, tests] Add SavepointCoordinator\n\n[comments] Rename config keys\n\n[comments] Fix docs and don't overload savepoint backend configuration with checkpoint backend configuration\n\n[comments] Use ConcurrentMap in HeapStateStore\n\n[comments] Fix typo and add missing serialVersionUID\n\n[comments] Fix Scala style\n\n[comments] Fix Scala style\n\n[docs] Emphasize dangers and recommended approaches\n\nAdd test to show inf restart loop on submission with unknown savepoint path\n\n[comments] Suppress resart of savepoint recovery failure\n\nThis closes #1434.\n",
					"commitDate": "2016-01-11, 8:30 AM",
					"commitName": "d739ee2532e0fd49ef37508b1c2e4a355473aaa5",
					"commitAuthor": "Ufuk Celebi",
					"commitDateOld": "2015-12-30, 4:45 PM",
					"commitNameOld": "2c7e63ae9ecc38c33f0b45df21bd324c2e597ef2",
					"commitAuthorOld": "Ufuk Celebi",
					"daysBetweenCommits": 11.66,
					"commitsBetweenForRepo": 26,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,80 +1,92 @@\n-\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n+\tpublic boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message == null) {\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n+\n+\t\t// Flag indicating whether the ack message was for a known pending\n+\t\t// checkpoint.\n+\t\tboolean isPendingCheckpoint;\n+\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n-\t\t\t\treturn;\n+\t\t\t\treturn false;\n \t\t\t}\n \n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n \n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n+\t\t\t\tisPendingCheckpoint = true;\n+\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted = checkpoint.toCompletedCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n \t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \t\t\t\t\t\tLOG.debug(completed.getStates().toString());\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \n+\t\t\t\t\t\tonFullyAcknowledgedCheckpoint(completed);\n+\n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n+\t\t\t\t\tisPendingCheckpoint = true;\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n+\t\t\t\t\tisPendingCheckpoint = false;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tExecutionAttemptID attemptId = ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n+\n+\t\treturn isPendingCheckpoint;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"2c7e63ae9ecc38c33f0b45df21bd324c2e597ef2": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-3131] [core, runtime] Add checkpoint statistics tracker\n\nAdds a simple tracker of checkpoint statistics.\n",
			"commitDate": "2015-12-30, 4:45 PM",
			"commitName": "2c7e63ae9ecc38c33f0b45df21bd324c2e597ef2",
			"commitAuthor": "Ufuk Celebi",
			"commitDateOld": "2015-11-26, 9:16 AM",
			"commitNameOld": "55fd5f32d7ef0292a01192ab08456fae49b91791",
			"commitAuthorOld": "Stephan Ewen",
			"daysBetweenCommits": 34.31,
			"commitsBetweenForRepo": 96,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,78 +1,80 @@\n \tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message == null) {\n \t\t\treturn;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn;\n \t\t}\n-\t\t\n+\n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\t\n+\n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n-\t\t\t\n+\n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n-\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n-\t\t\t\t\t\n+\t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted = checkpoint.toCompletedCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n-\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n+\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" +\n+\t\t\t\t\t\t\t\tcompleted.getDuration() + \" ms)\");\n \t\t\t\t\t\tLOG.debug(completed.getStates().toString());\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n-\t\t\t\t\t\t\n+\n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \n \t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\t\n+\n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n-\t\t\t\n+\n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tExecutionAttemptID attemptId = ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\tstatsTracker.onCompletedCheckpoint(completed);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"55fd5f32d7ef0292a01192ab08456fae49b91791": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-3051] [streaming] Add mechanisms to control the maximum number of concurrent checkpoints\n\nThis closes #1408\n",
			"commitDate": "2015-11-26, 9:16 AM",
			"commitName": "55fd5f32d7ef0292a01192ab08456fae49b91791",
			"commitAuthor": "Stephan Ewen",
			"commitDateOld": "2015-11-24, 1:28 AM",
			"commitNameOld": "c254bda3e84fcd9303f9a9e2a6f7a175d8e70d1e",
			"commitAuthorOld": "Gyula Fora",
			"daysBetweenCommits": 2.32,
			"commitsBetweenForRepo": 35,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,76 +1,78 @@\n \tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message == null) {\n \t\t\treturn;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn;\n \t\t}\n \t\t\n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tCompletedCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t\n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n \t\t\t\n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n \t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tcompleted = checkpoint.toCompletedCheckpoint();\n \n \t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n \n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n \t\t\t\t\t\tLOG.debug(completed.getStates().toString());\n \n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \t\t\t\t\t\t\n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n+\n+\t\t\t\t\t\ttriggerQueuedRequests();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \t\t\t\n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tExecutionAttemptID attemptId = ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"73c73e92750ab8fb068d0a3cb37afcb642084fc0": {
			"type": "Ymultichange(Yexceptionschange,Ybodychange)",
			"commitMessage": "[FLINK-2354] [runtime] Add job graph and checkpoint recovery\n\nThis closes #1153.\n",
			"commitDate": "2015-10-19, 4:16 PM",
			"commitName": "73c73e92750ab8fb068d0a3cb37afcb642084fc0",
			"commitAuthor": "Ufuk Celebi",
			"subchanges": [
				{
					"type": "Yexceptionschange",
					"commitMessage": "[FLINK-2354] [runtime] Add job graph and checkpoint recovery\n\nThis closes #1153.\n",
					"commitDate": "2015-10-19, 4:16 PM",
					"commitName": "73c73e92750ab8fb068d0a3cb37afcb642084fc0",
					"commitAuthor": "Ufuk Celebi",
					"commitDateOld": "2015-08-31, 3:02 AM",
					"commitNameOld": "b9de4ed37ffa68ef50dc6d6b3819afcc00d1d029",
					"commitAuthorOld": "Till Rohrmann",
					"daysBetweenCommits": 49.55,
					"commitsBetweenForRepo": 328,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,76 +1,76 @@\n-\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n+\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message == null) {\n \t\t\treturn;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn;\n \t\t}\n \t\t\n \t\tfinal long checkpointId = message.getCheckpointId();\n \n-\t\tSuccessfulCheckpoint completed = null;\n+\t\tCompletedCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t\n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n \t\t\t\n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n \t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n-\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n-\n \t\t\t\t\t\tcompleted = checkpoint.toCompletedCheckpoint();\n-\t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n-\t\t\t\t\t\tif (completedCheckpoints.size() > numSuccessfulCheckpointsToRetain) {\n-\t\t\t\t\t\t\tcompletedCheckpoints.removeFirst().discard(userClassLoader);\n-\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n+\n+\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n+\t\t\t\t\t\tLOG.debug(completed.getStates().toString());\n+\n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \t\t\t\t\t\t\n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \t\t\t\n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tExecutionAttemptID attemptId = ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[]",
						"newValue": "[Exception]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "[FLINK-2354] [runtime] Add job graph and checkpoint recovery\n\nThis closes #1153.\n",
					"commitDate": "2015-10-19, 4:16 PM",
					"commitName": "73c73e92750ab8fb068d0a3cb37afcb642084fc0",
					"commitAuthor": "Ufuk Celebi",
					"commitDateOld": "2015-08-31, 3:02 AM",
					"commitNameOld": "b9de4ed37ffa68ef50dc6d6b3819afcc00d1d029",
					"commitAuthorOld": "Till Rohrmann",
					"daysBetweenCommits": 49.55,
					"commitsBetweenForRepo": 328,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,76 +1,76 @@\n-\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n+\tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n \t\tif (shutdown || message == null) {\n \t\t\treturn;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn;\n \t\t}\n \t\t\n \t\tfinal long checkpointId = message.getCheckpointId();\n \n-\t\tSuccessfulCheckpoint completed = null;\n+\t\tCompletedCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t\n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n \t\t\t\n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n \t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n-\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n-\n \t\t\t\t\t\tcompleted = checkpoint.toCompletedCheckpoint();\n-\t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n-\t\t\t\t\t\tif (completedCheckpoints.size() > numSuccessfulCheckpointsToRetain) {\n-\t\t\t\t\t\t\tcompletedCheckpoints.removeFirst().discard(userClassLoader);\n-\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n+\n+\t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n+\t\t\t\t\t\tLOG.debug(completed.getStates().toString());\n+\n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \t\t\t\t\t\t\n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \t\t\t\n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tExecutionAttemptID attemptId = ee.getAttemptId();\n \t\t\t\t\tNotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"aa5e5b3087a68f2aac792c0b0fc64b4f9c707e9b": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-2008] [FLINK-2296] Fix checkpoint committing & KafkaITCase\n\nThis closes #895\n",
			"commitDate": "2015-07-13, 9:54 AM",
			"commitName": "aa5e5b3087a68f2aac792c0b0fc64b4f9c707e9b",
			"commitAuthor": "Robert Metzger",
			"commitDateOld": "2015-06-25, 8:38 AM",
			"commitNameOld": "0ecab82add0946503a000162813bb820f6f3b4d4",
			"commitAuthorOld": "Paris Carbone",
			"daysBetweenCommits": 18.05,
			"commitsBetweenForRepo": 73,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,79 +1,76 @@\n \tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n \t\tif (shutdown || message == null) {\n \t\t\treturn;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn;\n \t\t}\n \t\t\n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tSuccessfulCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t\n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n \t\t\t\n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n \t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n \n \t\t\t\t\t\tcompleted = checkpoint.toCompletedCheckpoint();\n \t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n \t\t\t\t\t\tif (completedCheckpoints.size() > numSuccessfulCheckpointsToRetain) {\n \t\t\t\t\t\t\tcompletedCheckpoints.removeFirst().discard(userClassLoader);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \t\t\t\t\t\t\n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \t\t\t\n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tExecutionAttemptID attemptId = ee.getAttemptId();\n-\t\t\t\t\tStateForTask stateForTask = completed.getState(ev.getJobvertexId());\n-\t\t\t\t\tSerializedValue<StateHandle<?>> taskState = (stateForTask != null) ? stateForTask.getState() : null;\n-\t\t\t\t\tConfirmCheckpoint confirmMessage = new ConfirmCheckpoint(job, attemptId, checkpointId, \n-\t\t\t\t\t\t\ttimestamp, taskState);\n-\t\t\t\t\tev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n+\t\t\t\t\tNotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n+\t\t\t\t\tev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0ecab82add0946503a000162813bb820f6f3b4d4": {
			"type": "Ybodychange",
			"commitMessage": "[streaming] fix for null state in ConfirmCheckpoint messages\n",
			"commitDate": "2015-06-25, 8:38 AM",
			"commitName": "0ecab82add0946503a000162813bb820f6f3b4d4",
			"commitAuthor": "Paris Carbone",
			"commitDateOld": "2015-06-25, 8:38 AM",
			"commitNameOld": "f27c3f1d1cbff7433a23227e75f2f8e30058397a",
			"commitAuthorOld": "Paris Carbone",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,77 +1,79 @@\n \tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n \t\tif (shutdown || message == null) {\n \t\t\treturn;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn;\n \t\t}\n \t\t\n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tSuccessfulCheckpoint completed = null;\n \t\tPendingCheckpoint checkpoint;\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t\n \t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n \t\t\t\n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n \t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n \n \t\t\t\t\t\tcompleted = checkpoint.toCompletedCheckpoint();\n \t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n \t\t\t\t\t\tif (completedCheckpoints.size() > numSuccessfulCheckpointsToRetain) {\n \t\t\t\t\t\t\tcompletedCheckpoints.removeFirst().discard(userClassLoader);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \t\t\t\t\t\t\n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \t\t\t\n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tExecutionAttemptID attemptId = ee.getAttemptId();\n+\t\t\t\t\tStateForTask stateForTask = completed.getState(ev.getJobvertexId());\n+\t\t\t\t\tSerializedValue<StateHandle<?>> taskState = (stateForTask != null) ? stateForTask.getState() : null;\n \t\t\t\t\tConfirmCheckpoint confirmMessage = new ConfirmCheckpoint(job, attemptId, checkpointId, \n-\t\t\t\t\t\t\ttimestamp, completed.getState(ev.getJobvertexId()).getState() );\n+\t\t\t\t\t\t\ttimestamp, taskState);\n \t\t\t\t\tev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f27c3f1d1cbff7433a23227e75f2f8e30058397a": {
			"type": "Ybodychange",
			"commitMessage": "[streaming] Add stateHandle to checkpointed message\n",
			"commitDate": "2015-06-25, 8:38 AM",
			"commitName": "f27c3f1d1cbff7433a23227e75f2f8e30058397a",
			"commitAuthor": "Paris Carbone",
			"commitDateOld": "2015-06-12, 1:54 AM",
			"commitNameOld": "078e6ef3ef0d455d6f405c21c1ca209b80418a23",
			"commitAuthorOld": "mbalassi",
			"daysBetweenCommits": 13.28,
			"commitsBetweenForRepo": 59,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,77 @@\n \tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n \t\tif (shutdown || message == null) {\n \t\t\treturn;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn;\n \t\t}\n \t\t\n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tSuccessfulCheckpoint completed = null;\n-\t\t\n+\t\tPendingCheckpoint checkpoint;\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t\n-\t\t\tPendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId);\n+\t\t\tcheckpoint = pendingCheckpoints.get(checkpointId);\n+\t\t\t\n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n \t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n \n \t\t\t\t\t\tcompleted = checkpoint.toCompletedCheckpoint();\n \t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n \t\t\t\t\t\tif (completedCheckpoints.size() > numSuccessfulCheckpointsToRetain) {\n \t\t\t\t\t\t\tcompletedCheckpoints.removeFirst().discard(userClassLoader);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \t\t\t\t\t\t\n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n+\t\t\t\n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tExecutionAttemptID attemptId = ee.getAttemptId();\n-\t\t\t\t\tConfirmCheckpoint confirmMessage = new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp);\n+\t\t\t\t\tConfirmCheckpoint confirmMessage = new ConfirmCheckpoint(job, attemptId, checkpointId, \n+\t\t\t\t\t\t\ttimestamp, completed.getState(ev.getJobvertexId()).getState() );\n \t\t\t\t\tev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"197cd6cf0fb10efc6badd5fc8584f4b36b09e705": {
			"type": "Ybodychange",
			"commitMessage": "[streaming] StateHandleProvider added for configurable state backend\n",
			"commitDate": "2015-05-19, 10:32 AM",
			"commitName": "197cd6cf0fb10efc6badd5fc8584f4b36b09e705",
			"commitAuthor": "Gyula Fora",
			"commitDateOld": "2015-05-19, 10:25 AM",
			"commitNameOld": "59bee4ad825d7252c791e0376ea2504602134fe7",
			"commitAuthorOld": "Gyula Fora",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,74 @@\n \tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n \t\tif (shutdown || message == null) {\n \t\t\treturn;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn;\n \t\t}\n \t\t\n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tSuccessfulCheckpoint completed = null;\n \t\t\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t\n \t\t\tPendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId);\n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n \t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n \n \t\t\t\t\t\tcompleted = checkpoint.toCompletedCheckpoint();\n \t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n \t\t\t\t\t\tif (completedCheckpoints.size() > numSuccessfulCheckpointsToRetain) {\n-\t\t\t\t\t\t\tcompletedCheckpoints.removeFirst().dispose(userClassLoader);;\n+\t\t\t\t\t\t\tcompletedCheckpoints.removeFirst().discard(userClassLoader);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \t\t\t\t\t\t\n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tExecutionAttemptID attemptId = ee.getAttemptId();\n \t\t\t\t\tConfirmCheckpoint confirmMessage = new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"59bee4ad825d7252c791e0376ea2504602134fe7": {
			"type": "Ybodychange",
			"commitMessage": "[streaming] Discard method added to state handle\n",
			"commitDate": "2015-05-19, 10:25 AM",
			"commitName": "59bee4ad825d7252c791e0376ea2504602134fe7",
			"commitAuthor": "Gyula Fora",
			"commitDateOld": "2015-05-12, 1:35 PM",
			"commitNameOld": "54e957614c38fed69baf726fc86059e9b11384cb",
			"commitAuthorOld": "Robert Metzger",
			"daysBetweenCommits": 6.87,
			"commitsBetweenForRepo": 37,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,74 @@\n \tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n \t\tif (shutdown || message == null) {\n \t\t\treturn;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn;\n \t\t}\n \t\t\n \t\tfinal long checkpointId = message.getCheckpointId();\n \n \t\tSuccessfulCheckpoint completed = null;\n \t\t\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t\n \t\t\tPendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId);\n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n \t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n \n \t\t\t\t\t\tcompleted = checkpoint.toCompletedCheckpoint();\n \t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n \t\t\t\t\t\tif (completedCheckpoints.size() > numSuccessfulCheckpointsToRetain) {\n-\t\t\t\t\t\t\tcompletedCheckpoints.removeFirst();\n+\t\t\t\t\t\t\tcompletedCheckpoints.removeFirst().dispose(userClassLoader);;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \t\t\t\t\t\t\n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n \t\tif (completed != null) {\n \t\t\tfinal long timestamp = completed.getTimestamp();\n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tExecutionAttemptID attemptId = ee.getAttemptId();\n \t\t\t\t\tConfirmCheckpoint confirmMessage = new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9b7f8aa121e4a231632296d0809029aca9ebde6a": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-1953] [runtime] Integrate new snapshot checkpoint coordinator with jobgraph and execution graph\n\nThis closes #651\n",
			"commitDate": "2015-05-12, 1:35 PM",
			"commitName": "9b7f8aa121e4a231632296d0809029aca9ebde6a",
			"commitAuthor": "Stephan Ewen",
			"commitDateOld": "2015-04-29, 2:47 AM",
			"commitNameOld": "7f0ce1428bc32181d6d79ca6f1226b9e2e3d93be",
			"commitAuthorOld": "Stephan Ewen",
			"daysBetweenCommits": 13.45,
			"commitsBetweenForRepo": 56,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,74 @@\n \tpublic void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n \t\tif (shutdown || message == null) {\n \t\t\treturn;\n \t\t}\n \t\tif (!job.equals(message.getJob())) {\n \t\t\tLOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n \t\t\treturn;\n \t\t}\n \t\t\n \t\tfinal long checkpointId = message.getCheckpointId();\n-\t\tboolean checkpointCompleted = false;\n+\n+\t\tSuccessfulCheckpoint completed = null;\n \t\t\n \t\tsynchronized (lock) {\n \t\t\t// we need to check inside the lock for being shutdown as well, otherwise we\n \t\t\t// get races and invalid error log messages\n \t\t\tif (shutdown) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t\n \t\t\tPendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId);\n \t\t\tif (checkpoint != null && !checkpoint.isDiscarded()) {\n \t\t\t\tif (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n \t\t\t\t\t\n \t\t\t\t\tif (checkpoint.isFullyAcknowledged()) {\n \t\t\t\t\t\tLOG.info(\"Completed checkpoint \" + checkpointId);\n \n-\t\t\t\t\t\tSuccessfulCheckpoint completed = checkpoint.toCompletedCheckpoint();\n+\t\t\t\t\t\tcompleted = checkpoint.toCompletedCheckpoint();\n \t\t\t\t\t\tcompletedCheckpoints.addLast(completed);\n \t\t\t\t\t\tif (completedCheckpoints.size() > numSuccessfulCheckpointsToRetain) {\n \t\t\t\t\t\t\tcompletedCheckpoints.removeFirst();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tpendingCheckpoints.remove(checkpointId);\n \t\t\t\t\t\trememberRecentCheckpointId(checkpointId);\n \t\t\t\t\t\t\n \t\t\t\t\t\tdropSubsumedCheckpoints(completed.getTimestamp());\n-\t\t\t\t\t\t\n-\t\t\t\t\t\tcheckpointCompleted = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// checkpoint did not accept message\n \t\t\t\t\tLOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId\n \t\t\t\t\t\t\t+ \" , task \" + message.getTaskExecutionId());\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (checkpoint != null) {\n \t\t\t\t// this should not happen\n \t\t\t\tthrow new IllegalStateException(\n \t\t\t\t\t\t\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n \t\t\t\tif (recentPendingCheckpoints.contains(checkpointId)) {\n \t\t\t\t\tLOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tLOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// send the confirmation messages to the necessary targets. we do this here\n \t\t// to be outside the lock scope\n-\t\tif (checkpointCompleted) {\n+\t\tif (completed != null) {\n+\t\t\tfinal long timestamp = completed.getTimestamp();\n \t\t\tfor (ExecutionVertex ev : tasksToCommitTo) {\n \t\t\t\tExecution ee = ev.getCurrentExecutionAttempt();\n \t\t\t\tif (ee != null) {\n \t\t\t\t\tExecutionAttemptID attemptId = ee.getAttemptId();\n-\t\t\t\t\tConfirmCheckpoint confirmMessage = new ConfirmCheckpoint(job, attemptId, checkpointId);\n+\t\t\t\t\tConfirmCheckpoint confirmMessage = new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp);\n \t\t\t\t\tev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7f0ce1428bc32181d6d79ca6f1226b9e2e3d93be": {
			"type": "Yintroduced",
			"commitMessage": "[FLINK-1953] [runtime] Implement robust and flexible checkpoint coordinator with tests.\n\n - Checkpoints can be configured to have different sets of tasks\n   that triggering the checkpoint barriers, that acknowledging the checkpoint,\n   and that require checkpoint confirmations.\n\n - A configurable number of successful chckpoints can be retained\n\n - Checkpoints time out after a certain time, if not acknowledged (prevent resource leaks)\n\n - Checkpoints are robust to lost messages and out of order acknowledging.\n",
			"commitDate": "2015-04-29, 2:47 AM",
			"commitName": "7f0ce1428bc32181d6d79ca6f1226b9e2e3d93be",
			"commitAuthor": "Stephan Ewen"
		}
	},
	"sha": "9e936a5f8198b0059e9b5fba33163c2bbe3efbdd"
}