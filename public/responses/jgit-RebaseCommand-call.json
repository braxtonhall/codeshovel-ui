{
	"repo": "https://github.com/eclipse/jgit.git",
	"file": "org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java",
	"method": {
		"longName": "RebaseCommand::call()",
		"startLine": 263,
		"methodName": "call",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"26c5d0e56a8c5adb2c93cda45e25175363798516": {
			"type": "Ybodychange",
			"commitMessage": "RebaseCommand: Remove unnecessary fall through comments\n\nIt's easier to read a list of cases\n\n\tcase A:\n\tcase B:\n\tcase C:\n\t\t... do something ...;\n\t\tbreak;\n\nwithout intervening \"// fall through\" lines separating the cases.\n\nThis also makes it clearer that JGit uses \"$FALL-THROUGH$\", not \"fall\nthrough\", to suppress fallthrough warnings in switch statements.\nEclipse does not pay attention to the second comment style.\n\nChange-Id: I5279a727aee2868854d06bfcaac8cb8186b4299e\nSigned-off-by: Jonathan Nieder <jrn@google.com>\n",
			"commitDate": "2018-08-04, 3:04 PM",
			"commitName": "26c5d0e56a8c5adb2c93cda45e25175363798516",
			"commitAuthor": "Jonathan Nieder",
			"commitDateOld": "2018-03-13, 3:16 PM",
			"commitNameOld": "5c70be00856d5375485e6f062b6e1e09a606601f",
			"commitAuthorOld": "David Pursehouse",
			"daysBetweenCommits": 143.99,
			"commitsBetweenForRepo": 211,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,119 +1,117 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tnewHead = null;\n \t\tlastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n-\t\t\t\t// fall through\n \t\t\tcase SKIP:\n-\t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId = rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName = rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName = upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tpreserveMerges = rebaseState.getRewrittenDir().exists();\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tautoStash();\n \t\t\t\tif (stopAfterInitialization\n \t\t\t\t\t\t|| !walk.isMergedInto(\n \t\t\t\t\t\t\t\twalk.parseCommit(repo.resolve(Constants.HEAD)),\n \t\t\t\t\t\t\t\tupstreamCommit)) {\n \t\t\t\t\torg.eclipse.jgit.api.Status status = Git.wrap(repo)\n \t\t\t\t\t\t\t.status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n \t\t\t\t\tif (status.hasUncommittedChanges()) {\n \t\t\t\t\t\tList<String> list = new ArrayList<>();\n \t\t\t\t\t\tlist.addAll(status.getUncommittedChanges());\n \t\t\t\t\t\treturn RebaseResult.uncommittedChanges(list);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res != null) {\n \t\t\t\t\tautoStashApply();\n \t\t\t\t\tif (rebaseState.getDir().exists())\n \t\t\t\t\t\tFileUtils.delete(rebaseState.getDir(),\n \t\t\t\t\t\t\t\tFileUtils.RECURSIVE);\n \t\t\t\t\treturn res;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \t\t\t\tList<RebaseTodoLine> doneLines = repo.readRebaseTodo(\n \t\t\t\t\t\trebaseState.getPath(DONE), true);\n \t\t\t\tRebaseTodoLine step = doneLines.get(doneLines.size() - 1);\n \t\t\t\tif (newHead != null\n \t\t\t\t\t\t&& step.getAction() != Action.PICK) {\n \t\t\t\t\tRebaseTodoLine newStep = new RebaseTodoLine(\n \t\t\t\t\t\t\tstep.getAction(),\n \t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n \t\t\t\t\t\t\tstep.getShortMessage());\n \t\t\t\t\tRebaseResult result = processStep(newStep, false);\n \t\t\t\t\tif (result != null)\n \t\t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t\tFile amendFile = rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists = amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead == null && !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tList<RebaseTodoLine> steps = repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (steps.size() == 0) {\n \t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n \t\t\t}\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i = 0; i < steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step = steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tRebaseResult result = processStep(step, true);\n \t\t\t\tif (result != null) {\n \t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn finishRebase(newHead, lastStepWasForward);\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": {
			"type": "Ybodychange",
			"commitMessage": "Enable and fix warnings about redundant specification of type arguments\n\nSince the introduction of generic type parameter inference in Java 7,\nit's not necessary to explicitly specify the type of generic parameters.\n\nEnable the warning in Eclipse, and fix all occurrences.\n\nChange-Id: I9158caf1beca5e4980b6240ac401f3868520aad0\nSigned-off-by: David Pursehouse <david.pursehouse@gmail.com>\n",
			"commitDate": "2017-02-20, 2:47 PM",
			"commitName": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
			"commitAuthor": "David Pursehouse",
			"commitDateOld": "2017-02-19, 5:05 PM",
			"commitNameOld": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
			"commitAuthorOld": "David Pursehouse",
			"daysBetweenCommits": 0.9,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,119 +1,119 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tnewHead = null;\n \t\tlastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId = rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName = rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName = upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tpreserveMerges = rebaseState.getRewrittenDir().exists();\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tautoStash();\n \t\t\t\tif (stopAfterInitialization\n \t\t\t\t\t\t|| !walk.isMergedInto(\n \t\t\t\t\t\t\t\twalk.parseCommit(repo.resolve(Constants.HEAD)),\n \t\t\t\t\t\t\t\tupstreamCommit)) {\n \t\t\t\t\torg.eclipse.jgit.api.Status status = Git.wrap(repo)\n \t\t\t\t\t\t\t.status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n \t\t\t\t\tif (status.hasUncommittedChanges()) {\n-\t\t\t\t\t\tList<String> list = new ArrayList<String>();\n+\t\t\t\t\t\tList<String> list = new ArrayList<>();\n \t\t\t\t\t\tlist.addAll(status.getUncommittedChanges());\n \t\t\t\t\t\treturn RebaseResult.uncommittedChanges(list);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res != null) {\n \t\t\t\t\tautoStashApply();\n \t\t\t\t\tif (rebaseState.getDir().exists())\n \t\t\t\t\t\tFileUtils.delete(rebaseState.getDir(),\n \t\t\t\t\t\t\t\tFileUtils.RECURSIVE);\n \t\t\t\t\treturn res;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \t\t\t\tList<RebaseTodoLine> doneLines = repo.readRebaseTodo(\n \t\t\t\t\t\trebaseState.getPath(DONE), true);\n \t\t\t\tRebaseTodoLine step = doneLines.get(doneLines.size() - 1);\n \t\t\t\tif (newHead != null\n \t\t\t\t\t\t&& step.getAction() != Action.PICK) {\n \t\t\t\t\tRebaseTodoLine newStep = new RebaseTodoLine(\n \t\t\t\t\t\t\tstep.getAction(),\n \t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n \t\t\t\t\t\t\tstep.getShortMessage());\n \t\t\t\t\tRebaseResult result = processStep(newStep, false);\n \t\t\t\t\tif (result != null)\n \t\t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t\tFile amendFile = rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists = amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead == null && !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tList<RebaseTodoLine> steps = repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (steps.size() == 0) {\n \t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n \t\t\t}\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i = 0; i < steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step = steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tRebaseResult result = processStep(step, true);\n \t\t\t\tif (result != null) {\n \t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn finishRebase(newHead, lastStepWasForward);\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6f0b92ff22ff58a4c8eb9de8d9b3281d77852070": {
			"type": "Ybodychange",
			"commitMessage": "RebaseCommand should ignore submodule modifications\n\nBefore a rebase happens the RebaseCommand checks that the working tree\nis clean. We don't want to start a rebase on a dirty working tree. If\nthe working tree is dirty a rebase should not be allowed. But\nRebaseCommand should ignore modifications done to submodules. E.g. if a\nsubmodules HEAD points to <x> but the root repository has in index that\nthe submodule should point to <y> then this should not prohibit a\nrebase. Also native git allows a rebase in this case. Since jgit's\nStatusCommand has learned to ignore submodule changes this is now used\nby the RebaseCommand to determine the repository state correctly.\n\nBug: 446922\nChange-Id: I487bf7484dca3f5501e6e514584e2871524eea19\n",
			"commitDate": "2014-11-03, 2:32 AM",
			"commitName": "6f0b92ff22ff58a4c8eb9de8d9b3281d77852070",
			"commitAuthor": "Christian Halstrick",
			"commitDateOld": "2014-09-04, 3:35 AM",
			"commitNameOld": "2f6372337cfd5944e2179f5ec5e2dbe0cbc96386",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 60,
			"commitsBetweenForRepo": 41,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,119 +1,119 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tnewHead = null;\n \t\tlastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId = rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName = rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName = upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tpreserveMerges = rebaseState.getRewrittenDir().exists();\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tautoStash();\n \t\t\t\tif (stopAfterInitialization\n \t\t\t\t\t\t|| !walk.isMergedInto(\n \t\t\t\t\t\t\t\twalk.parseCommit(repo.resolve(Constants.HEAD)),\n \t\t\t\t\t\t\t\tupstreamCommit)) {\n \t\t\t\t\torg.eclipse.jgit.api.Status status = Git.wrap(repo)\n-\t\t\t\t\t\t\t.status().call();\n+\t\t\t\t\t\t\t.status().setIgnoreSubmodules(IgnoreSubmoduleMode.ALL).call();\n \t\t\t\t\tif (status.hasUncommittedChanges()) {\n \t\t\t\t\t\tList<String> list = new ArrayList<String>();\n \t\t\t\t\t\tlist.addAll(status.getUncommittedChanges());\n \t\t\t\t\t\treturn RebaseResult.uncommittedChanges(list);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res != null) {\n \t\t\t\t\tautoStashApply();\n \t\t\t\t\tif (rebaseState.getDir().exists())\n \t\t\t\t\t\tFileUtils.delete(rebaseState.getDir(),\n \t\t\t\t\t\t\t\tFileUtils.RECURSIVE);\n \t\t\t\t\treturn res;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \t\t\t\tList<RebaseTodoLine> doneLines = repo.readRebaseTodo(\n \t\t\t\t\t\trebaseState.getPath(DONE), true);\n \t\t\t\tRebaseTodoLine step = doneLines.get(doneLines.size() - 1);\n \t\t\t\tif (newHead != null\n \t\t\t\t\t\t&& step.getAction() != Action.PICK) {\n \t\t\t\t\tRebaseTodoLine newStep = new RebaseTodoLine(\n \t\t\t\t\t\t\tstep.getAction(),\n \t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n \t\t\t\t\t\t\tstep.getShortMessage());\n \t\t\t\t\tRebaseResult result = processStep(newStep, false);\n \t\t\t\t\tif (result != null)\n \t\t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t\tFile amendFile = rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists = amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead == null && !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tList<RebaseTodoLine> steps = repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (steps.size() == 0) {\n \t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n \t\t\t}\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i = 0; i < steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step = steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tRebaseResult result = processStep(step, true);\n \t\t\t\tif (result != null) {\n \t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn finishRebase(newHead, lastStepWasForward);\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e0fbae5dc3fc2345383ec373b384fcca10e64f24": {
			"type": "Ybodychange",
			"commitMessage": "Rebase: Add --preserve-merges support\n\nWith --preserve-merges C Git re-does merges using the rewritten merge\nparents, discarding the old merge commit. For the common use-case of\npull with rebase this is unfortunate, as it loses the merge conflict\nresolution (and other fixes in the merge), which may have taken quite\nsome time to get right in the first place.\n\nTo overcome this we use a two-fold approach:\nIf any of the (non-first) merge parents of a merge were rewritten, we\nalso redo the merge, to include the (potential) new changes in those\ncommits.\nIf only the first parent was rewritten, i.e. we are merging a branch\nthat is otherwise unaffected by the rebase, we instead cherry-pick the\nmerge commit at hand. This is done with the --mainline 1 and --no-commit\noptions to apply the changes introduced by the merge. Then we set up an\nappropriate MERGE_HEAD and commit the result, thus effectively forging a\nmerge.\n\nApart from the approach taken to rebase merge commits, this\nimplementation closely follows C Git. As a result, both Git\nimplementations can continue rebases of each other.\n\nPreserving merges works for both interactive and non-interactive rebase,\nbut as in C Git it is easy do get undesired outcomes with interactive\nrebase.\n\nCommitCommand supports committing merges during rebase now.\n\nBug: 439421\nChange-Id: I4cf69b9d4ec6109d130ab8e3f42fcbdac25a13b2\nSigned-off-by: Konrad Kügler <swamblumat-eclipsebugs@yahoo.de>\n",
			"commitDate": "2014-07-15, 5:00 PM",
			"commitName": "e0fbae5dc3fc2345383ec373b384fcca10e64f24",
			"commitAuthor": "Konrad Kügler",
			"commitDateOld": "2014-05-16, 1:01 AM",
			"commitNameOld": "1350d27e904f7e016dd33cff01686e527b0d26ad",
			"commitAuthorOld": "Konrad Kügler",
			"daysBetweenCommits": 60.67,
			"commitsBetweenForRepo": 66,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,118 +1,119 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tnewHead = null;\n \t\tlastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId = rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName = rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName = upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n+\t\t\t\tpreserveMerges = rebaseState.getRewrittenDir().exists();\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tautoStash();\n \t\t\t\tif (stopAfterInitialization\n \t\t\t\t\t\t|| !walk.isMergedInto(\n \t\t\t\t\t\t\t\twalk.parseCommit(repo.resolve(Constants.HEAD)),\n \t\t\t\t\t\t\t\tupstreamCommit)) {\n \t\t\t\t\torg.eclipse.jgit.api.Status status = Git.wrap(repo)\n \t\t\t\t\t\t\t.status().call();\n \t\t\t\t\tif (status.hasUncommittedChanges()) {\n \t\t\t\t\t\tList<String> list = new ArrayList<String>();\n \t\t\t\t\t\tlist.addAll(status.getUncommittedChanges());\n \t\t\t\t\t\treturn RebaseResult.uncommittedChanges(list);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res != null) {\n \t\t\t\t\tautoStashApply();\n \t\t\t\t\tif (rebaseState.getDir().exists())\n \t\t\t\t\t\tFileUtils.delete(rebaseState.getDir(),\n \t\t\t\t\t\t\t\tFileUtils.RECURSIVE);\n \t\t\t\t\treturn res;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \t\t\t\tList<RebaseTodoLine> doneLines = repo.readRebaseTodo(\n \t\t\t\t\t\trebaseState.getPath(DONE), true);\n \t\t\t\tRebaseTodoLine step = doneLines.get(doneLines.size() - 1);\n \t\t\t\tif (newHead != null\n \t\t\t\t\t\t&& step.getAction() != Action.PICK) {\n \t\t\t\t\tRebaseTodoLine newStep = new RebaseTodoLine(\n \t\t\t\t\t\t\tstep.getAction(),\n \t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n \t\t\t\t\t\t\tstep.getShortMessage());\n \t\t\t\t\tRebaseResult result = processStep(newStep, false);\n \t\t\t\t\tif (result != null)\n \t\t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t\tFile amendFile = rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists = amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead == null && !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tList<RebaseTodoLine> steps = repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (steps.size() == 0) {\n \t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n \t\t\t}\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i = 0; i < steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step = steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tRebaseResult result = processStep(step, true);\n \t\t\t\tif (result != null) {\n \t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn finishRebase(newHead, lastStepWasForward);\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3db6e05e52b24e16fbe93376d3fd8935e5f4fc9b": {
			"type": "Ybodychange",
			"commitMessage": "Fix fast forward rebase with rebase.autostash=true\n\nThe folder .git/rebase-merge was not removed in this case. The\nrepository was then still in rebase state, but neither abort nor\ncontinue worked.\n\nBug: 425742\nChange-Id: I43cea6c9e5f3cef9d6b15643722fddecb40632d9\n",
			"commitDate": "2014-01-15, 5:23 AM",
			"commitName": "3db6e05e52b24e16fbe93376d3fd8935e5f4fc9b",
			"commitAuthor": "Stefan Lay",
			"commitDateOld": "2013-12-10, 7:54 AM",
			"commitNameOld": "e90438c0e867bd105334b75df3a6d640ef8dab01",
			"commitAuthorOld": "Stefan Lay",
			"daysBetweenCommits": 35.9,
			"commitsBetweenForRepo": 21,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,115 +1,118 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tnewHead = null;\n \t\tlastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId = rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName = rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName = upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tautoStash();\n \t\t\t\tif (stopAfterInitialization\n \t\t\t\t\t\t|| !walk.isMergedInto(\n \t\t\t\t\t\t\t\twalk.parseCommit(repo.resolve(Constants.HEAD)),\n \t\t\t\t\t\t\t\tupstreamCommit)) {\n \t\t\t\t\torg.eclipse.jgit.api.Status status = Git.wrap(repo)\n \t\t\t\t\t\t\t.status().call();\n \t\t\t\t\tif (status.hasUncommittedChanges()) {\n \t\t\t\t\t\tList<String> list = new ArrayList<String>();\n \t\t\t\t\t\tlist.addAll(status.getUncommittedChanges());\n \t\t\t\t\t\treturn RebaseResult.uncommittedChanges(list);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res != null) {\n \t\t\t\t\tautoStashApply();\n+\t\t\t\t\tif (rebaseState.getDir().exists())\n+\t\t\t\t\t\tFileUtils.delete(rebaseState.getDir(),\n+\t\t\t\t\t\t\t\tFileUtils.RECURSIVE);\n \t\t\t\t\treturn res;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \t\t\t\tList<RebaseTodoLine> doneLines = repo.readRebaseTodo(\n \t\t\t\t\t\trebaseState.getPath(DONE), true);\n \t\t\t\tRebaseTodoLine step = doneLines.get(doneLines.size() - 1);\n \t\t\t\tif (newHead != null\n \t\t\t\t\t\t&& step.getAction() != Action.PICK) {\n \t\t\t\t\tRebaseTodoLine newStep = new RebaseTodoLine(\n \t\t\t\t\t\t\tstep.getAction(),\n \t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n \t\t\t\t\t\t\tstep.getShortMessage());\n \t\t\t\t\tRebaseResult result = processStep(newStep, false);\n \t\t\t\t\tif (result != null)\n \t\t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t\tFile amendFile = rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists = amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead == null && !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tList<RebaseTodoLine> steps = repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (steps.size() == 0) {\n \t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n \t\t\t}\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i = 0; i < steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step = steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tRebaseResult result = processStep(step, true);\n \t\t\t\tif (result != null) {\n \t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn finishRebase(newHead, lastStepWasForward);\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f86a488e32906593903acb31a93a82bed8d87915": {
			"type": "Ybodychange",
			"commitMessage": "Implement rebase.autostash\n\nThis feature was introduced in native git with version 1.8.4.\n\nBug: 422951\nChange-Id: I42f194174d64d7ada6631e2156c2a7bf93b5e91c\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2013-12-04, 2:02 PM",
			"commitName": "f86a488e32906593903acb31a93a82bed8d87915",
			"commitAuthor": "Stefan Lay",
			"commitDateOld": "2013-12-02, 1:45 AM",
			"commitNameOld": "591998c2d628ec4f6309caea826fab16a6de2adc",
			"commitAuthorOld": "Stefan Lay",
			"daysBetweenCommits": 2.51,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,112 +1,115 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tnewHead = null;\n \t\tlastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId = rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName = rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName = upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n+\t\t\t\tautoStash();\n \t\t\t\tif (stopAfterInitialization\n \t\t\t\t\t\t|| !walk.isMergedInto(\n \t\t\t\t\t\t\t\twalk.parseCommit(repo.resolve(Constants.HEAD)),\n \t\t\t\t\t\t\t\tupstreamCommit)) {\n \t\t\t\t\torg.eclipse.jgit.api.Status status = Git.wrap(repo)\n \t\t\t\t\t\t\t.status().call();\n \t\t\t\t\tif (status.hasUncommittedChanges()) {\n \t\t\t\t\t\tList<String> list = new ArrayList<String>();\n \t\t\t\t\t\tlist.addAll(status.getUncommittedChanges());\n \t\t\t\t\t\treturn RebaseResult.uncommittedChanges(list);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n-\t\t\t\tif (res != null)\n+\t\t\t\tif (res != null) {\n+\t\t\t\t\tautoStashApply();\n \t\t\t\t\treturn res;\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \t\t\t\tList<RebaseTodoLine> doneLines = repo.readRebaseTodo(\n \t\t\t\t\t\trebaseState.getPath(DONE), true);\n \t\t\t\tRebaseTodoLine step = doneLines.get(doneLines.size() - 1);\n \t\t\t\tif (newHead != null\n \t\t\t\t\t\t&& step.getAction() != Action.PICK) {\n \t\t\t\t\tRebaseTodoLine newStep = new RebaseTodoLine(\n \t\t\t\t\t\t\tstep.getAction(),\n \t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n \t\t\t\t\t\t\tstep.getShortMessage());\n \t\t\t\t\tRebaseResult result = processStep(newStep, false);\n \t\t\t\t\tif (result != null)\n \t\t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t\tFile amendFile = rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists = amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead == null && !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tList<RebaseTodoLine> steps = repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (steps.size() == 0) {\n \t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n \t\t\t}\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i = 0; i < steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step = steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tRebaseResult result = processStep(step, true);\n \t\t\t\tif (result != null) {\n \t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn finishRebase(newHead, lastStepWasForward);\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"591998c2d628ec4f6309caea826fab16a6de2adc": {
			"type": "Ybodychange",
			"commitMessage": "Do not allow non-ff-rebase if there are uncommitted changes\n\nWith this change jgit checks for uncommitted changes before a rebase is\nstarted. This is also done by native git. One reason is that an abort\nwould override such changes. The check is skipped for a non-interactive\nrebase when it will result in a fast-forward. In this case there can be\nonly checkout conflicts but no merge conflicts, so there cannot be an\nabort which overrides uncommitted changes.\n\nBug: 422352\nChange-Id: I1e0b59b2a4d80a686b67a6729e441924362b1236\nSigned-off-by: Stefan Lay <stefan.lay@sap.com>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2013-12-02, 1:45 AM",
			"commitName": "591998c2d628ec4f6309caea826fab16a6de2adc",
			"commitAuthor": "Stefan Lay",
			"commitDateOld": "2013-11-29, 1:34 AM",
			"commitNameOld": "ec0d78d0939ee8ce30bd349bd885186c13d3b645",
			"commitAuthorOld": "Stefan Lay",
			"daysBetweenCommits": 3.01,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,100 +1,112 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tnewHead = null;\n \t\tlastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId = rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName = rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName = upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n+\t\t\t\tif (stopAfterInitialization\n+\t\t\t\t\t\t|| !walk.isMergedInto(\n+\t\t\t\t\t\t\t\twalk.parseCommit(repo.resolve(Constants.HEAD)),\n+\t\t\t\t\t\t\t\tupstreamCommit)) {\n+\t\t\t\t\torg.eclipse.jgit.api.Status status = Git.wrap(repo)\n+\t\t\t\t\t\t\t.status().call();\n+\t\t\t\t\tif (status.hasUncommittedChanges()) {\n+\t\t\t\t\t\tList<String> list = new ArrayList<String>();\n+\t\t\t\t\t\tlist.addAll(status.getUncommittedChanges());\n+\t\t\t\t\t\treturn RebaseResult.uncommittedChanges(list);\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \t\t\t\tList<RebaseTodoLine> doneLines = repo.readRebaseTodo(\n \t\t\t\t\t\trebaseState.getPath(DONE), true);\n \t\t\t\tRebaseTodoLine step = doneLines.get(doneLines.size() - 1);\n \t\t\t\tif (newHead != null\n \t\t\t\t\t\t&& step.getAction() != Action.PICK) {\n \t\t\t\t\tRebaseTodoLine newStep = new RebaseTodoLine(\n \t\t\t\t\t\t\tstep.getAction(),\n \t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n \t\t\t\t\t\t\tstep.getShortMessage());\n \t\t\t\t\tRebaseResult result = processStep(newStep, false);\n \t\t\t\t\tif (result != null)\n \t\t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t\tFile amendFile = rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists = amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead == null && !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tList<RebaseTodoLine> steps = repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (steps.size() == 0) {\n \t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n \t\t\t}\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i = 0; i < steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step = steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tRebaseResult result = processStep(step, true);\n \t\t\t\tif (result != null) {\n \t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn finishRebase(newHead, lastStepWasForward);\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ec0d78d0939ee8ce30bd349bd885186c13d3b645": {
			"type": "Ybodychange",
			"commitMessage": "Use static factory methods instead of overloaded constructors\n\nChange-Id: Ib10e0798dcfb9f1b611caec393926c95eff4c2a2\n",
			"commitDate": "2013-11-29, 1:34 AM",
			"commitName": "ec0d78d0939ee8ce30bd349bd885186c13d3b645",
			"commitAuthor": "Stefan Lay",
			"commitDateOld": "2013-11-22, 2:50 PM",
			"commitNameOld": "8339a07e8314d6a40e15252bcc736a46c0aca0ea",
			"commitAuthorOld": "Stefan Lay",
			"daysBetweenCommits": 6.45,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,100 +1,100 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tnewHead = null;\n \t\tlastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId = rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName = rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName = upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \t\t\t\tList<RebaseTodoLine> doneLines = repo.readRebaseTodo(\n \t\t\t\t\t\trebaseState.getPath(DONE), true);\n \t\t\t\tRebaseTodoLine step = doneLines.get(doneLines.size() - 1);\n \t\t\t\tif (newHead != null\n \t\t\t\t\t\t&& step.getAction() != Action.PICK) {\n \t\t\t\t\tRebaseTodoLine newStep = new RebaseTodoLine(\n \t\t\t\t\t\t\tstep.getAction(),\n \t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n \t\t\t\t\t\t\tstep.getShortMessage());\n \t\t\t\t\tRebaseResult result = processStep(newStep, false);\n \t\t\t\t\tif (result != null)\n \t\t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t\tFile amendFile = rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists = amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead == null && !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tList<RebaseTodoLine> steps = repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (steps.size() == 0) {\n \t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n \t\t\t}\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i = 0; i < steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step = steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tRebaseResult result = processStep(step, true);\n \t\t\t\tif (result != null) {\n \t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn finishRebase(newHead, lastStepWasForward);\n \t\t} catch (CheckoutConflictException cce) {\n-\t\t\treturn new RebaseResult(cce.getConflictingPaths());\n+\t\t\treturn RebaseResult.conflicts(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"979e3467112618cc787e161097986212eaaa4533": {
			"type": "Ybodychange",
			"commitMessage": "Interactive Rebase: Do actions if there were conflicts\n\nIf a commit was marked for edit, reword, squash or fixup, but the\ninteractive rebase stopped because of a conflict, the step was not done\nafter conflict resolution. This is done now.\n\nChange-Id: If8e7ccc50469165744f2b8a53d180f9ba0f72330\nSigned-off-by: Stefan Lay <stefan.lay@sap.com>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2013-11-08, 3:43 PM",
			"commitName": "979e3467112618cc787e161097986212eaaa4533",
			"commitAuthor": "Stefan Lay",
			"commitDateOld": "2013-11-06, 1:43 AM",
			"commitNameOld": "18069ffe8cbede40cf2524922c262b67656e7021",
			"commitAuthorOld": "Stefan Lay",
			"daysBetweenCommits": 2.58,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,162 +1,100 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n-\t\tRevCommit newHead = null;\n-\t\tboolean lastStepWasForward = false;\n+\t\tnewHead = null;\n+\t\tlastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId = rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName = rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName = upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n-\n+\t\t\t\tList<RebaseTodoLine> doneLines = repo.readRebaseTodo(\n+\t\t\t\t\t\trebaseState.getPath(DONE), true);\n+\t\t\t\tRebaseTodoLine step = doneLines.get(doneLines.size() - 1);\n+\t\t\t\tif (newHead != null\n+\t\t\t\t\t\t&& step.getAction() != Action.PICK) {\n+\t\t\t\t\tRebaseTodoLine newStep = new RebaseTodoLine(\n+\t\t\t\t\t\t\tstep.getAction(),\n+\t\t\t\t\t\t\tAbbreviatedObjectId.fromObjectId(newHead),\n+\t\t\t\t\t\t\tstep.getShortMessage());\n+\t\t\t\t\tRebaseResult result = processStep(newStep, false);\n+\t\t\t\t\tif (result != null)\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t}\n \t\t\t\tFile amendFile = rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists = amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead == null && !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n-\t\t\tObjectReader or = repo.newObjectReader();\n-\n \t\t\tList<RebaseTodoLine> steps = repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (steps.size() == 0) {\n \t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n \t\t\t}\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i = 0; i < steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step = steps.get(i);\n \t\t\t\tpopSteps(1);\n-\t\t\t\tif (Action.COMMENT.equals(step.getAction()))\n-\t\t\t\t\tcontinue;\n-\t\t\t\tCollection<ObjectId> ids = or.resolve(step.getCommit());\n-\t\t\t\tif (ids.size() != 1)\n-\t\t\t\t\tthrow new JGitInternalException(\n-\t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n-\t\t\t\tRevCommit commitToPick = walk\n-\t\t\t\t\t\t.parseCommit(ids.iterator().next());\n-\t\t\t\tif (monitor.isCancelled())\n-\t\t\t\t\treturn new RebaseResult(commitToPick, Status.STOPPED);\n-\t\t\t\ttry {\n-\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n-\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n-\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n-\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n-\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n-\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n-\t\t\t\t\t// unnecessary object rewriting\n-\t\t\t\t\tnewHead = tryFastForward(commitToPick);\n-\t\t\t\t\tlastStepWasForward = newHead != null;\n-\t\t\t\t\tif (!lastStepWasForward) {\n-\t\t\t\t\t\t// TODO if the content of this commit is already merged\n-\t\t\t\t\t\t// here we should skip this step in order to avoid\n-\t\t\t\t\t\t// confusing pseudo-changed\n-\t\t\t\t\t\tString ourCommitName = getOurCommitName();\n-\t\t\t\t\t\tCherryPickResult cherryPickResult = new Git(repo)\n-\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n-\t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName)\n-\t\t\t\t\t\t\t\t.setReflogPrefix(\"rebase:\").call(); //$NON-NLS-1$\n-\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n-\t\t\t\t\t\tcase FAILED:\n-\t\t\t\t\t\t\tif (operation == Operation.BEGIN)\n-\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n-\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n-\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t\treturn stop(commitToPick, Status.STOPPED);\n-\t\t\t\t\t\tcase CONFLICTING:\n-\t\t\t\t\t\t\treturn stop(commitToPick, Status.STOPPED);\n-\t\t\t\t\t\tcase OK:\n-\t\t\t\t\t\t\tnewHead = cherryPickResult.getNewHead();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tboolean isSquash = false;\n-\t\t\t\t\tswitch (step.getAction()) {\n-\t\t\t\t\tcase PICK:\n-\t\t\t\t\t\tcontinue; // continue rebase process on pick command\n-\t\t\t\t\tcase REWORD:\n-\t\t\t\t\t\tString oldMessage = commitToPick.getFullMessage();\n-\t\t\t\t\t\tString newMessage = interactiveHandler\n-\t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n-\t\t\t\t\t\tnewHead = new Git(repo).commit().setMessage(newMessage)\n-\t\t\t\t\t\t\t\t.setAmend(true).call();\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\tcase EDIT:\n-\t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n-\t\t\t\t\t\treturn stop(commitToPick, Status.EDIT);\n-\t\t\t\t\tcase COMMENT:\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tcase SQUASH:\n-\t\t\t\t\t\tisSquash = true;\n-\t\t\t\t\t\t//$FALL-THROUGH$\n-\t\t\t\t\tcase FIXUP:\n-\t\t\t\t\t\tresetSoftToParent();\n-\t\t\t\t\t\tRebaseTodoLine nextStep = (i >= steps.size() - 1 ? null\n-\t\t\t\t\t\t\t\t: steps.get(i + 1));\n-\t\t\t\t\t\tFile messageFixupFile = rebaseState.getFile(MESSAGE_FIXUP);\n-\t\t\t\t\t\tFile messageSquashFile = rebaseState\n-\t\t\t\t\t\t\t\t.getFile(MESSAGE_SQUASH);\n-\t\t\t\t\t\tif (isSquash && messageFixupFile.exists())\n-\t\t\t\t\t\t\t\tmessageFixupFile.delete();\n-\t\t\t\t\t\tnewHead = doSquashFixup(isSquash, commitToPick,\n-\t\t\t\t\t\t\t\tnextStep, messageFixupFile, messageSquashFile);\n-\t\t\t\t\t}\n-\t\t\t\t} finally {\n-\t\t\t\t\tmonitor.endTask();\n+\t\t\t\tRebaseResult result = processStep(step, true);\n+\t\t\t\tif (result != null) {\n+\t\t\t\t\treturn result;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn finishRebase(newHead, lastStepWasForward);\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn new RebaseResult(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"18069ffe8cbede40cf2524922c262b67656e7021": {
			"type": "Ybodychange",
			"commitMessage": "Rebase interactive should finish if last step is edit\n\nWhen the last step was an edit step, rebase interactive did not finish\nafter continuing the rebase. Instead, it returned with the status\nFAST_FORWARD.\n\nChange-Id: Ib19857474ac089dfeaae665ad5e95c66c21099b0\n",
			"commitDate": "2013-11-06, 1:43 AM",
			"commitName": "18069ffe8cbede40cf2524922c262b67656e7021",
			"commitAuthor": "Stefan Lay",
			"commitDateOld": "2013-11-05, 10:05 AM",
			"commitNameOld": "cce2561e9fe2ce1cf60182f9d95c8537ce13de92",
			"commitAuthorOld": "Stefan Lay",
			"daysBetweenCommits": 0.65,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,167 +1,162 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead = null;\n \t\tboolean lastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId = rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName = rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName = upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \n \t\t\t\tFile amendFile = rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists = amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead == null && !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n \n \t\t\tList<RebaseTodoLine> steps = repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n+\t\t\tif (steps.size() == 0) {\n+\t\t\t\treturn finishRebase(walk.parseCommit(repo.resolve(Constants.HEAD)), false);\n+\t\t\t}\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i = 0; i < steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step = steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tif (Action.COMMENT.equals(step.getAction()))\n \t\t\t\t\tcontinue;\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.getCommit());\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick, Status.STOPPED);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead = tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward = newHead != null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName = getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult = new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName)\n \t\t\t\t\t\t\t\t.setReflogPrefix(\"rebase:\").call(); //$NON-NLS-1$\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation == Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick, Status.STOPPED);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick, Status.STOPPED);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead = cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tboolean isSquash = false;\n \t\t\t\t\tswitch (step.getAction()) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage = commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage = interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead = new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tcase EDIT:\n \t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n \t\t\t\t\t\treturn stop(commitToPick, Status.EDIT);\n \t\t\t\t\tcase COMMENT:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase SQUASH:\n \t\t\t\t\t\tisSquash = true;\n \t\t\t\t\t\t//$FALL-THROUGH$\n \t\t\t\t\tcase FIXUP:\n \t\t\t\t\t\tresetSoftToParent();\n \t\t\t\t\t\tRebaseTodoLine nextStep = (i >= steps.size() - 1 ? null\n \t\t\t\t\t\t\t\t: steps.get(i + 1));\n \t\t\t\t\t\tFile messageFixupFile = rebaseState.getFile(MESSAGE_FIXUP);\n \t\t\t\t\t\tFile messageSquashFile = rebaseState\n \t\t\t\t\t\t\t\t.getFile(MESSAGE_SQUASH);\n \t\t\t\t\t\tif (isSquash && messageFixupFile.exists())\n \t\t\t\t\t\t\t\tmessageFixupFile.delete();\n \t\t\t\t\t\tnewHead = doSquashFixup(isSquash, commitToPick,\n \t\t\t\t\t\t\t\tnextStep, messageFixupFile, messageSquashFile);\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif (newHead != null) {\n-\t\t\t\tString headName = rebaseState.readFile(HEAD_NAME);\n-\t\t\t\tupdateHead(headName, newHead, upstreamCommit);\n-\t\t\t\tFileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n-\t\t\t\tif (lastStepWasForward)\n-\t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n-\t\t\t\treturn RebaseResult.OK_RESULT;\n-\t\t\t}\n-\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n+\t\t\treturn finishRebase(newHead, lastStepWasForward);\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn new RebaseResult(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cce2561e9fe2ce1cf60182f9d95c8537ce13de92": {
			"type": "Ybodychange",
			"commitMessage": "Add additional RebaseResult for editing commits\n\nWith the new RebaseResult.EDIT a client can now distinguish if rebase\nstopped due to a conflict or because the commit was marked for edit in\nan interactive rebase.\n\nChange-Id: I40f2311cf43ed5f290dcda65a7bd85ba770a85f5\nSigned-off-by: Stefan Lay <stefan.lay@sap.com>\n",
			"commitDate": "2013-11-05, 10:05 AM",
			"commitName": "cce2561e9fe2ce1cf60182f9d95c8537ce13de92",
			"commitAuthor": "Stefan Lay",
			"commitDateOld": "2013-11-05, 10:05 AM",
			"commitNameOld": "765896febb4b63cfe2c37dc0a73c90c79dd1591b",
			"commitAuthorOld": "Tobias Pfeifer",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,167 +1,167 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead = null;\n \t\tboolean lastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId = rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName = rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName = upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \n \t\t\t\tFile amendFile = rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists = amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead == null && !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n \n \t\t\tList<RebaseTodoLine> steps = repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tcheckSteps(steps);\n \t\t\tfor (int i = 0; i < steps.size(); i++) {\n \t\t\t\tRebaseTodoLine step = steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tif (Action.COMMENT.equals(step.getAction()))\n \t\t\t\t\tcontinue;\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.getCommit());\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n-\t\t\t\t\treturn new RebaseResult(commitToPick);\n+\t\t\t\t\treturn new RebaseResult(commitToPick, Status.STOPPED);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead = tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward = newHead != null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName = getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult = new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName)\n \t\t\t\t\t\t\t\t.setReflogPrefix(\"rebase:\").call(); //$NON-NLS-1$\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation == Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t\treturn stop(commitToPick);\n+\t\t\t\t\t\t\t\treturn stop(commitToPick, Status.STOPPED);\n \t\t\t\t\t\tcase CONFLICTING:\n-\t\t\t\t\t\t\treturn stop(commitToPick);\n+\t\t\t\t\t\t\treturn stop(commitToPick, Status.STOPPED);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead = cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tboolean isSquash = false;\n \t\t\t\t\tswitch (step.getAction()) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage = commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage = interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead = new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tcase EDIT:\n \t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n-\t\t\t\t\t\treturn stop(commitToPick);\n+\t\t\t\t\t\treturn stop(commitToPick, Status.EDIT);\n \t\t\t\t\tcase COMMENT:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase SQUASH:\n \t\t\t\t\t\tisSquash = true;\n \t\t\t\t\t\t//$FALL-THROUGH$\n \t\t\t\t\tcase FIXUP:\n \t\t\t\t\t\tresetSoftToParent();\n \t\t\t\t\t\tRebaseTodoLine nextStep = (i >= steps.size() - 1 ? null\n \t\t\t\t\t\t\t\t: steps.get(i + 1));\n \t\t\t\t\t\tFile messageFixupFile = rebaseState.getFile(MESSAGE_FIXUP);\n \t\t\t\t\t\tFile messageSquashFile = rebaseState\n \t\t\t\t\t\t\t\t.getFile(MESSAGE_SQUASH);\n \t\t\t\t\t\tif (isSquash && messageFixupFile.exists())\n \t\t\t\t\t\t\t\tmessageFixupFile.delete();\n \t\t\t\t\t\tnewHead = doSquashFixup(isSquash, commitToPick,\n \t\t\t\t\t\t\t\tnextStep, messageFixupFile, messageSquashFile);\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead != null) {\n \t\t\t\tString headName = rebaseState.readFile(HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead, upstreamCommit);\n \t\t\t\tFileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn new RebaseResult(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"765896febb4b63cfe2c37dc0a73c90c79dd1591b": {
			"type": "Ybodychange",
			"commitMessage": "Add Squash/Fixup support for rebase interactive in RebaseCommand\n\nThe rebase command now supports squash and fixup. Both actions are not\nallowed as the first step of the rebase.\n\nIn JGit, before any rebase step is performed, the next commit is\nalready cherry-picked. This commit keeps that behaviour. In case of\nsquash or fixup a soft reset to the parent is perfomed afterwards.\n\nCQ: 7684\nBug: 396510\nChange-Id: I3c4190940b4d7f19860e223d647fc78705e57203\nSigned-off-by: Tobias Pfeifer <to.pfeifer@web.de>\nSigned-off-by: Stefan Lay <stefan.lay@sap.com>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>\n",
			"commitDate": "2013-11-05, 10:05 AM",
			"commitName": "765896febb4b63cfe2c37dc0a73c90c79dd1591b",
			"commitAuthor": "Tobias Pfeifer",
			"commitDateOld": "2013-11-01, 4:43 PM",
			"commitNameOld": "da9db6b20c6203dae3f828adbd14218ea063ad91",
			"commitAuthorOld": "Tobias Pfeifer",
			"daysBetweenCommits": 3.76,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,150 +1,167 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead = null;\n \t\tboolean lastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase PROCESS_STEPS:\n \t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId = rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName = rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName = upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (stopAfterInitialization)\n \t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \n \t\t\t\tFile amendFile = rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists = amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead == null && !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n \n \t\t\tList<RebaseTodoLine> steps = repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n-\t\t\tfor (RebaseTodoLine step : steps) {\n+\t\t\tcheckSteps(steps);\n+\t\t\tfor (int i = 0; i < steps.size(); i++) {\n+\t\t\t\tRebaseTodoLine step = steps.get(i);\n \t\t\t\tpopSteps(1);\n \t\t\t\tif (Action.COMMENT.equals(step.getAction()))\n \t\t\t\t\tcontinue;\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.getCommit());\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead = tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward = newHead != null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName = getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult = new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName)\n \t\t\t\t\t\t\t\t.setReflogPrefix(\"rebase:\").call(); //$NON-NLS-1$\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation == Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead = cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n+\t\t\t\t\tboolean isSquash = false;\n \t\t\t\t\tswitch (step.getAction()) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage = commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage = interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead = new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tcase EDIT:\n \t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n \t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\tcase COMMENT:\n \t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase SQUASH:\n+\t\t\t\t\t\tisSquash = true;\n+\t\t\t\t\t\t//$FALL-THROUGH$\n+\t\t\t\t\tcase FIXUP:\n+\t\t\t\t\t\tresetSoftToParent();\n+\t\t\t\t\t\tRebaseTodoLine nextStep = (i >= steps.size() - 1 ? null\n+\t\t\t\t\t\t\t\t: steps.get(i + 1));\n+\t\t\t\t\t\tFile messageFixupFile = rebaseState.getFile(MESSAGE_FIXUP);\n+\t\t\t\t\t\tFile messageSquashFile = rebaseState\n+\t\t\t\t\t\t\t\t.getFile(MESSAGE_SQUASH);\n+\t\t\t\t\t\tif (isSquash && messageFixupFile.exists())\n+\t\t\t\t\t\t\t\tmessageFixupFile.delete();\n+\t\t\t\t\t\tnewHead = doSquashFixup(isSquash, commitToPick,\n+\t\t\t\t\t\t\t\tnextStep, messageFixupFile, messageSquashFile);\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead != null) {\n \t\t\t\tString headName = rebaseState.readFile(HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead, upstreamCommit);\n \t\t\t\tFileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn new RebaseResult(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"da9db6b20c6203dae3f828adbd14218ea063ad91": {
			"type": "Ybodychange",
			"commitMessage": "Enable to prepare interactive rebase and then start it explicitly\n\nAdd Operation.PROCESS_STEPS to RebaseCommand to enable starting\ninteractive rebase explicitly after rebase steps have been configured.\n\nChange-Id: I2d6f0de82010ea6523fbce6fb4501e847bdcdddc\nSigned-off-by: Tobias Pfeifer <to.pfeifer@web.de>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>\n",
			"commitDate": "2013-11-01, 4:43 PM",
			"commitName": "da9db6b20c6203dae3f828adbd14218ea063ad91",
			"commitAuthor": "Tobias Pfeifer",
			"commitDateOld": "2013-10-31, 7:22 AM",
			"commitNameOld": "c3873b584f81bc5be3fdea53e9e0e76271a9a854",
			"commitAuthorOld": "Christian Halstrick",
			"daysBetweenCommits": 1.39,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,146 +1,150 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead = null;\n \t\tboolean lastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n+\t\t\tcase PROCESS_STEPS:\n+\t\t\t\t// fall through\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId = rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName = rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName = upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n+\t\t\t\tif (stopAfterInitialization)\n+\t\t\t\t\treturn RebaseResult.INTERACTIVE_PREPARED_RESULT;\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \n \t\t\t\tFile amendFile = rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists = amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead == null && !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n \n \t\t\tList<RebaseTodoLine> steps = repo.readRebaseTodo(\n \t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n \t\t\t\t\t\tsteps, false);\n \t\t\t}\n \t\t\tfor (RebaseTodoLine step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tif (Action.COMMENT.equals(step.getAction()))\n \t\t\t\t\tcontinue;\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.getCommit());\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead = tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward = newHead != null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName = getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult = new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName)\n \t\t\t\t\t\t\t\t.setReflogPrefix(\"rebase:\").call(); //$NON-NLS-1$\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation == Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead = cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tswitch (step.getAction()) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage = commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage = interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead = new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tcase EDIT:\n \t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n \t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\tcase COMMENT:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead != null) {\n \t\t\t\tString headName = rebaseState.readFile(HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead, upstreamCommit);\n \t\t\t\tFileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn new RebaseResult(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c3873b584f81bc5be3fdea53e9e0e76271a9a854": {
			"type": "Ybodychange",
			"commitMessage": "Enhance reading of git-rebase-todo formatted files\n\nReading and writing files formatted like the git-rebase-todo files was\nhidden in the RebaseCommand. Certain constructs (like leading tabs and\nspaces) have not been handled as in native git. Also the upcoming\nrebase interactive feature in EGit needs reading/writing these files\nindependently from a RebaseCommand.\n\nTherefore reading and writing those files has been moved to the\nRepository class. RebaseCommand gets smaller because of that and doesn't\nhave to deal with reading/writing files.\n\nAdditional tests for empty todo-list files, or files containing comments\nhave been added.\n\nChange-Id: I323f3619952fecdf28ddf50139a88e0bea34f5ba\nSigned-off-by: Christian Halstrick <christian.halstrick@sap.com>\nAlso-by: Tobias Pfeifer <to.pfeifer@sap.com>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>\n",
			"commitDate": "2013-10-31, 7:22 AM",
			"commitName": "c3873b584f81bc5be3fdea53e9e0e76271a9a854",
			"commitAuthor": "Christian Halstrick",
			"commitDateOld": "2013-09-29, 2:17 PM",
			"commitNameOld": "c6aba99668eab76c1b05e021719f8ef9a69c3ae9",
			"commitAuthorOld": "Stefan Lay",
			"daysBetweenCommits": 31.71,
			"commitsBetweenForRepo": 24,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,160 +1,146 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead = null;\n \t\tboolean lastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId = rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName = rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName = upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \n \t\t\t\tFile amendFile = rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists = amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead == null && !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n \n-\t\t\tList<Step> steps = loadSteps();\n+\t\t\tList<RebaseTodoLine> steps = repo.readRebaseTodo(\n+\t\t\t\t\trebaseState.getPath(GIT_REBASE_TODO), false);\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n-\t\t\t\tBufferedWriter fw = new BufferedWriter(new OutputStreamWriter(\n-\t\t\t\t\t\tnew FileOutputStream(\n-\t\t\t\t\t\t\t\trebaseState.getFile(GIT_REBASE_TODO)),\n-\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n-\t\t\t\tfw.newLine();\n-\t\t\t\ttry {\n-\t\t\t\t\tStringBuilder sb = new StringBuilder();\n-\t\t\t\t\tfor (Step step : steps) {\n-\t\t\t\t\t\tsb.setLength(0);\n-\t\t\t\t\t\tsb.append(step.action.token);\n-\t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n-\t\t\t\t\t\tsb.append(step.commit.name());\n-\t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n-\t\t\t\t\t\tsb.append(RawParseUtils.decode(step.shortMessage)\n-\t\t\t\t\t\t\t\t.trim());\n-\t\t\t\t\t\tfw.write(sb.toString());\n-\t\t\t\t\t\tfw.newLine();\n-\t\t\t\t\t}\n-\t\t\t\t} finally {\n-\t\t\t\t\tfw.close();\n-\t\t\t\t}\n+\t\t\t\trepo.writeRebaseTodoFile(rebaseState.getPath(GIT_REBASE_TODO),\n+\t\t\t\t\t\tsteps, false);\n \t\t\t}\n-\t\t\tfor (Step step : steps) {\n+\t\t\tfor (RebaseTodoLine step : steps) {\n \t\t\t\tpopSteps(1);\n-\t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n+\t\t\t\tif (Action.COMMENT.equals(step.getAction()))\n+\t\t\t\t\tcontinue;\n+\t\t\t\tCollection<ObjectId> ids = or.resolve(step.getCommit());\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead = tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward = newHead != null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName = getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult = new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName)\n \t\t\t\t\t\t\t\t.setReflogPrefix(\"rebase:\").call(); //$NON-NLS-1$\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation == Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead = cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t\tswitch (step.action) {\n+\t\t\t\t\tswitch (step.getAction()) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage = commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage = interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead = new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tcase EDIT:\n \t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n \t\t\t\t\t\treturn stop(commitToPick);\n+\t\t\t\t\tcase COMMENT:\n+\t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead != null) {\n \t\t\t\tString headName = rebaseState.readFile(HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead, upstreamCommit);\n \t\t\t\tFileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn new RebaseResult(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"60e01cff2f763a85ed24a706d26eb9f159ffa832": {
			"type": "Ybodychange",
			"commitMessage": "Update reflog like C Git during rebase (non-interactive)\n\nBug: 346350\nChange-Id: I119766a00bc52a810c51cffaa19207cb8555ca22\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
			"commitDate": "2013-07-21, 8:54 PM",
			"commitName": "60e01cff2f763a85ed24a706d26eb9f159ffa832",
			"commitAuthor": "Robin Rosenberg",
			"commitDateOld": "2013-03-16, 4:32 PM",
			"commitNameOld": "44ea46dd40d2411dfc615c14db92786730d977be",
			"commitAuthorOld": "Robin Stocker",
			"daysBetweenCommits": 127.18,
			"commitsBetweenForRepo": 196,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,159 +1,160 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead = null;\n \t\tboolean lastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId = rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName = rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName = upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \n \t\t\t\tFile amendFile = rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists = amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead == null && !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n \n \t\t\tList<Step> steps = loadSteps();\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\tBufferedWriter fw = new BufferedWriter(new OutputStreamWriter(\n \t\t\t\t\t\tnew FileOutputStream(\n \t\t\t\t\t\t\t\trebaseState.getFile(GIT_REBASE_TODO)),\n \t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n \t\t\t\tfw.newLine();\n \t\t\t\ttry {\n \t\t\t\t\tStringBuilder sb = new StringBuilder();\n \t\t\t\t\tfor (Step step : steps) {\n \t\t\t\t\t\tsb.setLength(0);\n \t\t\t\t\t\tsb.append(step.action.token);\n \t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\tsb.append(step.commit.name());\n \t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\tsb.append(RawParseUtils.decode(step.shortMessage)\n \t\t\t\t\t\t\t\t.trim());\n \t\t\t\t\t\tfw.write(sb.toString());\n \t\t\t\t\t\tfw.newLine();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tfw.close();\n \t\t\t\t}\n \t\t\t}\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead = tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward = newHead != null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName = getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult = new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n-\t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n+\t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName)\n+\t\t\t\t\t\t\t\t.setReflogPrefix(\"rebase:\").call(); //$NON-NLS-1$\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation == Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead = cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tswitch (step.action) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage = commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage = interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead = new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tcase EDIT:\n \t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n \t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead != null) {\n \t\t\t\tString headName = rebaseState.readFile(HEAD_NAME);\n-\t\t\t\tupdateHead(headName, newHead);\n+\t\t\t\tupdateHead(headName, newHead, upstreamCommit);\n \t\t\t\tFileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn new RebaseResult(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0e9f1cf57dac274f92a6db38197e14b55b3277af": {
			"type": "Ybodychange",
			"commitMessage": "Support aborting non-interactive rebase started from C Git\n\nContinuing is trickier, as .git/rebase-apply contains no message file\nand no git-rebase-todo.\n\nBug: 336820\nChange-Id: I4eb87c850078ca187b38b81cc91c92afb1176945\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>\n",
			"commitDate": "2013-03-16, 4:32 PM",
			"commitName": "0e9f1cf57dac274f92a6db38197e14b55b3277af",
			"commitAuthor": "Robin Stocker",
			"commitDateOld": "2013-03-08, 8:40 AM",
			"commitNameOld": "3ad454497cdb6a917c00b01c735f5a469b8fb2ff",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 8.29,
			"commitsBetweenForRepo": 14,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,159 +1,159 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead = null;\n \t\tboolean lastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n-\t\t\t\tString upstreamCommitId = readFile(rebaseDir, ONTO);\n+\t\t\t\tString upstreamCommitId = rebaseState.readFile(ONTO);\n \t\t\t\ttry {\n-\t\t\t\t\tupstreamCommitName = readFile(rebaseDir, ONTO_NAME);\n+\t\t\t\t\tupstreamCommitName = rebaseState.readFile(ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName = upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \n-\t\t\t\tFile amendFile = new File(rebaseDir, AMEND);\n+\t\t\t\tFile amendFile = rebaseState.getFile(AMEND);\n \t\t\t\tboolean amendExists = amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead == null && !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n \n \t\t\tList<Step> steps = loadSteps();\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n-\t\t\t\tBufferedWriter fw = new BufferedWriter(\n-\t\t\t\t\t\tnew OutputStreamWriter(new FileOutputStream(new File(\n-\t\t\t\t\t\t\t\trebaseDir, GIT_REBASE_TODO)),\n+\t\t\t\tBufferedWriter fw = new BufferedWriter(new OutputStreamWriter(\n+\t\t\t\t\t\tnew FileOutputStream(\n+\t\t\t\t\t\t\t\trebaseState.getFile(GIT_REBASE_TODO)),\n \t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n \t\t\t\tfw.newLine();\n \t\t\t\ttry {\n \t\t\t\t\tStringBuilder sb = new StringBuilder();\n \t\t\t\t\tfor (Step step : steps) {\n \t\t\t\t\t\tsb.setLength(0);\n \t\t\t\t\t\tsb.append(step.action.token);\n \t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\tsb.append(step.commit.name());\n \t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\tsb.append(RawParseUtils.decode(step.shortMessage)\n \t\t\t\t\t\t\t\t.trim());\n \t\t\t\t\t\tfw.write(sb.toString());\n \t\t\t\t\t\tfw.newLine();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tfw.close();\n \t\t\t\t}\n \t\t\t}\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead = tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward = newHead != null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName = getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult = new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation == Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead = cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tswitch (step.action) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage = commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage = interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead = new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tcase EDIT:\n-\t\t\t\t\t\tcreateFile(rebaseDir, AMEND, commitToPick.name());\n+\t\t\t\t\t\trebaseState.createFile(AMEND, commitToPick.name());\n \t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead != null) {\n-\t\t\t\tString headName = readFile(rebaseDir, HEAD_NAME);\n+\t\t\t\tString headName = rebaseState.readFile(HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead);\n-\t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n+\t\t\t\tFileUtils.delete(rebaseState.getDir(), FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (CheckoutConflictException cce) {\n \t\t\treturn new RebaseResult(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"baf7ca9cc0d2bdf237a9bb19486d6fde5250a7f5": {
			"type": "Ybodychange",
			"commitMessage": "Improve handling of checkout conflicts\n\nThis converts a checkout conflict exception into a RebaseResult /\nMergeResult containing the conflicting paths, which enables EGit (or\nothers) to handle the situation in a user-friendly way\n\nChange-Id: I48d9bdcc1e98095576513a54a225a42409f301f3",
			"commitDate": "2013-01-11, 6:32 PM",
			"commitName": "baf7ca9cc0d2bdf237a9bb19486d6fde5250a7f5",
			"commitAuthor": "Markus Duft",
			"commitDateOld": "2012-12-27, 8:57 AM",
			"commitNameOld": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 15.4,
			"commitsBetweenForRepo": 28,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,157 +1,159 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead = null;\n \t\tboolean lastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId = readFile(rebaseDir, ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName = readFile(rebaseDir, ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName = upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \n \t\t\t\tFile amendFile = new File(rebaseDir, AMEND);\n \t\t\t\tboolean amendExists = amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead == null && !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n \n \t\t\tList<Step> steps = loadSteps();\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\tBufferedWriter fw = new BufferedWriter(\n \t\t\t\t\t\tnew OutputStreamWriter(new FileOutputStream(new File(\n \t\t\t\t\t\t\t\trebaseDir, GIT_REBASE_TODO)),\n \t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n \t\t\t\tfw.newLine();\n \t\t\t\ttry {\n \t\t\t\t\tStringBuilder sb = new StringBuilder();\n \t\t\t\t\tfor (Step step : steps) {\n \t\t\t\t\t\tsb.setLength(0);\n \t\t\t\t\t\tsb.append(step.action.token);\n \t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\tsb.append(step.commit.name());\n \t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\tsb.append(RawParseUtils.decode(step.shortMessage)\n \t\t\t\t\t\t\t\t.trim());\n \t\t\t\t\t\tfw.write(sb.toString());\n \t\t\t\t\t\tfw.newLine();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tfw.close();\n \t\t\t\t}\n \t\t\t}\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead = tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward = newHead != null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName = getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult = new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation == Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead = cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tswitch (step.action) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage = commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage = interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead = new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tcase EDIT:\n \t\t\t\t\t\tcreateFile(rebaseDir, AMEND, commitToPick.name());\n \t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead != null) {\n \t\t\t\tString headName = readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead);\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n+\t\t} catch (CheckoutConflictException cce) {\n+\t\t\treturn new RebaseResult(cce.getConflictingPaths());\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c310fa0c802f40a774edb58641de3ac5bfad0e2c": {
			"type": "Ybodychange",
			"commitMessage": "Mark non-externalizable strings as such\n\nA few classes such as Constanrs are marked with @SuppressWarnings, as are\ntoString() methods with many liternal, but otherwise $NLS-n$ is used for\nstring containing text that should not be translated. A few literals may\nfall into the gray zone, but mostly I've tried to only tag the obvious\nones.\n\nChange-Id: I22e50a77e2bf9e0b842a66bdf674e8fa1692f590\n",
			"commitDate": "2012-12-27, 8:57 AM",
			"commitName": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
			"commitAuthor": "Robin Rosenberg",
			"commitDateOld": "2012-12-05, 4:16 PM",
			"commitNameOld": "8d062dec0ca6815bd24457b02dbbc24f9dc143ee",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 21.69,
			"commitsBetweenForRepo": 11,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,157 +1,157 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead = null;\n \t\tboolean lastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId = readFile(rebaseDir, ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName = readFile(rebaseDir, ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName = upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \n \t\t\t\tFile amendFile = new File(rebaseDir, AMEND);\n \t\t\t\tboolean amendExists = amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead == null && !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n \n \t\t\tList<Step> steps = loadSteps();\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\tBufferedWriter fw = new BufferedWriter(\n \t\t\t\t\t\tnew OutputStreamWriter(new FileOutputStream(new File(\n \t\t\t\t\t\t\t\trebaseDir, GIT_REBASE_TODO)),\n \t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n \t\t\t\tfw.newLine();\n \t\t\t\ttry {\n \t\t\t\t\tStringBuilder sb = new StringBuilder();\n \t\t\t\t\tfor (Step step : steps) {\n \t\t\t\t\t\tsb.setLength(0);\n \t\t\t\t\t\tsb.append(step.action.token);\n-\t\t\t\t\t\tsb.append(\" \");\n+\t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\tsb.append(step.commit.name());\n-\t\t\t\t\t\tsb.append(\" \");\n+\t\t\t\t\t\tsb.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\tsb.append(RawParseUtils.decode(step.shortMessage)\n \t\t\t\t\t\t\t\t.trim());\n \t\t\t\t\t\tfw.write(sb.toString());\n \t\t\t\t\t\tfw.newLine();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tfw.close();\n \t\t\t\t}\n \t\t\t}\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead = tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward = newHead != null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName = getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult = new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation == Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead = cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tswitch (step.action) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage = commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage = interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead = new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tcase EDIT:\n \t\t\t\t\t\tcreateFile(rebaseDir, AMEND, commitToPick.name());\n \t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead != null) {\n \t\t\t\tString headName = readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead);\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"257f3fe4a1b9e450b2f665b5f0ed09a3ab3839b9": {
			"type": "Ybodychange",
			"commitMessage": "Commit message may not necessarily be in UTF-8\n\nTrying different encoding makes presentation nicer\nto user.\n\nChange-Id: I2d2c2a95d0b5cd709855d7a67cbc247478434d2f\n",
			"commitDate": "2012-11-27, 12:34 AM",
			"commitName": "257f3fe4a1b9e450b2f665b5f0ed09a3ab3839b9",
			"commitAuthor": "Robin Rosenberg",
			"commitDateOld": "2012-11-19, 9:02 AM",
			"commitNameOld": "8eb4d926371edea2d58dc598e3ebcddacbdc326e",
			"commitAuthorOld": "Dariusz Luksza",
			"daysBetweenCommits": 7.65,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,157 +1,157 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead = null;\n \t\tboolean lastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId = readFile(rebaseDir, ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName = readFile(rebaseDir, ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName = upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \n \t\t\t\tFile amendFile = new File(rebaseDir, AMEND);\n \t\t\t\tboolean amendExists = amendFile.exists();\n \t\t\t\tif (amendExists) {\n \t\t\t\t\tFileUtils.delete(amendFile);\n \t\t\t\t}\n \t\t\t\tif (newHead == null && !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n \n \t\t\tList<Step> steps = loadSteps();\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\tBufferedWriter fw = new BufferedWriter(\n \t\t\t\t\t\tnew OutputStreamWriter(new FileOutputStream(new File(\n \t\t\t\t\t\t\t\trebaseDir, GIT_REBASE_TODO)),\n \t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n \t\t\t\tfw.newLine();\n \t\t\t\ttry {\n \t\t\t\t\tStringBuilder sb = new StringBuilder();\n \t\t\t\t\tfor (Step step : steps) {\n \t\t\t\t\t\tsb.setLength(0);\n \t\t\t\t\t\tsb.append(step.action.token);\n \t\t\t\t\t\tsb.append(\" \");\n \t\t\t\t\t\tsb.append(step.commit.name());\n \t\t\t\t\t\tsb.append(\" \");\n-\t\t\t\t\t\tsb.append(new String(step.shortMessage,\n-\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING).trim());\n+\t\t\t\t\t\tsb.append(RawParseUtils.decode(step.shortMessage)\n+\t\t\t\t\t\t\t\t.trim());\n \t\t\t\t\t\tfw.write(sb.toString());\n \t\t\t\t\t\tfw.newLine();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tfw.close();\n \t\t\t\t}\n \t\t\t}\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead = tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward = newHead != null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName = getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult = new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation == Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead = cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tswitch (step.action) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage = commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage = interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead = new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tcase EDIT:\n \t\t\t\t\t\tcreateFile(rebaseDir, AMEND, commitToPick.name());\n \t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead != null) {\n \t\t\t\tString headName = readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead);\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8eb4d926371edea2d58dc598e3ebcddacbdc326e": {
			"type": "Ybodychange",
			"commitMessage": "Add support for rebase interactive 'edit' command\n\nThe 'edit' command allows you to change arbitrary commit\ncontent and the message of any commit in the repository.\n\nBug: 394577\nChange-Id: I43a44782cdb10b29f13784fa75ab37fe5d4da01b\nSigned-off-by: Dariusz Luksza <dariusz@luksza.org>\nSigned-off-by: Chris Aniszczyk <zx@twitter.com>\n",
			"commitDate": "2012-11-19, 9:02 AM",
			"commitName": "8eb4d926371edea2d58dc598e3ebcddacbdc326e",
			"commitAuthor": "Dariusz Luksza",
			"commitDateOld": "2012-11-19, 8:40 AM",
			"commitNameOld": "84fb2b59d11418d2fa753d27de11775ddc18adde",
			"commitAuthorOld": "Dariusz Luksza",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,149 +1,157 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead = null;\n \t\tboolean lastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId = readFile(rebaseDir, ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName = readFile(rebaseDir, ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName = upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \n-\t\t\t\tif (newHead == null) {\n+\t\t\t\tFile amendFile = new File(rebaseDir, AMEND);\n+\t\t\t\tboolean amendExists = amendFile.exists();\n+\t\t\t\tif (amendExists) {\n+\t\t\t\t\tFileUtils.delete(amendFile);\n+\t\t\t\t}\n+\t\t\t\tif (newHead == null && !amendExists) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n \n \t\t\tList<Step> steps = loadSteps();\n \t\t\tif (isInteractive()) {\n \t\t\t\tinteractiveHandler.prepareSteps(steps);\n \t\t\t\tBufferedWriter fw = new BufferedWriter(\n \t\t\t\t\t\tnew OutputStreamWriter(new FileOutputStream(new File(\n \t\t\t\t\t\t\t\trebaseDir, GIT_REBASE_TODO)),\n \t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n \t\t\t\tfw.newLine();\n \t\t\t\ttry {\n \t\t\t\t\tStringBuilder sb = new StringBuilder();\n \t\t\t\t\tfor (Step step : steps) {\n \t\t\t\t\t\tsb.setLength(0);\n \t\t\t\t\t\tsb.append(step.action.token);\n \t\t\t\t\t\tsb.append(\" \");\n \t\t\t\t\t\tsb.append(step.commit.name());\n \t\t\t\t\t\tsb.append(\" \");\n \t\t\t\t\t\tsb.append(new String(step.shortMessage,\n \t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING).trim());\n \t\t\t\t\t\tfw.write(sb.toString());\n \t\t\t\t\t\tfw.newLine();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tfw.close();\n \t\t\t\t}\n \t\t\t}\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead = tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward = newHead != null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName = getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult = new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation == Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead = cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tswitch (step.action) {\n \t\t\t\t\tcase PICK:\n \t\t\t\t\t\tcontinue; // continue rebase process on pick command\n \t\t\t\t\tcase REWORD:\n \t\t\t\t\t\tString oldMessage = commitToPick.getFullMessage();\n \t\t\t\t\t\tString newMessage = interactiveHandler\n \t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n \t\t\t\t\t\tnewHead = new Git(repo).commit().setMessage(newMessage)\n \t\t\t\t\t\t\t\t.setAmend(true).call();\n \t\t\t\t\t\tcontinue;\n+\t\t\t\t\tcase EDIT:\n+\t\t\t\t\t\tcreateFile(rebaseDir, AMEND, commitToPick.name());\n+\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead != null) {\n \t\t\t\tString headName = readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead);\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"84fb2b59d11418d2fa753d27de11775ddc18adde": {
			"type": "Ybodychange",
			"commitMessage": "Add support for rebase interactive 'reword' command\n\n'reword' command is used to change commit message of any\ncommit in git history.\n\nBug: 394575\nChange-Id: Ic974e76dfd923fd6f0cb8f07d1a6fbecd9abbf31\nSigned-off-by: Dariusz Luksza <dariusz@luksza.org>\nSigned-off-by: Chris Aniszczyk <zx@twitter.com>\n",
			"commitDate": "2012-11-19, 8:40 AM",
			"commitName": "84fb2b59d11418d2fa753d27de11775ddc18adde",
			"commitAuthor": "Dariusz Luksza",
			"commitDateOld": "2012-08-26, 4:54 PM",
			"commitNameOld": "0264c313bae0308dadc4ed1db28f2f979a435451",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 84.7,
			"commitsBetweenForRepo": 105,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,114 +1,149 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead = null;\n \t\tboolean lastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitId = readFile(rebaseDir, ONTO);\n \t\t\t\ttry {\n \t\t\t\t\tupstreamCommitName = readFile(rebaseDir, ONTO_NAME);\n \t\t\t\t} catch (FileNotFoundException e) {\n \t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n \t\t\t\t\t// was started by C Git)\n \t\t\t\t\tupstreamCommitName = upstreamCommitId;\n \t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \n \t\t\t\tif (newHead == null) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n \n \t\t\tList<Step> steps = loadSteps();\n+\t\t\tif (isInteractive()) {\n+\t\t\t\tinteractiveHandler.prepareSteps(steps);\n+\t\t\t\tBufferedWriter fw = new BufferedWriter(\n+\t\t\t\t\t\tnew OutputStreamWriter(new FileOutputStream(new File(\n+\t\t\t\t\t\t\t\trebaseDir, GIT_REBASE_TODO)),\n+\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n+\t\t\t\tfw.newLine();\n+\t\t\t\ttry {\n+\t\t\t\t\tStringBuilder sb = new StringBuilder();\n+\t\t\t\t\tfor (Step step : steps) {\n+\t\t\t\t\t\tsb.setLength(0);\n+\t\t\t\t\t\tsb.append(step.action.token);\n+\t\t\t\t\t\tsb.append(\" \");\n+\t\t\t\t\t\tsb.append(step.commit.name());\n+\t\t\t\t\t\tsb.append(\" \");\n+\t\t\t\t\t\tsb.append(new String(step.shortMessage,\n+\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING).trim());\n+\t\t\t\t\t\tfw.write(sb.toString());\n+\t\t\t\t\t\tfw.newLine();\n+\t\t\t\t\t}\n+\t\t\t\t} finally {\n+\t\t\t\t\tfw.close();\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead = tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward = newHead != null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tString ourCommitName = getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult = new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n \t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation == Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead = cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n+\t\t\t\t\tswitch (step.action) {\n+\t\t\t\t\tcase PICK:\n+\t\t\t\t\t\tcontinue; // continue rebase process on pick command\n+\t\t\t\t\tcase REWORD:\n+\t\t\t\t\t\tString oldMessage = commitToPick.getFullMessage();\n+\t\t\t\t\t\tString newMessage = interactiveHandler\n+\t\t\t\t\t\t\t\t.modifyCommitMessage(oldMessage);\n+\t\t\t\t\t\tnewHead = new Git(repo).commit().setMessage(newMessage)\n+\t\t\t\t\t\t\t\t.setAmend(true).call();\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead != null) {\n \t\t\t\tString headName = readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead);\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5854ca091a22346e1c710ca9f875165afb3f2cc8": {
			"type": "Ybodychange",
			"commitMessage": "Improve ours/theirs conflict markers for rebase, cherry-pick\n\nOn conflicts in rebase or cherry-pick, the conflict markers were like\nthis:\n\n    <<<<<<< OURS\n    a\n    =======\n    b\n    >>>>>>> THEIRS\n\nThis is technically correct, but it could be better.\n\nIt's especially confusing during a rebase, where the meaning of\nOURS/THEIRS is not obvious. The intuition is that \"ours\" is the commits\nthat \"I\" did before the rebase, but it's the other way around because of\nthe way rebase works. See various bug reports and stackoverflow\ndiscussions.\n\nWith this change, in the case of a cherry-pick while on master, the\nmarkers will be like this:\n\n    <<<<<<< master\n    a\n    =======\n    b\n    >>>>>>> bad1dea Message of the commit I'm cherry-picking\n\nIn the case of a \"git rebase master\":\n\n    <<<<<<< Upstream, based on master\n    a\n    =======\n    b\n    >>>>>>> b161dea Message of a commit I'm rebasing\n\nIt's not \"master\" because that would only be correct for the first\ncherry-pick during a rebase, after that, it's master + already\ncherry-picked commits.\n\nAnd in the case of a \"git pull --rebase\":\n\n    <<<<<<< Upstream, based on branch 'master' of git@example.org:repo\n    a\n    =======\n    b\n    >>>>>>> b161dea Message of a commit I'm rebasing\n\nBug: 336819\nChange-Id: I1333a8dd170bb0077f491962013485efb6f2a926\nSigned-off-by: Robin Stocker <robin@nibor.org>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2012-08-17, 4:11 PM",
			"commitName": "5854ca091a22346e1c710ca9f875165afb3f2cc8",
			"commitAuthor": "Robin Stocker",
			"commitDateOld": "2012-08-07, 8:49 AM",
			"commitNameOld": "993fcac2d34f113977c1ad7e0f83a2cc0f903f71",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 10.31,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,105 +1,114 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n \t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead = null;\n \t\tboolean lastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n-\t\t\t\tString upstreamCommitName = readFile(rebaseDir, ONTO);\n+\t\t\t\tString upstreamCommitId = readFile(rebaseDir, ONTO);\n+\t\t\t\ttry {\n+\t\t\t\t\tupstreamCommitName = readFile(rebaseDir, ONTO_NAME);\n+\t\t\t\t} catch (FileNotFoundException e) {\n+\t\t\t\t\t// Fall back to commit ID if file doesn't exist (e.g. rebase\n+\t\t\t\t\t// was started by C Git)\n+\t\t\t\t\tupstreamCommitName = upstreamCommitId;\n+\t\t\t\t}\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n-\t\t\t\t\t\t.resolve(upstreamCommitName));\n+\t\t\t\t\t\t.resolve(upstreamCommitId));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \n \t\t\t\tif (newHead == null) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n \n \t\t\tList<Step> steps = loadSteps();\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead = tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward = newHead != null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n+\t\t\t\t\t\tString ourCommitName = getOurCommitName();\n \t\t\t\t\t\tCherryPickResult cherryPickResult = new Git(repo)\n-\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick).call();\n+\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick)\n+\t\t\t\t\t\t\t\t.setOurCommitName(ourCommitName).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation == Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead = cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead != null) {\n \t\t\t\tString headName = readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead);\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b61d35e848e637ef85fde4ebe95d60ced171e963": {
			"type": "Yexceptionschange",
			"commitMessage": "Further cleanup of exceptions in Git API\n\n- Translate internal exceptions to corresponding API exception\n- Do not catch GitAPI exceptions internally to an internal\nexception. Just pass them to caller\n- Mention thrown exceptions in javadoc\n\nChange-Id: I9044cf86d2b0bcc8b63b7cc016e1bf0055a62053\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2012-06-05, 8:55 AM",
			"commitName": "b61d35e848e637ef85fde4ebe95d60ced171e963",
			"commitAuthor": "Robin Rosenberg",
			"commitDateOld": "2012-05-31, 1:52 PM",
			"commitNameOld": "058c74d8adcfb5ef0eed203a64b7f9ff65e87c8c",
			"commitAuthorOld": "Kevin Sawicki",
			"daysBetweenCommits": 4.79,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,105 +1,105 @@\n \tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n-\t\t\tRefNotFoundException {\n+\t\t\tRefNotFoundException, WrongRepositoryStateException {\n \t\tRevCommit newHead = null;\n \t\tboolean lastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName = readFile(rebaseDir, ONTO);\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \n \t\t\t\tif (newHead == null) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n \n \t\t\tList<Step> steps = loadSteps();\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead = tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward = newHead != null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tCherryPickResult cherryPickResult = new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation == Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead = cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead != null) {\n \t\t\t\tString headName = readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead);\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[GitAPIException, NoHeadException, RefNotFoundException]",
				"newValue": "[GitAPIException, NoHeadException, RefNotFoundException, WrongRepositoryStateException]"
			}
		},
		"4e1454ded6e2fcf6cb789c004756883c3ea5f77e": {
			"type": "Yexceptionschange",
			"commitMessage": "Git API does not declare GitAPIException call() and related cleanups\n\nAll commands should throw a GitAPIException so new exceptions can be\nadded without breaking the builds of old code, i.e. anyone that calls\na Git API should catch GitAPIException and not just the currently known\nexceptions.\n\nNow the only checked exceptions on Git API calls are GitException and\nsubclasses of it. New checked exceptions that are subclasses of\nGitException may be added without breaking the API.\n\nJavadoc for GitAPIException is declared on GitCommand and\ninherited to subclasses. JGitInternalException is not explicitly\ndocumented anymore.\n\nUnfortunately this change itself breaks the API. The intention is\nthat it shall be possible to add new checked subclasses of\nGitAPIException without breaking the API.\n\nBug: 366914\nEGit-Change-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nChange-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>\n",
			"commitDate": "2012-05-30, 2:08 PM",
			"commitName": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
			"commitAuthor": "Robin Rosenberg",
			"commitDateOld": "2012-04-02, 3:36 AM",
			"commitNameOld": "622232b936fee6d2f308947359b4bc09811ce556",
			"commitAuthorOld": "Tomasz Zarna",
			"daysBetweenCommits": 58.44,
			"commitsBetweenForRepo": 40,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,105 +1,105 @@\n-\tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n-\t\t\tJGitInternalException, GitAPIException {\n+\tpublic RebaseResult call() throws GitAPIException, NoHeadException,\n+\t\t\tRefNotFoundException {\n \t\tRevCommit newHead = null;\n \t\tboolean lastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName = readFile(rebaseDir, ONTO);\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \n \t\t\t\tif (newHead == null) {\n \t\t\t\t\t// continueRebase() returns null only if no commit was\n \t\t\t\t\t// neccessary. This means that no changes where left over\n \t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n \t\t\t\t\t// and displays a nice message to the user, telling him to\n \t\t\t\t\t// either do changes or skip the commit instead of continue.\n \t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n \n \t\t\tList<Step> steps = loadSteps();\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead = tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward = newHead != null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tCherryPickResult cherryPickResult = new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation == Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead = cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead != null) {\n \t\t\t\tString headName = readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead);\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[NoHeadException, RefNotFoundException, JGitInternalException, GitAPIException]",
				"newValue": "[GitAPIException, NoHeadException, RefNotFoundException]"
			}
		},
		"edc1fee033a23189742cea1807d8029d1b77da00": {
			"type": "Ybodychange",
			"commitMessage": "Fix rebase > continue when nothing left to commit.\n\nIf after resolving all conflicts nothing is left to commit, return\nan according result, so that downstreams (EGit, ...) can behave like\ncgit, and display a nice message informing the user.\n\nCurrently, EGit displays a \"HEAD advanced fast forward\" message, which\nis absolutely not helpful at all.\n\nThis is the basic API revamping required to get that state communicated\nto the outside world (EGit).\n\nBug: 336812\nChange-Id: If2665005cf54a5b51c0fe80bad019fa42b0205af",
			"commitDate": "2012-03-09, 5:56 AM",
			"commitName": "edc1fee033a23189742cea1807d8029d1b77da00",
			"commitAuthor": "Markus Duft",
			"commitDateOld": "2012-03-06, 2:43 PM",
			"commitNameOld": "90d002c15fd2131b9f80fb9bb6f28bf691c00b5d",
			"commitAuthorOld": "Tomasz Zarna",
			"daysBetweenCommits": 2.63,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,95 +1,105 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n \t\tRevCommit newHead = null;\n \t\tboolean lastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName = readFile(rebaseDir, ONTO);\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n-\t\t\tif (operation == Operation.CONTINUE)\n+\t\t\tif (operation == Operation.CONTINUE) {\n \t\t\t\tnewHead = continueRebase();\n \n+\t\t\t\tif (newHead == null) {\n+\t\t\t\t\t// continueRebase() returns null only if no commit was\n+\t\t\t\t\t// neccessary. This means that no changes where left over\n+\t\t\t\t\t// after resolving all conflicts. In this case, cgit stops\n+\t\t\t\t\t// and displays a nice message to the user, telling him to\n+\t\t\t\t\t// either do changes or skip the commit instead of continue.\n+\t\t\t\t\treturn RebaseResult.NOTHING_TO_COMMIT_RESULT;\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n \n \t\t\tList<Step> steps = loadSteps();\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead = tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward = newHead != null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tCherryPickResult cherryPickResult = new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation == Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead = cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead != null) {\n \t\t\t\tString headName = readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tupdateHead(headName, newHead);\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n \t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"557ea857e3b5229379476f1ee4160fcf5b695bbd": {
			"type": "Ybodychange",
			"commitMessage": "Implement rebase ff for upstream branches with merge commits\n\nChange Ib9898fe0f982fa08e41f1dca9452c43de715fdb6 added support for\nthe 'cherry-pick' fast forward case where the upstream commit history\ndoes not include any merge commits.  This change adds support for the\ncase where merge commits exist and the local branch has no changes.\n\nBug: 344779\nChange-Id: If203ce5aa1b4e5d4d7982deb621b710e71f4ee10\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
			"commitDate": "2011-05-18, 10:40 AM",
			"commitName": "557ea857e3b5229379476f1ee4160fcf5b695bbd",
			"commitAuthor": "Chris Aniszczyk",
			"commitDateOld": "2011-04-06, 12:28 PM",
			"commitNameOld": "6e10aa42e90a25b82f00f0c27574f57ffa9e4a25",
			"commitAuthorOld": "Robin Stocker",
			"daysBetweenCommits": 41.93,
			"commitsBetweenForRepo": 47,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,118 +1,95 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n \t\tRevCommit newHead = null;\n \t\tboolean lastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n-\t\t\t\t\treturn abort(new RebaseResult(Status.ABORTED));\n+\t\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName = readFile(rebaseDir, ONTO);\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n-\t\t\t\treturn abort(new RebaseResult(Status.ABORTED));\n+\t\t\t\treturn abort(RebaseResult.ABORTED_RESULT);\n \n \t\t\tif (operation == Operation.CONTINUE)\n \t\t\t\tnewHead = continueRebase();\n \n \t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n \n \t\t\tList<Step> steps = loadSteps();\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\ttry {\n \t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().applyingCommit,\n \t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t\t// unnecessary object rewriting\n \t\t\t\t\tnewHead = tryFastForward(commitToPick);\n \t\t\t\t\tlastStepWasForward = newHead != null;\n \t\t\t\t\tif (!lastStepWasForward) {\n \t\t\t\t\t\t// TODO if the content of this commit is already merged\n \t\t\t\t\t\t// here we should skip this step in order to avoid\n \t\t\t\t\t\t// confusing pseudo-changed\n \t\t\t\t\t\tCherryPickResult cherryPickResult = new Git(repo)\n \t\t\t\t\t\t\t\t.cherryPick().include(commitToPick).call();\n \t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n \t\t\t\t\t\tcase FAILED:\n \t\t\t\t\t\t\tif (operation == Operation.BEGIN)\n \t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n \t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase CONFLICTING:\n \t\t\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t\t\tcase OK:\n \t\t\t\t\t\t\tnewHead = cherryPickResult.getNewHead();\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead != null) {\n-\t\t\t\t// point the previous head (if any) to the new commit\n \t\t\t\tString headName = readFile(rebaseDir, HEAD_NAME);\n-\t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n-\t\t\t\t\tRefUpdate rup = repo.updateRef(headName);\n-\t\t\t\t\trup.setNewObjectId(newHead);\n-\t\t\t\t\tResult res = rup.forceUpdate();\n-\t\t\t\t\tswitch (res) {\n-\t\t\t\t\tcase FAST_FORWARD:\n-\t\t\t\t\tcase FORCED:\n-\t\t\t\t\tcase NO_CHANGE:\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n-\t\t\t\t\t}\n-\t\t\t\t\trup = repo.updateRef(Constants.HEAD);\n-\t\t\t\t\tres = rup.link(headName);\n-\t\t\t\t\tswitch (res) {\n-\t\t\t\t\tcase FAST_FORWARD:\n-\t\t\t\t\tcase FORCED:\n-\t\t\t\t\tcase NO_CHANGE:\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\tupdateHead(headName, newHead);\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n-\t\t\t\t\treturn new RebaseResult(Status.FAST_FORWARD);\n-\t\t\t\treturn new RebaseResult(Status.OK);\n+\t\t\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n+\t\t\t\treturn RebaseResult.OK_RESULT;\n \t\t\t}\n-\t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n+\t\t\treturn RebaseResult.FAST_FORWARD_RESULT;\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0b5ad24915824a8c999bb6951b131a958e418306": {
			"type": "Ybodychange",
			"commitMessage": "Introduce FAILED result for RebaseCommand\n\nIn case an underlying cherry-pick fails due to uncommitted changes, a\nRebaseCommand shall fail and roll-back changes.\n\nChange-Id: Ic22eb047fb03ac2c8391f777036b7dbf22a1b061\nSigned-off-by: Philipp Thun <philipp.thun@sap.com>\n",
			"commitDate": "2011-03-24, 5:24 AM",
			"commitName": "0b5ad24915824a8c999bb6951b131a958e418306",
			"commitAuthor": "Philipp Thun",
			"commitDateOld": "2011-03-23, 3:24 AM",
			"commitNameOld": "a21e508a318664dac23701ca29d5f0b64d36a76a",
			"commitAuthorOld": "Philipp Thun",
			"daysBetweenCommits": 1.08,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,104 +1,118 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n \t\tRevCommit newHead = null;\n \t\tboolean lastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n-\t\t\t\t\treturn abort();\n+\t\t\t\t\treturn abort(new RebaseResult(Status.ABORTED));\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName = readFile(rebaseDir, ONTO);\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n-\t\t\t\treturn abort();\n+\t\t\t\treturn abort(new RebaseResult(Status.ABORTED));\n \n-\t\t\tif (this.operation == Operation.CONTINUE)\n+\t\t\tif (operation == Operation.CONTINUE)\n \t\t\t\tnewHead = continueRebase();\n \n-\t\t\tif (this.operation == Operation.SKIP)\n+\t\t\tif (operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n \n \t\t\tList<Step> steps = loadSteps();\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n-\t\t\t\tmonitor.beginTask(MessageFormat.format(\n-\t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n-\t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n-\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n-\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n-\t\t\t\t// unnecessary object rewriting\n-\t\t\t\tnewHead = tryFastForward(commitToPick);\n-\t\t\t\tlastStepWasForward = newHead != null;\n-\t\t\t\tif (!lastStepWasForward)\n-\t\t\t\t\t// TODO if the content of this commit is already merged here\n-\t\t\t\t\t// we should skip this step in order to avoid confusing\n-\t\t\t\t\t// pseudo-changed\n-\t\t\t\t\tnewHead = new Git(repo).cherryPick().include(commitToPick)\n-\t\t\t\t\t\t\t.call().getNewHead();\n-\t\t\t\tmonitor.endTask();\n-\t\t\t\tif (newHead == null) {\n-\t\t\t\t\treturn stop(commitToPick);\n+\t\t\t\ttry {\n+\t\t\t\t\tmonitor.beginTask(MessageFormat.format(\n+\t\t\t\t\t\t\tJGitText.get().applyingCommit,\n+\t\t\t\t\t\t\tcommitToPick.getShortMessage()),\n+\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n+\t\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n+\t\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n+\t\t\t\t\t// unnecessary object rewriting\n+\t\t\t\t\tnewHead = tryFastForward(commitToPick);\n+\t\t\t\t\tlastStepWasForward = newHead != null;\n+\t\t\t\t\tif (!lastStepWasForward) {\n+\t\t\t\t\t\t// TODO if the content of this commit is already merged\n+\t\t\t\t\t\t// here we should skip this step in order to avoid\n+\t\t\t\t\t\t// confusing pseudo-changed\n+\t\t\t\t\t\tCherryPickResult cherryPickResult = new Git(repo)\n+\t\t\t\t\t\t\t\t.cherryPick().include(commitToPick).call();\n+\t\t\t\t\t\tswitch (cherryPickResult.getStatus()) {\n+\t\t\t\t\t\tcase FAILED:\n+\t\t\t\t\t\t\tif (operation == Operation.BEGIN)\n+\t\t\t\t\t\t\t\treturn abort(new RebaseResult(\n+\t\t\t\t\t\t\t\t\t\tcherryPickResult.getFailingPaths()));\n+\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\treturn stop(commitToPick);\n+\t\t\t\t\t\tcase CONFLICTING:\n+\t\t\t\t\t\t\treturn stop(commitToPick);\n+\t\t\t\t\t\tcase OK:\n+\t\t\t\t\t\t\tnewHead = cherryPickResult.getNewHead();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} finally {\n+\t\t\t\t\tmonitor.endTask();\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead != null) {\n \t\t\t\t// point the previous head (if any) to the new commit\n \t\t\t\tString headName = readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n \t\t\t\t\tRefUpdate rup = repo.updateRef(headName);\n \t\t\t\t\trup.setNewObjectId(newHead);\n \t\t\t\t\tResult res = rup.forceUpdate();\n \t\t\t\t\tswitch (res) {\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase NO_CHANGE:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n \t\t\t\t\t}\n \t\t\t\t\trup = repo.updateRef(Constants.HEAD);\n \t\t\t\t\tres = rup.link(headName);\n \t\t\t\t\tswitch (res) {\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase NO_CHANGE:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn new RebaseResult(Status.FAST_FORWARD);\n \t\t\t\treturn new RebaseResult(Status.OK);\n \t\t\t}\n \t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a21e508a318664dac23701ca29d5f0b64d36a76a": {
			"type": "Ybodychange",
			"commitMessage": "Introduce CherryPickResult\n\nIn order to distinguish cherry-pick failures caused by conflicts vs.\n'abnormal failures' (e.g. due to unstaged changes or a dirty\nworktree), a CherryPickResult class is introduced and returned by\nCherryPickCommand.call() instead of a RevCommit. This new class is\nsimilar to MergeResult and RebaseResult. The CherryPickResult contains\nall necessary information, e.g. paths causing the cherry-pick (a merge\ncalled within, respectively) to fail. This allows callers to better\nreact on failures.\n\nChange-Id: I5db57b9259e82ed118e4bf4ec94463efe68b8c1f\nSigned-off-by: Philipp Thun <philipp.thun@sap.com>\nSigned-off-by: Mathias Kinzler <mathias.kinzler@sap.com>",
			"commitDate": "2011-03-23, 3:24 AM",
			"commitName": "a21e508a318664dac23701ca29d5f0b64d36a76a",
			"commitAuthor": "Philipp Thun",
			"commitDateOld": "2011-01-31, 4:12 AM",
			"commitNameOld": "b15b9d5df25b375108ca125b31338df637454865",
			"commitAuthorOld": "Mathias Kinzler",
			"daysBetweenCommits": 50.92,
			"commitsBetweenForRepo": 158,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,104 +1,104 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n \t\tRevCommit newHead = null;\n \t\tboolean lastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort();\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName = readFile(rebaseDir, ONTO);\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort();\n \n \t\t\tif (this.operation == Operation.CONTINUE)\n \t\t\t\tnewHead = continueRebase();\n \n \t\t\tif (this.operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n \n \t\t\tList<Step> steps = loadSteps();\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n \t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n \t\t\t\t// if the first parent of commitToPick is the current HEAD,\n \t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t// unnecessary object rewriting\n \t\t\t\tnewHead = tryFastForward(commitToPick);\n \t\t\t\tlastStepWasForward = newHead != null;\n \t\t\t\tif (!lastStepWasForward)\n \t\t\t\t\t// TODO if the content of this commit is already merged here\n \t\t\t\t\t// we should skip this step in order to avoid confusing\n \t\t\t\t\t// pseudo-changed\n \t\t\t\t\tnewHead = new Git(repo).cherryPick().include(commitToPick)\n-\t\t\t\t\t\t\t.call();\n+\t\t\t\t\t\t\t.call().getNewHead();\n \t\t\t\tmonitor.endTask();\n \t\t\t\tif (newHead == null) {\n \t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead != null) {\n \t\t\t\t// point the previous head (if any) to the new commit\n \t\t\t\tString headName = readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n \t\t\t\t\tRefUpdate rup = repo.updateRef(headName);\n \t\t\t\t\trup.setNewObjectId(newHead);\n \t\t\t\t\tResult res = rup.forceUpdate();\n \t\t\t\t\tswitch (res) {\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase NO_CHANGE:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n \t\t\t\t\t}\n \t\t\t\t\trup = repo.updateRef(Constants.HEAD);\n \t\t\t\t\tres = rup.link(headName);\n \t\t\t\t\tswitch (res) {\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase NO_CHANGE:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\tif (lastStepWasForward)\n \t\t\t\t\treturn new RebaseResult(Status.FAST_FORWARD);\n \t\t\t\treturn new RebaseResult(Status.OK);\n \t\t\t}\n \t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e8a1328d05aa55b7ace0d101e34b87422219c959": {
			"type": "Ybodychange",
			"commitMessage": "RebaseCommand: detect and handle fast-forward properly\n\nThis bug was hidden by an incomplete test: the current Rebase\nimplementation using the \"git rebase -i\" pattern does not work\ncorrectly if fast-forwarding is involved. The reason for this is that\nthe log command does not return any commits in this case.\nIn addition, a check for already merged commits was introduced to\navoid spurious conflicts.\n\nChange-Id: Ib9898fe0f982fa08e41f1dca9452c43de715fdb6\nSigned-off-by: Mathias Kinzler <mathias.kinzler@sap.com>\n",
			"commitDate": "2011-01-28, 7:03 AM",
			"commitName": "e8a1328d05aa55b7ace0d101e34b87422219c959",
			"commitAuthor": "Mathias Kinzler",
			"commitDateOld": "2011-01-27, 5:11 PM",
			"commitNameOld": "38eec8f4a26935ba9e75bfbdde8a5682e05f338d",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 0.58,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,95 +1,104 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n \t\tRevCommit newHead = null;\n+\t\tboolean lastStepWasForward = false;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort();\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName = readFile(rebaseDir, ONTO);\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort();\n \n \t\t\tif (this.operation == Operation.CONTINUE)\n \t\t\t\tnewHead = continueRebase();\n \n \t\t\tif (this.operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n \n \t\t\tList<Step> steps = loadSteps();\n \t\t\tfor (Step step : steps) {\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n \t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n-\t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n-\t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n+\t\t\t\t// if the first parent of commitToPick is the current HEAD,\n+\t\t\t\t// we do a fast-forward instead of cherry-pick to avoid\n \t\t\t\t// unnecessary object rewriting\n-\t\t\t\tnewHead = new Git(repo).cherryPick().include(commitToPick)\n-\t\t\t\t\t\t.call();\n+\t\t\t\tnewHead = tryFastForward(commitToPick);\n+\t\t\t\tlastStepWasForward = newHead != null;\n+\t\t\t\tif (!lastStepWasForward)\n+\t\t\t\t\t// TODO if the content of this commit is already merged here\n+\t\t\t\t\t// we should skip this step in order to avoid confusing\n+\t\t\t\t\t// pseudo-changed\n+\t\t\t\t\tnewHead = new Git(repo).cherryPick().include(commitToPick)\n+\t\t\t\t\t\t\t.call();\n \t\t\t\tmonitor.endTask();\n \t\t\t\tif (newHead == null) {\n \t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead != null) {\n \t\t\t\t// point the previous head (if any) to the new commit\n \t\t\t\tString headName = readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n \t\t\t\t\tRefUpdate rup = repo.updateRef(headName);\n \t\t\t\t\trup.setNewObjectId(newHead);\n \t\t\t\t\tResult res = rup.forceUpdate();\n \t\t\t\t\tswitch (res) {\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase NO_CHANGE:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n \t\t\t\t\t}\n \t\t\t\t\trup = repo.updateRef(Constants.HEAD);\n \t\t\t\t\tres = rup.link(headName);\n \t\t\t\t\tswitch (res) {\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase NO_CHANGE:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n+\t\t\t\tif (lastStepWasForward)\n+\t\t\t\t\treturn new RebaseResult(Status.FAST_FORWARD);\n \t\t\t\treturn new RebaseResult(Status.OK);\n \t\t\t}\n \t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9b039b42e0ecf69640c5f1a34ee72a86dba3f1c2": {
			"type": "Ybodychange",
			"commitMessage": "Rebase: abort on unknown/unsupported command in git-rebase-todo\n\nThis is needed to ensure interoperability with the command line: if\nthe git-rebase-todo file was created manually (by git rebase -i in the\ncommand line), and any commands other than pick are used (reword,\nedit, fixup, squash) JGit must abort as it does not understand these\ncommands yet.\nThe same is true if an unknown command is found (e.g. due to a typo);\nthis is the same behavior as shown by the command line.\n\nChange-Id: I2322014f69460361f7fc09da223e8a5c31f100dd\nSigned-off-by: Mathias Kinzler <mathias.kinzler@sap.com>\n",
			"commitDate": "2010-12-10, 1:44 AM",
			"commitName": "9b039b42e0ecf69640c5f1a34ee72a86dba3f1c2",
			"commitAuthor": "Mathias Kinzler",
			"commitDateOld": "2010-12-09, 11:22 AM",
			"commitNameOld": "2a7cd0086bf1bd614478c5722eac5142326e6f2b",
			"commitAuthorOld": "Mathias Kinzler",
			"daysBetweenCommits": 0.6,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,97 +1,95 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n \t\tRevCommit newHead = null;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort();\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName = readFile(rebaseDir, ONTO);\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort();\n \n \t\t\tif (this.operation == Operation.CONTINUE)\n \t\t\t\tnewHead = continueRebase();\n \n \t\t\tif (this.operation == Operation.SKIP)\n \t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n \n \t\t\tList<Step> steps = loadSteps();\n \t\t\tfor (Step step : steps) {\n-\t\t\t\tif (step.action != Action.PICK)\n-\t\t\t\t\tcontinue;\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n \t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n \t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n \t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n \t\t\t\t// unnecessary object rewriting\n \t\t\t\tnewHead = new Git(repo).cherryPick().include(commitToPick)\n \t\t\t\t\t\t.call();\n \t\t\t\tmonitor.endTask();\n \t\t\t\tif (newHead == null) {\n \t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (newHead != null) {\n \t\t\t\t// point the previous head (if any) to the new commit\n \t\t\t\tString headName = readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n \t\t\t\t\tRefUpdate rup = repo.updateRef(headName);\n \t\t\t\t\trup.setNewObjectId(newHead);\n \t\t\t\t\tResult res = rup.forceUpdate();\n \t\t\t\t\tswitch (res) {\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase NO_CHANGE:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n \t\t\t\t\t}\n \t\t\t\t\trup = repo.updateRef(Constants.HEAD);\n \t\t\t\t\tres = rup.link(headName);\n \t\t\t\t\tswitch (res) {\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase NO_CHANGE:\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\treturn new RebaseResult(Status.OK);\n \t\t\t}\n \t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2a7cd0086bf1bd614478c5722eac5142326e6f2b": {
			"type": "Ybodychange",
			"commitMessage": "Rebase: fix wrong update if original HEAD after Merge+Skip\n\nRebase would update the original HEAD to the wrong commit when\n\"skipping\" the last commit after a merged commit.\n\nIncludes a test for the specific situation.\n\nChange-Id: I087314b1834a3f11a4561f04ca5c21411d54d993\nSigned-off-by: Mathias Kinzler <mathias.kinzler@sap.com>\n",
			"commitDate": "2010-12-09, 11:22 AM",
			"commitName": "2a7cd0086bf1bd614478c5722eac5142326e6f2b",
			"commitAuthor": "Mathias Kinzler",
			"commitDateOld": "2010-12-09, 8:10 AM",
			"commitNameOld": "6bca46e1683a07f18f00f6ad552eab79ab50bb88",
			"commitAuthorOld": "Mathias Kinzler",
			"daysBetweenCommits": 0.13,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,89 +1,97 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n \t\tRevCommit newHead = null;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort();\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName = readFile(rebaseDir, ONTO);\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort();\n \n \t\t\tif (this.operation == Operation.CONTINUE)\n \t\t\t\tnewHead = continueRebase();\n \n-\t\t\tList<Step> steps = loadSteps();\n-\n-\t\t\tif (this.operation == Operation.SKIP && !steps.isEmpty())\n-\t\t\t\tcheckoutCurrentHead();\n+\t\t\tif (this.operation == Operation.SKIP)\n+\t\t\t\tnewHead = checkoutCurrentHead();\n \n \t\t\tObjectReader or = repo.newObjectReader();\n-\t\t\tint stepsToPop = 0;\n \n+\t\t\tList<Step> steps = loadSteps();\n \t\t\tfor (Step step : steps) {\n \t\t\t\tif (step.action != Action.PICK)\n \t\t\t\t\tcontinue;\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n \t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n \t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n \t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n \t\t\t\t// unnecessary object rewriting\n \t\t\t\tnewHead = new Git(repo).cherryPick().include(commitToPick)\n \t\t\t\t\t\t.call();\n \t\t\t\tmonitor.endTask();\n \t\t\t\tif (newHead == null) {\n \t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t}\n-\t\t\t\tstepsToPop++;\n \t\t\t}\n-\t\t\tif (newHead != null || steps.isEmpty()) {\n+\t\t\tif (newHead != null) {\n \t\t\t\t// point the previous head (if any) to the new commit\n \t\t\t\tString headName = readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n \t\t\t\t\tRefUpdate rup = repo.updateRef(headName);\n-\t\t\t\t\tif (newHead != null) {\n-\t\t\t\t\t\trup.setNewObjectId(newHead);\n-\t\t\t\t\t\trup.forceUpdate();\n+\t\t\t\t\trup.setNewObjectId(newHead);\n+\t\t\t\t\tResult res = rup.forceUpdate();\n+\t\t\t\t\tswitch (res) {\n+\t\t\t\t\tcase FAST_FORWARD:\n+\t\t\t\t\tcase FORCED:\n+\t\t\t\t\tcase NO_CHANGE:\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n \t\t\t\t\t}\n \t\t\t\t\trup = repo.updateRef(Constants.HEAD);\n-\t\t\t\t\trup.link(headName);\n-\t\t\t\t}\n-\t\t\t\tif (this.operation == Operation.SKIP && steps.isEmpty()) {\n-\t\t\t\t\tcheckoutCurrentHead();\n+\t\t\t\t\tres = rup.link(headName);\n+\t\t\t\t\tswitch (res) {\n+\t\t\t\t\tcase FAST_FORWARD:\n+\t\t\t\t\tcase FORCED:\n+\t\t\t\t\tcase NO_CHANGE:\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tthrow new JGitInternalException(\"Updating HEAD failed\");\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\treturn new RebaseResult(Status.OK);\n \t\t\t}\n \t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6bca46e1683a07f18f00f6ad552eab79ab50bb88": {
			"type": "Ybodychange",
			"commitMessage": "Implement rebase --continue and --skip\n\nFor --continue, the Rebase command asserts that there are no unmerged\npaths in the current repository. Then it checks if a commit is needed.\nIf yes, the commit message and author are taken from the author_script\nand message files, respectively, and a commit is performed before the\nnext step is applied.\nFor --skip, the workspace is reset to the current HEAD before applying\nthe next step.\n\nIncludes some tests and a refactoring that extracts Strings in the\ncode into constants.\n\n\nChange-Id: I72d9968535727046e737ec20e23239fe79976179\nSigned-off-by: Mathias Kinzler <mathias.kinzler@sap.com>\nSigned-off-by: Christian Halstrick <christian.halstrick@sap.com>\n",
			"commitDate": "2010-12-09, 8:10 AM",
			"commitName": "6bca46e1683a07f18f00f6ad552eab79ab50bb88",
			"commitAuthor": "Mathias Kinzler",
			"commitDateOld": "2010-12-07, 5:18 PM",
			"commitNameOld": "45731756a56361a51e839e26d3b0bed1c06ee37a",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 1.62,
			"commitsBetweenForRepo": 16,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,86 +1,89 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n+\t\tRevCommit newHead = null;\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort();\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n-\t\t\t\tString upstreamCommitName = readFile(rebaseDir, \"onto\");\n+\t\t\t\tString upstreamCommitName = readFile(rebaseDir, ONTO);\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort();\n \n \t\t\tif (this.operation == Operation.CONTINUE)\n-\t\t\t\tthrow new UnsupportedOperationException(\n-\t\t\t\t\t\t\"--continue Not yet implemented\");\n-\n-\t\t\tif (this.operation == Operation.SKIP)\n-\t\t\t\tthrow new UnsupportedOperationException(\n-\t\t\t\t\t\t\"--skip Not yet implemented\");\n-\n-\t\t\tRevCommit newHead = null;\n+\t\t\t\tnewHead = continueRebase();\n \n \t\t\tList<Step> steps = loadSteps();\n+\n+\t\t\tif (this.operation == Operation.SKIP && !steps.isEmpty())\n+\t\t\t\tcheckoutCurrentHead();\n+\n \t\t\tObjectReader or = repo.newObjectReader();\n \t\t\tint stepsToPop = 0;\n \n \t\t\tfor (Step step : steps) {\n \t\t\t\tif (step.action != Action.PICK)\n \t\t\t\t\tcontinue;\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n \t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n \t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n \t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n \t\t\t\t// unnecessary object rewriting\n \t\t\t\tnewHead = new Git(repo).cherryPick().include(commitToPick)\n \t\t\t\t\t\t.call();\n \t\t\t\tmonitor.endTask();\n \t\t\t\tif (newHead == null) {\n \t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t}\n \t\t\t\tstepsToPop++;\n \t\t\t}\n-\t\t\tif (newHead != null) {\n+\t\t\tif (newHead != null || steps.isEmpty()) {\n \t\t\t\t// point the previous head (if any) to the new commit\n-\t\t\t\tString headName = readFile(rebaseDir, \"head-name\");\n+\t\t\t\tString headName = readFile(rebaseDir, HEAD_NAME);\n \t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n \t\t\t\t\tRefUpdate rup = repo.updateRef(headName);\n-\t\t\t\t\trup.setNewObjectId(newHead);\n-\t\t\t\t\trup.forceUpdate();\n+\t\t\t\t\tif (newHead != null) {\n+\t\t\t\t\t\trup.setNewObjectId(newHead);\n+\t\t\t\t\t\trup.forceUpdate();\n+\t\t\t\t\t}\n \t\t\t\t\trup = repo.updateRef(Constants.HEAD);\n \t\t\t\t\trup.link(headName);\n \t\t\t\t}\n+\t\t\t\tif (this.operation == Operation.SKIP && steps.isEmpty()) {\n+\t\t\t\t\tcheckoutCurrentHead();\n+\t\t\t\t}\n \t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\treturn new RebaseResult(Status.OK);\n \t\t\t}\n \t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"45731756a56361a51e839e26d3b0bed1c06ee37a": {
			"type": "Ybodychange",
			"commitMessage": "[findbugs] Do not ignore exceptional return value\n\njava.io.File.delete() reports failure as an exceptional\nreturn value false. Fix the code which silently ignored\nthis exceptional return value. Also remove some duplicate\ndeletion helper methods.\n\nChange-Id: I80ed20ca1f07a2bc6e779957a4ad0c713789c5be\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>\n",
			"commitDate": "2010-12-07, 5:18 PM",
			"commitName": "45731756a56361a51e839e26d3b0bed1c06ee37a",
			"commitAuthor": "Matthias Sohn",
			"commitDateOld": "2010-12-07, 5:34 AM",
			"commitNameOld": "ad96546ca023c260ed7250c447f4c8abe168afd3",
			"commitAuthorOld": "Mathias Kinzler",
			"daysBetweenCommits": 0.49,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,86 +1,86 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort();\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName = readFile(rebaseDir, \"onto\");\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort();\n \n \t\t\tif (this.operation == Operation.CONTINUE)\n \t\t\t\tthrow new UnsupportedOperationException(\n \t\t\t\t\t\t\"--continue Not yet implemented\");\n \n \t\t\tif (this.operation == Operation.SKIP)\n \t\t\t\tthrow new UnsupportedOperationException(\n \t\t\t\t\t\t\"--skip Not yet implemented\");\n \n \t\t\tRevCommit newHead = null;\n \n \t\t\tList<Step> steps = loadSteps();\n \t\t\tObjectReader or = repo.newObjectReader();\n \t\t\tint stepsToPop = 0;\n \n \t\t\tfor (Step step : steps) {\n \t\t\t\tif (step.action != Action.PICK)\n \t\t\t\t\tcontinue;\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n \t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n \t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n \t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n \t\t\t\t// unnecessary object rewriting\n \t\t\t\tnewHead = new Git(repo).cherryPick().include(commitToPick)\n \t\t\t\t\t\t.call();\n \t\t\t\tmonitor.endTask();\n \t\t\t\tif (newHead == null) {\n \t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t}\n \t\t\t\tstepsToPop++;\n \t\t\t}\n \t\t\tif (newHead != null) {\n \t\t\t\t// point the previous head (if any) to the new commit\n \t\t\t\tString headName = readFile(rebaseDir, \"head-name\");\n \t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n \t\t\t\t\tRefUpdate rup = repo.updateRef(headName);\n \t\t\t\t\trup.setNewObjectId(newHead);\n \t\t\t\t\trup.forceUpdate();\n \t\t\t\t\trup = repo.updateRef(Constants.HEAD);\n \t\t\t\t\trup.link(headName);\n \t\t\t\t}\n-\t\t\t\tdeleteRecursive(rebaseDir);\n+\t\t\t\tFileUtils.delete(rebaseDir, FileUtils.RECURSIVE);\n \t\t\t\treturn new RebaseResult(Status.OK);\n \t\t\t}\n \t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ad96546ca023c260ed7250c447f4c8abe168afd3": {
			"type": "Ybodychange",
			"commitMessage": "Rebase Interoperability third part: handle stop upon conflict\n\nThere are some files that need to exist so that the CLI can continue\nafter the rebase has been stopped due to conflicts\n\nChange-Id: I3cb4dc98609c059bf0cf9fd5f9e47a9c681cea2d\nSigned-off-by: Mathias Kinzler <mathias.kinzler@sap.com>\n",
			"commitDate": "2010-12-07, 5:34 AM",
			"commitName": "ad96546ca023c260ed7250c447f4c8abe168afd3",
			"commitAuthor": "Mathias Kinzler",
			"commitDateOld": "2010-12-01, 7:10 AM",
			"commitNameOld": "59e62ba7e10188c6170bd97ffbd9c8768d9745ea",
			"commitAuthorOld": "Mathias Kinzler",
			"daysBetweenCommits": 5.93,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,86 +1,86 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort();\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName = readFile(rebaseDir, \"onto\");\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort();\n \n \t\t\tif (this.operation == Operation.CONTINUE)\n \t\t\t\tthrow new UnsupportedOperationException(\n \t\t\t\t\t\t\"--continue Not yet implemented\");\n \n \t\t\tif (this.operation == Operation.SKIP)\n \t\t\t\tthrow new UnsupportedOperationException(\n \t\t\t\t\t\t\"--skip Not yet implemented\");\n \n \t\t\tRevCommit newHead = null;\n \n \t\t\tList<Step> steps = loadSteps();\n \t\t\tObjectReader or = repo.newObjectReader();\n \t\t\tint stepsToPop = 0;\n \n \t\t\tfor (Step step : steps) {\n \t\t\t\tif (step.action != Action.PICK)\n \t\t\t\t\tcontinue;\n \t\t\t\tpopSteps(1);\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n \t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n \t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n \t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n \t\t\t\t// unnecessary object rewriting\n \t\t\t\tnewHead = new Git(repo).cherryPick().include(commitToPick)\n \t\t\t\t\t\t.call();\n \t\t\t\tmonitor.endTask();\n \t\t\t\tif (newHead == null) {\n-\t\t\t\t\treturn new RebaseResult(commitToPick);\n+\t\t\t\t\treturn stop(commitToPick);\n \t\t\t\t}\n \t\t\t\tstepsToPop++;\n \t\t\t}\n \t\t\tif (newHead != null) {\n \t\t\t\t// point the previous head (if any) to the new commit\n \t\t\t\tString headName = readFile(rebaseDir, \"head-name\");\n \t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n \t\t\t\t\tRefUpdate rup = repo.updateRef(headName);\n \t\t\t\t\trup.setNewObjectId(newHead);\n \t\t\t\t\trup.forceUpdate();\n \t\t\t\t\trup = repo.updateRef(Constants.HEAD);\n \t\t\t\t\trup.link(headName);\n \t\t\t\t}\n \t\t\t\tdeleteRecursive(rebaseDir);\n \t\t\t\treturn new RebaseResult(Status.OK);\n \t\t\t}\n \t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"59e62ba7e10188c6170bd97ffbd9c8768d9745ea": {
			"type": "Ybodychange",
			"commitMessage": "Rebase Interoperability second part: fix \"pop steps\"\n\nIf the CLI stops a rebase upon conflict, the current\nstep is already popped from the git-rebase-todo and appended to the\n\"done\" file. The current implementation wrongly pops the step only\nafter successful cherry-pick.\n\nChange-Id: I8640dda0cbb2a5271ecf75fcbad69410122eeab6\nSigned-off-by: Mathias Kinzler <mathias.kinzler@sap.com>\n",
			"commitDate": "2010-12-01, 7:10 AM",
			"commitName": "59e62ba7e10188c6170bd97ffbd9c8768d9745ea",
			"commitAuthor": "Mathias Kinzler",
			"commitDateOld": "2010-12-01, 7:08 AM",
			"commitNameOld": "7aa1b85821e007c0243772273960069497284290",
			"commitAuthorOld": "Mathias Kinzler",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,86 +1,86 @@\n \tpublic RebaseResult call() throws NoHeadException, RefNotFoundException,\n \t\t\tJGitInternalException, GitAPIException {\n \t\tcheckCallable();\n \t\tcheckParameters();\n \t\ttry {\n \t\t\tswitch (operation) {\n \t\t\tcase ABORT:\n \t\t\t\ttry {\n \t\t\t\t\treturn abort();\n \t\t\t\t} catch (IOException ioe) {\n \t\t\t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t\t\t}\n \t\t\tcase SKIP:\n \t\t\t\t// fall through\n \t\t\tcase CONTINUE:\n \t\t\t\tString upstreamCommitName = readFile(rebaseDir, \"onto\");\n \t\t\t\tthis.upstreamCommit = walk.parseCommit(repo\n \t\t\t\t\t\t.resolve(upstreamCommitName));\n \t\t\t\tbreak;\n \t\t\tcase BEGIN:\n \t\t\t\tRebaseResult res = initFilesAndRewind();\n \t\t\t\tif (res != null)\n \t\t\t\t\treturn res;\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\treturn abort();\n \n \t\t\tif (this.operation == Operation.CONTINUE)\n \t\t\t\tthrow new UnsupportedOperationException(\n \t\t\t\t\t\t\"--continue Not yet implemented\");\n \n \t\t\tif (this.operation == Operation.SKIP)\n \t\t\t\tthrow new UnsupportedOperationException(\n \t\t\t\t\t\t\"--skip Not yet implemented\");\n \n \t\t\tRevCommit newHead = null;\n \n \t\t\tList<Step> steps = loadSteps();\n \t\t\tObjectReader or = repo.newObjectReader();\n \t\t\tint stepsToPop = 0;\n \n \t\t\tfor (Step step : steps) {\n \t\t\t\tif (step.action != Action.PICK)\n \t\t\t\t\tcontinue;\n+\t\t\t\tpopSteps(1);\n \t\t\t\tCollection<ObjectId> ids = or.resolve(step.commit);\n \t\t\t\tif (ids.size() != 1)\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\t\"Could not resolve uniquely the abbreviated object ID\");\n \t\t\t\tRevCommit commitToPick = walk\n \t\t\t\t\t\t.parseCommit(ids.iterator().next());\n \t\t\t\tif (monitor.isCancelled())\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\tmonitor.beginTask(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().applyingCommit, commitToPick\n \t\t\t\t\t\t\t\t.getShortMessage()), ProgressMonitor.UNKNOWN);\n \t\t\t\t// TODO if the first parent of commitToPick is the current HEAD,\n \t\t\t\t// we should fast-forward instead of cherry-pick to avoid\n \t\t\t\t// unnecessary object rewriting\n \t\t\t\tnewHead = new Git(repo).cherryPick().include(commitToPick)\n \t\t\t\t\t\t.call();\n \t\t\t\tmonitor.endTask();\n \t\t\t\tif (newHead == null) {\n-\t\t\t\t\tpopSteps(stepsToPop);\n \t\t\t\t\treturn new RebaseResult(commitToPick);\n \t\t\t\t}\n \t\t\t\tstepsToPop++;\n \t\t\t}\n \t\t\tif (newHead != null) {\n \t\t\t\t// point the previous head (if any) to the new commit\n \t\t\t\tString headName = readFile(rebaseDir, \"head-name\");\n \t\t\t\tif (headName.startsWith(Constants.R_REFS)) {\n \t\t\t\t\tRefUpdate rup = repo.updateRef(headName);\n \t\t\t\t\trup.setNewObjectId(newHead);\n \t\t\t\t\trup.forceUpdate();\n \t\t\t\t\trup = repo.updateRef(Constants.HEAD);\n \t\t\t\t\trup.link(headName);\n \t\t\t\t}\n \t\t\t\tdeleteRecursive(rebaseDir);\n \t\t\t\treturn new RebaseResult(Status.OK);\n \t\t\t}\n \t\t\treturn new RebaseResult(Status.UP_TO_DATE);\n \t\t} catch (IOException ioe) {\n \t\t\tthrow new JGitInternalException(ioe.getMessage(), ioe);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e5b96a7848d680cf50123a44cbc147db91d798d3": {
			"type": "Yintroduced",
			"commitMessage": "Initial implementation of a Rebase command\n\nThis is a first iteration to implement Rebase. At the moment, this\ndoes not implement --continue and --skip, so if the first\nconflict is found, the only option is to --abort the command.\n\nBug: 328217\nChange-Id: I24d60c0214e71e5572955f8261e10a42e9e95298\nSigned-off-by: Mathias Kinzler <mathias.kinzler@sap.com>\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
			"commitDate": "2010-11-22, 8:58 AM",
			"commitName": "e5b96a7848d680cf50123a44cbc147db91d798d3",
			"commitAuthor": "Mathias Kinzler"
		}
	},
	"sha": "bd1a82502680b5de5bf86f6c4470185fd1602386"
}