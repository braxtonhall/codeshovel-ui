{
	"repo": "https://github.com/eclipse/jgit.git",
	"file": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
	"method": {
		"longName": "PackWriter::findObjectsToPack(ProgressMonitor countingMonitor, ObjectWalk walker, Set<? extends ObjectId> want, Set<? extends ObjectId> have, Set<? extends ObjectId> noBitmaps)",
		"startLine": 1775,
		"methodName": "findObjectsToPack",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "private"
	},
	"history": {
		"32798dcfdb00662a640f0ff2915766591d21e287": {
			"type": "Ybodychange",
			"commitMessage": "Always send refs' objects despite \"filter\" in pack\n\nIn a0c9016abd (\"upload-pack: send refs' objects despite \"filter\"\",\n2018-07-09), Git updated the \"filter\" option in the fetch-pack\nupload-pack protocol to not filter objects explicitly specified in\n\"want\" lines, even if they match the criterion of the filter. Update\nJGit to match that behavior.\n\nChange-Id: Ia4d74326edb89e61062e397e05483298c50f9232\nSigned-off-by: Jonathan Tan <jonathantanmy@google.com>\n",
			"commitDate": "2018-07-20, 6:09 PM",
			"commitName": "32798dcfdb00662a640f0ff2915766591d21e287",
			"commitAuthor": "Jonathan Tan",
			"commitDateOld": "2018-05-18, 9:59 AM",
			"commitNameOld": "f3ec7cf3f0436a79e252251a31dbc62694555897",
			"commitAuthorOld": "Han-Wen Nienhuys",
			"daysBetweenCommits": 63.34,
			"commitsBetweenForRepo": 88,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,219 +1,219 @@\n \tprivate void findObjectsToPack(@NonNull ProgressMonitor countingMonitor,\n \t\t\t@NonNull ObjectWalk walker, @NonNull Set<? extends ObjectId> want,\n \t\t\t@NonNull Set<? extends ObjectId> have,\n \t\t\t@NonNull Set<? extends ObjectId> noBitmaps) throws IOException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tbeginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \t\texcludeFromBitmapSelection = noBitmaps;\n \n \t\tcanBuildBitmaps = config.isBuildBitmaps()\n \t\t\t\t&& !shallowPack\n \t\t\t\t&& have.isEmpty()\n \t\t\t\t&& (excludeInPacks == null || excludeInPacks.length == 0);\n \t\tif (!shallowPack && useBitmaps) {\n \t\t\tBitmapIndex bitmapIndex = reader.getBitmapIndex();\n \t\t\tif (bitmapIndex != null) {\n \t\t\t\tBitmapWalker bitmapWalker = new BitmapWalker(\n \t\t\t\t\t\twalker, bitmapIndex, countingMonitor);\n \t\t\t\tfindObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n \t\t\t\tendPhase(countingMonitor);\n \t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\tstats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tList<ObjectId> all = new ArrayList<>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal RevFlag include = walker.newFlag(\"include\"); //$NON-NLS-1$\n \t\tfinal RevFlag added = walker.newFlag(\"added\"); //$NON-NLS-1$\n \n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<>(want.size());\n \n \t\t// Retrieve the RevWalk's versions of \"want\" and \"have\" objects to\n \t\t// maintain any state previously set in the RevWalk.\n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\tif (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tif (walker instanceof DepthWalk.ObjectWalk) {\n \t\t\tDepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n \t\t\tfor (RevObject obj : wantObjs) {\n \t\t\t\tdepthWalk.markRoot(obj);\n \t\t\t}\n \t\t\t// Mark the tree objects associated with \"have\" commits as\n \t\t\t// uninteresting to avoid writing redundant blobs. A normal RevWalk\n \t\t\t// lazily propagates the \"uninteresting\" state from a commit to its\n \t\t\t// tree during the walk, but DepthWalks can terminate early so\n \t\t\t// preemptively propagate that state here.\n \t\t\tfor (RevObject obj : haveObjs) {\n \t\t\t\tif (obj instanceof RevCommit) {\n \t\t\t\t\tRevTree t = ((RevCommit) obj).getTree();\n \t\t\t\t\tdepthWalk.markUninteresting(t);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (unshallowObjects != null) {\n \t\t\t\tfor (ObjectId id : unshallowObjects) {\n \t\t\t\t\tdepthWalk.markUnshallow(walker.parseAny(id));\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\twalker.markStart(obj);\n \t\t}\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<>();\n \t\tBlockList<RevCommit> commits = new BlockList<>();\n \t\tSet<ObjectId> roots = new HashSet<>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (exclude(c))\n \t\t\t\tcontinue;\n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tif (c.getParentCount() == 0) {\n \t\t\t\troots.add(c.copy());\n \t\t\t}\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\tstats.rootCommits = Collections.unmodifiableSet(roots);\n \n \t\tif (shallowPack) {\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \t\t} else {\n \t\t\tint commitCnt = 0;\n \t\t\tboolean putTagTargets = false;\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\tif (!cmit.has(added)) {\n \t\t\t\t\tcmit.add(added);\n \t\t\t\t\taddObject(cmit, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !exclude(p)) {\n \t\t\t\t\t\tp.add(added);\n \t\t\t\t\t\taddObject(p, 0);\n \t\t\t\t\t\tcommitCnt++;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tputTagTargets = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n-\t\t\t\tfilterAndAddObject(o, o.getType(), pathHash);\n+\t\t\t\tfilterAndAddObject(o, o.getType(), pathHash, want);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n-\t\t\t\tfilterAndAddObject(o, o.getType(), walker.getPathHashCode());\n+\t\t\t\tfilterAndAddObject(o, o.getType(), walker.getPathHashCode(), want);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tendPhase(countingMonitor);\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\tstats.bitmapIndexMisses = -1;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4ac32e79b751944107470d5f4cb290eacd1b7cf9": {
			"type": "Ybodychange",
			"commitMessage": "Teach UploadPack to support filtering by blob size\n\nTeach UploadPack to advertise the filter capability and support a\n\"filter\" line in the request, accepting blob sizes only, if the\nconfiguration variable \"uploadpack.allowfilter\" is true. This feature is\ncurrently in the \"master\" branch of Git, and as of the time of writing,\nthis feature is to be released in Git 2.17.\n\nThis is incomplete in that the filter-by-sparse-specification feature\nalso supported by Git is not included in this patch.\n\nIf a JGit server were to be patched with this commit, and a repository\non that server configured with RequestPolicy.ANY or\nRequestPolicy.REACHABLE_COMMIT_TIP, a Git client built from the \"master\"\nbranch would be able to perform a partial clone.\n\nChange-Id: If72b4b422c06ab432137e9e5272d353b14b73259\nSigned-off-by: Jonathan Tan <jonathantanmy@google.com>\n",
			"commitDate": "2018-03-15, 2:46 PM",
			"commitName": "4ac32e79b751944107470d5f4cb290eacd1b7cf9",
			"commitAuthor": "Jonathan Tan",
			"commitDateOld": "2018-03-10, 11:38 AM",
			"commitNameOld": "cc19f649666704e5bf0184d3839be0c0c17439fc",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 5.09,
			"commitsBetweenForRepo": 48,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,219 +1,219 @@\n \tprivate void findObjectsToPack(@NonNull ProgressMonitor countingMonitor,\n \t\t\t@NonNull ObjectWalk walker, @NonNull Set<? extends ObjectId> want,\n \t\t\t@NonNull Set<? extends ObjectId> have,\n \t\t\t@NonNull Set<? extends ObjectId> noBitmaps) throws IOException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tbeginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \t\texcludeFromBitmapSelection = noBitmaps;\n \n \t\tcanBuildBitmaps = config.isBuildBitmaps()\n \t\t\t\t&& !shallowPack\n \t\t\t\t&& have.isEmpty()\n \t\t\t\t&& (excludeInPacks == null || excludeInPacks.length == 0);\n \t\tif (!shallowPack && useBitmaps) {\n \t\t\tBitmapIndex bitmapIndex = reader.getBitmapIndex();\n \t\t\tif (bitmapIndex != null) {\n \t\t\t\tBitmapWalker bitmapWalker = new BitmapWalker(\n \t\t\t\t\t\twalker, bitmapIndex, countingMonitor);\n \t\t\t\tfindObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n \t\t\t\tendPhase(countingMonitor);\n \t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\tstats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tList<ObjectId> all = new ArrayList<>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal RevFlag include = walker.newFlag(\"include\"); //$NON-NLS-1$\n \t\tfinal RevFlag added = walker.newFlag(\"added\"); //$NON-NLS-1$\n \n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<>(want.size());\n \n \t\t// Retrieve the RevWalk's versions of \"want\" and \"have\" objects to\n \t\t// maintain any state previously set in the RevWalk.\n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\tif (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tif (walker instanceof DepthWalk.ObjectWalk) {\n \t\t\tDepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n \t\t\tfor (RevObject obj : wantObjs) {\n \t\t\t\tdepthWalk.markRoot(obj);\n \t\t\t}\n \t\t\t// Mark the tree objects associated with \"have\" commits as\n \t\t\t// uninteresting to avoid writing redundant blobs. A normal RevWalk\n \t\t\t// lazily propagates the \"uninteresting\" state from a commit to its\n \t\t\t// tree during the walk, but DepthWalks can terminate early so\n \t\t\t// preemptively propagate that state here.\n \t\t\tfor (RevObject obj : haveObjs) {\n \t\t\t\tif (obj instanceof RevCommit) {\n \t\t\t\t\tRevTree t = ((RevCommit) obj).getTree();\n \t\t\t\t\tdepthWalk.markUninteresting(t);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (unshallowObjects != null) {\n \t\t\t\tfor (ObjectId id : unshallowObjects) {\n \t\t\t\t\tdepthWalk.markUnshallow(walker.parseAny(id));\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\twalker.markStart(obj);\n \t\t}\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<>();\n \t\tBlockList<RevCommit> commits = new BlockList<>();\n \t\tSet<ObjectId> roots = new HashSet<>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (exclude(c))\n \t\t\t\tcontinue;\n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tif (c.getParentCount() == 0) {\n \t\t\t\troots.add(c.copy());\n \t\t\t}\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\tstats.rootCommits = Collections.unmodifiableSet(roots);\n \n \t\tif (shallowPack) {\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \t\t} else {\n \t\t\tint commitCnt = 0;\n \t\t\tboolean putTagTargets = false;\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\tif (!cmit.has(added)) {\n \t\t\t\t\tcmit.add(added);\n \t\t\t\t\taddObject(cmit, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !exclude(p)) {\n \t\t\t\t\t\tp.add(added);\n \t\t\t\t\t\taddObject(p, 0);\n \t\t\t\t\t\tcommitCnt++;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tputTagTargets = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n-\t\t\t\taddObject(o, pathHash);\n+\t\t\t\tfilterAndAddObject(o, o.getType(), pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n-\t\t\t\taddObject(o, walker.getPathHashCode());\n+\t\t\t\tfilterAndAddObject(o, o.getType(), walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tendPhase(countingMonitor);\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\tstats.bitmapIndexMisses = -1;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ccf25f95411d7faae7b7aa5a75d74c62e6c47e07": {
			"type": "Ybodychange",
			"commitMessage": "Make PackWriterBitmapWalker public\n\nMake PackWriterBitmapWriter class public and move it to a more central\nlocation, in preparation for its use by another class (in a subsequent\ncommit).\n\nOne of its inner static classes, AddUnseenToBitmapFilter, previously\npackage-private, is also used directly in its former package. Therefore,\nAddUnseenToBitmapFilter and its sibling class have been moved to an\ninternal package instead.\n\nChange-Id: I740bc4bfc4e4e3c857d1ee7d25fe45e90cd22a75\nSigned-off-by: Jonathan Tan <jonathantanmy@google.com>\n",
			"commitDate": "2017-11-10, 4:41 PM",
			"commitName": "ccf25f95411d7faae7b7aa5a75d74c62e6c47e07",
			"commitAuthor": "Jonathan Tan",
			"commitDateOld": "2017-05-18, 4:25 PM",
			"commitNameOld": "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1",
			"commitAuthorOld": "Terry Parker",
			"daysBetweenCommits": 176.05,
			"commitsBetweenForRepo": 211,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,219 +1,219 @@\n \tprivate void findObjectsToPack(@NonNull ProgressMonitor countingMonitor,\n \t\t\t@NonNull ObjectWalk walker, @NonNull Set<? extends ObjectId> want,\n \t\t\t@NonNull Set<? extends ObjectId> have,\n \t\t\t@NonNull Set<? extends ObjectId> noBitmaps) throws IOException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tbeginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \t\texcludeFromBitmapSelection = noBitmaps;\n \n \t\tcanBuildBitmaps = config.isBuildBitmaps()\n \t\t\t\t&& !shallowPack\n \t\t\t\t&& have.isEmpty()\n \t\t\t\t&& (excludeInPacks == null || excludeInPacks.length == 0);\n \t\tif (!shallowPack && useBitmaps) {\n \t\t\tBitmapIndex bitmapIndex = reader.getBitmapIndex();\n \t\t\tif (bitmapIndex != null) {\n-\t\t\t\tPackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(\n+\t\t\t\tBitmapWalker bitmapWalker = new BitmapWalker(\n \t\t\t\t\t\twalker, bitmapIndex, countingMonitor);\n \t\t\t\tfindObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n \t\t\t\tendPhase(countingMonitor);\n \t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\tstats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tList<ObjectId> all = new ArrayList<>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal RevFlag include = walker.newFlag(\"include\"); //$NON-NLS-1$\n \t\tfinal RevFlag added = walker.newFlag(\"added\"); //$NON-NLS-1$\n \n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<>(want.size());\n \n \t\t// Retrieve the RevWalk's versions of \"want\" and \"have\" objects to\n \t\t// maintain any state previously set in the RevWalk.\n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\tif (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tif (walker instanceof DepthWalk.ObjectWalk) {\n \t\t\tDepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n \t\t\tfor (RevObject obj : wantObjs) {\n \t\t\t\tdepthWalk.markRoot(obj);\n \t\t\t}\n \t\t\t// Mark the tree objects associated with \"have\" commits as\n \t\t\t// uninteresting to avoid writing redundant blobs. A normal RevWalk\n \t\t\t// lazily propagates the \"uninteresting\" state from a commit to its\n \t\t\t// tree during the walk, but DepthWalks can terminate early so\n \t\t\t// preemptively propagate that state here.\n \t\t\tfor (RevObject obj : haveObjs) {\n \t\t\t\tif (obj instanceof RevCommit) {\n \t\t\t\t\tRevTree t = ((RevCommit) obj).getTree();\n \t\t\t\t\tdepthWalk.markUninteresting(t);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (unshallowObjects != null) {\n \t\t\t\tfor (ObjectId id : unshallowObjects) {\n \t\t\t\t\tdepthWalk.markUnshallow(walker.parseAny(id));\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\twalker.markStart(obj);\n \t\t}\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<>();\n \t\tBlockList<RevCommit> commits = new BlockList<>();\n \t\tSet<ObjectId> roots = new HashSet<>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (exclude(c))\n \t\t\t\tcontinue;\n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tif (c.getParentCount() == 0) {\n \t\t\t\troots.add(c.copy());\n \t\t\t}\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\tstats.rootCommits = Collections.unmodifiableSet(roots);\n \n \t\tif (shallowPack) {\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \t\t} else {\n \t\t\tint commitCnt = 0;\n \t\t\tboolean putTagTargets = false;\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\tif (!cmit.has(added)) {\n \t\t\t\t\tcmit.add(added);\n \t\t\t\t\taddObject(cmit, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !exclude(p)) {\n \t\t\t\t\t\tp.add(added);\n \t\t\t\t\t\taddObject(p, 0);\n \t\t\t\t\t\tcommitCnt++;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tputTagTargets = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\t\taddObject(o, pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \t\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tendPhase(countingMonitor);\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\tstats.bitmapIndexMisses = -1;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Exclude refs/tags from bitmap commit selection\n\nCommit db77610 ensured that all refs/tags commits are added to the\nprimary GC pack. It did that by adding all of the refs/tags commits\nto the primary GC pack PackWriter's \"interesting\" object set.\n\nUnfortunately, all commit objects in the \"interesting\" set are\nselected as commits for which bitmap indices will be built. In a\nrepository like chromium with lots of tags, this changed the number of\nbitmaps created from <700 to >10000. That puts huge memory pressure on\nthe GC task.\n\nThis change restores the original behavior of ignoring tags when\nselecting commits for bitmaps.\n\nIn the \"uninteresting\" set, commits for refs/heads and refs/tags for\nunannotated tags can not be differentiated. We instead identify\nrefs/tags commits by passing their ObjectIds as a new \"noBitmaps\"\nparameter to the PackWriter.preparePack() methods.\nPackWriterBitmapPreparer.setupTipCommitBitmaps() can then use that\n\"noBitmaps\" parameter to exclude those commits.\n\nChange-Id: Icd287c6b04fc1e48de773033fe432a9b0e904ac5\nSigned-off-by: Terry Parker <tparker@google.com>\n",
			"commitDate": "2017-05-18, 4:25 PM",
			"commitName": "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1",
			"commitAuthor": "Terry Parker",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Exclude refs/tags from bitmap commit selection\n\nCommit db77610 ensured that all refs/tags commits are added to the\nprimary GC pack. It did that by adding all of the refs/tags commits\nto the primary GC pack PackWriter's \"interesting\" object set.\n\nUnfortunately, all commit objects in the \"interesting\" set are\nselected as commits for which bitmap indices will be built. In a\nrepository like chromium with lots of tags, this changed the number of\nbitmaps created from <700 to >10000. That puts huge memory pressure on\nthe GC task.\n\nThis change restores the original behavior of ignoring tags when\nselecting commits for bitmaps.\n\nIn the \"uninteresting\" set, commits for refs/heads and refs/tags for\nunannotated tags can not be differentiated. We instead identify\nrefs/tags commits by passing their ObjectIds as a new \"noBitmaps\"\nparameter to the PackWriter.preparePack() methods.\nPackWriterBitmapPreparer.setupTipCommitBitmaps() can then use that\n\"noBitmaps\" parameter to exclude those commits.\n\nChange-Id: Icd287c6b04fc1e48de773033fe432a9b0e904ac5\nSigned-off-by: Terry Parker <tparker@google.com>\n",
					"commitDate": "2017-05-18, 4:25 PM",
					"commitName": "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1",
					"commitAuthor": "Terry Parker",
					"commitDateOld": "2017-05-03, 4:02 PM",
					"commitNameOld": "8f7d0a4fbe8862e71d900b0585c97407037ef9a5",
					"commitAuthorOld": "Zhen Chen",
					"daysBetweenCommits": 15.02,
					"commitsBetweenForRepo": 14,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,217 +1,219 @@\n \tprivate void findObjectsToPack(@NonNull ProgressMonitor countingMonitor,\n \t\t\t@NonNull ObjectWalk walker, @NonNull Set<? extends ObjectId> want,\n-\t\t\t@NonNull Set<? extends ObjectId> have) throws IOException {\n+\t\t\t@NonNull Set<? extends ObjectId> have,\n+\t\t\t@NonNull Set<? extends ObjectId> noBitmaps) throws IOException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tbeginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n+\t\texcludeFromBitmapSelection = noBitmaps;\n \n \t\tcanBuildBitmaps = config.isBuildBitmaps()\n \t\t\t\t&& !shallowPack\n \t\t\t\t&& have.isEmpty()\n \t\t\t\t&& (excludeInPacks == null || excludeInPacks.length == 0);\n \t\tif (!shallowPack && useBitmaps) {\n \t\t\tBitmapIndex bitmapIndex = reader.getBitmapIndex();\n \t\t\tif (bitmapIndex != null) {\n \t\t\t\tPackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(\n \t\t\t\t\t\twalker, bitmapIndex, countingMonitor);\n \t\t\t\tfindObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n \t\t\t\tendPhase(countingMonitor);\n \t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\tstats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tList<ObjectId> all = new ArrayList<>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal RevFlag include = walker.newFlag(\"include\"); //$NON-NLS-1$\n \t\tfinal RevFlag added = walker.newFlag(\"added\"); //$NON-NLS-1$\n \n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<>(want.size());\n \n \t\t// Retrieve the RevWalk's versions of \"want\" and \"have\" objects to\n \t\t// maintain any state previously set in the RevWalk.\n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\tif (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tif (walker instanceof DepthWalk.ObjectWalk) {\n \t\t\tDepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n \t\t\tfor (RevObject obj : wantObjs) {\n \t\t\t\tdepthWalk.markRoot(obj);\n \t\t\t}\n \t\t\t// Mark the tree objects associated with \"have\" commits as\n \t\t\t// uninteresting to avoid writing redundant blobs. A normal RevWalk\n \t\t\t// lazily propagates the \"uninteresting\" state from a commit to its\n \t\t\t// tree during the walk, but DepthWalks can terminate early so\n \t\t\t// preemptively propagate that state here.\n \t\t\tfor (RevObject obj : haveObjs) {\n \t\t\t\tif (obj instanceof RevCommit) {\n \t\t\t\t\tRevTree t = ((RevCommit) obj).getTree();\n \t\t\t\t\tdepthWalk.markUninteresting(t);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (unshallowObjects != null) {\n \t\t\t\tfor (ObjectId id : unshallowObjects) {\n \t\t\t\t\tdepthWalk.markUnshallow(walker.parseAny(id));\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\twalker.markStart(obj);\n \t\t}\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<>();\n \t\tBlockList<RevCommit> commits = new BlockList<>();\n \t\tSet<ObjectId> roots = new HashSet<>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (exclude(c))\n \t\t\t\tcontinue;\n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tif (c.getParentCount() == 0) {\n \t\t\t\troots.add(c.copy());\n \t\t\t}\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\tstats.rootCommits = Collections.unmodifiableSet(roots);\n \n \t\tif (shallowPack) {\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \t\t} else {\n \t\t\tint commitCnt = 0;\n \t\t\tboolean putTagTargets = false;\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\tif (!cmit.has(added)) {\n \t\t\t\t\tcmit.add(added);\n \t\t\t\t\taddObject(cmit, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !exclude(p)) {\n \t\t\t\t\t\tp.add(added);\n \t\t\t\t\t\taddObject(p, 0);\n \t\t\t\t\t\tcommitCnt++;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tputTagTargets = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\t\taddObject(o, pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \t\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tendPhase(countingMonitor);\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\tstats.bitmapIndexMisses = -1;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[countingMonitor-ProgressMonitor(annotations-@NonNull), walker-ObjectWalk(annotations-@NonNull), want-Set<? extends ObjectId>(annotations-@NonNull), have-Set<? extends ObjectId>(annotations-@NonNull)]",
						"newValue": "[countingMonitor-ProgressMonitor(annotations-@NonNull), walker-ObjectWalk(annotations-@NonNull), want-Set<? extends ObjectId>(annotations-@NonNull), have-Set<? extends ObjectId>(annotations-@NonNull), noBitmaps-Set<? extends ObjectId>(annotations-@NonNull)]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Exclude refs/tags from bitmap commit selection\n\nCommit db77610 ensured that all refs/tags commits are added to the\nprimary GC pack. It did that by adding all of the refs/tags commits\nto the primary GC pack PackWriter's \"interesting\" object set.\n\nUnfortunately, all commit objects in the \"interesting\" set are\nselected as commits for which bitmap indices will be built. In a\nrepository like chromium with lots of tags, this changed the number of\nbitmaps created from <700 to >10000. That puts huge memory pressure on\nthe GC task.\n\nThis change restores the original behavior of ignoring tags when\nselecting commits for bitmaps.\n\nIn the \"uninteresting\" set, commits for refs/heads and refs/tags for\nunannotated tags can not be differentiated. We instead identify\nrefs/tags commits by passing their ObjectIds as a new \"noBitmaps\"\nparameter to the PackWriter.preparePack() methods.\nPackWriterBitmapPreparer.setupTipCommitBitmaps() can then use that\n\"noBitmaps\" parameter to exclude those commits.\n\nChange-Id: Icd287c6b04fc1e48de773033fe432a9b0e904ac5\nSigned-off-by: Terry Parker <tparker@google.com>\n",
					"commitDate": "2017-05-18, 4:25 PM",
					"commitName": "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1",
					"commitAuthor": "Terry Parker",
					"commitDateOld": "2017-05-03, 4:02 PM",
					"commitNameOld": "8f7d0a4fbe8862e71d900b0585c97407037ef9a5",
					"commitAuthorOld": "Zhen Chen",
					"daysBetweenCommits": 15.02,
					"commitsBetweenForRepo": 14,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,217 +1,219 @@\n \tprivate void findObjectsToPack(@NonNull ProgressMonitor countingMonitor,\n \t\t\t@NonNull ObjectWalk walker, @NonNull Set<? extends ObjectId> want,\n-\t\t\t@NonNull Set<? extends ObjectId> have) throws IOException {\n+\t\t\t@NonNull Set<? extends ObjectId> have,\n+\t\t\t@NonNull Set<? extends ObjectId> noBitmaps) throws IOException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tbeginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n+\t\texcludeFromBitmapSelection = noBitmaps;\n \n \t\tcanBuildBitmaps = config.isBuildBitmaps()\n \t\t\t\t&& !shallowPack\n \t\t\t\t&& have.isEmpty()\n \t\t\t\t&& (excludeInPacks == null || excludeInPacks.length == 0);\n \t\tif (!shallowPack && useBitmaps) {\n \t\t\tBitmapIndex bitmapIndex = reader.getBitmapIndex();\n \t\t\tif (bitmapIndex != null) {\n \t\t\t\tPackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(\n \t\t\t\t\t\twalker, bitmapIndex, countingMonitor);\n \t\t\t\tfindObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n \t\t\t\tendPhase(countingMonitor);\n \t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\tstats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tList<ObjectId> all = new ArrayList<>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal RevFlag include = walker.newFlag(\"include\"); //$NON-NLS-1$\n \t\tfinal RevFlag added = walker.newFlag(\"added\"); //$NON-NLS-1$\n \n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<>(want.size());\n \n \t\t// Retrieve the RevWalk's versions of \"want\" and \"have\" objects to\n \t\t// maintain any state previously set in the RevWalk.\n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\tif (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tif (walker instanceof DepthWalk.ObjectWalk) {\n \t\t\tDepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n \t\t\tfor (RevObject obj : wantObjs) {\n \t\t\t\tdepthWalk.markRoot(obj);\n \t\t\t}\n \t\t\t// Mark the tree objects associated with \"have\" commits as\n \t\t\t// uninteresting to avoid writing redundant blobs. A normal RevWalk\n \t\t\t// lazily propagates the \"uninteresting\" state from a commit to its\n \t\t\t// tree during the walk, but DepthWalks can terminate early so\n \t\t\t// preemptively propagate that state here.\n \t\t\tfor (RevObject obj : haveObjs) {\n \t\t\t\tif (obj instanceof RevCommit) {\n \t\t\t\t\tRevTree t = ((RevCommit) obj).getTree();\n \t\t\t\t\tdepthWalk.markUninteresting(t);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (unshallowObjects != null) {\n \t\t\t\tfor (ObjectId id : unshallowObjects) {\n \t\t\t\t\tdepthWalk.markUnshallow(walker.parseAny(id));\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\twalker.markStart(obj);\n \t\t}\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<>();\n \t\tBlockList<RevCommit> commits = new BlockList<>();\n \t\tSet<ObjectId> roots = new HashSet<>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (exclude(c))\n \t\t\t\tcontinue;\n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tif (c.getParentCount() == 0) {\n \t\t\t\troots.add(c.copy());\n \t\t\t}\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\tstats.rootCommits = Collections.unmodifiableSet(roots);\n \n \t\tif (shallowPack) {\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \t\t} else {\n \t\t\tint commitCnt = 0;\n \t\t\tboolean putTagTargets = false;\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\tif (!cmit.has(added)) {\n \t\t\t\t\tcmit.add(added);\n \t\t\t\t\taddObject(cmit, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !exclude(p)) {\n \t\t\t\t\t\tp.add(added);\n \t\t\t\t\t\taddObject(p, 0);\n \t\t\t\t\t\tcommitCnt++;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tputTagTargets = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\t\taddObject(o, pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \t\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tendPhase(countingMonitor);\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\tstats.bitmapIndexMisses = -1;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": {
			"type": "Ybodychange",
			"commitMessage": "Enable and fix warnings about redundant specification of type arguments\n\nSince the introduction of generic type parameter inference in Java 7,\nit's not necessary to explicitly specify the type of generic parameters.\n\nEnable the warning in Eclipse, and fix all occurrences.\n\nChange-Id: I9158caf1beca5e4980b6240ac401f3868520aad0\nSigned-off-by: David Pursehouse <david.pursehouse@gmail.com>\n",
			"commitDate": "2017-02-20, 2:47 PM",
			"commitName": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
			"commitAuthor": "David Pursehouse",
			"commitDateOld": "2017-02-19, 5:05 PM",
			"commitNameOld": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
			"commitAuthorOld": "David Pursehouse",
			"daysBetweenCommits": 0.9,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,217 +1,217 @@\n \tprivate void findObjectsToPack(@NonNull ProgressMonitor countingMonitor,\n \t\t\t@NonNull ObjectWalk walker, @NonNull Set<? extends ObjectId> want,\n \t\t\t@NonNull Set<? extends ObjectId> have) throws IOException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tbeginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tcanBuildBitmaps = config.isBuildBitmaps()\n \t\t\t\t&& !shallowPack\n \t\t\t\t&& have.isEmpty()\n \t\t\t\t&& (excludeInPacks == null || excludeInPacks.length == 0);\n \t\tif (!shallowPack && useBitmaps) {\n \t\t\tBitmapIndex bitmapIndex = reader.getBitmapIndex();\n \t\t\tif (bitmapIndex != null) {\n \t\t\t\tPackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(\n \t\t\t\t\t\twalker, bitmapIndex, countingMonitor);\n \t\t\t\tfindObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n \t\t\t\tendPhase(countingMonitor);\n \t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\tstats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n-\t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n+\t\tList<ObjectId> all = new ArrayList<>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal RevFlag include = walker.newFlag(\"include\"); //$NON-NLS-1$\n \t\tfinal RevFlag added = walker.newFlag(\"added\"); //$NON-NLS-1$\n \n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n-\t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n-\t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n-\t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n+\t\tList<RevObject> wantObjs = new ArrayList<>(want.size());\n+\t\tList<RevObject> haveObjs = new ArrayList<>(haveEst);\n+\t\tList<RevTag> wantTags = new ArrayList<>(want.size());\n \n \t\t// Retrieve the RevWalk's versions of \"want\" and \"have\" objects to\n \t\t// maintain any state previously set in the RevWalk.\n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\tif (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n-\t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n+\t\t\tall = new ArrayList<>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tif (walker instanceof DepthWalk.ObjectWalk) {\n \t\t\tDepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n \t\t\tfor (RevObject obj : wantObjs) {\n \t\t\t\tdepthWalk.markRoot(obj);\n \t\t\t}\n \t\t\t// Mark the tree objects associated with \"have\" commits as\n \t\t\t// uninteresting to avoid writing redundant blobs. A normal RevWalk\n \t\t\t// lazily propagates the \"uninteresting\" state from a commit to its\n \t\t\t// tree during the walk, but DepthWalks can terminate early so\n \t\t\t// preemptively propagate that state here.\n \t\t\tfor (RevObject obj : haveObjs) {\n \t\t\t\tif (obj instanceof RevCommit) {\n \t\t\t\t\tRevTree t = ((RevCommit) obj).getTree();\n \t\t\t\t\tdepthWalk.markUninteresting(t);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (unshallowObjects != null) {\n \t\t\t\tfor (ObjectId id : unshallowObjects) {\n \t\t\t\t\tdepthWalk.markUnshallow(walker.parseAny(id));\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\twalker.markStart(obj);\n \t\t}\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n-\t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n-\t\tBlockList<RevCommit> commits = new BlockList<RevCommit>();\n+\t\tSet<RevTree> baseTrees = new HashSet<>();\n+\t\tBlockList<RevCommit> commits = new BlockList<>();\n \t\tSet<ObjectId> roots = new HashSet<>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (exclude(c))\n \t\t\t\tcontinue;\n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tif (c.getParentCount() == 0) {\n \t\t\t\troots.add(c.copy());\n \t\t\t}\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\tstats.rootCommits = Collections.unmodifiableSet(roots);\n \n \t\tif (shallowPack) {\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \t\t} else {\n \t\t\tint commitCnt = 0;\n \t\t\tboolean putTagTargets = false;\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\tif (!cmit.has(added)) {\n \t\t\t\t\tcmit.add(added);\n \t\t\t\t\taddObject(cmit, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !exclude(p)) {\n \t\t\t\t\t\tp.add(added);\n \t\t\t\t\t\taddObject(p, 0);\n \t\t\t\t\t\tcommitCnt++;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tputTagTargets = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\t\taddObject(o, pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \t\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tendPhase(countingMonitor);\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\tstats.bitmapIndexMisses = -1;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d385a7a5e5cacd875da4301ddeb46a7c56a725fa": {
			"type": "Ybodychange",
			"commitMessage": "Shallow fetch: Respect \"shallow\" lines\n\nWhen fetching from a shallow clone, the client sends \"have\" lines\nto tell the server about objects it already has and \"shallow\" lines\nto tell where its local history terminates. In some circumstances,\nthe server fails to honor the shallow lines and fails to return\nobjects that the client needs.\n\nUploadPack passes the \"have\" lines to PackWriter so PackWriter can\nomit them from the generated pack. UploadPack processes \"shallow\"\nlines by calling RevWalk.assumeShallow() with the set of shallow\ncommits. RevWalk creates and caches RevCommits for these shallow\ncommits, clearing out their parents. That way, walks correctly\nterminate at the shallow commits instead of assuming the client has\nhistory going back behind them. UploadPack converts its RevWalk to an\nObjectWalk, maintaining the cached RevCommits, and passes it to\nPackWriter.\n\nUnfortunately, to support shallow fetches the PackWriter does the\nfollowing:\n\n  if (shallowPack && !(walk instanceof DepthWalk.ObjectWalk))\n    walk = new DepthWalk.ObjectWalk(reader, depth);\n\nThat is, when the client sends a \"deepen\" line (fetch --depth=<n>)\nand the caller has not passed in a DepthWalk.ObjectWalk, PackWriter\nthrows away the RevWalk that was passed in and makes a new one. The\ncleared parent lists prepared by RevWalk.assumeShallow() are lost.\nFortunately UploadPack intends to pass in a DepthWalk.ObjectWalk.\nIt tries to create it by calling toObjectWalkWithSameObjects() on\na DepthWalk.RevWalk. But it doesn't work: because DepthWalk.RevWalk\ndoes not override the standard RevWalk#toObjectWalkWithSameObjects\nimplementation, the result is a plain ObjectWalk instead of an\ninstance of DepthWalk.ObjectWalk.\n\nThe result is that the \"shallow\" information is thrown away and\nobjects reachable from the shallow commits can be omitted from the\npack sent when fetching with --depth from a shallow clone.\n\nMultiple factors collude to limit the circumstances under which this\nbug can be observed:\n\n1. Commits with depth != 0 don't enter DepthGenerator's pending queue.\n   That means a \"have\" cannot have any effect on DepthGenerator unless\n   it is also a \"want\".\n\n2. DepthGenerator#next() doesn't call carryFlagsImpl(), so the\n   uninteresting flag is not propagated to ancestors there even if a\n   \"have\" is also a \"want\".\n\n3. JGit treats a depth of 1 as \"1 past the wants\".\n\nBecause of (2), the only place the UNINTERESTING flag can leak to a\nshallow commit's parents is in the carryFlags() call from\nmarkUninteresting(). carryFlags() only traverses commits that have\nalready been parsed: commits yet to be parsed are supposed to inherit\ncorrect flags from their parent in PendingGenerator#next (which\ndoesn't happen here --- that is (2)). So the list of commits that have\nalready been parsed becomes relevant.\n\nWhen we hit the markUninteresting() call, all \"want\"s, \"have\"s, and\ncommits to be unshallowed have been parsed. carryFlags() only\naffects the parsed commits. If the \"want\" is a direct parent of a\n\"have\", then it carryFlags() marks it as uninteresting. If the \"have\"\nwas also a \"shallow\", then its parent pointer should have been null\nand the \"want\" shouldn't have been marked, so we see the bug. If the\n\"want\" is a more distant ancestor then (2) keeps the uninteresting\nstate from propagating to the \"want\" and we don't see the bug. If the\n\"shallow\" is not also a \"have\" then the shallow commit isn't parsed\nso (2) keeps the uninteresting state from propagating to the \"want\nso we don't see the bug.\n\nHere is a reproduction case (time flowing left to right, arrows\npointing to parents). \"C\" must be a commit that the client\nreports as a \"have\" during negotiation. That can only happen if the\nserver reports it as an existing branch or tag in the first round of\nnegotiation:\n\n  A <-- B <-- C <-- D\n\nFirst do\n\n  git clone --depth 1 <repo>\n\nwhich yields D as a \"have\" and C as a \"shallow\" commit. Then try\n\n  git fetch --depth 1 <repo> B:refs/heads/B\n\nNegotiation sets up: have D, shallow C, have C, want B.\nBut due to this bug B is marked as uninteresting and is not sent.\n\nChange-Id: I6e14b57b2f85e52d28cdcf356df647870f475440\nSigned-off-by: Terry Parker <tparker@google.com>\n",
			"commitDate": "2016-08-05, 4:37 PM",
			"commitName": "d385a7a5e5cacd875da4301ddeb46a7c56a725fa",
			"commitAuthor": "Terry Parker",
			"commitDateOld": "2016-08-04, 6:20 PM",
			"commitNameOld": "7edf05530d83d7f8971db4262ea43e11124c6b63",
			"commitAuthorOld": "Terry Parker",
			"daysBetweenCommits": 0.93,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,217 +1,217 @@\n \tprivate void findObjectsToPack(@NonNull ProgressMonitor countingMonitor,\n \t\t\t@NonNull ObjectWalk walker, @NonNull Set<? extends ObjectId> want,\n \t\t\t@NonNull Set<? extends ObjectId> have) throws IOException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tbeginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tcanBuildBitmaps = config.isBuildBitmaps()\n \t\t\t\t&& !shallowPack\n \t\t\t\t&& have.isEmpty()\n \t\t\t\t&& (excludeInPacks == null || excludeInPacks.length == 0);\n \t\tif (!shallowPack && useBitmaps) {\n \t\t\tBitmapIndex bitmapIndex = reader.getBitmapIndex();\n \t\t\tif (bitmapIndex != null) {\n \t\t\t\tPackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(\n \t\t\t\t\t\twalker, bitmapIndex, countingMonitor);\n \t\t\t\tfindObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n \t\t\t\tendPhase(countingMonitor);\n \t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\tstats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal RevFlag include = walker.newFlag(\"include\"); //$NON-NLS-1$\n \t\tfinal RevFlag added = walker.newFlag(\"added\"); //$NON-NLS-1$\n \n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n \t\t// Retrieve the RevWalk's versions of \"want\" and \"have\" objects to\n-\t\t// maintain any flags previously set in the RevWalk.\n+\t\t// maintain any state previously set in the RevWalk.\n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\tif (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tif (walker instanceof DepthWalk.ObjectWalk) {\n \t\t\tDepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n \t\t\tfor (RevObject obj : wantObjs) {\n \t\t\t\tdepthWalk.markRoot(obj);\n \t\t\t}\n \t\t\t// Mark the tree objects associated with \"have\" commits as\n \t\t\t// uninteresting to avoid writing redundant blobs. A normal RevWalk\n \t\t\t// lazily propagates the \"uninteresting\" state from a commit to its\n \t\t\t// tree during the walk, but DepthWalks can terminate early so\n \t\t\t// preemptively propagate that state here.\n \t\t\tfor (RevObject obj : haveObjs) {\n \t\t\t\tif (obj instanceof RevCommit) {\n \t\t\t\t\tRevTree t = ((RevCommit) obj).getTree();\n \t\t\t\t\tdepthWalk.markUninteresting(t);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (unshallowObjects != null) {\n \t\t\t\tfor (ObjectId id : unshallowObjects) {\n \t\t\t\t\tdepthWalk.markUnshallow(walker.parseAny(id));\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\twalker.markStart(obj);\n \t\t}\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tBlockList<RevCommit> commits = new BlockList<RevCommit>();\n \t\tSet<ObjectId> roots = new HashSet<>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (exclude(c))\n \t\t\t\tcontinue;\n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tif (c.getParentCount() == 0) {\n \t\t\t\troots.add(c.copy());\n \t\t\t}\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\tstats.rootCommits = Collections.unmodifiableSet(roots);\n \n \t\tif (shallowPack) {\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \t\t} else {\n \t\t\tint commitCnt = 0;\n \t\t\tboolean putTagTargets = false;\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\tif (!cmit.has(added)) {\n \t\t\t\t\tcmit.add(added);\n \t\t\t\t\taddObject(cmit, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !exclude(p)) {\n \t\t\t\t\t\tp.add(added);\n \t\t\t\t\t\taddObject(p, 0);\n \t\t\t\t\t\tcommitCnt++;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tputTagTargets = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\t\taddObject(o, pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \t\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tendPhase(countingMonitor);\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\tstats.bitmapIndexMisses = -1;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7edf05530d83d7f8971db4262ea43e11124c6b63": {
			"type": "Ybodychange",
			"commitMessage": "Shallow fetch: avoid sending unneeded blobs\n\nWhen doing an incremental fetch from JGit, \"have\" commits are marked\nas \"uninteresting\". In a non-shallow fetch, when the RevWalk hits an\n\"uninteresting\" commit it marks the commit's corresponding tree as\nuninteresting. That has the effect of dropping those trees and all the\ntrees and blobs they reference out of the thin pack returned to the\nclient.\n\nHowever, shallow fetches use a DepthWalk to limit the RevWalk, which\nnearly always causes the RevWalk to terminate before encountering the\n\"have\" commits. As a result the pack created for the incremental fetch\nnever encounters \"uninteresting\" tree objects and thus includes\nduplicate objects that it knows the client already has.\n\nChange-Id: I7b1f7c3b0d83e04d34cd2fa676f1ad4fec904c05\nSigned-off-by: Terry Parker <tparker@google.com>\n",
			"commitDate": "2016-08-04, 6:20 PM",
			"commitName": "7edf05530d83d7f8971db4262ea43e11124c6b63",
			"commitAuthor": "Terry Parker",
			"commitDateOld": "2016-01-12, 5:30 PM",
			"commitNameOld": "4e650c0d76b716c0e9cb3592d30def9e609066c1",
			"commitAuthorOld": "Shawn Pearce",
			"daysBetweenCommits": 204.99,
			"commitsBetweenForRepo": 316,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,201 +1,217 @@\n \tprivate void findObjectsToPack(@NonNull ProgressMonitor countingMonitor,\n \t\t\t@NonNull ObjectWalk walker, @NonNull Set<? extends ObjectId> want,\n \t\t\t@NonNull Set<? extends ObjectId> have) throws IOException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tbeginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tcanBuildBitmaps = config.isBuildBitmaps()\n \t\t\t\t&& !shallowPack\n \t\t\t\t&& have.isEmpty()\n \t\t\t\t&& (excludeInPacks == null || excludeInPacks.length == 0);\n \t\tif (!shallowPack && useBitmaps) {\n \t\t\tBitmapIndex bitmapIndex = reader.getBitmapIndex();\n \t\t\tif (bitmapIndex != null) {\n \t\t\t\tPackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(\n \t\t\t\t\t\twalker, bitmapIndex, countingMonitor);\n \t\t\t\tfindObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n \t\t\t\tendPhase(countingMonitor);\n \t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\tstats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal RevFlag include = walker.newFlag(\"include\"); //$NON-NLS-1$\n \t\tfinal RevFlag added = walker.newFlag(\"added\"); //$NON-NLS-1$\n \n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n+\t\t// Retrieve the RevWalk's versions of \"want\" and \"have\" objects to\n+\t\t// maintain any flags previously set in the RevWalk.\n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\tif (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tif (walker instanceof DepthWalk.ObjectWalk) {\n \t\t\tDepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n-\t\t\tfor (RevObject obj : wantObjs)\n+\t\t\tfor (RevObject obj : wantObjs) {\n \t\t\t\tdepthWalk.markRoot(obj);\n+\t\t\t}\n+\t\t\t// Mark the tree objects associated with \"have\" commits as\n+\t\t\t// uninteresting to avoid writing redundant blobs. A normal RevWalk\n+\t\t\t// lazily propagates the \"uninteresting\" state from a commit to its\n+\t\t\t// tree during the walk, but DepthWalks can terminate early so\n+\t\t\t// preemptively propagate that state here.\n+\t\t\tfor (RevObject obj : haveObjs) {\n+\t\t\t\tif (obj instanceof RevCommit) {\n+\t\t\t\t\tRevTree t = ((RevCommit) obj).getTree();\n+\t\t\t\t\tdepthWalk.markUninteresting(t);\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\tif (unshallowObjects != null) {\n-\t\t\t\tfor (ObjectId id : unshallowObjects)\n+\t\t\t\tfor (ObjectId id : unshallowObjects) {\n \t\t\t\t\tdepthWalk.markUnshallow(walker.parseAny(id));\n+\t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\twalker.markStart(obj);\n \t\t}\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tBlockList<RevCommit> commits = new BlockList<RevCommit>();\n \t\tSet<ObjectId> roots = new HashSet<>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (exclude(c))\n \t\t\t\tcontinue;\n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tif (c.getParentCount() == 0) {\n \t\t\t\troots.add(c.copy());\n \t\t\t}\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\tstats.rootCommits = Collections.unmodifiableSet(roots);\n \n \t\tif (shallowPack) {\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \t\t} else {\n \t\t\tint commitCnt = 0;\n \t\t\tboolean putTagTargets = false;\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\tif (!cmit.has(added)) {\n \t\t\t\t\tcmit.add(added);\n \t\t\t\t\taddObject(cmit, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !exclude(p)) {\n \t\t\t\t\t\tp.add(added);\n \t\t\t\t\t\taddObject(p, 0);\n \t\t\t\t\t\tcommitCnt++;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tputTagTargets = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\t\taddObject(o, pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \t\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tendPhase(countingMonitor);\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\tstats.bitmapIndexMisses = -1;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4e650c0d76b716c0e9cb3592d30def9e609066c1": {
			"type": "Ymultichange(Yexceptionschange,Ybodychange,Yparametermetachange)",
			"commitMessage": "PackWriter: Declare preparePack object sets as @NonNull\n\nRequire callers to pass in valid sets for both want and have\ncollections. Offer PackWriter.NONE as a handy constant for an\nempty collection for the have part of preparePack instead of null.\n\nChange-Id: Ifda4450f5e488cbfefd728382b7d30797e229217\n",
			"commitDate": "2016-01-12, 5:30 PM",
			"commitName": "4e650c0d76b716c0e9cb3592d30def9e609066c1",
			"commitAuthor": "Shawn Pearce",
			"subchanges": [
				{
					"type": "Yexceptionschange",
					"commitMessage": "PackWriter: Declare preparePack object sets as @NonNull\n\nRequire callers to pass in valid sets for both want and have\ncollections. Offer PackWriter.NONE as a handy constant for an\nempty collection for the have part of preparePack instead of null.\n\nChange-Id: Ifda4450f5e488cbfefd728382b7d30797e229217\n",
					"commitDate": "2016-01-12, 5:30 PM",
					"commitName": "4e650c0d76b716c0e9cb3592d30def9e609066c1",
					"commitAuthor": "Shawn Pearce",
					"commitDateOld": "2015-12-29, 4:32 PM",
					"commitNameOld": "29aa444760ea729dd10cdb0468055282a59096e5",
					"commitAuthorOld": "Shawn Pearce",
					"daysBetweenCommits": 14.04,
					"commitsBetweenForRepo": 38,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,206 +1,201 @@\n-\tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n-\t\t\tfinal ObjectWalk walker, final Set<? extends ObjectId> want,\n-\t\t\tSet<? extends ObjectId> have)\n-\t\t\tthrows MissingObjectException, IOException,\n-\t\t\tIncorrectObjectTypeException {\n+\tprivate void findObjectsToPack(@NonNull ProgressMonitor countingMonitor,\n+\t\t\t@NonNull ObjectWalk walker, @NonNull Set<? extends ObjectId> want,\n+\t\t\t@NonNull Set<? extends ObjectId> have) throws IOException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tbeginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n \n-\t\tif (have == null)\n-\t\t\thave = Collections.emptySet();\n-\n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tcanBuildBitmaps = config.isBuildBitmaps()\n \t\t\t\t&& !shallowPack\n \t\t\t\t&& have.isEmpty()\n \t\t\t\t&& (excludeInPacks == null || excludeInPacks.length == 0);\n \t\tif (!shallowPack && useBitmaps) {\n \t\t\tBitmapIndex bitmapIndex = reader.getBitmapIndex();\n \t\t\tif (bitmapIndex != null) {\n \t\t\t\tPackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(\n \t\t\t\t\t\twalker, bitmapIndex, countingMonitor);\n \t\t\t\tfindObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n \t\t\t\tendPhase(countingMonitor);\n \t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\tstats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal RevFlag include = walker.newFlag(\"include\"); //$NON-NLS-1$\n \t\tfinal RevFlag added = walker.newFlag(\"added\"); //$NON-NLS-1$\n \n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\tif (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tif (walker instanceof DepthWalk.ObjectWalk) {\n \t\t\tDepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\tdepthWalk.markRoot(obj);\n \t\t\tif (unshallowObjects != null) {\n \t\t\t\tfor (ObjectId id : unshallowObjects)\n \t\t\t\t\tdepthWalk.markUnshallow(walker.parseAny(id));\n \t\t\t}\n \t\t} else {\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\twalker.markStart(obj);\n \t\t}\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tBlockList<RevCommit> commits = new BlockList<RevCommit>();\n \t\tSet<ObjectId> roots = new HashSet<>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (exclude(c))\n \t\t\t\tcontinue;\n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tif (c.getParentCount() == 0) {\n \t\t\t\troots.add(c.copy());\n \t\t\t}\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\tstats.rootCommits = Collections.unmodifiableSet(roots);\n \n \t\tif (shallowPack) {\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \t\t} else {\n \t\t\tint commitCnt = 0;\n \t\t\tboolean putTagTargets = false;\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\tif (!cmit.has(added)) {\n \t\t\t\t\tcmit.add(added);\n \t\t\t\t\taddObject(cmit, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !exclude(p)) {\n \t\t\t\t\t\tp.add(added);\n \t\t\t\t\t\taddObject(p, 0);\n \t\t\t\t\t\tcommitCnt++;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tputTagTargets = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\t\taddObject(o, pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \t\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tendPhase(countingMonitor);\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\tstats.bitmapIndexMisses = -1;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[MissingObjectException, IOException, IncorrectObjectTypeException]",
						"newValue": "[IOException]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "PackWriter: Declare preparePack object sets as @NonNull\n\nRequire callers to pass in valid sets for both want and have\ncollections. Offer PackWriter.NONE as a handy constant for an\nempty collection for the have part of preparePack instead of null.\n\nChange-Id: Ifda4450f5e488cbfefd728382b7d30797e229217\n",
					"commitDate": "2016-01-12, 5:30 PM",
					"commitName": "4e650c0d76b716c0e9cb3592d30def9e609066c1",
					"commitAuthor": "Shawn Pearce",
					"commitDateOld": "2015-12-29, 4:32 PM",
					"commitNameOld": "29aa444760ea729dd10cdb0468055282a59096e5",
					"commitAuthorOld": "Shawn Pearce",
					"daysBetweenCommits": 14.04,
					"commitsBetweenForRepo": 38,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,206 +1,201 @@\n-\tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n-\t\t\tfinal ObjectWalk walker, final Set<? extends ObjectId> want,\n-\t\t\tSet<? extends ObjectId> have)\n-\t\t\tthrows MissingObjectException, IOException,\n-\t\t\tIncorrectObjectTypeException {\n+\tprivate void findObjectsToPack(@NonNull ProgressMonitor countingMonitor,\n+\t\t\t@NonNull ObjectWalk walker, @NonNull Set<? extends ObjectId> want,\n+\t\t\t@NonNull Set<? extends ObjectId> have) throws IOException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tbeginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n \n-\t\tif (have == null)\n-\t\t\thave = Collections.emptySet();\n-\n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tcanBuildBitmaps = config.isBuildBitmaps()\n \t\t\t\t&& !shallowPack\n \t\t\t\t&& have.isEmpty()\n \t\t\t\t&& (excludeInPacks == null || excludeInPacks.length == 0);\n \t\tif (!shallowPack && useBitmaps) {\n \t\t\tBitmapIndex bitmapIndex = reader.getBitmapIndex();\n \t\t\tif (bitmapIndex != null) {\n \t\t\t\tPackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(\n \t\t\t\t\t\twalker, bitmapIndex, countingMonitor);\n \t\t\t\tfindObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n \t\t\t\tendPhase(countingMonitor);\n \t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\tstats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal RevFlag include = walker.newFlag(\"include\"); //$NON-NLS-1$\n \t\tfinal RevFlag added = walker.newFlag(\"added\"); //$NON-NLS-1$\n \n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\tif (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tif (walker instanceof DepthWalk.ObjectWalk) {\n \t\t\tDepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\tdepthWalk.markRoot(obj);\n \t\t\tif (unshallowObjects != null) {\n \t\t\t\tfor (ObjectId id : unshallowObjects)\n \t\t\t\t\tdepthWalk.markUnshallow(walker.parseAny(id));\n \t\t\t}\n \t\t} else {\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\twalker.markStart(obj);\n \t\t}\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tBlockList<RevCommit> commits = new BlockList<RevCommit>();\n \t\tSet<ObjectId> roots = new HashSet<>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (exclude(c))\n \t\t\t\tcontinue;\n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tif (c.getParentCount() == 0) {\n \t\t\t\troots.add(c.copy());\n \t\t\t}\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\tstats.rootCommits = Collections.unmodifiableSet(roots);\n \n \t\tif (shallowPack) {\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \t\t} else {\n \t\t\tint commitCnt = 0;\n \t\t\tboolean putTagTargets = false;\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\tif (!cmit.has(added)) {\n \t\t\t\t\tcmit.add(added);\n \t\t\t\t\taddObject(cmit, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !exclude(p)) {\n \t\t\t\t\t\tp.add(added);\n \t\t\t\t\t\taddObject(p, 0);\n \t\t\t\t\t\tcommitCnt++;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tputTagTargets = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\t\taddObject(o, pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \t\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tendPhase(countingMonitor);\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\tstats.bitmapIndexMisses = -1;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				},
				{
					"type": "Yparametermetachange",
					"commitMessage": "PackWriter: Declare preparePack object sets as @NonNull\n\nRequire callers to pass in valid sets for both want and have\ncollections. Offer PackWriter.NONE as a handy constant for an\nempty collection for the have part of preparePack instead of null.\n\nChange-Id: Ifda4450f5e488cbfefd728382b7d30797e229217\n",
					"commitDate": "2016-01-12, 5:30 PM",
					"commitName": "4e650c0d76b716c0e9cb3592d30def9e609066c1",
					"commitAuthor": "Shawn Pearce",
					"commitDateOld": "2015-12-29, 4:32 PM",
					"commitNameOld": "29aa444760ea729dd10cdb0468055282a59096e5",
					"commitAuthorOld": "Shawn Pearce",
					"daysBetweenCommits": 14.04,
					"commitsBetweenForRepo": 38,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,206 +1,201 @@\n-\tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n-\t\t\tfinal ObjectWalk walker, final Set<? extends ObjectId> want,\n-\t\t\tSet<? extends ObjectId> have)\n-\t\t\tthrows MissingObjectException, IOException,\n-\t\t\tIncorrectObjectTypeException {\n+\tprivate void findObjectsToPack(@NonNull ProgressMonitor countingMonitor,\n+\t\t\t@NonNull ObjectWalk walker, @NonNull Set<? extends ObjectId> want,\n+\t\t\t@NonNull Set<? extends ObjectId> have) throws IOException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tbeginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n \n-\t\tif (have == null)\n-\t\t\thave = Collections.emptySet();\n-\n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tcanBuildBitmaps = config.isBuildBitmaps()\n \t\t\t\t&& !shallowPack\n \t\t\t\t&& have.isEmpty()\n \t\t\t\t&& (excludeInPacks == null || excludeInPacks.length == 0);\n \t\tif (!shallowPack && useBitmaps) {\n \t\t\tBitmapIndex bitmapIndex = reader.getBitmapIndex();\n \t\t\tif (bitmapIndex != null) {\n \t\t\t\tPackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(\n \t\t\t\t\t\twalker, bitmapIndex, countingMonitor);\n \t\t\t\tfindObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n \t\t\t\tendPhase(countingMonitor);\n \t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\tstats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal RevFlag include = walker.newFlag(\"include\"); //$NON-NLS-1$\n \t\tfinal RevFlag added = walker.newFlag(\"added\"); //$NON-NLS-1$\n \n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\tif (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tif (walker instanceof DepthWalk.ObjectWalk) {\n \t\t\tDepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\tdepthWalk.markRoot(obj);\n \t\t\tif (unshallowObjects != null) {\n \t\t\t\tfor (ObjectId id : unshallowObjects)\n \t\t\t\t\tdepthWalk.markUnshallow(walker.parseAny(id));\n \t\t\t}\n \t\t} else {\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\twalker.markStart(obj);\n \t\t}\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tBlockList<RevCommit> commits = new BlockList<RevCommit>();\n \t\tSet<ObjectId> roots = new HashSet<>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (exclude(c))\n \t\t\t\tcontinue;\n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tif (c.getParentCount() == 0) {\n \t\t\t\troots.add(c.copy());\n \t\t\t}\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\tstats.rootCommits = Collections.unmodifiableSet(roots);\n \n \t\tif (shallowPack) {\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \t\t} else {\n \t\t\tint commitCnt = 0;\n \t\t\tboolean putTagTargets = false;\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\tif (!cmit.has(added)) {\n \t\t\t\t\tcmit.add(added);\n \t\t\t\t\taddObject(cmit, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !exclude(p)) {\n \t\t\t\t\t\tp.add(added);\n \t\t\t\t\t\taddObject(p, 0);\n \t\t\t\t\t\tcommitCnt++;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tputTagTargets = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\t\taddObject(o, pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \t\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tendPhase(countingMonitor);\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\tstats.bitmapIndexMisses = -1;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[countingMonitor-ProgressMonitor(modifiers-final), walker-ObjectWalk(modifiers-final), want-Set<? extends ObjectId>(modifiers-final), have-Set<? extends ObjectId>]",
						"newValue": "[countingMonitor-ProgressMonitor(annotations-@NonNull), walker-ObjectWalk(annotations-@NonNull), want-Set<? extends ObjectId>(annotations-@NonNull), have-Set<? extends ObjectId>(annotations-@NonNull)]"
					}
				}
			]
		},
		"1d7d0f95e0be8121ee16640fa1cd3b0805fd9092": {
			"type": "Ybodychange",
			"commitMessage": "Expose the set of root commits in PackStatistics\n\nRoot commits are commits with zero parents.  If a commmit has no\nparents it is the first commit in the repository.  In general the root\ncommits should be unique for any given project, as the first commit\nwill be created at a different time, by a different user with its own\nmessage.  These root commits can be used as a \"fingerprint\" to\nidentify disjoint histories.\n\nChange-Id: Id891dbc1f17c816cea404569578bb7635ff85cdb\n",
			"commitDate": "2015-08-16, 3:10 PM",
			"commitName": "1d7d0f95e0be8121ee16640fa1cd3b0805fd9092",
			"commitAuthor": "Shawn Pearce",
			"commitDateOld": "2015-08-14, 12:13 PM",
			"commitNameOld": "f9bd6c1239b9e66bfd74e5a2462621a5f5fa641c",
			"commitAuthorOld": "Shawn Pearce",
			"daysBetweenCommits": 2.12,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,201 +1,206 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker, final Set<? extends ObjectId> want,\n \t\t\tSet<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tbeginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tcanBuildBitmaps = config.isBuildBitmaps()\n \t\t\t\t&& !shallowPack\n \t\t\t\t&& have.isEmpty()\n \t\t\t\t&& (excludeInPacks == null || excludeInPacks.length == 0);\n \t\tif (!shallowPack && useBitmaps) {\n \t\t\tBitmapIndex bitmapIndex = reader.getBitmapIndex();\n \t\t\tif (bitmapIndex != null) {\n \t\t\t\tPackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(\n \t\t\t\t\t\twalker, bitmapIndex, countingMonitor);\n \t\t\t\tfindObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n \t\t\t\tendPhase(countingMonitor);\n \t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\tstats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal RevFlag include = walker.newFlag(\"include\"); //$NON-NLS-1$\n \t\tfinal RevFlag added = walker.newFlag(\"added\"); //$NON-NLS-1$\n \n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\tif (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tif (walker instanceof DepthWalk.ObjectWalk) {\n \t\t\tDepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\tdepthWalk.markRoot(obj);\n \t\t\tif (unshallowObjects != null) {\n \t\t\t\tfor (ObjectId id : unshallowObjects)\n \t\t\t\t\tdepthWalk.markUnshallow(walker.parseAny(id));\n \t\t\t}\n \t\t} else {\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\twalker.markStart(obj);\n \t\t}\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tBlockList<RevCommit> commits = new BlockList<RevCommit>();\n+\t\tSet<ObjectId> roots = new HashSet<>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (exclude(c))\n \t\t\t\tcontinue;\n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n+\t\t\tif (c.getParentCount() == 0) {\n+\t\t\t\troots.add(c.copy());\n+\t\t\t}\n \t\t\tcountingMonitor.update(1);\n \t\t}\n+\t\tstats.rootCommits = Collections.unmodifiableSet(roots);\n \n \t\tif (shallowPack) {\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \t\t} else {\n \t\t\tint commitCnt = 0;\n \t\t\tboolean putTagTargets = false;\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\tif (!cmit.has(added)) {\n \t\t\t\t\tcmit.add(added);\n \t\t\t\t\taddObject(cmit, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !exclude(p)) {\n \t\t\t\t\t\tp.add(added);\n \t\t\t\t\t\taddObject(p, 0);\n \t\t\t\t\t\tcommitCnt++;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tputTagTargets = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\t\taddObject(o, pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \t\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tendPhase(countingMonitor);\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\tstats.bitmapIndexMisses = -1;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dd22bc831a0ec47ecc999eb19be1bd8fad899e9b": {
			"type": "Ybodychange",
			"commitMessage": "Update PackWriter.Statistics.getBitmapIndexMises()\n\nReturn -1 from PackWriter.Statistics.getBitmapIndexMises() when no\nbitmap indices were found, to differentiate it from the case where\nthe bitmap indices contained all of the want/have commits.\n\nChange-Id: I78d4600b462c19f62b347217a0b2c19eaaf3a14b\nSigned-off-by: Terry Parker <tparker@google.com>",
			"commitDate": "2015-06-02, 8:49 PM",
			"commitName": "dd22bc831a0ec47ecc999eb19be1bd8fad899e9b",
			"commitAuthor": "Terry Parker",
			"commitDateOld": "2015-05-26, 3:37 PM",
			"commitNameOld": "0e8ac496cd9bbfa3fa306ac45706f501fc24ac38",
			"commitAuthorOld": "Terry Parker",
			"daysBetweenCommits": 7.22,
			"commitsBetweenForRepo": 24,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,200 +1,201 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker, final Set<? extends ObjectId> want,\n \t\t\tSet<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tbeginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tcanBuildBitmaps = config.isBuildBitmaps()\n \t\t\t\t&& !shallowPack\n \t\t\t\t&& have.isEmpty()\n \t\t\t\t&& (excludeInPacks == null || excludeInPacks.length == 0);\n \t\tif (!shallowPack && useBitmaps) {\n \t\t\tBitmapIndex bitmapIndex = reader.getBitmapIndex();\n \t\t\tif (bitmapIndex != null) {\n \t\t\t\tPackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(\n \t\t\t\t\t\twalker, bitmapIndex, countingMonitor);\n \t\t\t\tfindObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n \t\t\t\tendPhase(countingMonitor);\n \t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\tstats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal RevFlag include = walker.newFlag(\"include\"); //$NON-NLS-1$\n \t\tfinal RevFlag added = walker.newFlag(\"added\"); //$NON-NLS-1$\n \n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\tif (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tif (walker instanceof DepthWalk.ObjectWalk) {\n \t\t\tDepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\tdepthWalk.markRoot(obj);\n \t\t\tif (unshallowObjects != null) {\n \t\t\t\tfor (ObjectId id : unshallowObjects)\n \t\t\t\t\tdepthWalk.markUnshallow(walker.parseAny(id));\n \t\t\t}\n \t\t} else {\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\twalker.markStart(obj);\n \t\t}\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tBlockList<RevCommit> commits = new BlockList<RevCommit>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (exclude(c))\n \t\t\t\tcontinue;\n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tif (shallowPack) {\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \t\t} else {\n \t\t\tint commitCnt = 0;\n \t\t\tboolean putTagTargets = false;\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\tif (!cmit.has(added)) {\n \t\t\t\t\tcmit.add(added);\n \t\t\t\t\taddObject(cmit, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !exclude(p)) {\n \t\t\t\t\t\tp.add(added);\n \t\t\t\t\t\taddObject(p, 0);\n \t\t\t\t\t\tcommitCnt++;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tputTagTargets = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\t\taddObject(o, pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \t\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tendPhase(countingMonitor);\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n+\t\tstats.bitmapIndexMisses = -1;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0e8ac496cd9bbfa3fa306ac45706f501fc24ac38": {
			"type": "Ybodychange",
			"commitMessage": "Add bitmap index misses to PackWriter.Statistics\n\nRevWalks to find commits that are not in bitmap indices are expensive.\nTrack the count of commits that are enumerated via RevWalks as \"bitmap\nindex misses\" in the PackWriter.Statistics class.\n\nChange-Id: Ie0135a0a0aeba2dfb6df78839d545006629f16cb\nSigned-off-by: Terry Parker <tparker@google.com>\n",
			"commitDate": "2015-05-26, 3:37 PM",
			"commitName": "0e8ac496cd9bbfa3fa306ac45706f501fc24ac38",
			"commitAuthor": "Terry Parker",
			"commitDateOld": "2015-05-20, 6:05 PM",
			"commitNameOld": "686124bec32fcdee1545e7d9c312dcf0276b44af",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 5.9,
			"commitsBetweenForRepo": 24,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,199 +1,200 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker, final Set<? extends ObjectId> want,\n \t\t\tSet<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tbeginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tcanBuildBitmaps = config.isBuildBitmaps()\n \t\t\t\t&& !shallowPack\n \t\t\t\t&& have.isEmpty()\n \t\t\t\t&& (excludeInPacks == null || excludeInPacks.length == 0);\n \t\tif (!shallowPack && useBitmaps) {\n \t\t\tBitmapIndex bitmapIndex = reader.getBitmapIndex();\n \t\t\tif (bitmapIndex != null) {\n \t\t\t\tPackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(\n \t\t\t\t\t\twalker, bitmapIndex, countingMonitor);\n \t\t\t\tfindObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n \t\t\t\tendPhase(countingMonitor);\n \t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n+\t\t\t\tstats.bitmapIndexMisses = bitmapWalker.getCountOfBitmapIndexMisses();\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal RevFlag include = walker.newFlag(\"include\"); //$NON-NLS-1$\n \t\tfinal RevFlag added = walker.newFlag(\"added\"); //$NON-NLS-1$\n \n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\tif (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tif (walker instanceof DepthWalk.ObjectWalk) {\n \t\t\tDepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\tdepthWalk.markRoot(obj);\n \t\t\tif (unshallowObjects != null) {\n \t\t\t\tfor (ObjectId id : unshallowObjects)\n \t\t\t\t\tdepthWalk.markUnshallow(walker.parseAny(id));\n \t\t\t}\n \t\t} else {\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\twalker.markStart(obj);\n \t\t}\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tBlockList<RevCommit> commits = new BlockList<RevCommit>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (exclude(c))\n \t\t\t\tcontinue;\n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tif (shallowPack) {\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \t\t} else {\n \t\t\tint commitCnt = 0;\n \t\t\tboolean putTagTargets = false;\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\tif (!cmit.has(added)) {\n \t\t\t\t\tcmit.add(added);\n \t\t\t\t\taddObject(cmit, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !exclude(p)) {\n \t\t\t\t\t\tp.add(added);\n \t\t\t\t\t\taddObject(p, 0);\n \t\t\t\t\t\tcommitCnt++;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tputTagTargets = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\t\taddObject(o, pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \t\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tendPhase(countingMonitor);\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"53e39094bf012a4f5b3fe5557219707cb7b0f010": {
			"type": "Ybodychange",
			"commitMessage": "ObjectWalk: make setRetainBody(false) the default\n\nDespite being the primary author of RevWalk and ObjectWalk I still\nfail to remember to setRetainBody(false) in application code using\nan ObjectWalk to examine the graph.\n\nDocument the default for RevWalk is setRetainBody(true), where the\napplication usually wants the commit bodies to display or inspect.\n\nChange the default for ObjectWalk to setRetainBody(false), as nearly\nall callers want only the graph shape and do not need the larger text\ninside a commit body. This allows some code in JGit to be simplified.\n\nChange-Id: I367e42209e805bd5e1f41b4072aeb2fa98ec9d99\n",
			"commitDate": "2015-05-10, 11:45 AM",
			"commitName": "53e39094bf012a4f5b3fe5557219707cb7b0f010",
			"commitAuthor": "Shawn Pearce",
			"commitDateOld": "2015-04-24, 4:51 PM",
			"commitNameOld": "10412ddfedfe80537ffa497c7960443d703ee129",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 15.79,
			"commitsBetweenForRepo": 18,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,201 +1,199 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker, final Set<? extends ObjectId> want,\n \t\t\tSet<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tbeginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n-\t\twalker.setRetainBody(false);\n-\n \t\tcanBuildBitmaps = config.isBuildBitmaps()\n \t\t\t\t&& !shallowPack\n \t\t\t\t&& have.isEmpty()\n \t\t\t\t&& (excludeInPacks == null || excludeInPacks.length == 0);\n \t\tif (!shallowPack && useBitmaps) {\n \t\t\tBitmapIndex bitmapIndex = reader.getBitmapIndex();\n \t\t\tif (bitmapIndex != null) {\n \t\t\t\tPackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(\n \t\t\t\t\t\twalker, bitmapIndex, countingMonitor);\n \t\t\t\tfindObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n \t\t\t\tendPhase(countingMonitor);\n \t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal RevFlag include = walker.newFlag(\"include\"); //$NON-NLS-1$\n \t\tfinal RevFlag added = walker.newFlag(\"added\"); //$NON-NLS-1$\n \n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\tif (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tif (walker instanceof DepthWalk.ObjectWalk) {\n \t\t\tDepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\tdepthWalk.markRoot(obj);\n \t\t\tif (unshallowObjects != null) {\n \t\t\t\tfor (ObjectId id : unshallowObjects)\n \t\t\t\t\tdepthWalk.markUnshallow(walker.parseAny(id));\n \t\t\t}\n \t\t} else {\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\twalker.markStart(obj);\n \t\t}\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tBlockList<RevCommit> commits = new BlockList<RevCommit>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (exclude(c))\n \t\t\t\tcontinue;\n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tif (shallowPack) {\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \t\t} else {\n \t\t\tint commitCnt = 0;\n \t\t\tboolean putTagTargets = false;\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\tif (!cmit.has(added)) {\n \t\t\t\t\tcmit.add(added);\n \t\t\t\t\taddObject(cmit, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !exclude(p)) {\n \t\t\t\t\t\tp.add(added);\n \t\t\t\t\t\taddObject(p, 0);\n \t\t\t\t\t\tcommitCnt++;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tputTagTargets = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\t\taddObject(o, pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \t\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tendPhase(countingMonitor);\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f32b8612433e499090c76ded014dd5e94322b786": {
			"type": "Yfilerename",
			"commitMessage": "JGit 3.0: move internal classes into an internal subpackage\n\nThis breaks all existing callers once. Applications are not supposed\nto build against the internal storage API unless they can accept API\nchurn and make necessary updates as versions change.\n\nChange-Id: I2ab1327c202ef2003565e1b0770a583970e432e9\n",
			"commitDate": "2013-03-18, 10:30 AM",
			"commitName": "f32b8612433e499090c76ded014dd5e94322b786",
			"commitAuthor": "Shawn Pearce",
			"commitDateOld": "2013-03-18, 8:35 AM",
			"commitNameOld": "462bbc052e766ee9ea585cd4366165a8dac86496",
			"commitAuthorOld": "Shawn Pearce",
			"daysBetweenCommits": 0.08,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
				"newPath": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java"
			}
		},
		"3760e4319b02ce79ff1eeae021fd88faebf739d5": {
			"type": "Ybodychange",
			"commitMessage": "Remove cached_packs support in favor of bitmaps\n\nThe bitmap code in PackWriter knows exactly when to use a pack as\na \"cached pack\". It enables cached pack usage only when the pack\nhas a bitmap and its entire closure of objects needs to be sent.\nThis is a much simpler code path to maintain, and JGit actually\nhas a way to write the necessary index.\n\nChange-Id: I2645d482f8733fdf0c4120cc59ba9aa4d4ba6881\n",
			"commitDate": "2013-03-14, 5:36 PM",
			"commitName": "3760e4319b02ce79ff1eeae021fd88faebf739d5",
			"commitAuthor": "Shawn Pearce",
			"commitDateOld": "2013-03-05, 12:15 PM",
			"commitNameOld": "f82821728b60901932292bab6dd3e0a642301e02",
			"commitAuthorOld": "Colby Ranger",
			"daysBetweenCommits": 9.18,
			"commitsBetweenForRepo": 19,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,251 +1,201 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker, final Set<? extends ObjectId> want,\n \t\t\tSet<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tbeginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\twalker.setRetainBody(false);\n \n \t\tcanBuildBitmaps = config.isBuildBitmaps()\n \t\t\t\t&& !shallowPack\n \t\t\t\t&& have.isEmpty()\n \t\t\t\t&& (excludeInPacks == null || excludeInPacks.length == 0);\n \t\tif (!shallowPack && useBitmaps) {\n \t\t\tBitmapIndex bitmapIndex = reader.getBitmapIndex();\n \t\t\tif (bitmapIndex != null) {\n \t\t\t\tPackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(\n \t\t\t\t\t\twalker, bitmapIndex, countingMonitor);\n \t\t\t\tfindObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n \t\t\t\tendPhase(countingMonitor);\n \t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n-\t\tfinal Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n-\t\tfinal RevFlag inCachedPack = walker.newFlag(\"inCachedPack\"); //$NON-NLS-1$\n \t\tfinal RevFlag include = walker.newFlag(\"include\"); //$NON-NLS-1$\n \t\tfinal RevFlag added = walker.newFlag(\"added\"); //$NON-NLS-1$\n \n-\t\tfinal RevFlagSet keepOnRestart = new RevFlagSet();\n-\t\tkeepOnRestart.add(inCachedPack);\n-\n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n-\t\t\tif (useCachedPacks && reuseSupport != null) {\n-\t\t\t\tSet<ObjectId> need = new HashSet<ObjectId>(want);\n-\t\t\t\tList<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n-\n-\t\t\t\tfor (CachedPack pack : reuseSupport.getCachedPacks()) {\n-\t\t\t\t\tif (need.containsAll(pack.getTips())) {\n-\t\t\t\t\t\tneed.removeAll(pack.getTips());\n-\t\t\t\t\t\tshortCircuit.add(pack);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tfor (ObjectId id : pack.getTips()) {\n-\t\t\t\t\t\ttipToPack.put(id, pack);\n-\t\t\t\t\t\tall.add(id);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (need.isEmpty() && !shortCircuit.isEmpty()) {\n-\t\t\t\t\tcachedPacks.addAll(shortCircuit);\n-\t\t\t\t\tfor (CachedPack pack : shortCircuit)\n-\t\t\t\t\t\tcountingMonitor.update((int) pack.getObjectCount());\n-\t\t\t\t\tendPhase(countingMonitor);\n-\t\t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\thaveEst += tipToPack.size();\n-\t\t\t}\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n-\n-\t\t\t\t\tif (tipToPack.containsKey(o))\n-\t\t\t\t\t\to.add(inCachedPack);\n-\n \t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\tif (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tif (walker instanceof DepthWalk.ObjectWalk) {\n \t\t\tDepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\tdepthWalk.markRoot(obj);\n \t\t\tif (unshallowObjects != null) {\n \t\t\t\tfor (ObjectId id : unshallowObjects)\n \t\t\t\t\tdepthWalk.markUnshallow(walker.parseAny(id));\n \t\t\t}\n \t\t} else {\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\twalker.markStart(obj);\n \t\t}\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tBlockList<RevCommit> commits = new BlockList<RevCommit>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (exclude(c))\n \t\t\t\tcontinue;\n-\t\t\tif (c.has(inCachedPack)) {\n-\t\t\t\tCachedPack pack = tipToPack.get(c);\n-\t\t\t\tif (includesAllTips(pack, include, walker)) {\n-\t\t\t\t\tuseCachedPack(walker, keepOnRestart, //\n-\t\t\t\t\t\t\twantObjs, haveObjs, pack);\n-\t\t\t\t\tcommits = new BlockList<RevCommit>();\n-\n-\t\t\t\t\tendPhase(countingMonitor);\n-\t\t\t\t\tbeginPhase(PackingPhase.COUNTING, countingMonitor,\n-\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tif (shallowPack) {\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \t\t} else {\n \t\t\tint commitCnt = 0;\n \t\t\tboolean putTagTargets = false;\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\tif (!cmit.has(added)) {\n \t\t\t\t\tcmit.add(added);\n \t\t\t\t\taddObject(cmit, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !exclude(p)) {\n \t\t\t\t\t\tp.add(added);\n \t\t\t\t\t\taddObject(p, 0);\n \t\t\t\t\t\tcommitCnt++;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tputTagTargets = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\t\taddObject(o, pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \t\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tendPhase(countingMonitor);\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dafcb8f6db82b899c917832768f1c240d273190c": {
			"type": "Ybodychange",
			"commitMessage": "Support creating pack bitmap indexes in PackWriter.\n\nUpdate the PackWriter to support writing out pack bitmap indexes,\na parallel \".bitmap\" file to the \".pack\" file.\nBitmaps are selected at commits every 1 to 5,000 commits for\neach unique path from the start. The most recent 100 commits are\nall bitmapped. The next 19,000 commits have a bitmaps every 100\ncommits. The remaining commits have a bitmap every 5,000 commits.\nCommits with more than 1 parent are prefered over ones\nwith 1 or less. Furthermore, previously computed bitmaps are reused,\nif the previous entry had the reuse flag set, which is set when the\nbitmap was placed at the max allowed distance.\n\nBitmaps are used to speed up the counting phase when packing, for\nrequests that are not shallow. The PackWriterBitmapWalker uses\na RevFilter to proactively mark commits with RevFlag.SEEN, when\nthey appear in a bitmap. The walker produces the full closure\nof reachable ObjectIds, given the collection of starting ObjectIds.\n\nFor fetch request, two ObjectWalks are executed to compute the\nObjectIds reachable from the haves and from the wants. The\nObjectIds needed to be written are determined by taking all the\nresulting wants AND NOT the haves.\n\nFor clone requests, we get cached pack support for \"free\" since\nit is possible to determine if all of the ObjectIds in a pack file\nare included in the resulting list of ObjectIds to write.\n\nOn my machine, the best times for clones and fetches of the linux\nkernel repository (with about 2.6M objects and 300K commits) are\ntabulated below:\n\nOperation                   Index V2               Index VE003\nClone                       37530ms (524.06 MiB)     82ms (524.06 MiB)\nFetch (1 commit back)          75ms                 107ms\nFetch (10 commits back)       456ms (269.51 KiB)    341ms (265.19 KiB)\nFetch (100 commits back)      449ms (269.91 KiB)    337ms (267.28 KiB)\nFetch (1000 commits back)    2229ms ( 14.75 MiB)    189ms ( 14.42 MiB)\nFetch (10000 commits back)   2177ms ( 16.30 MiB)    254ms ( 15.88 MiB)\nFetch (100000 commits back) 14340ms (185.83 MiB)   1655ms (189.39 MiB)\n\nChange-Id: Icdb0cdd66ff168917fb9ef17b96093990cc6a98d\n",
			"commitDate": "2013-03-05, 12:14 PM",
			"commitName": "dafcb8f6db82b899c917832768f1c240d273190c",
			"commitAuthor": "Colby Ranger",
			"commitDateOld": "2013-03-04, 3:43 PM",
			"commitNameOld": "be7a135e94d9c71da3e9cd28edfd10ba7be3747d",
			"commitAuthorOld": "Colby Ranger",
			"daysBetweenCommits": 0.86,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,234 +1,251 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker, final Set<? extends ObjectId> want,\n \t\t\tSet<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tbeginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n+\t\twalker.setRetainBody(false);\n+\n+\t\tcanBuildBitmaps = config.isBuildBitmaps()\n+\t\t\t\t&& !shallowPack\n+\t\t\t\t&& have.isEmpty()\n+\t\t\t\t&& (excludeInPacks == null || excludeInPacks.length == 0);\n+\t\tif (!shallowPack && useBitmaps) {\n+\t\t\tBitmapIndex bitmapIndex = reader.getBitmapIndex();\n+\t\t\tif (bitmapIndex != null) {\n+\t\t\t\tPackWriterBitmapWalker bitmapWalker = new PackWriterBitmapWalker(\n+\t\t\t\t\t\twalker, bitmapIndex, countingMonitor);\n+\t\t\t\tfindObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n+\t\t\t\tendPhase(countingMonitor);\n+\t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n \t\tfinal RevFlag inCachedPack = walker.newFlag(\"inCachedPack\"); //$NON-NLS-1$\n \t\tfinal RevFlag include = walker.newFlag(\"include\"); //$NON-NLS-1$\n \t\tfinal RevFlag added = walker.newFlag(\"added\"); //$NON-NLS-1$\n \n \t\tfinal RevFlagSet keepOnRestart = new RevFlagSet();\n \t\tkeepOnRestart.add(inCachedPack);\n \n-\t\twalker.setRetainBody(false);\n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t\tif (useCachedPacks && reuseSupport != null) {\n \t\t\t\tSet<ObjectId> need = new HashSet<ObjectId>(want);\n \t\t\t\tList<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n \n \t\t\t\tfor (CachedPack pack : reuseSupport.getCachedPacks()) {\n \t\t\t\t\tif (need.containsAll(pack.getTips())) {\n \t\t\t\t\t\tneed.removeAll(pack.getTips());\n \t\t\t\t\t\tshortCircuit.add(pack);\n \t\t\t\t\t}\n \n \t\t\t\t\tfor (ObjectId id : pack.getTips()) {\n \t\t\t\t\t\ttipToPack.put(id, pack);\n \t\t\t\t\t\tall.add(id);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (need.isEmpty() && !shortCircuit.isEmpty()) {\n \t\t\t\t\tcachedPacks.addAll(shortCircuit);\n \t\t\t\t\tfor (CachedPack pack : shortCircuit)\n \t\t\t\t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\t\t\t\tendPhase(countingMonitor);\n \t\t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\t\treturn;\n \t\t\t\t}\n \n \t\t\t\thaveEst += tipToPack.size();\n \t\t\t}\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tif (tipToPack.containsKey(o))\n \t\t\t\t\t\to.add(inCachedPack);\n \n \t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\tif (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tif (walker instanceof DepthWalk.ObjectWalk) {\n \t\t\tDepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\tdepthWalk.markRoot(obj);\n \t\t\tif (unshallowObjects != null) {\n \t\t\t\tfor (ObjectId id : unshallowObjects)\n \t\t\t\t\tdepthWalk.markUnshallow(walker.parseAny(id));\n \t\t\t}\n \t\t} else {\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\twalker.markStart(obj);\n \t\t}\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tBlockList<RevCommit> commits = new BlockList<RevCommit>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (exclude(c))\n \t\t\t\tcontinue;\n \t\t\tif (c.has(inCachedPack)) {\n \t\t\t\tCachedPack pack = tipToPack.get(c);\n \t\t\t\tif (includesAllTips(pack, include, walker)) {\n \t\t\t\t\tuseCachedPack(walker, keepOnRestart, //\n \t\t\t\t\t\t\twantObjs, haveObjs, pack);\n \t\t\t\t\tcommits = new BlockList<RevCommit>();\n \n \t\t\t\t\tendPhase(countingMonitor);\n \t\t\t\t\tbeginPhase(PackingPhase.COUNTING, countingMonitor,\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tif (shallowPack) {\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \t\t} else {\n \t\t\tint commitCnt = 0;\n \t\t\tboolean putTagTargets = false;\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\tif (!cmit.has(added)) {\n \t\t\t\t\tcmit.add(added);\n \t\t\t\t\taddObject(cmit, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !exclude(p)) {\n \t\t\t\t\t\tp.add(added);\n \t\t\t\t\t\taddObject(p, 0);\n \t\t\t\t\t\tcommitCnt++;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tputTagTargets = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\t\taddObject(o, pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \t\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tendPhase(countingMonitor);\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c310fa0c802f40a774edb58641de3ac5bfad0e2c": {
			"type": "Ybodychange",
			"commitMessage": "Mark non-externalizable strings as such\n\nA few classes such as Constanrs are marked with @SuppressWarnings, as are\ntoString() methods with many liternal, but otherwise $NLS-n$ is used for\nstring containing text that should not be translated. A few literals may\nfall into the gray zone, but mostly I've tried to only tag the obvious\nones.\n\nChange-Id: I22e50a77e2bf9e0b842a66bdf674e8fa1692f590\n",
			"commitDate": "2012-12-27, 8:57 AM",
			"commitName": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
			"commitAuthor": "Robin Rosenberg",
			"commitDateOld": "2012-08-13, 3:29 PM",
			"commitNameOld": "b77ba049762e4ea3aadb756dad1d06c859bb3fe3",
			"commitAuthorOld": "Colby Ranger",
			"daysBetweenCommits": 135.77,
			"commitsBetweenForRepo": 148,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,234 +1,234 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker, final Set<? extends ObjectId> want,\n \t\t\tSet<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tbeginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n-\t\tfinal RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n-\t\tfinal RevFlag include = walker.newFlag(\"include\");\n-\t\tfinal RevFlag added = walker.newFlag(\"added\");\n+\t\tfinal RevFlag inCachedPack = walker.newFlag(\"inCachedPack\"); //$NON-NLS-1$\n+\t\tfinal RevFlag include = walker.newFlag(\"include\"); //$NON-NLS-1$\n+\t\tfinal RevFlag added = walker.newFlag(\"added\"); //$NON-NLS-1$\n \n \t\tfinal RevFlagSet keepOnRestart = new RevFlagSet();\n \t\tkeepOnRestart.add(inCachedPack);\n \n \t\twalker.setRetainBody(false);\n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t\tif (useCachedPacks && reuseSupport != null) {\n \t\t\t\tSet<ObjectId> need = new HashSet<ObjectId>(want);\n \t\t\t\tList<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n \n \t\t\t\tfor (CachedPack pack : reuseSupport.getCachedPacks()) {\n \t\t\t\t\tif (need.containsAll(pack.getTips())) {\n \t\t\t\t\t\tneed.removeAll(pack.getTips());\n \t\t\t\t\t\tshortCircuit.add(pack);\n \t\t\t\t\t}\n \n \t\t\t\t\tfor (ObjectId id : pack.getTips()) {\n \t\t\t\t\t\ttipToPack.put(id, pack);\n \t\t\t\t\t\tall.add(id);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (need.isEmpty() && !shortCircuit.isEmpty()) {\n \t\t\t\t\tcachedPacks.addAll(shortCircuit);\n \t\t\t\t\tfor (CachedPack pack : shortCircuit)\n \t\t\t\t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\t\t\t\tendPhase(countingMonitor);\n \t\t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\t\treturn;\n \t\t\t\t}\n \n \t\t\t\thaveEst += tipToPack.size();\n \t\t\t}\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tif (tipToPack.containsKey(o))\n \t\t\t\t\t\to.add(inCachedPack);\n \n \t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\tif (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tif (walker instanceof DepthWalk.ObjectWalk) {\n \t\t\tDepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\tdepthWalk.markRoot(obj);\n \t\t\tif (unshallowObjects != null) {\n \t\t\t\tfor (ObjectId id : unshallowObjects)\n \t\t\t\t\tdepthWalk.markUnshallow(walker.parseAny(id));\n \t\t\t}\n \t\t} else {\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\twalker.markStart(obj);\n \t\t}\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tBlockList<RevCommit> commits = new BlockList<RevCommit>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (exclude(c))\n \t\t\t\tcontinue;\n \t\t\tif (c.has(inCachedPack)) {\n \t\t\t\tCachedPack pack = tipToPack.get(c);\n \t\t\t\tif (includesAllTips(pack, include, walker)) {\n \t\t\t\t\tuseCachedPack(walker, keepOnRestart, //\n \t\t\t\t\t\t\twantObjs, haveObjs, pack);\n \t\t\t\t\tcommits = new BlockList<RevCommit>();\n \n \t\t\t\t\tendPhase(countingMonitor);\n \t\t\t\t\tbeginPhase(PackingPhase.COUNTING, countingMonitor,\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tif (shallowPack) {\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \t\t} else {\n \t\t\tint commitCnt = 0;\n \t\t\tboolean putTagTargets = false;\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\tif (!cmit.has(added)) {\n \t\t\t\t\tcmit.add(added);\n \t\t\t\t\taddObject(cmit, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !exclude(p)) {\n \t\t\t\t\t\tp.add(added);\n \t\t\t\t\t\taddObject(p, 0);\n \t\t\t\t\t\tcommitCnt++;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tputTagTargets = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\t\taddObject(o, pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \t\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tendPhase(countingMonitor);\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0f84b86e01da4680633c32bad101d021e0cb98ad": {
			"type": "Ybodychange",
			"commitMessage": "fix PackWriter excluded objects handling\n\nPackWriter supports excluding objects from being written to the pack.\nYou may specify a PackIndex which lists all those objects which should\nnot go into the new pack. This feature was broken because not all\ncommits have been checked whether they should be excluded or not. For\nother object types the exclude algorithm worked. This commit adds the\nmissing check.\n\nChange-Id: Id0047098393641ccba784c58b8325175c22fcece\nSigned-off-by: Christian Halstrick <christian.halstrick@sap.com>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>\n",
			"commitDate": "2012-06-04, 8:52 AM",
			"commitName": "0f84b86e01da4680633c32bad101d021e0cb98ad",
			"commitAuthor": "Christian Halstrick",
			"commitDateOld": "2012-05-08, 10:42 PM",
			"commitNameOld": "17fb542e9eaca9dffc4c84a6d23608dadb4b1ea1",
			"commitAuthorOld": "Kevin Sawicki",
			"daysBetweenCommits": 26.42,
			"commitsBetweenForRepo": 36,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,233 +1,234 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker, final Set<? extends ObjectId> want,\n \t\t\tSet<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tbeginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n \t\tfinal RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n \t\tfinal RevFlag include = walker.newFlag(\"include\");\n \t\tfinal RevFlag added = walker.newFlag(\"added\");\n \n \t\tfinal RevFlagSet keepOnRestart = new RevFlagSet();\n \t\tkeepOnRestart.add(inCachedPack);\n \n \t\twalker.setRetainBody(false);\n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t\tif (useCachedPacks && reuseSupport != null) {\n \t\t\t\tSet<ObjectId> need = new HashSet<ObjectId>(want);\n \t\t\t\tList<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n \n \t\t\t\tfor (CachedPack pack : reuseSupport.getCachedPacks()) {\n \t\t\t\t\tif (need.containsAll(pack.getTips())) {\n \t\t\t\t\t\tneed.removeAll(pack.getTips());\n \t\t\t\t\t\tshortCircuit.add(pack);\n \t\t\t\t\t}\n \n \t\t\t\t\tfor (ObjectId id : pack.getTips()) {\n \t\t\t\t\t\ttipToPack.put(id, pack);\n \t\t\t\t\t\tall.add(id);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (need.isEmpty() && !shortCircuit.isEmpty()) {\n \t\t\t\t\tcachedPacks.addAll(shortCircuit);\n \t\t\t\t\tfor (CachedPack pack : shortCircuit)\n \t\t\t\t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\t\t\t\tendPhase(countingMonitor);\n \t\t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\t\treturn;\n \t\t\t\t}\n \n \t\t\t\thaveEst += tipToPack.size();\n \t\t\t}\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tif (tipToPack.containsKey(o))\n \t\t\t\t\t\to.add(inCachedPack);\n \n \t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\tif (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tif (walker instanceof DepthWalk.ObjectWalk) {\n \t\t\tDepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\tdepthWalk.markRoot(obj);\n \t\t\tif (unshallowObjects != null) {\n \t\t\t\tfor (ObjectId id : unshallowObjects)\n \t\t\t\t\tdepthWalk.markUnshallow(walker.parseAny(id));\n \t\t\t}\n \t\t} else {\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\twalker.markStart(obj);\n \t\t}\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tBlockList<RevCommit> commits = new BlockList<RevCommit>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (exclude(c))\n \t\t\t\tcontinue;\n \t\t\tif (c.has(inCachedPack)) {\n \t\t\t\tCachedPack pack = tipToPack.get(c);\n \t\t\t\tif (includesAllTips(pack, include, walker)) {\n \t\t\t\t\tuseCachedPack(walker, keepOnRestart, //\n \t\t\t\t\t\t\twantObjs, haveObjs, pack);\n \t\t\t\t\tcommits = new BlockList<RevCommit>();\n \n \t\t\t\t\tendPhase(countingMonitor);\n \t\t\t\t\tbeginPhase(PackingPhase.COUNTING, countingMonitor,\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tif (shallowPack) {\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \t\t} else {\n \t\t\tint commitCnt = 0;\n \t\t\tboolean putTagTargets = false;\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\tif (!cmit.has(added)) {\n \t\t\t\t\tcmit.add(added);\n \t\t\t\t\taddObject(cmit, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\t\tRevCommit p = cmit.getParent(i);\n-\t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n+\t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)\n+\t\t\t\t\t\t\t&& !exclude(p)) {\n \t\t\t\t\t\tp.add(added);\n \t\t\t\t\t\taddObject(p, 0);\n \t\t\t\t\t\tcommitCnt++;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tputTagTargets = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\t\taddObject(o, pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \t\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tendPhase(countingMonitor);\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"16b8ebf2d1d099ac355767b1b1853ae7bf8854f1": {
			"type": "Ybodychange",
			"commitMessage": "Add an object encapsulating the state of a PackWriter\n\nExposes essentially the same state machine to the programmer as is\nexposed to the client via a ProgressMonitor, using a wrapper around\nbeginTask()/endTask().\n\nChange-Id: Ic3622b4acea65d2b9b3551c668806981fa7293e3\n",
			"commitDate": "2011-11-14, 11:27 AM",
			"commitName": "16b8ebf2d1d099ac355767b1b1853ae7bf8854f1",
			"commitAuthor": "Dave Borowitz",
			"commitDateOld": "2011-09-14, 4:34 PM",
			"commitNameOld": "1b6a549ff350673402f797fe7f878175e2b5ba30",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 60.83,
			"commitsBetweenForRepo": 63,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,234 +1,233 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker, final Set<? extends ObjectId> want,\n \t\t\tSet<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n-\t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n-\t\t\t\tProgressMonitor.UNKNOWN);\n+\t\tbeginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n \t\tfinal RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n \t\tfinal RevFlag include = walker.newFlag(\"include\");\n \t\tfinal RevFlag added = walker.newFlag(\"added\");\n \n \t\tfinal RevFlagSet keepOnRestart = new RevFlagSet();\n \t\tkeepOnRestart.add(inCachedPack);\n \n \t\twalker.setRetainBody(false);\n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t\tif (useCachedPacks && reuseSupport != null) {\n \t\t\t\tSet<ObjectId> need = new HashSet<ObjectId>(want);\n \t\t\t\tList<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n \n \t\t\t\tfor (CachedPack pack : reuseSupport.getCachedPacks()) {\n \t\t\t\t\tif (need.containsAll(pack.getTips())) {\n \t\t\t\t\t\tneed.removeAll(pack.getTips());\n \t\t\t\t\t\tshortCircuit.add(pack);\n \t\t\t\t\t}\n \n \t\t\t\t\tfor (ObjectId id : pack.getTips()) {\n \t\t\t\t\t\ttipToPack.put(id, pack);\n \t\t\t\t\t\tall.add(id);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (need.isEmpty() && !shortCircuit.isEmpty()) {\n \t\t\t\t\tcachedPacks.addAll(shortCircuit);\n \t\t\t\t\tfor (CachedPack pack : shortCircuit)\n \t\t\t\t\t\tcountingMonitor.update((int) pack.getObjectCount());\n-\t\t\t\t\tcountingMonitor.endTask();\n+\t\t\t\t\tendPhase(countingMonitor);\n \t\t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\t\treturn;\n \t\t\t\t}\n \n \t\t\t\thaveEst += tipToPack.size();\n \t\t\t}\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tif (tipToPack.containsKey(o))\n \t\t\t\t\t\to.add(inCachedPack);\n \n \t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\tif (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tif (walker instanceof DepthWalk.ObjectWalk) {\n \t\t\tDepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\tdepthWalk.markRoot(obj);\n \t\t\tif (unshallowObjects != null) {\n \t\t\t\tfor (ObjectId id : unshallowObjects)\n \t\t\t\t\tdepthWalk.markUnshallow(walker.parseAny(id));\n \t\t\t}\n \t\t} else {\n \t\t\tfor (RevObject obj : wantObjs)\n \t\t\t\twalker.markStart(obj);\n \t\t}\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tBlockList<RevCommit> commits = new BlockList<RevCommit>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (exclude(c))\n \t\t\t\tcontinue;\n \t\t\tif (c.has(inCachedPack)) {\n \t\t\t\tCachedPack pack = tipToPack.get(c);\n \t\t\t\tif (includesAllTips(pack, include, walker)) {\n \t\t\t\t\tuseCachedPack(walker, keepOnRestart, //\n \t\t\t\t\t\t\twantObjs, haveObjs, pack);\n \t\t\t\t\tcommits = new BlockList<RevCommit>();\n \n-\t\t\t\t\tcountingMonitor.endTask();\n-\t\t\t\t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n+\t\t\t\t\tendPhase(countingMonitor);\n+\t\t\t\t\tbeginPhase(PackingPhase.COUNTING, countingMonitor,\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tif (shallowPack) {\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \t\t} else {\n \t\t\tint commitCnt = 0;\n \t\t\tboolean putTagTargets = false;\n \t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\tif (!cmit.has(added)) {\n \t\t\t\t\tcmit.add(added);\n \t\t\t\t\taddObject(cmit, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n \t\t\t\t\t\tp.add(added);\n \t\t\t\t\t\taddObject(p, 0);\n \t\t\t\t\t\tcommitCnt++;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tputTagTargets = true;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\t\taddObject(o, pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \t\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n-\t\tcountingMonitor.endTask();\n+\t\tendPhase(countingMonitor);\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9952223e0645fd7a8cddc6093a7f449c6390238d": {
			"type": "Ybodychange",
			"commitMessage": "Implement server support for shallow clones\n\nThis implements the server side of shallow clones only (i.e.\ngit-upload-pack), not the client side.\n\nCQ: 5517\nBug: 301627\nChange-Id: Ied5f501f9c8d1fe90ab2ba44fac5fa67ed0035a4\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
			"commitDate": "2011-08-21, 3:04 PM",
			"commitName": "9952223e0645fd7a8cddc6093a7f449c6390238d",
			"commitAuthor": "Matt Fischer",
			"commitDateOld": "2011-08-21, 2:59 PM",
			"commitNameOld": "a1a8c6d77ec5bea13c4f5ca428e425d95e14e003",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,218 +1,234 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker, final Set<? extends ObjectId> want,\n \t\t\tSet<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n \t\tfinal RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n \t\tfinal RevFlag include = walker.newFlag(\"include\");\n \t\tfinal RevFlag added = walker.newFlag(\"added\");\n \n \t\tfinal RevFlagSet keepOnRestart = new RevFlagSet();\n \t\tkeepOnRestart.add(inCachedPack);\n \n \t\twalker.setRetainBody(false);\n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t\tif (useCachedPacks && reuseSupport != null) {\n \t\t\t\tSet<ObjectId> need = new HashSet<ObjectId>(want);\n \t\t\t\tList<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n \n \t\t\t\tfor (CachedPack pack : reuseSupport.getCachedPacks()) {\n \t\t\t\t\tif (need.containsAll(pack.getTips())) {\n \t\t\t\t\t\tneed.removeAll(pack.getTips());\n \t\t\t\t\t\tshortCircuit.add(pack);\n \t\t\t\t\t}\n \n \t\t\t\t\tfor (ObjectId id : pack.getTips()) {\n \t\t\t\t\t\ttipToPack.put(id, pack);\n \t\t\t\t\t\tall.add(id);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (need.isEmpty() && !shortCircuit.isEmpty()) {\n \t\t\t\t\tcachedPacks.addAll(shortCircuit);\n \t\t\t\t\tfor (CachedPack pack : shortCircuit)\n \t\t\t\t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\t\treturn;\n \t\t\t\t}\n \n \t\t\t\thaveEst += tipToPack.size();\n \t\t\t}\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tif (tipToPack.containsKey(o))\n \t\t\t\t\t\to.add(inCachedPack);\n \n-\t\t\t\t\tif (have.contains(o)) {\n+\t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\thaveObjs.add(o);\n-\t\t\t\t\t} else if (want.contains(o)) {\n+\t\t\t\t\tif (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n-\t\tfor (RevObject obj : wantObjs)\n-\t\t\twalker.markStart(obj);\n+\t\tif (walker instanceof DepthWalk.ObjectWalk) {\n+\t\t\tDepthWalk.ObjectWalk depthWalk = (DepthWalk.ObjectWalk) walker;\n+\t\t\tfor (RevObject obj : wantObjs)\n+\t\t\t\tdepthWalk.markRoot(obj);\n+\t\t\tif (unshallowObjects != null) {\n+\t\t\t\tfor (ObjectId id : unshallowObjects)\n+\t\t\t\t\tdepthWalk.markUnshallow(walker.parseAny(id));\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfor (RevObject obj : wantObjs)\n+\t\t\t\twalker.markStart(obj);\n+\t\t}\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tBlockList<RevCommit> commits = new BlockList<RevCommit>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (exclude(c))\n \t\t\t\tcontinue;\n \t\t\tif (c.has(inCachedPack)) {\n \t\t\t\tCachedPack pack = tipToPack.get(c);\n \t\t\t\tif (includesAllTips(pack, include, walker)) {\n \t\t\t\t\tuseCachedPack(walker, keepOnRestart, //\n \t\t\t\t\t\t\twantObjs, haveObjs, pack);\n \t\t\t\t\tcommits = new BlockList<RevCommit>();\n \n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n-\t\tint commitCnt = 0;\n-\t\tboolean putTagTargets = false;\n-\t\tfor (RevCommit cmit : commits) {\n-\t\t\tif (!cmit.has(added)) {\n-\t\t\t\tcmit.add(added);\n+\t\tif (shallowPack) {\n+\t\t\tfor (RevCommit cmit : commits) {\n \t\t\t\taddObject(cmit, 0);\n-\t\t\t\tcommitCnt++;\n \t\t\t}\n-\n-\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n-\t\t\t\tRevCommit p = cmit.getParent(i);\n-\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n-\t\t\t\t\tp.add(added);\n-\t\t\t\t\taddObject(p, 0);\n+\t\t} else {\n+\t\t\tint commitCnt = 0;\n+\t\t\tboolean putTagTargets = false;\n+\t\t\tfor (RevCommit cmit : commits) {\n+\t\t\t\tif (!cmit.has(added)) {\n+\t\t\t\t\tcmit.add(added);\n+\t\t\t\t\taddObject(cmit, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n-\t\t\t}\n \n-\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n-\t\t\t\tfor (ObjectId id : tagTargets) {\n-\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n-\t\t\t\t\tif (obj instanceof RevCommit\n-\t\t\t\t\t\t\t&& obj.has(include)\n-\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n-\t\t\t\t\t\t\t&& !obj.has(added)) {\n-\t\t\t\t\t\tobj.add(added);\n-\t\t\t\t\t\taddObject(obj, 0);\n+\t\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n+\t\t\t\t\tRevCommit p = cmit.getParent(i);\n+\t\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n+\t\t\t\t\t\tp.add(added);\n+\t\t\t\t\t\taddObject(p, 0);\n+\t\t\t\t\t\tcommitCnt++;\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tputTagTargets = true;\n+\n+\t\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n+\t\t\t\t\tfor (ObjectId id : tagTargets) {\n+\t\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n+\t\t\t\t\t\tif (obj instanceof RevCommit\n+\t\t\t\t\t\t\t\t&& obj.has(include)\n+\t\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n+\t\t\t\t\t\t\t\t&& !obj.has(added)) {\n+\t\t\t\t\t\t\tobj.add(added);\n+\t\t\t\t\t\t\taddObject(obj, 0);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tputTagTargets = true;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\t\taddObject(o, pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\tif (exclude(o))\n \t\t\t\t\tcontinue;\n \t\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tcountingMonitor.endTask();\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a1a8c6d77ec5bea13c4f5ca428e425d95e14e003": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: support excluding objects already in other packs\n\nThis can be useful when implementing garbage collection and there\nare packs that should not be copied, such as huge packs that have\na sibling \".keep\" file alongside of them.\n\nCallers driving PackWriter need to initialize the list of packs not\nto include objects from by passing each index to excludeObjects().\n\nChange-Id: Id7f34df69df97be406bcae184308e92b0e8690fd\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
			"commitDate": "2011-08-21, 2:59 PM",
			"commitName": "a1a8c6d77ec5bea13c4f5ca428e425d95e14e003",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-08-16, 1:18 PM",
			"commitNameOld": "74333e63b60440be5ff9f591f2203b635e26e3a0",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 5.07,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,212 +1,218 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker, final Set<? extends ObjectId> want,\n \t\t\tSet<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n \t\tfinal RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n \t\tfinal RevFlag include = walker.newFlag(\"include\");\n \t\tfinal RevFlag added = walker.newFlag(\"added\");\n \n \t\tfinal RevFlagSet keepOnRestart = new RevFlagSet();\n \t\tkeepOnRestart.add(inCachedPack);\n \n \t\twalker.setRetainBody(false);\n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t\tif (useCachedPacks && reuseSupport != null) {\n \t\t\t\tSet<ObjectId> need = new HashSet<ObjectId>(want);\n \t\t\t\tList<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n \n \t\t\t\tfor (CachedPack pack : reuseSupport.getCachedPacks()) {\n \t\t\t\t\tif (need.containsAll(pack.getTips())) {\n \t\t\t\t\t\tneed.removeAll(pack.getTips());\n \t\t\t\t\t\tshortCircuit.add(pack);\n \t\t\t\t\t}\n \n \t\t\t\t\tfor (ObjectId id : pack.getTips()) {\n \t\t\t\t\t\ttipToPack.put(id, pack);\n \t\t\t\t\t\tall.add(id);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (need.isEmpty() && !shortCircuit.isEmpty()) {\n \t\t\t\t\tcachedPacks.addAll(shortCircuit);\n \t\t\t\t\tfor (CachedPack pack : shortCircuit)\n \t\t\t\t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\t\treturn;\n \t\t\t\t}\n \n \t\t\t\thaveEst += tipToPack.size();\n \t\t\t}\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tif (tipToPack.containsKey(o))\n \t\t\t\t\t\to.add(inCachedPack);\n \n \t\t\t\t\tif (have.contains(o)) {\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\t} else if (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tfor (RevObject obj : wantObjs)\n \t\t\twalker.markStart(obj);\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tBlockList<RevCommit> commits = new BlockList<RevCommit>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n+\t\t\tif (exclude(c))\n+\t\t\t\tcontinue;\n \t\t\tif (c.has(inCachedPack)) {\n \t\t\t\tCachedPack pack = tipToPack.get(c);\n \t\t\t\tif (includesAllTips(pack, include, walker)) {\n \t\t\t\t\tuseCachedPack(walker, keepOnRestart, //\n \t\t\t\t\t\t\twantObjs, haveObjs, pack);\n \t\t\t\t\tcommits = new BlockList<RevCommit>();\n \n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tint commitCnt = 0;\n \t\tboolean putTagTargets = false;\n \t\tfor (RevCommit cmit : commits) {\n \t\t\tif (!cmit.has(added)) {\n \t\t\t\tcmit.add(added);\n \t\t\t\taddObject(cmit, 0);\n \t\t\t\tcommitCnt++;\n \t\t\t}\n \n \t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n \t\t\t\t\tp.add(added);\n \t\t\t\t\taddObject(p, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tputTagTargets = true;\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n+\t\t\t\tif (exclude(o))\n+\t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\t\taddObject(o, pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n+\t\t\t\tif (exclude(o))\n+\t\t\t\t\tcontinue;\n \t\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tcountingMonitor.endTask();\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"74333e63b60440be5ff9f591f2203b635e26e3a0": {
			"type": "Yparameterchange",
			"commitMessage": "PackWriter: Make want/have actual sets\n\nDuring parsing these are used with contains(). If they are a List\ntype, the contains operation is not efficient. Some callers such\nas UploadPack often pass a List here, so convert to Set when the\ntype isn't efficient for contains().\n\nChange-Id: If948ae3bf1f46e756bd2d5db14795e12ba7a6207\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-08-16, 1:18 PM",
			"commitName": "74333e63b60440be5ff9f591f2203b635e26e3a0",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-08-13, 6:01 PM",
			"commitNameOld": "2610eaf386f37386e9886a8635d499ebf772a240",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 2.8,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,212 +1,212 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n-\t\t\tfinal ObjectWalk walker, final Collection<? extends ObjectId> want,\n-\t\t\tCollection<? extends ObjectId> have)\n+\t\t\tfinal ObjectWalk walker, final Set<? extends ObjectId> want,\n+\t\t\tSet<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n \t\tfinal RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n \t\tfinal RevFlag include = walker.newFlag(\"include\");\n \t\tfinal RevFlag added = walker.newFlag(\"added\");\n \n \t\tfinal RevFlagSet keepOnRestart = new RevFlagSet();\n \t\tkeepOnRestart.add(inCachedPack);\n \n \t\twalker.setRetainBody(false);\n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t\tif (useCachedPacks && reuseSupport != null) {\n \t\t\t\tSet<ObjectId> need = new HashSet<ObjectId>(want);\n \t\t\t\tList<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n \n \t\t\t\tfor (CachedPack pack : reuseSupport.getCachedPacks()) {\n \t\t\t\t\tif (need.containsAll(pack.getTips())) {\n \t\t\t\t\t\tneed.removeAll(pack.getTips());\n \t\t\t\t\t\tshortCircuit.add(pack);\n \t\t\t\t\t}\n \n \t\t\t\t\tfor (ObjectId id : pack.getTips()) {\n \t\t\t\t\t\ttipToPack.put(id, pack);\n \t\t\t\t\t\tall.add(id);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (need.isEmpty() && !shortCircuit.isEmpty()) {\n \t\t\t\t\tcachedPacks.addAll(shortCircuit);\n \t\t\t\t\tfor (CachedPack pack : shortCircuit)\n \t\t\t\t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\t\treturn;\n \t\t\t\t}\n \n \t\t\t\thaveEst += tipToPack.size();\n \t\t\t}\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tif (tipToPack.containsKey(o))\n \t\t\t\t\t\to.add(inCachedPack);\n \n \t\t\t\t\tif (have.contains(o)) {\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\t} else if (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tfor (RevObject obj : wantObjs)\n \t\t\twalker.markStart(obj);\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tBlockList<RevCommit> commits = new BlockList<RevCommit>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (c.has(inCachedPack)) {\n \t\t\t\tCachedPack pack = tipToPack.get(c);\n \t\t\t\tif (includesAllTips(pack, include, walker)) {\n \t\t\t\t\tuseCachedPack(walker, keepOnRestart, //\n \t\t\t\t\t\t\twantObjs, haveObjs, pack);\n \t\t\t\t\tcommits = new BlockList<RevCommit>();\n \n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tint commitCnt = 0;\n \t\tboolean putTagTargets = false;\n \t\tfor (RevCommit cmit : commits) {\n \t\t\tif (!cmit.has(added)) {\n \t\t\t\tcmit.add(added);\n \t\t\t\taddObject(cmit, 0);\n \t\t\t\tcommitCnt++;\n \t\t\t}\n \n \t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n \t\t\t\t\tp.add(added);\n \t\t\t\t\taddObject(p, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tputTagTargets = true;\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tif (thin && !baseTrees.isEmpty()) {\n \t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \n \t\t\t\tint pathHash = walker.getPathHashCode();\n \t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\t\tint pathLen = walker.getPathLength();\n \t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\t\taddObject(o, pathHash);\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t} else {\n \t\t\tRevObject o;\n \t\t\twhile ((o = walker.nextObject()) != null) {\n \t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\t\tcontinue;\n \t\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\t\tcountingMonitor.update(1);\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tcountingMonitor.endTask();\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[countingMonitor-ProgressMonitor(modifiers-final), walker-ObjectWalk(modifiers-final), want-Collection<? extends ObjectId>(modifiers-final), have-Collection<? extends ObjectId>]",
				"newValue": "[countingMonitor-ProgressMonitor(modifiers-final), walker-ObjectWalk(modifiers-final), want-Set<? extends ObjectId>(modifiers-final), have-Set<? extends ObjectId>]"
			}
		},
		"99e6cfb131bb407247acbc8c0a73e7c7cf37ebc2": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: Only search for base objects on thin packs\n\nA non-thin pack does not need to worry about preferred bases, the pack\nwill be self-contained and all required delta base objects will appear\nwithin the pack itself. Obtaining the path buffer and length from the\nObjectWalk to build the preferred base table is \"expensive\", so avoid\nthe cost unless a thin pack is being constructed.\n\nChange-Id: I16e30cd864f4189d4304e7957a7cd5bdb9e84528\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-08-08, 4:10 PM",
			"commitName": "99e6cfb131bb407247acbc8c0a73e7c7cf37ebc2",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-07-28, 11:22 AM",
			"commitNameOld": "68cc21b60d83b5c4fb1de6c34a79836c51dd9b3b",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 11.2,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,203 +1,212 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker, final Collection<? extends ObjectId> want,\n \t\t\tCollection<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n \t\tfinal RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n \t\tfinal RevFlag include = walker.newFlag(\"include\");\n \t\tfinal RevFlag added = walker.newFlag(\"added\");\n \n \t\tfinal RevFlagSet keepOnRestart = new RevFlagSet();\n \t\tkeepOnRestart.add(inCachedPack);\n \n \t\twalker.setRetainBody(false);\n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t\tif (useCachedPacks && reuseSupport != null) {\n \t\t\t\tSet<ObjectId> need = new HashSet<ObjectId>(want);\n \t\t\t\tList<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n \n \t\t\t\tfor (CachedPack pack : reuseSupport.getCachedPacks()) {\n \t\t\t\t\tif (need.containsAll(pack.getTips())) {\n \t\t\t\t\t\tneed.removeAll(pack.getTips());\n \t\t\t\t\t\tshortCircuit.add(pack);\n \t\t\t\t\t}\n \n \t\t\t\t\tfor (ObjectId id : pack.getTips()) {\n \t\t\t\t\t\ttipToPack.put(id, pack);\n \t\t\t\t\t\tall.add(id);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (need.isEmpty() && !shortCircuit.isEmpty()) {\n \t\t\t\t\tcachedPacks.addAll(shortCircuit);\n \t\t\t\t\tfor (CachedPack pack : shortCircuit)\n \t\t\t\t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\t\treturn;\n \t\t\t\t}\n \n \t\t\t\thaveEst += tipToPack.size();\n \t\t\t}\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tif (tipToPack.containsKey(o))\n \t\t\t\t\t\to.add(inCachedPack);\n \n \t\t\t\t\tif (have.contains(o)) {\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\t} else if (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tfor (RevObject obj : wantObjs)\n \t\t\twalker.markStart(obj);\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tBlockList<RevCommit> commits = new BlockList<RevCommit>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (c.has(inCachedPack)) {\n \t\t\t\tCachedPack pack = tipToPack.get(c);\n \t\t\t\tif (includesAllTips(pack, include, walker)) {\n \t\t\t\t\tuseCachedPack(walker, keepOnRestart, //\n \t\t\t\t\t\t\twantObjs, haveObjs, pack);\n \t\t\t\t\tcommits = new BlockList<RevCommit>();\n \n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tint commitCnt = 0;\n \t\tboolean putTagTargets = false;\n \t\tfor (RevCommit cmit : commits) {\n \t\t\tif (!cmit.has(added)) {\n \t\t\t\tcmit.add(added);\n \t\t\t\taddObject(cmit, 0);\n \t\t\t\tcommitCnt++;\n \t\t\t}\n \n \t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n \t\t\t\t\tp.add(added);\n \t\t\t\t\taddObject(p, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tputTagTargets = true;\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n-\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n-\t\t\t\tobjectsMap, edgeObjects, reader);\n-\t\tRevObject o;\n-\t\twhile ((o = walker.nextObject()) != null) {\n-\t\t\tif (o.has(RevFlag.UNINTERESTING))\n-\t\t\t\tcontinue;\n+\t\tif (thin && !baseTrees.isEmpty()) {\n+\t\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n+\t\t\t\t\tobjectsMap, edgeObjects, reader);\n+\t\t\tRevObject o;\n+\t\t\twhile ((o = walker.nextObject()) != null) {\n+\t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n+\t\t\t\t\tcontinue;\n \n-\t\t\tint pathHash = walker.getPathHashCode();\n-\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n-\t\t\tint pathLen = walker.getPathLength();\n-\n-\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n-\t\t\taddObject(o, pathHash);\n-\t\t\tcountingMonitor.update(1);\n+\t\t\t\tint pathHash = walker.getPathHashCode();\n+\t\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n+\t\t\t\tint pathLen = walker.getPathLength();\n+\t\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n+\t\t\t\taddObject(o, pathHash);\n+\t\t\t\tcountingMonitor.update(1);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tRevObject o;\n+\t\t\twhile ((o = walker.nextObject()) != null) {\n+\t\t\t\tif (o.has(RevFlag.UNINTERESTING))\n+\t\t\t\t\tcontinue;\n+\t\t\t\taddObject(o, walker.getPathHashCode());\n+\t\t\t\tcountingMonitor.update(1);\n+\t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tcountingMonitor.endTask();\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9f5bbb5dd41f87d6428eb49c021e00d8099d0c17": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: Speed up pruning of objects from cached packs\n\nDuring object enumeration for the thin pack, very few objects come\nout that are duplicated with the cached pack. Typically these are\nonly cases where a blob or tree was cherry-picked forward, got a\ncopy or rename, or was reverted... all relatively infrequent events.\n\nSpeed up pruning of the thin pack object list by combining the phase\nwith the object representation selection. Implementers should already\nbe offering to reuse the object from the cached pack if it is stored\nthere, at which point the implementation can perform a very fast type\nof containment test using the cached pack's identity rather than yet\nanother index lookup.  For the local disk case this is probably not a\nbig improvement, but it does help on the DHT implementation where the\ntwo passes combined into one reduces latency.\n\nChange-Id: I6a07fc75d9075bf6233e967360b6546f9e9a2b33\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-04-01, 3:40 PM",
			"commitName": "9f5bbb5dd41f87d6428eb49c021e00d8099d0c17",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-03-18, 12:31 PM",
			"commitNameOld": "bb1956e647d2f48ef36ef98a7f22120fdad0b37c",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 14.13,
			"commitsBetweenForRepo": 22,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,235 +1,203 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker, final Collection<? extends ObjectId> want,\n \t\t\tCollection<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n \t\tfinal RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n \t\tfinal RevFlag include = walker.newFlag(\"include\");\n \t\tfinal RevFlag added = walker.newFlag(\"added\");\n \n \t\tfinal RevFlagSet keepOnRestart = new RevFlagSet();\n \t\tkeepOnRestart.add(inCachedPack);\n \n \t\twalker.setRetainBody(false);\n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t\tif (useCachedPacks && reuseSupport != null) {\n \t\t\t\tSet<ObjectId> need = new HashSet<ObjectId>(want);\n \t\t\t\tList<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n \n \t\t\t\tfor (CachedPack pack : reuseSupport.getCachedPacks()) {\n \t\t\t\t\tif (need.containsAll(pack.getTips())) {\n \t\t\t\t\t\tneed.removeAll(pack.getTips());\n \t\t\t\t\t\tshortCircuit.add(pack);\n \t\t\t\t\t}\n \n \t\t\t\t\tfor (ObjectId id : pack.getTips()) {\n \t\t\t\t\t\ttipToPack.put(id, pack);\n \t\t\t\t\t\tall.add(id);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (need.isEmpty() && !shortCircuit.isEmpty()) {\n \t\t\t\t\tcachedPacks.addAll(shortCircuit);\n \t\t\t\t\tfor (CachedPack pack : shortCircuit)\n \t\t\t\t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\t\treturn;\n \t\t\t\t}\n \n \t\t\t\thaveEst += tipToPack.size();\n \t\t\t}\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tif (tipToPack.containsKey(o))\n \t\t\t\t\t\to.add(inCachedPack);\n \n \t\t\t\t\tif (have.contains(o)) {\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\t} else if (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tfor (RevObject obj : wantObjs)\n \t\t\twalker.markStart(obj);\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n-\t\tint typesToPrune = 0;\n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tBlockList<RevCommit> commits = new BlockList<RevCommit>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (c.has(inCachedPack)) {\n \t\t\t\tCachedPack pack = tipToPack.get(c);\n \t\t\t\tif (includesAllTips(pack, include, walker)) {\n \t\t\t\t\tuseCachedPack(walker, keepOnRestart, //\n \t\t\t\t\t\t\twantObjs, haveObjs, pack);\n \t\t\t\t\tcommits = new BlockList<RevCommit>();\n \n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tint commitCnt = 0;\n \t\tboolean putTagTargets = false;\n \t\tfor (RevCommit cmit : commits) {\n \t\t\tif (!cmit.has(added)) {\n \t\t\t\tcmit.add(added);\n \t\t\t\taddObject(cmit, 0);\n \t\t\t\tcommitCnt++;\n \t\t\t}\n \n \t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n \t\t\t\t\tp.add(added);\n \t\t\t\t\taddObject(p, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tputTagTargets = true;\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n-\t\tfor (CachedPack p : cachedPacks) {\n-\t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n-\t\t\t\tif (baseTrees.size() <= maxBases)\n-\t\t\t\t\tbaseTrees.add(walker.lookupCommit(d).getTree());\n-\t\t\t\tobjectsMap.get(d).setEdge();\n-\t\t\t\ttypesToPrune |= 1 << Constants.OBJ_COMMIT;\n-\t\t\t}\n-\t\t}\n-\n \t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\tobjectsMap, edgeObjects, reader);\n \t\tRevObject o;\n \t\twhile ((o = walker.nextObject()) != null) {\n \t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\tcontinue;\n \n \t\t\tint pathHash = walker.getPathHashCode();\n \t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\tint pathLen = walker.getPathLength();\n \n \t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\taddObject(o, pathHash);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n-\t\tfor (CachedPack p : cachedPacks) {\n-\t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n-\t\t\t\tobjectsMap.get(d).setEdge();\n-\t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TREE;\n-\t\t\t}\n-\t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n-\t\t\t\tobjectsMap.get(d).setEdge();\n-\t\t\t\ttypesToPrune |= 1 << Constants.OBJ_BLOB;\n-\t\t\t}\n-\t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n-\t\t\t\tobjectsMap.get(d).setEdge();\n-\t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TAG;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (typesToPrune != 0) {\n-\t\t\tpruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n-\t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TREE);\n-\t\t\tpruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n-\t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TAG);\n-\t\t}\n-\n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tcountingMonitor.endTask();\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f67e5602af72b7b2238eb6f6fcdc206a47edabd5": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: Reduce GC during enumeration\n\nInstead of resizing an ArrayList until all objects have been added,\nappend objects into a specialized List type that uses small arrays\nof 1024 entries for each 1024 objects added.\n\nFor a large repository like linux-2.6, PackWriter will now allocate\n1,758 smaller arrays to hold the object list, without creating any\ngarbage from the intermediate states due to list expansion.\n\n1024 was chosen as the block size (and initial directory size) as this\nis a reasonable balance for the PackWriter code.  Each block uses\napproximately 4096 bytes in a 32 bit JVM, as does the default top\nlevel block directory.  The top level directory doesn't expand until 1\nmillion items have been added to the list, which for linux-2.6 won't\nyet occur as the lists are per-object-type and are thus bounded to\nabout 1/3 of 1.8 million.\n\nChange-Id: If9e4092eb502394c5d3d044b58cf49952772f6d6\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-03-07, 7:23 PM",
			"commitName": "f67e5602af72b7b2238eb6f6fcdc206a47edabd5",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-03-02, 1:49 PM",
			"commitNameOld": "a468cb57c2f2fbd8da163f002b505255ea768244",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 5.23,
			"commitsBetweenForRepo": 16,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,240 +1,235 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker, final Collection<? extends ObjectId> want,\n \t\t\tCollection<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n \t\tfinal RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n \t\tfinal RevFlag include = walker.newFlag(\"include\");\n \t\tfinal RevFlag added = walker.newFlag(\"added\");\n \n \t\tfinal RevFlagSet keepOnRestart = new RevFlagSet();\n \t\tkeepOnRestart.add(inCachedPack);\n \n \t\twalker.setRetainBody(false);\n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t\tif (useCachedPacks && reuseSupport != null) {\n \t\t\t\tSet<ObjectId> need = new HashSet<ObjectId>(want);\n \t\t\t\tList<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n \n \t\t\t\tfor (CachedPack pack : reuseSupport.getCachedPacks()) {\n \t\t\t\t\tif (need.containsAll(pack.getTips())) {\n \t\t\t\t\t\tneed.removeAll(pack.getTips());\n \t\t\t\t\t\tshortCircuit.add(pack);\n \t\t\t\t\t}\n \n \t\t\t\t\tfor (ObjectId id : pack.getTips()) {\n \t\t\t\t\t\ttipToPack.put(id, pack);\n \t\t\t\t\t\tall.add(id);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (need.isEmpty() && !shortCircuit.isEmpty()) {\n \t\t\t\t\tcachedPacks.addAll(shortCircuit);\n \t\t\t\t\tfor (CachedPack pack : shortCircuit)\n \t\t\t\t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\t\treturn;\n \t\t\t\t}\n \n \t\t\t\thaveEst += tipToPack.size();\n \t\t\t}\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tif (tipToPack.containsKey(o))\n \t\t\t\t\t\to.add(inCachedPack);\n \n \t\t\t\t\tif (have.contains(o)) {\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\t} else if (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tfor (RevObject obj : wantObjs)\n \t\t\twalker.markStart(obj);\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tint typesToPrune = 0;\n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n-\t\tList<RevCommit> commits = new ArrayList<RevCommit>();\n+\t\tBlockList<RevCommit> commits = new BlockList<RevCommit>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (c.has(inCachedPack)) {\n \t\t\t\tCachedPack pack = tipToPack.get(c);\n \t\t\t\tif (includesAllTips(pack, include, walker)) {\n \t\t\t\t\tuseCachedPack(walker, keepOnRestart, //\n \t\t\t\t\t\t\twantObjs, haveObjs, pack);\n-\t\t\t\t\tcommits = new ArrayList<RevCommit>();\n+\t\t\t\t\tcommits = new BlockList<RevCommit>();\n \n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n-\t\tif (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n-\t\t\tArrayList<ObjectToPack> list = (ArrayList<ObjectToPack>) objectsLists[Constants.OBJ_COMMIT];\n-\t\t\tlist.ensureCapacity(list.size() + commits.size());\n-\t\t}\n-\n \t\tint commitCnt = 0;\n \t\tboolean putTagTargets = false;\n \t\tfor (RevCommit cmit : commits) {\n \t\t\tif (!cmit.has(added)) {\n \t\t\t\tcmit.add(added);\n \t\t\t\taddObject(cmit, 0);\n \t\t\t\tcommitCnt++;\n \t\t\t}\n \n \t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n \t\t\t\t\tp.add(added);\n \t\t\t\t\taddObject(p, 0);\n \t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!putTagTargets && 4096 < commitCnt) {\n \t\t\t\tfor (ObjectId id : tagTargets) {\n \t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n \t\t\t\t\tif (obj instanceof RevCommit\n \t\t\t\t\t\t\t&& obj.has(include)\n \t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n \t\t\t\t\t\t\t&& !obj.has(added)) {\n \t\t\t\t\t\tobj.add(added);\n \t\t\t\t\t\taddObject(obj, 0);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tputTagTargets = true;\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tfor (CachedPack p : cachedPacks) {\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(walker.lookupCommit(d).getTree());\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_COMMIT;\n \t\t\t}\n \t\t}\n \n \t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\tobjectsMap, edgeObjects, reader);\n \t\tRevObject o;\n \t\twhile ((o = walker.nextObject()) != null) {\n \t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\tcontinue;\n \n \t\t\tint pathHash = walker.getPathHashCode();\n \t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\tint pathLen = walker.getPathLength();\n \n \t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\taddObject(o, pathHash);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tfor (CachedPack p : cachedPacks) {\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TREE;\n \t\t\t}\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_BLOB;\n \t\t\t}\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TAG;\n \t\t\t}\n \t\t}\n \n \t\tif (typesToPrune != 0) {\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TREE);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TAG);\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tcountingMonitor.endTask();\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8f865bfffed575c3a4db6d7db92dc5f752f97237": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: Hoist and cluster reference targets\n\nMany source browsers and network related tools like UploadPack need\nto find and parse the target of all branches and annotated tags\nwithin the repository during their startup phase.  Clustering these\ntogether into the same part of the pack file will improve locality,\nreducing thrashing when an application starts and needs to load\nall of these into memory at once.\n\nTo prevent bottlenecking basic log viewing tools that are scannning\nbackwards from the tip of a current branch (and don't need tags)\nwe place this cluster of older targets after 4096 newer commits\nhave already been placed into the pack stream.  4096 was chosen as\na rough guess, but was based on a few factors:\n\n  - log viewers typically show 5-200 commits per page\n  - users only view the first page or two\n\n  - DHT can cram 2200-4000 commits per 1 MiB chunk\n    thus these will fall into the second commit chunk (roughly)\n\nUnfortunately this placement hurts history tools that are scanning\nbackwards through the commit graph and completely ignored tags or\nbranch heads when they started.\n\nAn ancient tagged commit is no longer positioned behind its first\nchild (its now much earlier), resulting in a page fault for the\nparser to reload this cluster of objects on demand.  This may be\nan acceptable loss.  If a user is walking backwards and has already\nscanned through more than 4096 commits of history, waiting for the\nregion to reload isn't really that bad compared to the amount of\ntime already spent.\n\nIf the repository is so small that there are less than 4096 commits,\nthis change has no impact on the placement of objects.\n\nChange-Id: If3052e430d305e17878d94145c93754f56b74c61\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-02-18, 7:15 PM",
			"commitName": "8f865bfffed575c3a4db6d7db92dc5f752f97237",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-02-18, 7:15 PM",
			"commitNameOld": "19037e8cfc2d9534f79e40c898fdaeacaf499e82",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,221 +1,240 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker, final Collection<? extends ObjectId> want,\n \t\t\tCollection<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n \t\tfinal RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n \t\tfinal RevFlag include = walker.newFlag(\"include\");\n \t\tfinal RevFlag added = walker.newFlag(\"added\");\n \n \t\tfinal RevFlagSet keepOnRestart = new RevFlagSet();\n \t\tkeepOnRestart.add(inCachedPack);\n \n \t\twalker.setRetainBody(false);\n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t\tif (useCachedPacks && reuseSupport != null) {\n \t\t\t\tSet<ObjectId> need = new HashSet<ObjectId>(want);\n \t\t\t\tList<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n \n \t\t\t\tfor (CachedPack pack : reuseSupport.getCachedPacks()) {\n \t\t\t\t\tif (need.containsAll(pack.getTips())) {\n \t\t\t\t\t\tneed.removeAll(pack.getTips());\n \t\t\t\t\t\tshortCircuit.add(pack);\n \t\t\t\t\t}\n \n \t\t\t\t\tfor (ObjectId id : pack.getTips()) {\n \t\t\t\t\t\ttipToPack.put(id, pack);\n \t\t\t\t\t\tall.add(id);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (need.isEmpty() && !shortCircuit.isEmpty()) {\n \t\t\t\t\tcachedPacks.addAll(shortCircuit);\n \t\t\t\t\tfor (CachedPack pack : shortCircuit)\n \t\t\t\t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\t\treturn;\n \t\t\t\t}\n \n \t\t\t\thaveEst += tipToPack.size();\n \t\t\t}\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tif (tipToPack.containsKey(o))\n \t\t\t\t\t\to.add(inCachedPack);\n \n \t\t\t\t\tif (have.contains(o)) {\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\t} else if (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\tif (o instanceof RevTag)\n \t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tif (!wantTags.isEmpty()) {\n \t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n \t\t\tfor (RevTag tag : wantTags)\n \t\t\t\tall.add(tag.getObject());\n \t\t\tq = walker.parseAny(all, true);\n \t\t\ttry {\n \t\t\t\twhile (q.next() != null) {\n \t\t\t\t\t// Just need to pop the queue item to parse the object.\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tq.release();\n \t\t\t}\n \t\t}\n \n \t\tfor (RevObject obj : wantObjs)\n \t\t\twalker.markStart(obj);\n \t\tfor (RevObject obj : haveObjs)\n \t\t\twalker.markUninteresting(obj);\n \n \t\tint typesToPrune = 0;\n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tList<RevCommit> commits = new ArrayList<RevCommit>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (c.has(inCachedPack)) {\n \t\t\t\tCachedPack pack = tipToPack.get(c);\n \t\t\t\tif (includesAllTips(pack, include, walker)) {\n \t\t\t\t\tuseCachedPack(walker, keepOnRestart, //\n \t\t\t\t\t\t\twantObjs, haveObjs, pack);\n \t\t\t\t\tcommits = new ArrayList<RevCommit>();\n \n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tif (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n \t\t\tArrayList<ObjectToPack> list = (ArrayList<ObjectToPack>) objectsLists[Constants.OBJ_COMMIT];\n \t\t\tlist.ensureCapacity(list.size() + commits.size());\n \t\t}\n+\n+\t\tint commitCnt = 0;\n+\t\tboolean putTagTargets = false;\n \t\tfor (RevCommit cmit : commits) {\n \t\t\tif (!cmit.has(added)) {\n \t\t\t\tcmit.add(added);\n \t\t\t\taddObject(cmit, 0);\n+\t\t\t\tcommitCnt++;\n \t\t\t}\n \n \t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n \t\t\t\t\tp.add(added);\n \t\t\t\t\taddObject(p, 0);\n+\t\t\t\t\tcommitCnt++;\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\tif (!putTagTargets && 4096 < commitCnt) {\n+\t\t\t\tfor (ObjectId id : tagTargets) {\n+\t\t\t\t\tRevObject obj = walker.lookupOrNull(id);\n+\t\t\t\t\tif (obj instanceof RevCommit\n+\t\t\t\t\t\t\t&& obj.has(include)\n+\t\t\t\t\t\t\t&& !obj.has(RevFlag.UNINTERESTING)\n+\t\t\t\t\t\t\t&& !obj.has(added)) {\n+\t\t\t\t\t\tobj.add(added);\n+\t\t\t\t\t\taddObject(obj, 0);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tputTagTargets = true;\n+\t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tfor (CachedPack p : cachedPacks) {\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(walker.lookupCommit(d).getTree());\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_COMMIT;\n \t\t\t}\n \t\t}\n \n \t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\tobjectsMap, edgeObjects, reader);\n \t\tRevObject o;\n \t\twhile ((o = walker.nextObject()) != null) {\n \t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\tcontinue;\n \n \t\t\tint pathHash = walker.getPathHashCode();\n \t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\tint pathLen = walker.getPathLength();\n \n \t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\taddObject(o, pathHash);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tfor (CachedPack p : cachedPacks) {\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TREE;\n \t\t\t}\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_BLOB;\n \t\t\t}\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TAG;\n \t\t\t}\n \t\t}\n \n \t\tif (typesToPrune != 0) {\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TREE);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TAG);\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tcountingMonitor.endTask();\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"19037e8cfc2d9534f79e40c898fdaeacaf499e82": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: Parse tag target objects in a batch\n\nIf the underlying storage has a high latency per SHA-1 lookup\n(e.g. the DHT support we are working on), parsing each wanted\nannotated tag object back to its underlying commit is too slow,\nits a sequential lookup for each tag.  With hundreds of tags in\na repository this takes far too long.\n\nInstead queue up a list of the tags whose objects need to be found,\nand then locate all of those in one parseAny batch.  This works\nfor the common case of annotated tag to single tree or commit.\nFor the less often used tag->tag->commit, it at least gets us\none level parsed in the larger batch before we have to go back to\nsequential lookups.\n\nChange-Id: I94beef3f14281406f15c8cf9fa02d83faf102a19\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-02-18, 7:15 PM",
			"commitName": "19037e8cfc2d9534f79e40c898fdaeacaf499e82",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-02-18, 6:36 PM",
			"commitNameOld": "3e64b928d51b3a28e89cfe2a3f0eeae35ef07839",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,201 +1,221 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker, final Collection<? extends ObjectId> want,\n \t\t\tCollection<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n \t\tfinal RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n \t\tfinal RevFlag include = walker.newFlag(\"include\");\n \t\tfinal RevFlag added = walker.newFlag(\"added\");\n \n \t\tfinal RevFlagSet keepOnRestart = new RevFlagSet();\n \t\tkeepOnRestart.add(inCachedPack);\n \n \t\twalker.setRetainBody(false);\n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t\tif (useCachedPacks && reuseSupport != null) {\n \t\t\t\tSet<ObjectId> need = new HashSet<ObjectId>(want);\n \t\t\t\tList<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n \n \t\t\t\tfor (CachedPack pack : reuseSupport.getCachedPacks()) {\n \t\t\t\t\tif (need.containsAll(pack.getTips())) {\n \t\t\t\t\t\tneed.removeAll(pack.getTips());\n \t\t\t\t\t\tshortCircuit.add(pack);\n \t\t\t\t\t}\n \n \t\t\t\t\tfor (ObjectId id : pack.getTips()) {\n \t\t\t\t\t\ttipToPack.put(id, pack);\n \t\t\t\t\t\tall.add(id);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (need.isEmpty() && !shortCircuit.isEmpty()) {\n \t\t\t\t\tcachedPacks.addAll(shortCircuit);\n \t\t\t\t\tfor (CachedPack pack : shortCircuit)\n \t\t\t\t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t\t\t\t\treturn;\n \t\t\t\t}\n \n \t\t\t\thaveEst += tipToPack.size();\n \t\t\t}\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n+\t\tList<RevTag> wantTags = new ArrayList<RevTag>(want.size());\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tif (tipToPack.containsKey(o))\n \t\t\t\t\t\to.add(inCachedPack);\n \n \t\t\t\t\tif (have.contains(o)) {\n \t\t\t\t\t\thaveObjs.add(o);\n-\t\t\t\t\t\twalker.markUninteresting(o);\n \t\t\t\t\t} else if (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n-\t\t\t\t\t\twalker.markStart(o);\n+\t\t\t\t\t\tif (o instanceof RevTag)\n+\t\t\t\t\t\t\twantTags.add((RevTag) o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n+\t\tif (!wantTags.isEmpty()) {\n+\t\t\tall = new ArrayList<ObjectId>(wantTags.size());\n+\t\t\tfor (RevTag tag : wantTags)\n+\t\t\t\tall.add(tag.getObject());\n+\t\t\tq = walker.parseAny(all, true);\n+\t\t\ttry {\n+\t\t\t\twhile (q.next() != null) {\n+\t\t\t\t\t// Just need to pop the queue item to parse the object.\n+\t\t\t\t}\n+\t\t\t} finally {\n+\t\t\t\tq.release();\n+\t\t\t}\n+\t\t}\n+\n+\t\tfor (RevObject obj : wantObjs)\n+\t\t\twalker.markStart(obj);\n+\t\tfor (RevObject obj : haveObjs)\n+\t\t\twalker.markUninteresting(obj);\n+\n \t\tint typesToPrune = 0;\n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tList<RevCommit> commits = new ArrayList<RevCommit>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (c.has(inCachedPack)) {\n \t\t\t\tCachedPack pack = tipToPack.get(c);\n \t\t\t\tif (includesAllTips(pack, include, walker)) {\n \t\t\t\t\tuseCachedPack(walker, keepOnRestart, //\n \t\t\t\t\t\t\twantObjs, haveObjs, pack);\n \t\t\t\t\tcommits = new ArrayList<RevCommit>();\n \n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tif (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n \t\t\tArrayList<ObjectToPack> list = (ArrayList<ObjectToPack>) objectsLists[Constants.OBJ_COMMIT];\n \t\t\tlist.ensureCapacity(list.size() + commits.size());\n \t\t}\n \t\tfor (RevCommit cmit : commits) {\n \t\t\tif (!cmit.has(added)) {\n \t\t\t\tcmit.add(added);\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \n \t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n \t\t\t\t\tp.add(added);\n \t\t\t\t\taddObject(p, 0);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tfor (CachedPack p : cachedPacks) {\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(walker.lookupCommit(d).getTree());\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_COMMIT;\n \t\t\t}\n \t\t}\n \n \t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\tobjectsMap, edgeObjects, reader);\n \t\tRevObject o;\n \t\twhile ((o = walker.nextObject()) != null) {\n \t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\tcontinue;\n \n \t\t\tint pathHash = walker.getPathHashCode();\n \t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\tint pathLen = walker.getPathLength();\n \n \t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\taddObject(o, pathHash);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tfor (CachedPack p : cachedPacks) {\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TREE;\n \t\t\t}\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_BLOB;\n \t\t\t}\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TAG;\n \t\t\t}\n \t\t}\n \n \t\tif (typesToPrune != 0) {\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TREE);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TAG);\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tcountingMonitor.endTask();\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3e64b928d51b3a28e89cfe2a3f0eeae35ef07839": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: Short-circuit counting on full cached pack reuse\n\nIf one or more cached packs fully covers the request, don't bother\nwith looking up the objects and trying to walk the graph.  Just use\nthe cached packs and return immediately.\n\nThis helps clones of quiet repositories that have not been modified\nsince their last repack, its likely the cached packs are accurate\nand no graph walking is required.\n\nChange-Id: I9062a5ac2f71b525322590209664a84051fd5f8a\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-02-18, 6:36 PM",
			"commitName": "3e64b928d51b3a28e89cfe2a3f0eeae35ef07839",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-02-18, 6:36 PM",
			"commitNameOld": "388ba7e005fdc5b61a7a494fa44ba24489d0c6d0",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,183 +1,201 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker, final Collection<? extends ObjectId> want,\n \t\t\tCollection<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n \t\tfinal RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n \t\tfinal RevFlag include = walker.newFlag(\"include\");\n \t\tfinal RevFlag added = walker.newFlag(\"added\");\n \n \t\tfinal RevFlagSet keepOnRestart = new RevFlagSet();\n \t\tkeepOnRestart.add(inCachedPack);\n \n \t\twalker.setRetainBody(false);\n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t\tif (useCachedPacks && reuseSupport != null) {\n+\t\t\t\tSet<ObjectId> need = new HashSet<ObjectId>(want);\n+\t\t\t\tList<CachedPack> shortCircuit = new LinkedList<CachedPack>();\n+\n \t\t\t\tfor (CachedPack pack : reuseSupport.getCachedPacks()) {\n+\t\t\t\t\tif (need.containsAll(pack.getTips())) {\n+\t\t\t\t\t\tneed.removeAll(pack.getTips());\n+\t\t\t\t\t\tshortCircuit.add(pack);\n+\t\t\t\t\t}\n+\n \t\t\t\t\tfor (ObjectId id : pack.getTips()) {\n \t\t\t\t\t\ttipToPack.put(id, pack);\n \t\t\t\t\t\tall.add(id);\n \t\t\t\t\t}\n \t\t\t\t}\n+\n+\t\t\t\tif (need.isEmpty() && !shortCircuit.isEmpty()) {\n+\t\t\t\t\tcachedPacks.addAll(shortCircuit);\n+\t\t\t\t\tfor (CachedPack pack : shortCircuit)\n+\t\t\t\t\t\tcountingMonitor.update((int) pack.getObjectCount());\n+\t\t\t\t\tcountingMonitor.endTask();\n+\t\t\t\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n \t\t\t\thaveEst += tipToPack.size();\n \t\t\t}\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tif (tipToPack.containsKey(o))\n \t\t\t\t\t\to.add(inCachedPack);\n \n \t\t\t\t\tif (have.contains(o)) {\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\t\twalker.markUninteresting(o);\n \t\t\t\t\t} else if (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\twalker.markStart(o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tint typesToPrune = 0;\n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tList<RevCommit> commits = new ArrayList<RevCommit>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (c.has(inCachedPack)) {\n \t\t\t\tCachedPack pack = tipToPack.get(c);\n \t\t\t\tif (includesAllTips(pack, include, walker)) {\n \t\t\t\t\tuseCachedPack(walker, keepOnRestart, //\n \t\t\t\t\t\t\twantObjs, haveObjs, pack);\n \t\t\t\t\tcommits = new ArrayList<RevCommit>();\n \n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tif (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n \t\t\tArrayList<ObjectToPack> list = (ArrayList<ObjectToPack>) objectsLists[Constants.OBJ_COMMIT];\n \t\t\tlist.ensureCapacity(list.size() + commits.size());\n \t\t}\n \t\tfor (RevCommit cmit : commits) {\n \t\t\tif (!cmit.has(added)) {\n \t\t\t\tcmit.add(added);\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \n \t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n \t\t\t\t\tp.add(added);\n \t\t\t\t\taddObject(p, 0);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tfor (CachedPack p : cachedPacks) {\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(walker.lookupCommit(d).getTree());\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_COMMIT;\n \t\t\t}\n \t\t}\n \n \t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\tobjectsMap, edgeObjects, reader);\n \t\tRevObject o;\n \t\twhile ((o = walker.nextObject()) != null) {\n \t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\tcontinue;\n \n \t\t\tint pathHash = walker.getPathHashCode();\n \t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\tint pathLen = walker.getPathLength();\n \n \t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\taddObject(o, pathHash);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tfor (CachedPack p : cachedPacks) {\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TREE;\n \t\t\t}\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_BLOB;\n \t\t\t}\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TAG;\n \t\t\t}\n \t\t}\n \n \t\tif (typesToPrune != 0) {\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TREE);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TAG);\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tcountingMonitor.endTask();\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4275c4c1cffeffae6b12eb6aa2df957c23107b48": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: Fix warning about untyped collection\n\nChange-Id: I44699d8ab9768844ba91f7224a7d4ee685c93ce6\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-02-18, 6:36 PM",
			"commitName": "4275c4c1cffeffae6b12eb6aa2df957c23107b48",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-02-17, 10:32 PM",
			"commitNameOld": "733780e8a158b7bc45b8b687ac353ecadc905a63",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0.84,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,183 +1,183 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker, final Collection<? extends ObjectId> want,\n \t\t\tCollection<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n-\t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet(want));\n-\t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet(have));\n+\t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));\n+\t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n \t\tfinal RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n \t\tfinal RevFlag include = walker.newFlag(\"include\");\n \t\tfinal RevFlag added = walker.newFlag(\"added\");\n \n \t\tfinal RevFlagSet keepOnRestart = new RevFlagSet();\n \t\tkeepOnRestart.add(inCachedPack);\n \n \t\twalker.setRetainBody(false);\n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t\tif (useCachedPacks && reuseSupport != null) {\n \t\t\t\tfor (CachedPack pack : reuseSupport.getCachedPacks()) {\n \t\t\t\t\tfor (ObjectId id : pack.getTips()) {\n \t\t\t\t\t\ttipToPack.put(id, pack);\n \t\t\t\t\t\tall.add(id);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\thaveEst += tipToPack.size();\n \t\t\t}\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tif (tipToPack.containsKey(o))\n \t\t\t\t\t\to.add(inCachedPack);\n \n \t\t\t\t\tif (have.contains(o)) {\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\t\twalker.markUninteresting(o);\n \t\t\t\t\t} else if (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\twalker.markStart(o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tint typesToPrune = 0;\n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tList<RevCommit> commits = new ArrayList<RevCommit>();\n \t\tRevCommit c;\n \t\twhile ((c = walker.next()) != null) {\n \t\t\tif (c.has(inCachedPack)) {\n \t\t\t\tCachedPack pack = tipToPack.get(c);\n \t\t\t\tif (includesAllTips(pack, include, walker)) {\n \t\t\t\t\tuseCachedPack(walker, keepOnRestart, //\n \t\t\t\t\t\t\twantObjs, haveObjs, pack);\n \t\t\t\t\tcommits = new ArrayList<RevCommit>();\n \n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tcommits.add(c);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tif (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n \t\t\tArrayList<ObjectToPack> list = (ArrayList<ObjectToPack>) objectsLists[Constants.OBJ_COMMIT];\n \t\t\tlist.ensureCapacity(list.size() + commits.size());\n \t\t}\n \t\tfor (RevCommit cmit : commits) {\n \t\t\tif (!cmit.has(added)) {\n \t\t\t\tcmit.add(added);\n \t\t\t\taddObject(cmit, 0);\n \t\t\t}\n \n \t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n \t\t\t\tRevCommit p = cmit.getParent(i);\n \t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n \t\t\t\t\tp.add(added);\n \t\t\t\t\taddObject(p, 0);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcommits = null;\n \n \t\tfor (CachedPack p : cachedPacks) {\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(walker.lookupCommit(d).getTree());\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_COMMIT;\n \t\t\t}\n \t\t}\n \n \t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\tobjectsMap, edgeObjects, reader);\n \t\tRevObject o;\n \t\twhile ((o = walker.nextObject()) != null) {\n \t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\tcontinue;\n \n \t\t\tint pathHash = walker.getPathHashCode();\n \t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\tint pathLen = walker.getPathLength();\n \n \t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\taddObject(o, pathHash);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tfor (CachedPack p : cachedPacks) {\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TREE;\n \t\t\t}\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_BLOB;\n \t\t\t}\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TAG;\n \t\t\t}\n \t\t}\n \n \t\tif (typesToPrune != 0) {\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TREE);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TAG);\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tcountingMonitor.endTask();\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"733780e8a158b7bc45b8b687ac353ecadc905a63": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: Sort commits by parse order to improve locality\n\nRevWalk in JGit and the revision code in C Git both parse commits out\nof the pack file in an order that differs from strict timestamp and\ntopological sorting.  Both implementations pop a commit from the head\nof a date queue, and then immediately parse all of its parents in\norder to insert those into the date queue at the proper positions as\ndetermined by their committer timestamp field.  This implies that the\nparents are parsed when their most recent child is popped from the\nqueue, and not where they are popped during traversal.\n\nHoisting a parent commit to be immediately behind its child improves\nlocality by making sure all parents of a merge are clustered together,\nand thus can be paged into the parser by the pack file buffering\nsystem (aka WindowCache in JGit) together.\n\nChange-Id: I80f9e64cafa2e8f082776b43845edf23065386a2\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-02-17, 10:32 PM",
			"commitName": "733780e8a158b7bc45b8b687ac353ecadc905a63",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-02-15, 5:32 PM",
			"commitNameOld": "14f99dc29d67fa4d2cb227ab906c5c8379499f6b",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 2.21,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,159 +1,183 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker, final Collection<? extends ObjectId> want,\n \t\t\tCollection<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tfinal long countingStart = System.currentTimeMillis();\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet(want));\n \t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet(have));\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n \t\tfinal RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n \t\tfinal RevFlag include = walker.newFlag(\"include\");\n+\t\tfinal RevFlag added = walker.newFlag(\"added\");\n \n \t\tfinal RevFlagSet keepOnRestart = new RevFlagSet();\n \t\tkeepOnRestart.add(inCachedPack);\n \n \t\twalker.setRetainBody(false);\n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t\tif (useCachedPacks && reuseSupport != null) {\n \t\t\t\tfor (CachedPack pack : reuseSupport.getCachedPacks()) {\n \t\t\t\t\tfor (ObjectId id : pack.getTips()) {\n \t\t\t\t\t\ttipToPack.put(id, pack);\n \t\t\t\t\t\tall.add(id);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\thaveEst += tipToPack.size();\n \t\t\t}\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tif (tipToPack.containsKey(o))\n \t\t\t\t\t\to.add(inCachedPack);\n \n \t\t\t\t\tif (have.contains(o)) {\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\t\twalker.markUninteresting(o);\n \t\t\t\t\t} else if (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\twalker.markStart(o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tint typesToPrune = 0;\n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n-\t\tRevObject o;\n-\t\twhile ((o = walker.next()) != null) {\n-\t\t\tif (o.has(inCachedPack)) {\n-\t\t\t\tCachedPack pack = tipToPack.get(o);\n+\t\tList<RevCommit> commits = new ArrayList<RevCommit>();\n+\t\tRevCommit c;\n+\t\twhile ((c = walker.next()) != null) {\n+\t\t\tif (c.has(inCachedPack)) {\n+\t\t\t\tCachedPack pack = tipToPack.get(c);\n \t\t\t\tif (includesAllTips(pack, include, walker)) {\n \t\t\t\t\tuseCachedPack(walker, keepOnRestart, //\n \t\t\t\t\t\t\twantObjs, haveObjs, pack);\n+\t\t\t\t\tcommits = new ArrayList<RevCommit>();\n \n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tif (o.has(RevFlag.UNINTERESTING)) {\n+\t\t\tif (c.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n-\t\t\t\t\tbaseTrees.add(((RevCommit) o).getTree());\n+\t\t\t\t\tbaseTrees.add(c.getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n-\t\t\taddObject(o, 0);\n+\t\t\tcommits.add(c);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n+\t\tif (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n+\t\t\tArrayList<ObjectToPack> list = (ArrayList<ObjectToPack>) objectsLists[Constants.OBJ_COMMIT];\n+\t\t\tlist.ensureCapacity(list.size() + commits.size());\n+\t\t}\n+\t\tfor (RevCommit cmit : commits) {\n+\t\t\tif (!cmit.has(added)) {\n+\t\t\t\tcmit.add(added);\n+\t\t\t\taddObject(cmit, 0);\n+\t\t\t}\n+\n+\t\t\tfor (int i = 0; i < cmit.getParentCount(); i++) {\n+\t\t\t\tRevCommit p = cmit.getParent(i);\n+\t\t\t\tif (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {\n+\t\t\t\t\tp.add(added);\n+\t\t\t\t\taddObject(p, 0);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tcommits = null;\n+\n \t\tfor (CachedPack p : cachedPacks) {\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(walker.lookupCommit(d).getTree());\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_COMMIT;\n \t\t\t}\n \t\t}\n \n \t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\tobjectsMap, edgeObjects, reader);\n+\t\tRevObject o;\n \t\twhile ((o = walker.nextObject()) != null) {\n \t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\tcontinue;\n \n \t\t\tint pathHash = walker.getPathHashCode();\n \t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\tint pathLen = walker.getPathLength();\n \n \t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\taddObject(o, pathHash);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tfor (CachedPack p : cachedPacks) {\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TREE;\n \t\t\t}\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_BLOB;\n \t\t\t}\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TAG;\n \t\t\t}\n \t\t}\n \n \t\tif (typesToPrune != 0) {\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TREE);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TAG);\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tcountingMonitor.endTask();\n \t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c8c4524b6b36c1d97e715de9e1ff1aa18763a390": {
			"type": "Ybodychange",
			"commitMessage": "UploadPack: Expose PackWriter activity to a logger\n\nThe UploadPackLogger interface allows applications that embed\nGitServlet or otherwise use UploadPack to service clients to\ntrack and log how PackWriter was used, and what it sent.  This\nprovides more granularity into the request activity than might\nbe available from the HTTP server logs, helping administrators\nto better understand utilization and Git server performance.\n\nChange-Id: I1d36b060eb3385339d5f986e68192789ef70fc4e\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-02-13, 2:43 PM",
			"commitName": "c8c4524b6b36c1d97e715de9e1ff1aa18763a390",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-02-13, 2:43 PM",
			"commitNameOld": "5664fb3bfb63e4db49dc07d13ace419e810186c2",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,154 +1,159 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker, final Collection<? extends ObjectId> want,\n \t\t\tCollection<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n+\t\tfinal long countingStart = System.currentTimeMillis();\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n+\t\tstats.interestingObjects = Collections.unmodifiableSet(new HashSet(want));\n+\t\tstats.uninterestingObjects = Collections.unmodifiableSet(new HashSet(have));\n+\n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n \t\tfinal RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n \t\tfinal RevFlag include = walker.newFlag(\"include\");\n \n \t\tfinal RevFlagSet keepOnRestart = new RevFlagSet();\n \t\tkeepOnRestart.add(inCachedPack);\n \n \t\twalker.setRetainBody(false);\n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t\tif (useCachedPacks && reuseSupport != null) {\n \t\t\t\tfor (CachedPack pack : reuseSupport.getCachedPacks()) {\n \t\t\t\t\tfor (ObjectId id : pack.getTips()) {\n \t\t\t\t\t\ttipToPack.put(id, pack);\n \t\t\t\t\t\tall.add(id);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\thaveEst += tipToPack.size();\n \t\t\t}\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tif (tipToPack.containsKey(o))\n \t\t\t\t\t\to.add(inCachedPack);\n \n \t\t\t\t\tif (have.contains(o)) {\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\t\twalker.markUninteresting(o);\n \t\t\t\t\t} else if (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\twalker.markStart(o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tint typesToPrune = 0;\n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tRevObject o;\n \t\twhile ((o = walker.next()) != null) {\n \t\t\tif (o.has(inCachedPack)) {\n \t\t\t\tCachedPack pack = tipToPack.get(o);\n \t\t\t\tif (includesAllTips(pack, include, walker)) {\n \t\t\t\t\tuseCachedPack(walker, keepOnRestart, //\n \t\t\t\t\t\t\twantObjs, haveObjs, pack);\n \n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (o.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(((RevCommit) o).getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\taddObject(o, 0);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tfor (CachedPack p : cachedPacks) {\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(walker.lookupCommit(d).getTree());\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_COMMIT;\n \t\t\t}\n \t\t}\n \n \t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\tobjectsMap, edgeObjects, reader);\n \t\twhile ((o = walker.nextObject()) != null) {\n \t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\tcontinue;\n \n \t\t\tint pathHash = walker.getPathHashCode();\n \t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\tint pathLen = walker.getPathLength();\n \n \t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\taddObject(o, pathHash);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tfor (CachedPack p : cachedPacks) {\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TREE;\n \t\t\t}\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_BLOB;\n \t\t\t}\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TAG;\n \t\t\t}\n \t\t}\n \n \t\tif (typesToPrune != 0) {\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TREE);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TAG);\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tcountingMonitor.endTask();\n+\t\tstats.timeCounting = System.currentTimeMillis() - countingStart;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5664fb3bfb63e4db49dc07d13ace419e810186c2": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "UploadPack: Donate parsed commits to PackWriter\n\nWhen UploadPack has computed the merge base between the client's have\nset and the want set, its already loaded and parsed all of the\ninteresting commits that PackWriter needs to transmit to the client.\nSwitching the RevWalk and its object pool over to be an ObjectWalk\nsaves PackWriter from needing to re-parse these same commits from the\nObjectDatabase, reducing the startup latency for the enumeration\nphase of packing.\n\nUploadPack doesn't want to use an ObjectWalk for the okToGiveUp()\ntests because its slower, during each commit popped it needs to cache\nthe tree into the pendingObjects list, and during each reset() it\ndiscards a bunch of ObjectWalk specific state and reallocates some\ninternal collections.  ObjectWalk was never meant to be rapidly\nreset() like UploadPack does, so its perhaps somewhat cleaner to allow\n\"upgrading\" a RevWalk to an ObjectWalk.\n\nBug: 301639\nChange-Id: I97ef52a0b79d78229c272880aedb7f74d0f7532f\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-02-13, 2:43 PM",
			"commitName": "5664fb3bfb63e4db49dc07d13ace419e810186c2",
			"commitAuthor": "Shawn O. Pearce",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "UploadPack: Donate parsed commits to PackWriter\n\nWhen UploadPack has computed the merge base between the client's have\nset and the want set, its already loaded and parsed all of the\ninteresting commits that PackWriter needs to transmit to the client.\nSwitching the RevWalk and its object pool over to be an ObjectWalk\nsaves PackWriter from needing to re-parse these same commits from the\nObjectDatabase, reducing the startup latency for the enumeration\nphase of packing.\n\nUploadPack doesn't want to use an ObjectWalk for the okToGiveUp()\ntests because its slower, during each commit popped it needs to cache\nthe tree into the pendingObjects list, and during each reset() it\ndiscards a bunch of ObjectWalk specific state and reallocates some\ninternal collections.  ObjectWalk was never meant to be rapidly\nreset() like UploadPack does, so its perhaps somewhat cleaner to allow\n\"upgrading\" a RevWalk to an ObjectWalk.\n\nBug: 301639\nChange-Id: I97ef52a0b79d78229c272880aedb7f74d0f7532f\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
					"commitDate": "2011-02-13, 2:43 PM",
					"commitName": "5664fb3bfb63e4db49dc07d13ace419e810186c2",
					"commitAuthor": "Shawn O. Pearce",
					"commitDateOld": "2011-02-03, 2:20 PM",
					"commitNameOld": "461b012e9565af8174e5b9d2b2c3a582011ce77e",
					"commitAuthorOld": "Shawn O. Pearce",
					"daysBetweenCommits": 10.02,
					"commitsBetweenForRepo": 19,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,155 +1,154 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n-\t\t\tfinal Collection<? extends ObjectId> want,\n+\t\t\tfinal ObjectWalk walker, final Collection<? extends ObjectId> want,\n \t\t\tCollection<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n-\t\tfinal ObjectWalk walker = new ObjectWalk(reader);\n \t\tfinal RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n \t\tfinal RevFlag include = walker.newFlag(\"include\");\n \n \t\tfinal RevFlagSet keepOnRestart = new RevFlagSet();\n \t\tkeepOnRestart.add(inCachedPack);\n \n \t\twalker.setRetainBody(false);\n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t\tif (useCachedPacks && reuseSupport != null) {\n \t\t\t\tfor (CachedPack pack : reuseSupport.getCachedPacks()) {\n \t\t\t\t\tfor (ObjectId id : pack.getTips()) {\n \t\t\t\t\t\ttipToPack.put(id, pack);\n \t\t\t\t\t\tall.add(id);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\thaveEst += tipToPack.size();\n \t\t\t}\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tif (tipToPack.containsKey(o))\n \t\t\t\t\t\to.add(inCachedPack);\n \n \t\t\t\t\tif (have.contains(o)) {\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\t\twalker.markUninteresting(o);\n \t\t\t\t\t} else if (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\twalker.markStart(o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tint typesToPrune = 0;\n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tRevObject o;\n \t\twhile ((o = walker.next()) != null) {\n \t\t\tif (o.has(inCachedPack)) {\n \t\t\t\tCachedPack pack = tipToPack.get(o);\n \t\t\t\tif (includesAllTips(pack, include, walker)) {\n \t\t\t\t\tuseCachedPack(walker, keepOnRestart, //\n \t\t\t\t\t\t\twantObjs, haveObjs, pack);\n \n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (o.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(((RevCommit) o).getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\taddObject(o, 0);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tfor (CachedPack p : cachedPacks) {\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(walker.lookupCommit(d).getTree());\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_COMMIT;\n \t\t\t}\n \t\t}\n \n \t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\tobjectsMap, edgeObjects, reader);\n \t\twhile ((o = walker.nextObject()) != null) {\n \t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\tcontinue;\n \n \t\t\tint pathHash = walker.getPathHashCode();\n \t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\tint pathLen = walker.getPathLength();\n \n \t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\taddObject(o, pathHash);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tfor (CachedPack p : cachedPacks) {\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TREE;\n \t\t\t}\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_BLOB;\n \t\t\t}\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TAG;\n \t\t\t}\n \t\t}\n \n \t\tif (typesToPrune != 0) {\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TREE);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TAG);\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tcountingMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[countingMonitor-ProgressMonitor(modifiers-final), want-Collection<? extends ObjectId>(modifiers-final), have-Collection<? extends ObjectId>]",
						"newValue": "[countingMonitor-ProgressMonitor(modifiers-final), walker-ObjectWalk(modifiers-final), want-Collection<? extends ObjectId>(modifiers-final), have-Collection<? extends ObjectId>]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "UploadPack: Donate parsed commits to PackWriter\n\nWhen UploadPack has computed the merge base between the client's have\nset and the want set, its already loaded and parsed all of the\ninteresting commits that PackWriter needs to transmit to the client.\nSwitching the RevWalk and its object pool over to be an ObjectWalk\nsaves PackWriter from needing to re-parse these same commits from the\nObjectDatabase, reducing the startup latency for the enumeration\nphase of packing.\n\nUploadPack doesn't want to use an ObjectWalk for the okToGiveUp()\ntests because its slower, during each commit popped it needs to cache\nthe tree into the pendingObjects list, and during each reset() it\ndiscards a bunch of ObjectWalk specific state and reallocates some\ninternal collections.  ObjectWalk was never meant to be rapidly\nreset() like UploadPack does, so its perhaps somewhat cleaner to allow\n\"upgrading\" a RevWalk to an ObjectWalk.\n\nBug: 301639\nChange-Id: I97ef52a0b79d78229c272880aedb7f74d0f7532f\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
					"commitDate": "2011-02-13, 2:43 PM",
					"commitName": "5664fb3bfb63e4db49dc07d13ace419e810186c2",
					"commitAuthor": "Shawn O. Pearce",
					"commitDateOld": "2011-02-03, 2:20 PM",
					"commitNameOld": "461b012e9565af8174e5b9d2b2c3a582011ce77e",
					"commitAuthorOld": "Shawn O. Pearce",
					"daysBetweenCommits": 10.02,
					"commitsBetweenForRepo": 19,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,155 +1,154 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n-\t\t\tfinal Collection<? extends ObjectId> want,\n+\t\t\tfinal ObjectWalk walker, final Collection<? extends ObjectId> want,\n \t\t\tCollection<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n-\t\tfinal ObjectWalk walker = new ObjectWalk(reader);\n \t\tfinal RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n \t\tfinal RevFlag include = walker.newFlag(\"include\");\n \n \t\tfinal RevFlagSet keepOnRestart = new RevFlagSet();\n \t\tkeepOnRestart.add(inCachedPack);\n \n \t\twalker.setRetainBody(false);\n \t\twalker.carry(include);\n \n \t\tint haveEst = have.size();\n \t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\t\tif (useCachedPacks && reuseSupport != null) {\n \t\t\t\tfor (CachedPack pack : reuseSupport.getCachedPacks()) {\n \t\t\t\t\tfor (ObjectId id : pack.getTips()) {\n \t\t\t\t\t\ttipToPack.put(id, pack);\n \t\t\t\t\t\tall.add(id);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\thaveEst += tipToPack.size();\n \t\t\t}\n \t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n \t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tif (tipToPack.containsKey(o))\n \t\t\t\t\t\to.add(inCachedPack);\n \n \t\t\t\t\tif (have.contains(o)) {\n \t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\t\twalker.markUninteresting(o);\n \t\t\t\t\t} else if (want.contains(o)) {\n \t\t\t\t\t\to.add(include);\n \t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\twalker.markStart(o);\n \t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n \t\tint typesToPrune = 0;\n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tRevObject o;\n \t\twhile ((o = walker.next()) != null) {\n \t\t\tif (o.has(inCachedPack)) {\n \t\t\t\tCachedPack pack = tipToPack.get(o);\n \t\t\t\tif (includesAllTips(pack, include, walker)) {\n \t\t\t\t\tuseCachedPack(walker, keepOnRestart, //\n \t\t\t\t\t\t\twantObjs, haveObjs, pack);\n \n \t\t\t\t\tcountingMonitor.endTask();\n \t\t\t\t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (o.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(((RevCommit) o).getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\taddObject(o, 0);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tfor (CachedPack p : cachedPacks) {\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(walker.lookupCommit(d).getTree());\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_COMMIT;\n \t\t\t}\n \t\t}\n \n \t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n \t\t\t\tobjectsMap, edgeObjects, reader);\n \t\twhile ((o = walker.nextObject()) != null) {\n \t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\tcontinue;\n \n \t\t\tint pathHash = walker.getPathHashCode();\n \t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\tint pathLen = walker.getPathLength();\n \n \t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\taddObject(o, pathHash);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n \t\tfor (CachedPack p : cachedPacks) {\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TREE;\n \t\t\t}\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_BLOB;\n \t\t\t}\n \t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n \t\t\t\tobjectsMap.get(d).setEdge();\n \t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TAG;\n \t\t\t}\n \t\t}\n \n \t\tif (typesToPrune != 0) {\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TREE);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n \t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TAG);\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tcountingMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"461b012e9565af8174e5b9d2b2c3a582011ce77e": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: Support reuse of entire packs\n\nThe most expensive part of packing a repository for transport to\nanother system is enumerating all of the objects in the repository.\nOnce this gets to the size of the linux-2.6 repository (1.8 million\nobjects), enumeration can take several CPU minutes and costs a lot\nof temporary working set memory.\n\nTeach PackWriter to efficiently reuse an existing \"cached pack\"\nby answering a clone request with a thin pack followed by a larger\ncached pack appended to the end.  This requires the repository\nowner to first construct the cached pack by hand, and record the\ntip commits inside of $GIT_DIR/objects/info/cached-packs:\n\n  cd $GIT_DIR\n  root=$(git rev-parse master)\n  tmp=objects/.tmp-$$\n  names=$(echo $root | git pack-objects --keep-true-parents --revs $tmp)\n  for n in $names; do\n    chmod a-w $tmp-$n.pack $tmp-$n.idx\n    touch objects/pack/pack-$n.keep\n    mv $tmp-$n.pack objects/pack/pack-$n.pack\n    mv $tmp-$n.idx objects/pack/pack-$n.idx\n  done\n\n  (echo \"+ $root\";\n   for n in $names; do echo \"P $n\"; done;\n   echo) >>objects/info/cached-packs\n\n  git repack -a -d\n\nWhen a clone request needs to include $root, the corresponding\ncached pack will be copied as-is, rather than enumerating all of\nthe objects that are reachable from $root.\n\nFor a linux-2.6 kernel repository that should be about 376 MiB,\nthe above process creates two packs of 368 MiB and 38 MiB[1].\nThis is a local disk usage increase of ~26 MiB, due to reduced\ndelta compression between the large cached pack and the smaller\nrecent activity pack.  The overhead is similar to 1 full copy of\nthe compressed project sources.\n\nWith this cached pack in hand, JGit daemon completes a clone request\nin 1m17s less time, but a slightly larger data transfer (+2.39 MiB):\n\n  Before:\n    remote: Counting objects: 1861830, done\n    remote: Finding sources: 100% (1861830/1861830)\n    remote: Getting sizes: 100% (88243/88243)\n    remote: Compressing objects: 100% (88184/88184)\n    Receiving objects: 100% (1861830/1861830), 376.01 MiB | 19.01 MiB/s, done.\n    remote: Total 1861830 (delta 4706), reused 1851053 (delta 1553844)\n    Resolving deltas: 100% (1564621/1564621), done.\n\n    real  3m19.005s\n\n  After:\n    remote: Counting objects: 1601, done\n    remote: Counting objects: 1828460, done\n    remote: Finding sources: 100% (50475/50475)\n    remote: Getting sizes: 100% (18843/18843)\n    remote: Compressing objects: 100% (7585/7585)\n    remote: Total 1861830 (delta 2407), reused 1856197 (delta 37510)\n    Receiving objects: 100% (1861830/1861830), 378.40 MiB | 31.31 MiB/s, done.\n    Resolving deltas: 100% (1559477/1559477), done.\n\n    real 2m2.938s\n\nRepository owners can periodically refresh their cached packs by\nrepacking their repository, folding all newer objects into a larger\ncached pack.  Since repacking is already considered to be a normal\nGit maintenance activity, this isn't a very big burden.\n\n[1] In this test $root was set back about two weeks.\n\nChange-Id: Ib87131d5c4b5e8c5cacb0f4fe16ff4ece554734b\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-02-03, 2:20 PM",
			"commitName": "461b012e9565af8174e5b9d2b2c3a582011ce77e",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-02-02, 6:17 PM",
			"commitNameOld": "71f168fcd77ec100d68233d3d467f770304f6eb8",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0.84,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,76 +1,155 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal Collection<? extends ObjectId> want,\n \t\t\tCollection<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n+\t\tfinal Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();\n \t\tfinal ObjectWalk walker = new ObjectWalk(reader);\n+\t\tfinal RevFlag inCachedPack = walker.newFlag(\"inCachedPack\");\n+\t\tfinal RevFlag include = walker.newFlag(\"include\");\n+\n+\t\tfinal RevFlagSet keepOnRestart = new RevFlagSet();\n+\t\tkeepOnRestart.add(inCachedPack);\n+\n \t\twalker.setRetainBody(false);\n-\t\tif (have.isEmpty())\n+\t\twalker.carry(include);\n+\n+\t\tint haveEst = have.size();\n+\t\tif (have.isEmpty()) {\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n-\t\telse {\n+\t\t\tif (useCachedPacks && reuseSupport != null) {\n+\t\t\t\tfor (CachedPack pack : reuseSupport.getCachedPacks()) {\n+\t\t\t\t\tfor (ObjectId id : pack.getTips()) {\n+\t\t\t\t\t\ttipToPack.put(id, pack);\n+\t\t\t\t\t\tall.add(id);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\thaveEst += tipToPack.size();\n+\t\t\t}\n+\t\t} else {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n+\t\tList<RevObject> wantObjs = new ArrayList<RevObject>(want.size());\n+\t\tList<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);\n+\n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n-\t\t\t\t\tif (have.contains(o))\n+\n+\t\t\t\t\tif (tipToPack.containsKey(o))\n+\t\t\t\t\t\to.add(inCachedPack);\n+\n+\t\t\t\t\tif (have.contains(o)) {\n+\t\t\t\t\t\thaveObjs.add(o);\n \t\t\t\t\t\twalker.markUninteresting(o);\n-\t\t\t\t\telse\n+\t\t\t\t\t} else if (want.contains(o)) {\n+\t\t\t\t\t\to.add(include);\n+\t\t\t\t\t\twantObjs.add(o);\n \t\t\t\t\t\twalker.markStart(o);\n+\t\t\t\t\t}\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n+\t\tint typesToPrune = 0;\n \t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n \t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tRevObject o;\n \t\twhile ((o = walker.next()) != null) {\n+\t\t\tif (o.has(inCachedPack)) {\n+\t\t\t\tCachedPack pack = tipToPack.get(o);\n+\t\t\t\tif (includesAllTips(pack, include, walker)) {\n+\t\t\t\t\tuseCachedPack(walker, keepOnRestart, //\n+\t\t\t\t\t\t\twantObjs, haveObjs, pack);\n+\n+\t\t\t\t\tcountingMonitor.endTask();\n+\t\t\t\t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n+\t\t\t\t\t\t\tProgressMonitor.UNKNOWN);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\tif (o.has(RevFlag.UNINTERESTING)) {\n \t\t\t\tif (baseTrees.size() <= maxBases)\n \t\t\t\t\tbaseTrees.add(((RevCommit) o).getTree());\n \t\t\t\tcontinue;\n \t\t\t}\n+\n \t\t\taddObject(o, 0);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \n+\t\tfor (CachedPack p : cachedPacks) {\n+\t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n+\t\t\t\tif (baseTrees.size() <= maxBases)\n+\t\t\t\t\tbaseTrees.add(walker.lookupCommit(d).getTree());\n+\t\t\t\tobjectsMap.get(d).setEdge();\n+\t\t\t\ttypesToPrune |= 1 << Constants.OBJ_COMMIT;\n+\t\t\t}\n+\t\t}\n+\n \t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n-\t\t\t\tedgeObjects, reader);\n+\t\t\t\tobjectsMap, edgeObjects, reader);\n \t\twhile ((o = walker.nextObject()) != null) {\n \t\t\tif (o.has(RevFlag.UNINTERESTING))\n \t\t\t\tcontinue;\n \n \t\t\tint pathHash = walker.getPathHashCode();\n \t\t\tbyte[] pathBuf = walker.getPathBuffer();\n \t\t\tint pathLen = walker.getPathLength();\n \n \t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n \t\t\taddObject(o, pathHash);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n+\n+\t\tfor (CachedPack p : cachedPacks) {\n+\t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n+\t\t\t\tobjectsMap.get(d).setEdge();\n+\t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TREE;\n+\t\t\t}\n+\t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n+\t\t\t\tobjectsMap.get(d).setEdge();\n+\t\t\t\ttypesToPrune |= 1 << Constants.OBJ_BLOB;\n+\t\t\t}\n+\t\t\tfor (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n+\t\t\t\tobjectsMap.get(d).setEdge();\n+\t\t\t\ttypesToPrune |= 1 << Constants.OBJ_TAG;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (typesToPrune != 0) {\n+\t\t\tpruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n+\t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TREE);\n+\t\t\tpruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n+\t\t\tpruneObjectList(typesToPrune, Constants.OBJ_TAG);\n+\t\t}\n+\n+\t\tfor (CachedPack pack : cachedPacks)\n+\t\t\tcountingMonitor.update((int) pack.getObjectCount());\n \t\tcountingMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"13bcf05a9ea2d4943faef2c879aac65d37517eb6": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: Make thin packs more efficient\n\nThere is no point in pushing all of the files within the edge\ncommits into the delta search when making a thin pack.  This floods\nthe delta search window with objects that are unlikely to be useful\nbases for the objects that will be written out, resulting in lower\ndata compression and higher transfer sizes.\n\nInstead observe the path of a tree or blob that is being pushed\ninto the outgoing set, and use that path to locate up to WINDOW\nancestor versions from the edge commits.  Push only those objects\ninto the edgeObjects set, reducing the number of objects seen by the\nsearch window.  This allows PackWriter to only look at ancestors\nfor the modified files, rather than all files in the project.\nLimiting the search to WINDOW size makes sense, because more than\nWINDOW edge objects will just skip through the window search as\nnone of them need to be delta compressed.\n\nTo further improve compression, sort edge objects into the front\nof the window list, rather than randomly throughout.  This puts\nnon-edges later in the window and gives them a better chance at\nfinding their base, since they search backwards through the window.\n\nThese changes make a significant difference in the thin-pack:\n\n  Before:\n    remote: Counting objects: 144190, done\n    remote: Finding sources: 100% (50275/50275)\n    remote: Getting sizes: 100% (101405/101405)\n    remote: Compressing objects: 100% (7587/7587)\n    Receiving objects: 100% (50275/50275), 24.67 MiB | 9.90 MiB/s, done.\n    Resolving deltas: 100% (40339/40339), completed with 2218 local objects.\n\n    real    0m30.267s\n\n  After:\n    remote: Counting objects: 61549, done\n    remote: Finding sources: 100% (50275/50275)\n    remote: Getting sizes: 100% (18862/18862)\n    remote: Compressing objects: 100% (7588/7588)\n    Receiving objects: 100% (50275/50275), 11.04 MiB | 3.51 MiB/s, done.\n    Resolving deltas: 100% (43160/43160), completed with 5014 local objects.\n\n    real    0m22.170s\n\nThe resulting pack is 13.63 MiB smaller, even though it contains the\nsame exact objects.  82,543 fewer objects had to have their sizes\nlooked up, which saved about 8s of server CPU time.  2,796 more\nobjects from the client were used as part of the base object set,\nwhich contributed to the smaller transfer size.\n\nChange-Id: Id01271950432c6960897495b09deab70e33993a9\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\nSigend-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
			"commitDate": "2011-02-01, 8:12 AM",
			"commitName": "13bcf05a9ea2d4943faef2c879aac65d37517eb6",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-02-01, 8:03 AM",
			"commitNameOld": "2fbcba41e365752681f635c706d577e605d3336a",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,59 +1,76 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal Collection<? extends ObjectId> want,\n \t\t\tCollection<? extends ObjectId> have)\n \t\t\tthrows MissingObjectException, IOException,\n \t\t\tIncorrectObjectTypeException {\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n \n \t\tif (have == null)\n \t\t\thave = Collections.emptySet();\n \n \t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n \t\tall.addAll(want);\n \t\tall.addAll(have);\n \n \t\tfinal ObjectWalk walker = new ObjectWalk(reader);\n \t\twalker.setRetainBody(false);\n \t\tif (have.isEmpty())\n \t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n \t\telse {\n \t\t\twalker.sort(RevSort.TOPO);\n \t\t\tif (thin)\n \t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n \t\t}\n \n \t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n \t\ttry {\n \t\t\tfor (;;) {\n \t\t\t\ttry {\n \t\t\t\t\tRevObject o = q.next();\n \t\t\t\t\tif (o == null)\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tif (have.contains(o))\n \t\t\t\t\t\twalker.markUninteresting(o);\n \t\t\t\t\telse\n \t\t\t\t\t\twalker.markStart(o);\n \t\t\t\t} catch (MissingObjectException e) {\n \t\t\t\t\tif (ignoreMissingUninteresting\n \t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t} finally {\n \t\t\tq.release();\n \t\t}\n \n+\t\tfinal int maxBases = config.getDeltaSearchWindowSize();\n+\t\tSet<RevTree> baseTrees = new HashSet<RevTree>();\n \t\tRevObject o;\n-\n \t\twhile ((o = walker.next()) != null) {\n+\t\t\tif (o.has(RevFlag.UNINTERESTING)) {\n+\t\t\t\tif (baseTrees.size() <= maxBases)\n+\t\t\t\t\tbaseTrees.add(((RevCommit) o).getTree());\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\taddObject(o, 0);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n+\n+\t\tBaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //\n+\t\t\t\tedgeObjects, reader);\n \t\twhile ((o = walker.nextObject()) != null) {\n-\t\t\taddObject(o, walker.getPathHashCode());\n+\t\t\tif (o.has(RevFlag.UNINTERESTING))\n+\t\t\t\tcontinue;\n+\n+\t\t\tint pathHash = walker.getPathHashCode();\n+\t\t\tbyte[] pathBuf = walker.getPathBuffer();\n+\t\t\tint pathLen = walker.getPathLength();\n+\n+\t\t\tbases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n+\t\t\taddObject(o, pathHash);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\tcountingMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2fbcba41e365752681f635c706d577e605d3336a": {
			"type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
			"commitMessage": "PackWriter: Cleanup findObjectToPack method\n\nSome of this code predates making ObjectId.equals() final\nand fixing RevObject.equals() to match ObjectId.equals().\nIt was therefore more complex than it needs to be, because\nit tried to work around RevObject's broken equals() rules\nby converting to ObjectId in a different collection.\n\nAlso combine setUpWalker() and findObjectsToPack() methods,\nthese can be one method and the code is actually cleaner.\n\nChange-Id: I0f4cf9997cd66d8b6e7f80873979ef1439e507fe\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
			"commitDate": "2011-02-01, 8:03 AM",
			"commitName": "2fbcba41e365752681f635c706d577e605d3336a",
			"commitAuthor": "Shawn O. Pearce",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "PackWriter: Cleanup findObjectToPack method\n\nSome of this code predates making ObjectId.equals() final\nand fixing RevObject.equals() to match ObjectId.equals().\nIt was therefore more complex than it needs to be, because\nit tried to work around RevObject's broken equals() rules\nby converting to ObjectId in a different collection.\n\nAlso combine setUpWalker() and findObjectsToPack() methods,\nthese can be one method and the code is actually cleaner.\n\nChange-Id: I0f4cf9997cd66d8b6e7f80873979ef1439e507fe\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
					"commitDate": "2011-02-01, 8:03 AM",
					"commitName": "2fbcba41e365752681f635c706d577e605d3336a",
					"commitAuthor": "Shawn O. Pearce",
					"commitDateOld": "2011-02-01, 8:01 AM",
					"commitNameOld": "8f63dface2e08b228cdeb3bef3f93458eab9ce14",
					"commitAuthorOld": "Shawn O. Pearce",
					"daysBetweenCommits": 0,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,17 +1,59 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n-\t\t\tfinal ObjectWalk walker) throws MissingObjectException,\n-\t\t\tIncorrectObjectTypeException,\t\t\tIOException {\n+\t\t\tfinal Collection<? extends ObjectId> want,\n+\t\t\tCollection<? extends ObjectId> have)\n+\t\t\tthrows MissingObjectException, IOException,\n+\t\t\tIncorrectObjectTypeException {\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n+\n+\t\tif (have == null)\n+\t\t\thave = Collections.emptySet();\n+\n+\t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n+\t\tall.addAll(want);\n+\t\tall.addAll(have);\n+\n+\t\tfinal ObjectWalk walker = new ObjectWalk(reader);\n+\t\twalker.setRetainBody(false);\n+\t\tif (have.isEmpty())\n+\t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n+\t\telse {\n+\t\t\twalker.sort(RevSort.TOPO);\n+\t\t\tif (thin)\n+\t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n+\t\t}\n+\n+\t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n+\t\ttry {\n+\t\t\tfor (;;) {\n+\t\t\t\ttry {\n+\t\t\t\t\tRevObject o = q.next();\n+\t\t\t\t\tif (o == null)\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tif (have.contains(o))\n+\t\t\t\t\t\twalker.markUninteresting(o);\n+\t\t\t\t\telse\n+\t\t\t\t\t\twalker.markStart(o);\n+\t\t\t\t} catch (MissingObjectException e) {\n+\t\t\t\t\tif (ignoreMissingUninteresting\n+\t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\tthrow e;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} finally {\n+\t\t\tq.release();\n+\t\t}\n+\n \t\tRevObject o;\n \n \t\twhile ((o = walker.next()) != null) {\n \t\t\taddObject(o, 0);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\twhile ((o = walker.nextObject()) != null) {\n \t\t\taddObject(o, walker.getPathHashCode());\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\tcountingMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[countingMonitor-ProgressMonitor(modifiers-final), walker-ObjectWalk(modifiers-final)]",
						"newValue": "[countingMonitor-ProgressMonitor(modifiers-final), want-Collection<? extends ObjectId>(modifiers-final), have-Collection<? extends ObjectId>]"
					}
				},
				{
					"type": "Yexceptionschange",
					"commitMessage": "PackWriter: Cleanup findObjectToPack method\n\nSome of this code predates making ObjectId.equals() final\nand fixing RevObject.equals() to match ObjectId.equals().\nIt was therefore more complex than it needs to be, because\nit tried to work around RevObject's broken equals() rules\nby converting to ObjectId in a different collection.\n\nAlso combine setUpWalker() and findObjectsToPack() methods,\nthese can be one method and the code is actually cleaner.\n\nChange-Id: I0f4cf9997cd66d8b6e7f80873979ef1439e507fe\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
					"commitDate": "2011-02-01, 8:03 AM",
					"commitName": "2fbcba41e365752681f635c706d577e605d3336a",
					"commitAuthor": "Shawn O. Pearce",
					"commitDateOld": "2011-02-01, 8:01 AM",
					"commitNameOld": "8f63dface2e08b228cdeb3bef3f93458eab9ce14",
					"commitAuthorOld": "Shawn O. Pearce",
					"daysBetweenCommits": 0,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,17 +1,59 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n-\t\t\tfinal ObjectWalk walker) throws MissingObjectException,\n-\t\t\tIncorrectObjectTypeException,\t\t\tIOException {\n+\t\t\tfinal Collection<? extends ObjectId> want,\n+\t\t\tCollection<? extends ObjectId> have)\n+\t\t\tthrows MissingObjectException, IOException,\n+\t\t\tIncorrectObjectTypeException {\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n+\n+\t\tif (have == null)\n+\t\t\thave = Collections.emptySet();\n+\n+\t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n+\t\tall.addAll(want);\n+\t\tall.addAll(have);\n+\n+\t\tfinal ObjectWalk walker = new ObjectWalk(reader);\n+\t\twalker.setRetainBody(false);\n+\t\tif (have.isEmpty())\n+\t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n+\t\telse {\n+\t\t\twalker.sort(RevSort.TOPO);\n+\t\t\tif (thin)\n+\t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n+\t\t}\n+\n+\t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n+\t\ttry {\n+\t\t\tfor (;;) {\n+\t\t\t\ttry {\n+\t\t\t\t\tRevObject o = q.next();\n+\t\t\t\t\tif (o == null)\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tif (have.contains(o))\n+\t\t\t\t\t\twalker.markUninteresting(o);\n+\t\t\t\t\telse\n+\t\t\t\t\t\twalker.markStart(o);\n+\t\t\t\t} catch (MissingObjectException e) {\n+\t\t\t\t\tif (ignoreMissingUninteresting\n+\t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\tthrow e;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} finally {\n+\t\t\tq.release();\n+\t\t}\n+\n \t\tRevObject o;\n \n \t\twhile ((o = walker.next()) != null) {\n \t\t\taddObject(o, 0);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\twhile ((o = walker.nextObject()) != null) {\n \t\t\taddObject(o, walker.getPathHashCode());\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\tcountingMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[MissingObjectException, IncorrectObjectTypeException, IOException]",
						"newValue": "[MissingObjectException, IOException, IncorrectObjectTypeException]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "PackWriter: Cleanup findObjectToPack method\n\nSome of this code predates making ObjectId.equals() final\nand fixing RevObject.equals() to match ObjectId.equals().\nIt was therefore more complex than it needs to be, because\nit tried to work around RevObject's broken equals() rules\nby converting to ObjectId in a different collection.\n\nAlso combine setUpWalker() and findObjectsToPack() methods,\nthese can be one method and the code is actually cleaner.\n\nChange-Id: I0f4cf9997cd66d8b6e7f80873979ef1439e507fe\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
					"commitDate": "2011-02-01, 8:03 AM",
					"commitName": "2fbcba41e365752681f635c706d577e605d3336a",
					"commitAuthor": "Shawn O. Pearce",
					"commitDateOld": "2011-02-01, 8:01 AM",
					"commitNameOld": "8f63dface2e08b228cdeb3bef3f93458eab9ce14",
					"commitAuthorOld": "Shawn O. Pearce",
					"daysBetweenCommits": 0,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,17 +1,59 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n-\t\t\tfinal ObjectWalk walker) throws MissingObjectException,\n-\t\t\tIncorrectObjectTypeException,\t\t\tIOException {\n+\t\t\tfinal Collection<? extends ObjectId> want,\n+\t\t\tCollection<? extends ObjectId> have)\n+\t\t\tthrows MissingObjectException, IOException,\n+\t\t\tIncorrectObjectTypeException {\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n+\n+\t\tif (have == null)\n+\t\t\thave = Collections.emptySet();\n+\n+\t\tList<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());\n+\t\tall.addAll(want);\n+\t\tall.addAll(have);\n+\n+\t\tfinal ObjectWalk walker = new ObjectWalk(reader);\n+\t\twalker.setRetainBody(false);\n+\t\tif (have.isEmpty())\n+\t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n+\t\telse {\n+\t\t\twalker.sort(RevSort.TOPO);\n+\t\t\tif (thin)\n+\t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n+\t\t}\n+\n+\t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n+\t\ttry {\n+\t\t\tfor (;;) {\n+\t\t\t\ttry {\n+\t\t\t\t\tRevObject o = q.next();\n+\t\t\t\t\tif (o == null)\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tif (have.contains(o))\n+\t\t\t\t\t\twalker.markUninteresting(o);\n+\t\t\t\t\telse\n+\t\t\t\t\t\twalker.markStart(o);\n+\t\t\t\t} catch (MissingObjectException e) {\n+\t\t\t\t\tif (ignoreMissingUninteresting\n+\t\t\t\t\t\t\t&& have.contains(e.getObjectId()))\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\tthrow e;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} finally {\n+\t\t\tq.release();\n+\t\t}\n+\n \t\tRevObject o;\n \n \t\twhile ((o = walker.next()) != null) {\n \t\t\taddObject(o, 0);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\twhile ((o = walker.nextObject()) != null) {\n \t\t\taddObject(o, walker.getPathHashCode());\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\tcountingMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"065a0a8122be356d1f898321763d3518b504b075": {
			"type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
			"commitMessage": "Revert \"Teach PackWriter how to reuse an existing object list\"\n\nThis reverts commit f5fe2dca3cb9f57891e1a4b18832fcc158d0c490.\n\nI regret adding this feature to the public API.  Caches aren't always\nthe best idea, as they require work to maintain.  Here the cache is\nredundant information that must be computed, and when it grows stale\nmust be removed.  The redundant information takes up more disk space,\nabout the same size as the pack-*.idx files are.  For the linux-2.6\nrepository, that's more than 40 MB for a 400 MB repository.  So the\ncache is a 10% increase in disk usage.\n\nThe entire point of this cache is to improve PackWriter performance,\nand only PackWriter performance, and only when sending an initial\nclone to a new client.  There may be better ways to optimize this, and\nuntil we have a solid solution, we shouldn't be using a separate cache\nin JGit.\n",
			"commitDate": "2011-01-28, 8:20 AM",
			"commitName": "065a0a8122be356d1f898321763d3518b504b075",
			"commitAuthor": "Shawn O. Pearce",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Revert \"Teach PackWriter how to reuse an existing object list\"\n\nThis reverts commit f5fe2dca3cb9f57891e1a4b18832fcc158d0c490.\n\nI regret adding this feature to the public API.  Caches aren't always\nthe best idea, as they require work to maintain.  Here the cache is\nredundant information that must be computed, and when it grows stale\nmust be removed.  The redundant information takes up more disk space,\nabout the same size as the pack-*.idx files are.  For the linux-2.6\nrepository, that's more than 40 MB for a 400 MB repository.  So the\ncache is a 10% increase in disk usage.\n\nThe entire point of this cache is to improve PackWriter performance,\nand only PackWriter performance, and only when sending an initial\nclone to a new client.  There may be better ways to optimize this, and\nuntil we have a solid solution, we shouldn't be using a separate cache\nin JGit.\n",
					"commitDate": "2011-01-28, 8:20 AM",
					"commitName": "065a0a8122be356d1f898321763d3518b504b075",
					"commitAuthor": "Shawn O. Pearce",
					"commitDateOld": "2011-01-27, 10:38 AM",
					"commitNameOld": "f5fe2dca3cb9f57891e1a4b18832fcc158d0c490",
					"commitAuthorOld": "Shawn O. Pearce",
					"daysBetweenCommits": 0.9,
					"commitsBetweenForRepo": 3,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,79 +1,17 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n-\t\t\tfinal Collection<? extends ObjectId> interestingObjects,\n-\t\t\tfinal Collection<? extends ObjectId> uninterestingObjects)\n-\t\t\tthrows MissingObjectException, IOException,\n-\t\t\tIncorrectObjectTypeException {\n+\t\t\tfinal ObjectWalk walker) throws MissingObjectException,\n+\t\t\tIncorrectObjectTypeException,\t\t\tIOException {\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n-\n-\t\tList<ObjectId> all = new ArrayList<ObjectId>(interestingObjects.size());\n-\t\tfor (ObjectId id : interestingObjects)\n-\t\t\tall.add(id.copy());\n-\n-\t\tfinal Set<ObjectId> not;\n-\t\tif (uninterestingObjects != null && !uninterestingObjects.isEmpty()) {\n-\t\t\tnot = new HashSet<ObjectId>();\n-\t\t\tfor (ObjectId id : uninterestingObjects)\n-\t\t\t\tnot.add(id.copy());\n-\t\t\tall.addAll(not);\n-\t\t} else\n-\t\t\tnot = Collections.emptySet();\n-\n-\t\tfinal ObjectWalk walker = new ObjectWalk(reader);\n-\t\tfinal RevFlag hasObjectList = walker.newFlag(\"hasObjectList\");\n-\n-\t\twalker.setRetainBody(false);\n-\t\tif (not.isEmpty()) {\n-\t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n-\t\t\tfor (ObjectId listName : reader.getAvailableObjectLists())\n-\t\t\t\twalker.lookupCommit(listName).add(hasObjectList);\n-\t\t} else {\n-\t\t\twalker.sort(RevSort.TOPO);\n-\t\t\tif (thin)\n-\t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n-\t\t}\n-\n-\t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n-\t\ttry {\n-\t\t\tfor (;;) {\n-\t\t\t\ttry {\n-\t\t\t\t\tRevObject o = q.next();\n-\t\t\t\t\tif (o == null)\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tif (not.contains(o.copy()))\n-\t\t\t\t\t\twalker.markUninteresting(o);\n-\t\t\t\t\telse\n-\t\t\t\t\t\twalker.markStart(o);\n-\t\t\t\t} catch (MissingObjectException e) {\n-\t\t\t\t\tif (ignoreMissingUninteresting\n-\t\t\t\t\t\t\t&& not.contains(e.getObjectId()))\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\tthrow e;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} finally {\n-\t\t\tq.release();\n-\t\t}\n-\n-\t\tRevObject listName = null;\n \t\tRevObject o;\n \n \t\twhile ((o = walker.next()) != null) {\n-\t\t\tif (o.has(hasObjectList)) {\n-\t\t\t\tlistName = o;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\taddResultOrBase(o, 0);\n+\t\t\taddObject(o, 0);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n-\t\tif (listName != null) {\n-\t\t\taddByObjectList(listName, countingMonitor, walker,\n-\t\t\t\t\tinterestingObjects);\n-\t\t} else {\n-\t\t\twhile ((o = walker.nextObject()) != null) {\n-\t\t\t\taddResultOrBase(o, walker.getPathHashCode());\n-\t\t\t\tcountingMonitor.update(1);\n-\t\t\t}\n+\t\twhile ((o = walker.nextObject()) != null) {\n+\t\t\taddObject(o, walker.getPathHashCode());\n+\t\t\tcountingMonitor.update(1);\n \t\t}\n \t\tcountingMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[countingMonitor-ProgressMonitor(modifiers-final), interestingObjects-Collection<? extends ObjectId>(modifiers-final), uninterestingObjects-Collection<? extends ObjectId>(modifiers-final)]",
						"newValue": "[countingMonitor-ProgressMonitor(modifiers-final), walker-ObjectWalk(modifiers-final)]"
					}
				},
				{
					"type": "Yexceptionschange",
					"commitMessage": "Revert \"Teach PackWriter how to reuse an existing object list\"\n\nThis reverts commit f5fe2dca3cb9f57891e1a4b18832fcc158d0c490.\n\nI regret adding this feature to the public API.  Caches aren't always\nthe best idea, as they require work to maintain.  Here the cache is\nredundant information that must be computed, and when it grows stale\nmust be removed.  The redundant information takes up more disk space,\nabout the same size as the pack-*.idx files are.  For the linux-2.6\nrepository, that's more than 40 MB for a 400 MB repository.  So the\ncache is a 10% increase in disk usage.\n\nThe entire point of this cache is to improve PackWriter performance,\nand only PackWriter performance, and only when sending an initial\nclone to a new client.  There may be better ways to optimize this, and\nuntil we have a solid solution, we shouldn't be using a separate cache\nin JGit.\n",
					"commitDate": "2011-01-28, 8:20 AM",
					"commitName": "065a0a8122be356d1f898321763d3518b504b075",
					"commitAuthor": "Shawn O. Pearce",
					"commitDateOld": "2011-01-27, 10:38 AM",
					"commitNameOld": "f5fe2dca3cb9f57891e1a4b18832fcc158d0c490",
					"commitAuthorOld": "Shawn O. Pearce",
					"daysBetweenCommits": 0.9,
					"commitsBetweenForRepo": 3,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,79 +1,17 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n-\t\t\tfinal Collection<? extends ObjectId> interestingObjects,\n-\t\t\tfinal Collection<? extends ObjectId> uninterestingObjects)\n-\t\t\tthrows MissingObjectException, IOException,\n-\t\t\tIncorrectObjectTypeException {\n+\t\t\tfinal ObjectWalk walker) throws MissingObjectException,\n+\t\t\tIncorrectObjectTypeException,\t\t\tIOException {\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n-\n-\t\tList<ObjectId> all = new ArrayList<ObjectId>(interestingObjects.size());\n-\t\tfor (ObjectId id : interestingObjects)\n-\t\t\tall.add(id.copy());\n-\n-\t\tfinal Set<ObjectId> not;\n-\t\tif (uninterestingObjects != null && !uninterestingObjects.isEmpty()) {\n-\t\t\tnot = new HashSet<ObjectId>();\n-\t\t\tfor (ObjectId id : uninterestingObjects)\n-\t\t\t\tnot.add(id.copy());\n-\t\t\tall.addAll(not);\n-\t\t} else\n-\t\t\tnot = Collections.emptySet();\n-\n-\t\tfinal ObjectWalk walker = new ObjectWalk(reader);\n-\t\tfinal RevFlag hasObjectList = walker.newFlag(\"hasObjectList\");\n-\n-\t\twalker.setRetainBody(false);\n-\t\tif (not.isEmpty()) {\n-\t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n-\t\t\tfor (ObjectId listName : reader.getAvailableObjectLists())\n-\t\t\t\twalker.lookupCommit(listName).add(hasObjectList);\n-\t\t} else {\n-\t\t\twalker.sort(RevSort.TOPO);\n-\t\t\tif (thin)\n-\t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n-\t\t}\n-\n-\t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n-\t\ttry {\n-\t\t\tfor (;;) {\n-\t\t\t\ttry {\n-\t\t\t\t\tRevObject o = q.next();\n-\t\t\t\t\tif (o == null)\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tif (not.contains(o.copy()))\n-\t\t\t\t\t\twalker.markUninteresting(o);\n-\t\t\t\t\telse\n-\t\t\t\t\t\twalker.markStart(o);\n-\t\t\t\t} catch (MissingObjectException e) {\n-\t\t\t\t\tif (ignoreMissingUninteresting\n-\t\t\t\t\t\t\t&& not.contains(e.getObjectId()))\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\tthrow e;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} finally {\n-\t\t\tq.release();\n-\t\t}\n-\n-\t\tRevObject listName = null;\n \t\tRevObject o;\n \n \t\twhile ((o = walker.next()) != null) {\n-\t\t\tif (o.has(hasObjectList)) {\n-\t\t\t\tlistName = o;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\taddResultOrBase(o, 0);\n+\t\t\taddObject(o, 0);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n-\t\tif (listName != null) {\n-\t\t\taddByObjectList(listName, countingMonitor, walker,\n-\t\t\t\t\tinterestingObjects);\n-\t\t} else {\n-\t\t\twhile ((o = walker.nextObject()) != null) {\n-\t\t\t\taddResultOrBase(o, walker.getPathHashCode());\n-\t\t\t\tcountingMonitor.update(1);\n-\t\t\t}\n+\t\twhile ((o = walker.nextObject()) != null) {\n+\t\t\taddObject(o, walker.getPathHashCode());\n+\t\t\tcountingMonitor.update(1);\n \t\t}\n \t\tcountingMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[MissingObjectException, IOException, IncorrectObjectTypeException]",
						"newValue": "[MissingObjectException, IncorrectObjectTypeException, IOException]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Revert \"Teach PackWriter how to reuse an existing object list\"\n\nThis reverts commit f5fe2dca3cb9f57891e1a4b18832fcc158d0c490.\n\nI regret adding this feature to the public API.  Caches aren't always\nthe best idea, as they require work to maintain.  Here the cache is\nredundant information that must be computed, and when it grows stale\nmust be removed.  The redundant information takes up more disk space,\nabout the same size as the pack-*.idx files are.  For the linux-2.6\nrepository, that's more than 40 MB for a 400 MB repository.  So the\ncache is a 10% increase in disk usage.\n\nThe entire point of this cache is to improve PackWriter performance,\nand only PackWriter performance, and only when sending an initial\nclone to a new client.  There may be better ways to optimize this, and\nuntil we have a solid solution, we shouldn't be using a separate cache\nin JGit.\n",
					"commitDate": "2011-01-28, 8:20 AM",
					"commitName": "065a0a8122be356d1f898321763d3518b504b075",
					"commitAuthor": "Shawn O. Pearce",
					"commitDateOld": "2011-01-27, 10:38 AM",
					"commitNameOld": "f5fe2dca3cb9f57891e1a4b18832fcc158d0c490",
					"commitAuthorOld": "Shawn O. Pearce",
					"daysBetweenCommits": 0.9,
					"commitsBetweenForRepo": 3,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,79 +1,17 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n-\t\t\tfinal Collection<? extends ObjectId> interestingObjects,\n-\t\t\tfinal Collection<? extends ObjectId> uninterestingObjects)\n-\t\t\tthrows MissingObjectException, IOException,\n-\t\t\tIncorrectObjectTypeException {\n+\t\t\tfinal ObjectWalk walker) throws MissingObjectException,\n+\t\t\tIncorrectObjectTypeException,\t\t\tIOException {\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n-\n-\t\tList<ObjectId> all = new ArrayList<ObjectId>(interestingObjects.size());\n-\t\tfor (ObjectId id : interestingObjects)\n-\t\t\tall.add(id.copy());\n-\n-\t\tfinal Set<ObjectId> not;\n-\t\tif (uninterestingObjects != null && !uninterestingObjects.isEmpty()) {\n-\t\t\tnot = new HashSet<ObjectId>();\n-\t\t\tfor (ObjectId id : uninterestingObjects)\n-\t\t\t\tnot.add(id.copy());\n-\t\t\tall.addAll(not);\n-\t\t} else\n-\t\t\tnot = Collections.emptySet();\n-\n-\t\tfinal ObjectWalk walker = new ObjectWalk(reader);\n-\t\tfinal RevFlag hasObjectList = walker.newFlag(\"hasObjectList\");\n-\n-\t\twalker.setRetainBody(false);\n-\t\tif (not.isEmpty()) {\n-\t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n-\t\t\tfor (ObjectId listName : reader.getAvailableObjectLists())\n-\t\t\t\twalker.lookupCommit(listName).add(hasObjectList);\n-\t\t} else {\n-\t\t\twalker.sort(RevSort.TOPO);\n-\t\t\tif (thin)\n-\t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n-\t\t}\n-\n-\t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n-\t\ttry {\n-\t\t\tfor (;;) {\n-\t\t\t\ttry {\n-\t\t\t\t\tRevObject o = q.next();\n-\t\t\t\t\tif (o == null)\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\tif (not.contains(o.copy()))\n-\t\t\t\t\t\twalker.markUninteresting(o);\n-\t\t\t\t\telse\n-\t\t\t\t\t\twalker.markStart(o);\n-\t\t\t\t} catch (MissingObjectException e) {\n-\t\t\t\t\tif (ignoreMissingUninteresting\n-\t\t\t\t\t\t\t&& not.contains(e.getObjectId()))\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\tthrow e;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} finally {\n-\t\t\tq.release();\n-\t\t}\n-\n-\t\tRevObject listName = null;\n \t\tRevObject o;\n \n \t\twhile ((o = walker.next()) != null) {\n-\t\t\tif (o.has(hasObjectList)) {\n-\t\t\t\tlistName = o;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\taddResultOrBase(o, 0);\n+\t\t\taddObject(o, 0);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n-\t\tif (listName != null) {\n-\t\t\taddByObjectList(listName, countingMonitor, walker,\n-\t\t\t\t\tinterestingObjects);\n-\t\t} else {\n-\t\t\twhile ((o = walker.nextObject()) != null) {\n-\t\t\t\taddResultOrBase(o, walker.getPathHashCode());\n-\t\t\t\tcountingMonitor.update(1);\n-\t\t\t}\n+\t\twhile ((o = walker.nextObject()) != null) {\n+\t\t\taddObject(o, walker.getPathHashCode());\n+\t\t\tcountingMonitor.update(1);\n \t\t}\n \t\tcountingMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"f5fe2dca3cb9f57891e1a4b18832fcc158d0c490": {
			"type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
			"commitMessage": "Teach PackWriter how to reuse an existing object list\n\nCounting the objects needed for packing is the most expensive part of\nan UploadPack request that has no uninteresting objects (otherwise\nknown as an initial clone).  During this phase the PackWriter is\nenumerating the entire set of objects in this repository, so they can\nbe sent to the client for their new clone.\n\nAllow the ObjectReader (and therefore the underlying storage system)\nto keep a cached list of all reachable objects from a small number of\npoints in the project's history.  If one of those points is reached\nduring enumeration of the commit graph, most objects are obtained from\nthe cached list instead of direct traversal.\n\nPackWriter uses the list by discarding the current object lists and\nrestarting a traversal from all refs but marking the object list name\nas uninteresting.  This allows PackWriter to enumerate all objects\nthat are more recent than the list creation, or that were on side\nbranches that the list does not include.\n\nHowever, ObjectWalk tags all of the trees and commits within the list\ncommit as UNINTERESTING, which would normally cause PackWriter to\nconstruct a thin pack that excludes these objects.  To avoid that,\naddObject() was refactored to allow this list-based enumeration to\nalways include an object, even if it has been tagged UNINTERESTING by\nthe ObjectWalk.  This implies the list-based enumeration may only be\nused for initial clones, where all objects are being sent.\n\nThe UNINTERESTING labeling occurs because StartGenerator always\nenables the BoundaryGenerator if the walker is an ObjectWalk and a\ncommit was marked UNINTERESTING, even if RevSort.BOUNDARY was not\nenabled.  This is the default reasonable behavior for an ObjectWalk,\nbut isn't desired here in PackWriter with the list-based enumeration.\nRather than trying to change all of this behavior, PackWriter works\naround it.\n\nBecause the list name commit's immediate files and trees were all\nenumerated before the list enumeration itself starts (and are also\nwithin the list itself) PackWriter runs the risk of adding the same\nobjects to its ObjectIdSubclassMap twice.  Since this breaks the\ninternal map data structure (and also may cause the object to transmit\ntwice), PackWriter needs to use a new \"added\" RevFlag to track whether\nor not an object has been put into the outgoing list yet.\n\nChange-Id: Ie99ed4d969a6bb20cc2528ac6b8fb91043cee071\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-01-27, 10:38 AM",
			"commitName": "f5fe2dca3cb9f57891e1a4b18832fcc158d0c490",
			"commitAuthor": "Shawn O. Pearce",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Teach PackWriter how to reuse an existing object list\n\nCounting the objects needed for packing is the most expensive part of\nan UploadPack request that has no uninteresting objects (otherwise\nknown as an initial clone).  During this phase the PackWriter is\nenumerating the entire set of objects in this repository, so they can\nbe sent to the client for their new clone.\n\nAllow the ObjectReader (and therefore the underlying storage system)\nto keep a cached list of all reachable objects from a small number of\npoints in the project's history.  If one of those points is reached\nduring enumeration of the commit graph, most objects are obtained from\nthe cached list instead of direct traversal.\n\nPackWriter uses the list by discarding the current object lists and\nrestarting a traversal from all refs but marking the object list name\nas uninteresting.  This allows PackWriter to enumerate all objects\nthat are more recent than the list creation, or that were on side\nbranches that the list does not include.\n\nHowever, ObjectWalk tags all of the trees and commits within the list\ncommit as UNINTERESTING, which would normally cause PackWriter to\nconstruct a thin pack that excludes these objects.  To avoid that,\naddObject() was refactored to allow this list-based enumeration to\nalways include an object, even if it has been tagged UNINTERESTING by\nthe ObjectWalk.  This implies the list-based enumeration may only be\nused for initial clones, where all objects are being sent.\n\nThe UNINTERESTING labeling occurs because StartGenerator always\nenables the BoundaryGenerator if the walker is an ObjectWalk and a\ncommit was marked UNINTERESTING, even if RevSort.BOUNDARY was not\nenabled.  This is the default reasonable behavior for an ObjectWalk,\nbut isn't desired here in PackWriter with the list-based enumeration.\nRather than trying to change all of this behavior, PackWriter works\naround it.\n\nBecause the list name commit's immediate files and trees were all\nenumerated before the list enumeration itself starts (and are also\nwithin the list itself) PackWriter runs the risk of adding the same\nobjects to its ObjectIdSubclassMap twice.  Since this breaks the\ninternal map data structure (and also may cause the object to transmit\ntwice), PackWriter needs to use a new \"added\" RevFlag to track whether\nor not an object has been put into the outgoing list yet.\n\nChange-Id: Ie99ed4d969a6bb20cc2528ac6b8fb91043cee071\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
					"commitDate": "2011-01-27, 10:38 AM",
					"commitName": "f5fe2dca3cb9f57891e1a4b18832fcc158d0c490",
					"commitAuthor": "Shawn O. Pearce",
					"commitDateOld": "2011-01-27, 9:58 AM",
					"commitNameOld": "c218a0760ddcdd9a392b0ae15f99fdccf823cd42",
					"commitAuthorOld": "Shawn O. Pearce",
					"daysBetweenCommits": 0.03,
					"commitsBetweenForRepo": 2,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,17 +1,79 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n-\t\t\tfinal ObjectWalk walker) throws MissingObjectException,\n-\t\t\tIncorrectObjectTypeException,\t\t\tIOException {\n+\t\t\tfinal Collection<? extends ObjectId> interestingObjects,\n+\t\t\tfinal Collection<? extends ObjectId> uninterestingObjects)\n+\t\t\tthrows MissingObjectException, IOException,\n+\t\t\tIncorrectObjectTypeException {\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n+\n+\t\tList<ObjectId> all = new ArrayList<ObjectId>(interestingObjects.size());\n+\t\tfor (ObjectId id : interestingObjects)\n+\t\t\tall.add(id.copy());\n+\n+\t\tfinal Set<ObjectId> not;\n+\t\tif (uninterestingObjects != null && !uninterestingObjects.isEmpty()) {\n+\t\t\tnot = new HashSet<ObjectId>();\n+\t\t\tfor (ObjectId id : uninterestingObjects)\n+\t\t\t\tnot.add(id.copy());\n+\t\t\tall.addAll(not);\n+\t\t} else\n+\t\t\tnot = Collections.emptySet();\n+\n+\t\tfinal ObjectWalk walker = new ObjectWalk(reader);\n+\t\tfinal RevFlag hasObjectList = walker.newFlag(\"hasObjectList\");\n+\n+\t\twalker.setRetainBody(false);\n+\t\tif (not.isEmpty()) {\n+\t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n+\t\t\tfor (ObjectId listName : reader.getAvailableObjectLists())\n+\t\t\t\twalker.lookupCommit(listName).add(hasObjectList);\n+\t\t} else {\n+\t\t\twalker.sort(RevSort.TOPO);\n+\t\t\tif (thin)\n+\t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n+\t\t}\n+\n+\t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n+\t\ttry {\n+\t\t\tfor (;;) {\n+\t\t\t\ttry {\n+\t\t\t\t\tRevObject o = q.next();\n+\t\t\t\t\tif (o == null)\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tif (not.contains(o.copy()))\n+\t\t\t\t\t\twalker.markUninteresting(o);\n+\t\t\t\t\telse\n+\t\t\t\t\t\twalker.markStart(o);\n+\t\t\t\t} catch (MissingObjectException e) {\n+\t\t\t\t\tif (ignoreMissingUninteresting\n+\t\t\t\t\t\t\t&& not.contains(e.getObjectId()))\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\tthrow e;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} finally {\n+\t\t\tq.release();\n+\t\t}\n+\n+\t\tRevObject listName = null;\n \t\tRevObject o;\n \n \t\twhile ((o = walker.next()) != null) {\n-\t\t\taddObject(o, 0);\n+\t\t\tif (o.has(hasObjectList)) {\n+\t\t\t\tlistName = o;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\taddResultOrBase(o, 0);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n-\t\twhile ((o = walker.nextObject()) != null) {\n-\t\t\taddObject(o, walker.getPathHashCode());\n-\t\t\tcountingMonitor.update(1);\n+\t\tif (listName != null) {\n+\t\t\taddByObjectList(listName, countingMonitor, walker,\n+\t\t\t\t\tinterestingObjects);\n+\t\t} else {\n+\t\t\twhile ((o = walker.nextObject()) != null) {\n+\t\t\t\taddResultOrBase(o, walker.getPathHashCode());\n+\t\t\t\tcountingMonitor.update(1);\n+\t\t\t}\n \t\t}\n \t\tcountingMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[countingMonitor-ProgressMonitor(modifiers-final), walker-ObjectWalk(modifiers-final)]",
						"newValue": "[countingMonitor-ProgressMonitor(modifiers-final), interestingObjects-Collection<? extends ObjectId>(modifiers-final), uninterestingObjects-Collection<? extends ObjectId>(modifiers-final)]"
					}
				},
				{
					"type": "Yexceptionschange",
					"commitMessage": "Teach PackWriter how to reuse an existing object list\n\nCounting the objects needed for packing is the most expensive part of\nan UploadPack request that has no uninteresting objects (otherwise\nknown as an initial clone).  During this phase the PackWriter is\nenumerating the entire set of objects in this repository, so they can\nbe sent to the client for their new clone.\n\nAllow the ObjectReader (and therefore the underlying storage system)\nto keep a cached list of all reachable objects from a small number of\npoints in the project's history.  If one of those points is reached\nduring enumeration of the commit graph, most objects are obtained from\nthe cached list instead of direct traversal.\n\nPackWriter uses the list by discarding the current object lists and\nrestarting a traversal from all refs but marking the object list name\nas uninteresting.  This allows PackWriter to enumerate all objects\nthat are more recent than the list creation, or that were on side\nbranches that the list does not include.\n\nHowever, ObjectWalk tags all of the trees and commits within the list\ncommit as UNINTERESTING, which would normally cause PackWriter to\nconstruct a thin pack that excludes these objects.  To avoid that,\naddObject() was refactored to allow this list-based enumeration to\nalways include an object, even if it has been tagged UNINTERESTING by\nthe ObjectWalk.  This implies the list-based enumeration may only be\nused for initial clones, where all objects are being sent.\n\nThe UNINTERESTING labeling occurs because StartGenerator always\nenables the BoundaryGenerator if the walker is an ObjectWalk and a\ncommit was marked UNINTERESTING, even if RevSort.BOUNDARY was not\nenabled.  This is the default reasonable behavior for an ObjectWalk,\nbut isn't desired here in PackWriter with the list-based enumeration.\nRather than trying to change all of this behavior, PackWriter works\naround it.\n\nBecause the list name commit's immediate files and trees were all\nenumerated before the list enumeration itself starts (and are also\nwithin the list itself) PackWriter runs the risk of adding the same\nobjects to its ObjectIdSubclassMap twice.  Since this breaks the\ninternal map data structure (and also may cause the object to transmit\ntwice), PackWriter needs to use a new \"added\" RevFlag to track whether\nor not an object has been put into the outgoing list yet.\n\nChange-Id: Ie99ed4d969a6bb20cc2528ac6b8fb91043cee071\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
					"commitDate": "2011-01-27, 10:38 AM",
					"commitName": "f5fe2dca3cb9f57891e1a4b18832fcc158d0c490",
					"commitAuthor": "Shawn O. Pearce",
					"commitDateOld": "2011-01-27, 9:58 AM",
					"commitNameOld": "c218a0760ddcdd9a392b0ae15f99fdccf823cd42",
					"commitAuthorOld": "Shawn O. Pearce",
					"daysBetweenCommits": 0.03,
					"commitsBetweenForRepo": 2,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,17 +1,79 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n-\t\t\tfinal ObjectWalk walker) throws MissingObjectException,\n-\t\t\tIncorrectObjectTypeException,\t\t\tIOException {\n+\t\t\tfinal Collection<? extends ObjectId> interestingObjects,\n+\t\t\tfinal Collection<? extends ObjectId> uninterestingObjects)\n+\t\t\tthrows MissingObjectException, IOException,\n+\t\t\tIncorrectObjectTypeException {\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n+\n+\t\tList<ObjectId> all = new ArrayList<ObjectId>(interestingObjects.size());\n+\t\tfor (ObjectId id : interestingObjects)\n+\t\t\tall.add(id.copy());\n+\n+\t\tfinal Set<ObjectId> not;\n+\t\tif (uninterestingObjects != null && !uninterestingObjects.isEmpty()) {\n+\t\t\tnot = new HashSet<ObjectId>();\n+\t\t\tfor (ObjectId id : uninterestingObjects)\n+\t\t\t\tnot.add(id.copy());\n+\t\t\tall.addAll(not);\n+\t\t} else\n+\t\t\tnot = Collections.emptySet();\n+\n+\t\tfinal ObjectWalk walker = new ObjectWalk(reader);\n+\t\tfinal RevFlag hasObjectList = walker.newFlag(\"hasObjectList\");\n+\n+\t\twalker.setRetainBody(false);\n+\t\tif (not.isEmpty()) {\n+\t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n+\t\t\tfor (ObjectId listName : reader.getAvailableObjectLists())\n+\t\t\t\twalker.lookupCommit(listName).add(hasObjectList);\n+\t\t} else {\n+\t\t\twalker.sort(RevSort.TOPO);\n+\t\t\tif (thin)\n+\t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n+\t\t}\n+\n+\t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n+\t\ttry {\n+\t\t\tfor (;;) {\n+\t\t\t\ttry {\n+\t\t\t\t\tRevObject o = q.next();\n+\t\t\t\t\tif (o == null)\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tif (not.contains(o.copy()))\n+\t\t\t\t\t\twalker.markUninteresting(o);\n+\t\t\t\t\telse\n+\t\t\t\t\t\twalker.markStart(o);\n+\t\t\t\t} catch (MissingObjectException e) {\n+\t\t\t\t\tif (ignoreMissingUninteresting\n+\t\t\t\t\t\t\t&& not.contains(e.getObjectId()))\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\tthrow e;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} finally {\n+\t\t\tq.release();\n+\t\t}\n+\n+\t\tRevObject listName = null;\n \t\tRevObject o;\n \n \t\twhile ((o = walker.next()) != null) {\n-\t\t\taddObject(o, 0);\n+\t\t\tif (o.has(hasObjectList)) {\n+\t\t\t\tlistName = o;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\taddResultOrBase(o, 0);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n-\t\twhile ((o = walker.nextObject()) != null) {\n-\t\t\taddObject(o, walker.getPathHashCode());\n-\t\t\tcountingMonitor.update(1);\n+\t\tif (listName != null) {\n+\t\t\taddByObjectList(listName, countingMonitor, walker,\n+\t\t\t\t\tinterestingObjects);\n+\t\t} else {\n+\t\t\twhile ((o = walker.nextObject()) != null) {\n+\t\t\t\taddResultOrBase(o, walker.getPathHashCode());\n+\t\t\t\tcountingMonitor.update(1);\n+\t\t\t}\n \t\t}\n \t\tcountingMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[MissingObjectException, IncorrectObjectTypeException, IOException]",
						"newValue": "[MissingObjectException, IOException, IncorrectObjectTypeException]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Teach PackWriter how to reuse an existing object list\n\nCounting the objects needed for packing is the most expensive part of\nan UploadPack request that has no uninteresting objects (otherwise\nknown as an initial clone).  During this phase the PackWriter is\nenumerating the entire set of objects in this repository, so they can\nbe sent to the client for their new clone.\n\nAllow the ObjectReader (and therefore the underlying storage system)\nto keep a cached list of all reachable objects from a small number of\npoints in the project's history.  If one of those points is reached\nduring enumeration of the commit graph, most objects are obtained from\nthe cached list instead of direct traversal.\n\nPackWriter uses the list by discarding the current object lists and\nrestarting a traversal from all refs but marking the object list name\nas uninteresting.  This allows PackWriter to enumerate all objects\nthat are more recent than the list creation, or that were on side\nbranches that the list does not include.\n\nHowever, ObjectWalk tags all of the trees and commits within the list\ncommit as UNINTERESTING, which would normally cause PackWriter to\nconstruct a thin pack that excludes these objects.  To avoid that,\naddObject() was refactored to allow this list-based enumeration to\nalways include an object, even if it has been tagged UNINTERESTING by\nthe ObjectWalk.  This implies the list-based enumeration may only be\nused for initial clones, where all objects are being sent.\n\nThe UNINTERESTING labeling occurs because StartGenerator always\nenables the BoundaryGenerator if the walker is an ObjectWalk and a\ncommit was marked UNINTERESTING, even if RevSort.BOUNDARY was not\nenabled.  This is the default reasonable behavior for an ObjectWalk,\nbut isn't desired here in PackWriter with the list-based enumeration.\nRather than trying to change all of this behavior, PackWriter works\naround it.\n\nBecause the list name commit's immediate files and trees were all\nenumerated before the list enumeration itself starts (and are also\nwithin the list itself) PackWriter runs the risk of adding the same\nobjects to its ObjectIdSubclassMap twice.  Since this breaks the\ninternal map data structure (and also may cause the object to transmit\ntwice), PackWriter needs to use a new \"added\" RevFlag to track whether\nor not an object has been put into the outgoing list yet.\n\nChange-Id: Ie99ed4d969a6bb20cc2528ac6b8fb91043cee071\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
					"commitDate": "2011-01-27, 10:38 AM",
					"commitName": "f5fe2dca3cb9f57891e1a4b18832fcc158d0c490",
					"commitAuthor": "Shawn O. Pearce",
					"commitDateOld": "2011-01-27, 9:58 AM",
					"commitNameOld": "c218a0760ddcdd9a392b0ae15f99fdccf823cd42",
					"commitAuthorOld": "Shawn O. Pearce",
					"daysBetweenCommits": 0.03,
					"commitsBetweenForRepo": 2,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,17 +1,79 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n-\t\t\tfinal ObjectWalk walker) throws MissingObjectException,\n-\t\t\tIncorrectObjectTypeException,\t\t\tIOException {\n+\t\t\tfinal Collection<? extends ObjectId> interestingObjects,\n+\t\t\tfinal Collection<? extends ObjectId> uninterestingObjects)\n+\t\t\tthrows MissingObjectException, IOException,\n+\t\t\tIncorrectObjectTypeException {\n \t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n+\n+\t\tList<ObjectId> all = new ArrayList<ObjectId>(interestingObjects.size());\n+\t\tfor (ObjectId id : interestingObjects)\n+\t\t\tall.add(id.copy());\n+\n+\t\tfinal Set<ObjectId> not;\n+\t\tif (uninterestingObjects != null && !uninterestingObjects.isEmpty()) {\n+\t\t\tnot = new HashSet<ObjectId>();\n+\t\t\tfor (ObjectId id : uninterestingObjects)\n+\t\t\t\tnot.add(id.copy());\n+\t\t\tall.addAll(not);\n+\t\t} else\n+\t\t\tnot = Collections.emptySet();\n+\n+\t\tfinal ObjectWalk walker = new ObjectWalk(reader);\n+\t\tfinal RevFlag hasObjectList = walker.newFlag(\"hasObjectList\");\n+\n+\t\twalker.setRetainBody(false);\n+\t\tif (not.isEmpty()) {\n+\t\t\twalker.sort(RevSort.COMMIT_TIME_DESC);\n+\t\t\tfor (ObjectId listName : reader.getAvailableObjectLists())\n+\t\t\t\twalker.lookupCommit(listName).add(hasObjectList);\n+\t\t} else {\n+\t\t\twalker.sort(RevSort.TOPO);\n+\t\t\tif (thin)\n+\t\t\t\twalker.sort(RevSort.BOUNDARY, true);\n+\t\t}\n+\n+\t\tAsyncRevObjectQueue q = walker.parseAny(all, true);\n+\t\ttry {\n+\t\t\tfor (;;) {\n+\t\t\t\ttry {\n+\t\t\t\t\tRevObject o = q.next();\n+\t\t\t\t\tif (o == null)\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tif (not.contains(o.copy()))\n+\t\t\t\t\t\twalker.markUninteresting(o);\n+\t\t\t\t\telse\n+\t\t\t\t\t\twalker.markStart(o);\n+\t\t\t\t} catch (MissingObjectException e) {\n+\t\t\t\t\tif (ignoreMissingUninteresting\n+\t\t\t\t\t\t\t&& not.contains(e.getObjectId()))\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\tthrow e;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} finally {\n+\t\t\tq.release();\n+\t\t}\n+\n+\t\tRevObject listName = null;\n \t\tRevObject o;\n \n \t\twhile ((o = walker.next()) != null) {\n-\t\t\taddObject(o, 0);\n+\t\t\tif (o.has(hasObjectList)) {\n+\t\t\t\tlistName = o;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\taddResultOrBase(o, 0);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n-\t\twhile ((o = walker.nextObject()) != null) {\n-\t\t\taddObject(o, walker.getPathHashCode());\n-\t\t\tcountingMonitor.update(1);\n+\t\tif (listName != null) {\n+\t\t\taddByObjectList(listName, countingMonitor, walker,\n+\t\t\t\t\tinterestingObjects);\n+\t\t} else {\n+\t\t\twhile ((o = walker.nextObject()) != null) {\n+\t\t\t\taddResultOrBase(o, walker.getPathHashCode());\n+\t\t\t\tcountingMonitor.update(1);\n+\t\t\t}\n \t\t}\n \t\tcountingMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"21f76c2a69836ec618c82eb9305656dcec70befb": {
			"type": "Ybodychange",
			"commitMessage": "Remove static progress task names from PackWriter\n\nThese need to be dynamic based on the current thread's environment\nat time of execution in order to be properly localized for the end\nuser that will be seeing these messages.\n\nChange-Id: I4976f462cfe606edd2761c0e36b2f6b20f63d53c\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-07-28, 11:50 AM",
			"commitName": "21f76c2a69836ec618c82eb9305656dcec70befb",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-07-27, 10:40 AM",
			"commitNameOld": "a00377a7e23dbde315598ee20f61c45d031e159a",
			"commitAuthorOld": "Robin Stocker",
			"daysBetweenCommits": 1.05,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,17 +1,17 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker) throws MissingObjectException,\n \t\t\tIncorrectObjectTypeException,\t\t\tIOException {\n-\t\tcountingMonitor.beginTask(COUNTING_OBJECTS_PROGRESS,\n+\t\tcountingMonitor.beginTask(JGitText.get().countingObjects,\n \t\t\t\tProgressMonitor.UNKNOWN);\n \t\tRevObject o;\n \n \t\twhile ((o = walker.next()) != null) {\n \t\t\taddObject(o, 0);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\twhile ((o = walker.nextObject()) != null) {\n \t\t\taddObject(o, walker.getPathHashCode());\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\tcountingMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2f93a09dd10696b6388a0fcb4099341ccef05169": {
			"type": "Ybodychange",
			"commitMessage": "Save object path hash codes during packing\n\nWe need to remember these so we can later cluster objects that\nhave similar file paths near each other as we search for deltas\nbetween them.\n\nChange-Id: I52cb1e4ca15c9c267a2dbf51dd0d795f885f4cf8\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-07-09, 4:17 PM",
			"commitName": "2f93a09dd10696b6388a0fcb4099341ccef05169",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-06-30, 7:50 PM",
			"commitNameOld": "a0fd06e5c2696cc6bed396fd513ec8e4465e399c",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 8.85,
			"commitsBetweenForRepo": 21,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,17 +1,17 @@\n \tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n \t\t\tfinal ObjectWalk walker) throws MissingObjectException,\n \t\t\tIncorrectObjectTypeException,\t\t\tIOException {\n \t\tcountingMonitor.beginTask(COUNTING_OBJECTS_PROGRESS,\n \t\t\t\tProgressMonitor.UNKNOWN);\n \t\tRevObject o;\n \n \t\twhile ((o = walker.next()) != null) {\n-\t\t\taddObject(o);\n+\t\t\taddObject(o, 0);\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\twhile ((o = walker.nextObject()) != null) {\n-\t\t\taddObject(o);\n+\t\t\taddObject(o, walker.getPathHashCode());\n \t\t\tcountingMonitor.update(1);\n \t\t}\n \t\tcountingMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6b62e53b607630b6c00411741972838ced552f4d": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Move PackWriter progress monitors onto the operations\n\nRather than taking the ProgressMonitor objects in our constructor and\ncarrying them around as instance fields, take them as arguments to the\nactual time consuming operations we need to run.\n\nChange-Id: I2b230d07e277de029b1061c807e67de5428cc1c4\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-06-28, 12:47 PM",
			"commitName": "6b62e53b607630b6c00411741972838ced552f4d",
			"commitAuthor": "Shawn O. Pearce",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Move PackWriter progress monitors onto the operations\n\nRather than taking the ProgressMonitor objects in our constructor and\ncarrying them around as instance fields, take them as arguments to the\nactual time consuming operations we need to run.\n\nChange-Id: I2b230d07e277de029b1061c807e67de5428cc1c4\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
					"commitDate": "2010-06-28, 12:47 PM",
					"commitName": "6b62e53b607630b6c00411741972838ced552f4d",
					"commitAuthor": "Shawn O. Pearce",
					"commitDateOld": "2010-06-28, 12:47 PM",
					"commitNameOld": "f288c27e465a91e80b53c4100c0d9b2f2341a9aa",
					"commitAuthorOld": "Shawn O. Pearce",
					"daysBetweenCommits": 0,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,17 +1,17 @@\n-\tprivate void findObjectsToPack(final ObjectWalk walker)\n-\t\t\tthrows MissingObjectException, IncorrectObjectTypeException,\n-\t\t\tIOException {\n-\t\tinitMonitor.beginTask(COUNTING_OBJECTS_PROGRESS,\n+\tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n+\t\t\tfinal ObjectWalk walker) throws MissingObjectException,\n+\t\t\tIncorrectObjectTypeException,\t\t\tIOException {\n+\t\tcountingMonitor.beginTask(COUNTING_OBJECTS_PROGRESS,\n \t\t\t\tProgressMonitor.UNKNOWN);\n \t\tRevObject o;\n \n \t\twhile ((o = walker.next()) != null) {\n \t\t\taddObject(o);\n-\t\t\tinitMonitor.update(1);\n+\t\t\tcountingMonitor.update(1);\n \t\t}\n \t\twhile ((o = walker.nextObject()) != null) {\n \t\t\taddObject(o);\n-\t\t\tinitMonitor.update(1);\n+\t\t\tcountingMonitor.update(1);\n \t\t}\n-\t\tinitMonitor.endTask();\n+\t\tcountingMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[walker-ObjectWalk(modifiers-final)]",
						"newValue": "[countingMonitor-ProgressMonitor(modifiers-final), walker-ObjectWalk(modifiers-final)]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Move PackWriter progress monitors onto the operations\n\nRather than taking the ProgressMonitor objects in our constructor and\ncarrying them around as instance fields, take them as arguments to the\nactual time consuming operations we need to run.\n\nChange-Id: I2b230d07e277de029b1061c807e67de5428cc1c4\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
					"commitDate": "2010-06-28, 12:47 PM",
					"commitName": "6b62e53b607630b6c00411741972838ced552f4d",
					"commitAuthor": "Shawn O. Pearce",
					"commitDateOld": "2010-06-28, 12:47 PM",
					"commitNameOld": "f288c27e465a91e80b53c4100c0d9b2f2341a9aa",
					"commitAuthorOld": "Shawn O. Pearce",
					"daysBetweenCommits": 0,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,17 +1,17 @@\n-\tprivate void findObjectsToPack(final ObjectWalk walker)\n-\t\t\tthrows MissingObjectException, IncorrectObjectTypeException,\n-\t\t\tIOException {\n-\t\tinitMonitor.beginTask(COUNTING_OBJECTS_PROGRESS,\n+\tprivate void findObjectsToPack(final ProgressMonitor countingMonitor,\n+\t\t\tfinal ObjectWalk walker) throws MissingObjectException,\n+\t\t\tIncorrectObjectTypeException,\t\t\tIOException {\n+\t\tcountingMonitor.beginTask(COUNTING_OBJECTS_PROGRESS,\n \t\t\t\tProgressMonitor.UNKNOWN);\n \t\tRevObject o;\n \n \t\twhile ((o = walker.next()) != null) {\n \t\t\taddObject(o);\n-\t\t\tinitMonitor.update(1);\n+\t\t\tcountingMonitor.update(1);\n \t\t}\n \t\twhile ((o = walker.nextObject()) != null) {\n \t\t\taddObject(o);\n-\t\t\tinitMonitor.update(1);\n+\t\t\tcountingMonitor.update(1);\n \t\t}\n-\t\tinitMonitor.endTask();\n+\t\tcountingMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"ea21c111cb7ac0c8dc39c4df3fe90c08ddcce066": {
			"type": "Yfilerename",
			"commitMessage": "Move PackWriter over to storage.pack.PackWriter\n\nSimilar to what we did with the file code, move the pack writer\ninto its own package so the related classes and their package\nprivate methods are hidden from the rest of the library.\n\nChange-Id: Ic1b5c7c8c8d266e90c910d8d68dfc8e93586854f\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-06-26, 7:51 PM",
			"commitName": "ea21c111cb7ac0c8dc39c4df3fe90c08ddcce066",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-06-26, 7:50 PM",
			"commitNameOld": "71aace52f7bfc36c65c92ab54c6f020dffc873ab",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "org.eclipse.jgit/src/org/eclipse/jgit/lib/PackWriter.java",
				"newPath": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java"
			}
		},
		"1a6964c8274c50f0253db75f010d78ef0e739343": {
			"type": "Yintroduced",
			"commitMessage": "Initial JGit contribution to eclipse.org\n\nPer CQ 3448 this is the initial contribution of the JGit project\nto eclipse.org.  It is derived from the historical JGit repository\nat commit 3a2dd9921c8a08740a9e02c421469e5b1a9e47cb.\n\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2009-09-29, 5:47 PM",
			"commitName": "1a6964c8274c50f0253db75f010d78ef0e739343",
			"commitAuthor": "Git Development Community"
		}
	},
	"sha": "bd1a82502680b5de5bf86f6c4470185fd1602386"
}