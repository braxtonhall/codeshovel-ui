{
	"repo": "https://github.com/spring-projects/spring-framework.git",
	"file": "spring-beans/src/main/java/org/springframework/beans/AbstractNestablePropertyAccessor.java",
	"method": {
		"longName": "protected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv);",
		"startLine": 273,
		"methodName": "setPropertyValue",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "protected"
	},
	"history": {
		"64d6561cbbda4d5a74cd0f3ce5983e29c9d42b89": {
			"type": "Ybodychange",
			"commitMessage": "AbstractNestablePropertyAccessor's setPropertyValue refactored into several delegate methods\n\nIssue: SPR-15053\n",
			"commitDate": "2016-12-26, 10:47 AM",
			"commitName": "64d6561cbbda4d5a74cd0f3ce5983e29c9d42b89",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2016-09-13, 12:55 PM",
			"commitNameOld": "c69e6a36f7322d52d2989ea9136c7aff33f199c9",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 103.95,
			"commitsBetweenForRepo": 562,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,193 +1,8 @@\n \tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n-\t\tString propertyName = tokens.canonicalName;\n-\t\tString actualName = tokens.actualName;\n-\n \t\tif (tokens.keys != null) {\n-\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n-\t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n-\t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n-\t\t\tgetterTokens.actualName = tokens.actualName;\n-\t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n-\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n-\t\t\tObject propValue;\n-\t\t\ttry {\n-\t\t\t\tpropValue = getPropertyValue(getterTokens);\n-\t\t\t}\n-\t\t\tcatch (NotReadablePropertyException ex) {\n-\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n-\t\t\t}\n-\t\t\t// Set value for last key.\n-\t\t\tString key = tokens.keys[tokens.keys.length - 1];\n-\t\t\tif (propValue == null) {\n-\t\t\t\t// null map value case\n-\t\t\t\tif (isAutoGrowNestedPaths()) {\n-\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n-\t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n-\t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n-\t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (propValue.getClass().isArray()) {\n-\t\t\t\tPropertyHandler ph = getLocalPropertyHandler(actualName);\n-\t\t\t\tClass<?> requiredType = propValue.getClass().getComponentType();\n-\t\t\t\tint arrayIndex = Integer.parseInt(key);\n-\t\t\t\tObject oldValue = null;\n-\t\t\t\ttry {\n-\t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n-\t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n-\t\t\t\t\t}\n-\t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n-\t\t\t\t\tint length = Array.getLength(propValue);\n-\t\t\t\t\tif (arrayIndex >= length && arrayIndex < this.autoGrowCollectionLimit) {\n-\t\t\t\t\t\tClass<?> componentType = propValue.getClass().getComponentType();\n-\t\t\t\t\t\tObject newArray = Array.newInstance(componentType, arrayIndex + 1);\n-\t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n-\t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n-\t\t\t\t\t\tpropValue = getPropertyValue(actualName);\n-\t\t\t\t\t}\n-\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n-\t\t\t\t}\n-\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n-\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if (propValue instanceof List) {\n-\t\t\t\tPropertyHandler ph = getPropertyHandler(actualName);\n-\t\t\t\tClass<?> requiredType = ph.getCollectionType(tokens.keys.length);\n-\t\t\t\tList<Object> list = (List<Object>) propValue;\n-\t\t\t\tint index = Integer.parseInt(key);\n-\t\t\t\tObject oldValue = null;\n-\t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n-\t\t\t\t\toldValue = list.get(index);\n-\t\t\t\t}\n-\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n-\t\t\t\tint size = list.size();\n-\t\t\t\tif (index >= size && index < this.autoGrowCollectionLimit) {\n-\t\t\t\t\tfor (int i = size; i < index; i++) {\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tlist.add(null);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcatch (NullPointerException ex) {\n-\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n-\t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n-\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tlist.add(convertedValue);\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tlist.set(index, convertedValue);\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n-\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\t\t\"Invalid list index in property path '\" + propertyName + \"'\", ex);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if (propValue instanceof Map) {\n-\t\t\t\tPropertyHandler ph = getLocalPropertyHandler(actualName);\n-\t\t\t\tClass<?> mapKeyType = ph.getMapKeyType(tokens.keys.length);\n-\t\t\t\tClass<?> mapValueType = ph.getMapValueType(tokens.keys.length);\n-\t\t\t\tMap<Object, Object> map = (Map<Object, Object>) propValue;\n-\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n-\t\t\t\t// must not kick in for map keys but rather only for map values.\n-\t\t\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(mapKeyType);\n-\t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n-\t\t\t\tObject oldValue = null;\n-\t\t\t\tif (isExtractOldValueForEditor()) {\n-\t\t\t\t\toldValue = map.get(convertedMapKey);\n-\t\t\t\t}\n-\t\t\t\t// Pass full property name and old value in here, since we want full\n-\t\t\t\t// conversion ability for map values.\n-\t\t\t\tObject convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\tmapValueType, ph.nested(tokens.keys.length));\n-\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n-\t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n-\t\t\t}\n+\t\t\tprocessKeyedProperty(tokens, pv);\n \t\t}\n-\n \t\telse {\n-\t\t\tPropertyHandler ph = getLocalPropertyHandler(actualName);\n-\t\t\tif (ph == null || !ph.isWritable()) {\n-\t\t\t\tif (pv.isOptional()) {\n-\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n-\t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n-\t\t\t\t\t}\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tthrow createNotWritablePropertyException(propertyName);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tObject oldValue = null;\n-\t\t\ttry {\n-\t\t\t\tObject originalValue = pv.getValue();\n-\t\t\t\tObject valueToApply = originalValue;\n-\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n-\t\t\t\t\tif (pv.isConverted()) {\n-\t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n-\t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\tif (isExtractOldValueForEditor() && ph.isReadable()) {\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\toldValue = ph.getValue();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tcatch (Exception ex) {\n-\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n-\t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n-\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tvalueToApply = convertForProperty(\n-\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, ph.toTypeDescriptor());\n-\t\t\t\t\t}\n-\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n-\t\t\t\t}\n-\t\t\t\tph.setValue(this.wrappedObject, valueToApply);\n-\t\t\t}\n-\t\t\tcatch (TypeMismatchException ex) {\n-\t\t\t\tthrow ex;\n-\t\t\t}\n-\t\t\tcatch (InvocationTargetException ex) {\n-\t\t\t\tPropertyChangeEvent propertyChangeEvent =\n-\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n-\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tThrowable cause = ex.getTargetException();\n-\t\t\t\t\tif (cause instanceof UndeclaredThrowableException) {\n-\t\t\t\t\t\t// May happen e.g. with Groovy-generated methods\n-\t\t\t\t\t\tcause = cause.getCause();\n-\t\t\t\t\t}\n-\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, cause);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tcatch (Exception ex) {\n-\t\t\t\tPropertyChangeEvent pce =\n-\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\tthrow new MethodInvocationException(pce, ex);\n-\t\t\t}\n+\t\t\tprocessLocalProperty(tokens, pv);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5c1d3fca15d9c020a07a0130a3992926d7087f1a": {
			"type": "Ybodychange",
			"commitMessage": "BeanFactory does not unwrap java.util.Optional for top-level bean\n\nIssue: SPR-14121\n",
			"commitDate": "2016-04-07, 5:18 AM",
			"commitName": "5c1d3fca15d9c020a07a0130a3992926d7087f1a",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2015-12-09, 3:28 AM",
			"commitNameOld": "11806b921541ba225008937d9054d08ab06524ae",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 120.03,
			"commitsBetweenForRepo": 538,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,193 +1,193 @@\n \tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n+\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (isAutoGrowNestedPaths()) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n+\t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyHandler ph = getLocalPropertyHandler(actualName);\n \t\t\t\tClass<?> requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n \t\t\t\t\tint length = Array.getLength(propValue);\n \t\t\t\t\tif (arrayIndex >= length && arrayIndex < this.autoGrowCollectionLimit) {\n \t\t\t\t\t\tClass<?> componentType = propValue.getClass().getComponentType();\n \t\t\t\t\t\tObject newArray = Array.newInstance(componentType, arrayIndex + 1);\n \t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n \t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n \t\t\t\t\t\tpropValue = getPropertyValue(actualName);\n \t\t\t\t\t}\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyHandler ph = getPropertyHandler(actualName);\n \t\t\t\tClass<?> requiredType = ph.getCollectionType(tokens.keys.length);\n \t\t\t\tList<Object> list = (List<Object>) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n \t\t\t\tint size = list.size();\n \t\t\t\tif (index >= size && index < this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i = size; i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n-\t\t\t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n-\t\t\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n+\t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n+\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyHandler ph = getLocalPropertyHandler(actualName);\n \t\t\t\tClass<?> mapKeyType = ph.getMapKeyType(tokens.keys.length);\n \t\t\t\tClass<?> mapValueType = ph.getMapValueType(tokens.keys.length);\n \t\t\t\tMap<Object, Object> map = (Map<Object, Object>) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(mapKeyType);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, ph.nested(tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n-\t\t\t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n+\t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyHandler ph = getLocalPropertyHandler(actualName);\n \t\t\tif (ph == null || !ph.isWritable()) {\n \t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow createNotWritablePropertyException(propertyName);\n \t\t\t\t}\n \t\t\t}\n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && ph.isReadable()) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\toldValue = ph.getValue();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(\n \t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, ph.toTypeDescriptor());\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n-\t\t\t\tph.setValue(object, valueToApply);\n+\t\t\t\tph.setValue(this.wrappedObject, valueToApply);\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tThrowable cause = ex.getTargetException();\n \t\t\t\t\tif (cause instanceof UndeclaredThrowableException) {\n \t\t\t\t\t\t// May happen e.g. with Groovy-generated methods\n \t\t\t\t\t\tcause = cause.getCause();\n \t\t\t\t\t}\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, cause);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2dc674f356fbe941b98301f89494767f80d55e6a": {
			"type": "Ymovefromfile",
			"commitMessage": "Restore AbstractPropertyAccessor\n\nCommit 3d86f15 added a lot of new feature in AbstractPropertyAccessor\nshared by both DirectFieldAccessor and BeanWrapperImpl. This makes this\nabstract class harder to implement for others having simpler use cases.\n\nIt turns that Spring Data has such use case; this commit split these new\nfeatures in a dedicated new base class, leaving AbstractPropertyAccessor\nuntouched.\n\nIssue: SPR-12805\n",
			"commitDate": "2015-05-22, 1:33 AM",
			"commitName": "2dc674f356fbe941b98301f89494767f80d55e6a",
			"commitAuthor": "Stephane Nicoll",
			"commitDateOld": "2015-05-22, 1:28 AM",
			"commitNameOld": "27c435c4eae6502ba068a5da8c19d626c28316c3",
			"commitAuthorOld": "Stephane Nicoll",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "spring-beans/src/main/java/org/springframework/beans/AbstractPropertyAccessor.java",
				"newPath": "spring-beans/src/main/java/org/springframework/beans/AbstractNestablePropertyAccessor.java",
				"oldMethodName": "setPropertyValue",
				"newMethodName": "setPropertyValue"
			}
		},
		"6fb31903536c0a41dd4fbe153c81494ccfd4d405": {
			"type": "Ybodychange",
			"commitMessage": "Fix regression with binding and validation\n\nPreviously, the binding may have to call the getter first to retrieve the\nold value of a property before actually setting it. This was guarded by\na catch block that was accidentally removed in 3d86f15\n\nRestore that catch block and add a test to cover it.\n\nIssue: SPR-12805\n",
			"commitDate": "2015-05-21, 8:48 AM",
			"commitName": "6fb31903536c0a41dd4fbe153c81494ccfd4d405",
			"commitAuthor": "Stephane Nicoll",
			"commitDateOld": "2015-05-21, 4:49 AM",
			"commitNameOld": "3d86f15a847d4567c3b08b21a21500398a394e31",
			"commitAuthorOld": "Stephane Nicoll",
			"daysBetweenCommits": 0.17,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,182 +1,193 @@\n \tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (isAutoGrowNestedPaths()) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyHandler ph = getLocalPropertyHandler(actualName);\n \t\t\t\tClass<?> requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n \t\t\t\t\tint length = Array.getLength(propValue);\n \t\t\t\t\tif (arrayIndex >= length && arrayIndex < this.autoGrowCollectionLimit) {\n \t\t\t\t\t\tClass<?> componentType = propValue.getClass().getComponentType();\n \t\t\t\t\t\tObject newArray = Array.newInstance(componentType, arrayIndex + 1);\n \t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n \t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n \t\t\t\t\t\tpropValue = getPropertyValue(actualName);\n \t\t\t\t\t}\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyHandler ph = getPropertyHandler(actualName);\n \t\t\t\tClass<?> requiredType = ph.getCollectionType(tokens.keys.length);\n \t\t\t\tList<Object> list = (List<Object>) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n \t\t\t\tint size = list.size();\n \t\t\t\tif (index >= size && index < this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i = size; i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyHandler ph = getLocalPropertyHandler(actualName);\n \t\t\t\tClass<?> mapKeyType = ph.getMapKeyType(tokens.keys.length);\n \t\t\t\tClass<?> mapValueType = ph.getMapValueType(tokens.keys.length);\n \t\t\t\tMap<Object, Object> map = (Map<Object, Object>) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(mapKeyType);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, ph.nested(tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyHandler ph = getLocalPropertyHandler(actualName);\n \t\t\tif (ph == null || !ph.isWritable()) {\n \t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow createNotWritablePropertyException(propertyName);\n \t\t\t\t}\n \t\t\t}\n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && ph.isReadable()) {\n-\t\t\t\t\t\t\toldValue = ph.getValue();\n+\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\toldValue = ph.getValue();\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n+\t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n+\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(\n \t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, ph.toTypeDescriptor());\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tph.setValue(object, valueToApply);\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tThrowable cause = ex.getTargetException();\n \t\t\t\t\tif (cause instanceof UndeclaredThrowableException) {\n \t\t\t\t\t\t// May happen e.g. with Groovy-generated methods\n \t\t\t\t\t\tcause = cause.getCause();\n \t\t\t\t\t}\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, cause);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3d86f15a847d4567c3b08b21a21500398a394e31": {
			"type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
			"commitMessage": "Merge BeanWrapperImpl and DirectFieldAccessor\n\n`BeanWrapperImpl` and `DirectFieldAccessor` are two\n`ConfigurablePropertyAccessor` implementations with different features\nset.\n\nThis commit harmonizes the two implementations to use a common base class\nthat delegates the actual property handling to the sub-classes:\n\n* `BeanWrapperImpl`:  `PropertyDescriptor` and introspection utilities\n* `DirectFieldAccessor`: reflection on `java.lang.Field`\n\nIssues: SPR-12206 - SPR-12805\n",
			"commitDate": "2015-05-21, 4:49 AM",
			"commitName": "3d86f15a847d4567c3b08b21a21500398a394e31",
			"commitAuthor": "Stephane Nicoll",
			"subchanges": [
				{
					"type": "Ymovefromfile",
					"commitMessage": "Merge BeanWrapperImpl and DirectFieldAccessor\n\n`BeanWrapperImpl` and `DirectFieldAccessor` are two\n`ConfigurablePropertyAccessor` implementations with different features\nset.\n\nThis commit harmonizes the two implementations to use a common base class\nthat delegates the actual property handling to the sub-classes:\n\n* `BeanWrapperImpl`:  `PropertyDescriptor` and introspection utilities\n* `DirectFieldAccessor`: reflection on `java.lang.Field`\n\nIssues: SPR-12206 - SPR-12805\n",
					"commitDate": "2015-05-21, 4:49 AM",
					"commitName": "3d86f15a847d4567c3b08b21a21500398a394e31",
					"commitAuthor": "Stephane Nicoll",
					"commitDateOld": "2015-05-20, 2:06 PM",
					"commitNameOld": "ad4c8795ae13c94f942526765b5cf36ac6c3ae9b",
					"commitAuthorOld": "Rossen Stoyanchev",
					"daysBetweenCommits": 0.61,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,262 +1,182 @@\n-\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n+\tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n+\t\t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (isAutoGrowNestedPaths()) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n+\t\t\t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n-\t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n+\t\t\t\tPropertyHandler ph = getLocalPropertyHandler(actualName);\n \t\t\t\tClass<?> requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n \t\t\t\t\tint length = Array.getLength(propValue);\n \t\t\t\t\tif (arrayIndex >= length && arrayIndex < this.autoGrowCollectionLimit) {\n \t\t\t\t\t\tClass<?> componentType = propValue.getClass().getComponentType();\n \t\t\t\t\t\tObject newArray = Array.newInstance(componentType, arrayIndex + 1);\n \t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n \t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n \t\t\t\t\t\tpropValue = getPropertyValue(actualName);\n \t\t\t\t\t}\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n-\t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass<?> requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n-\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n+\t\t\t\tPropertyHandler ph = getPropertyHandler(actualName);\n+\t\t\t\tClass<?> requiredType = ph.getCollectionType(tokens.keys.length);\n \t\t\t\tList<Object> list = (List<Object>) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n \t\t\t\tint size = list.size();\n \t\t\t\tif (index >= size && index < this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i = size; i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n-\t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n-\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n+\t\t\t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n+\t\t\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n-\t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass<?> mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n-\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n-\t\t\t\tClass<?> mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n-\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n+\t\t\t\tPropertyHandler ph = getLocalPropertyHandler(actualName);\n+\t\t\t\tClass<?> mapKeyType = ph.getMapKeyType(tokens.keys.length);\n+\t\t\t\tClass<?> mapValueType = ph.getMapValueType(tokens.keys.length);\n \t\t\t\tMap<Object, Object> map = (Map<Object, Object>) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(mapKeyType);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\t\tmapValueType, ph.nested(tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n-\t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n+\t\t\t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n-\t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n-\t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n-\t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n-\t\t\t\t\tif (pv.isOptional()) {\n+\t\t\tPropertyHandler ph = getLocalPropertyHandler(actualName);\n+\t\t\tif (ph == null || !ph.isWritable()) {\n+\t\t\t\tif (pv.isOptional()) {\n+\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n-\t\t\t\t\t\treturn;\n \t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n-\t\t\t\t\t\tthrow new NotWritablePropertyException(\n-\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n-\t\t\t\t\t}\n+\t\t\t\t\treturn;\n \t\t\t\t}\n-\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n+\t\t\t\telse {\n+\t\t\t\t\tthrow createNotWritablePropertyException(propertyName);\n+\t\t\t\t}\n \t\t\t}\n-\n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n-\t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n-\t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n-\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n-\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n-\t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n-\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n-\t\t\t\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n-\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n-\t\t\t\t\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t});\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n-\t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n-\t\t\t\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n-\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t}, acc);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tcatch (Exception ex) {\n-\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n-\t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n-\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (isExtractOldValueForEditor() && ph.isReadable()) {\n+\t\t\t\t\t\t\toldValue = ph.getValue();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(\n-\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n+\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, ph.toTypeDescriptor());\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n-\t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n-\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n-\t\t\t\t\t\tpd.getWriteMethod());\n-\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n-\t\t\t\t\tif (System.getSecurityManager()!= null) {\n-\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic Object run() {\n-\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n-\t\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\twriteMethod.setAccessible(true);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tfinal Object value = valueToApply;\n-\t\t\t\tif (System.getSecurityManager() != null) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic Object run() throws Exception {\n-\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n-\t\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}, acc);\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (PrivilegedActionException ex) {\n-\t\t\t\t\t\tthrow ex.getException();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\twriteMethod.invoke(this.object, value);\n-\t\t\t\t}\n+\t\t\t\tph.setValue(object, valueToApply);\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n-\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n+\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tThrowable cause = ex.getTargetException();\n \t\t\t\t\tif (cause instanceof UndeclaredThrowableException) {\n \t\t\t\t\t\t// May happen e.g. with Groovy-generated methods\n \t\t\t\t\t\tcause = cause.getCause();\n \t\t\t\t\t}\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, cause);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldPath": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
						"newPath": "spring-beans/src/main/java/org/springframework/beans/AbstractPropertyAccessor.java",
						"oldMethodName": "setPropertyValue",
						"newMethodName": "setPropertyValue"
					}
				},
				{
					"type": "Ymodifierchange",
					"commitMessage": "Merge BeanWrapperImpl and DirectFieldAccessor\n\n`BeanWrapperImpl` and `DirectFieldAccessor` are two\n`ConfigurablePropertyAccessor` implementations with different features\nset.\n\nThis commit harmonizes the two implementations to use a common base class\nthat delegates the actual property handling to the sub-classes:\n\n* `BeanWrapperImpl`:  `PropertyDescriptor` and introspection utilities\n* `DirectFieldAccessor`: reflection on `java.lang.Field`\n\nIssues: SPR-12206 - SPR-12805\n",
					"commitDate": "2015-05-21, 4:49 AM",
					"commitName": "3d86f15a847d4567c3b08b21a21500398a394e31",
					"commitAuthor": "Stephane Nicoll",
					"commitDateOld": "2015-05-20, 2:06 PM",
					"commitNameOld": "ad4c8795ae13c94f942526765b5cf36ac6c3ae9b",
					"commitAuthorOld": "Rossen Stoyanchev",
					"daysBetweenCommits": 0.61,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,262 +1,182 @@\n-\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n+\tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n+\t\t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (isAutoGrowNestedPaths()) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n+\t\t\t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n-\t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n+\t\t\t\tPropertyHandler ph = getLocalPropertyHandler(actualName);\n \t\t\t\tClass<?> requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n \t\t\t\t\tint length = Array.getLength(propValue);\n \t\t\t\t\tif (arrayIndex >= length && arrayIndex < this.autoGrowCollectionLimit) {\n \t\t\t\t\t\tClass<?> componentType = propValue.getClass().getComponentType();\n \t\t\t\t\t\tObject newArray = Array.newInstance(componentType, arrayIndex + 1);\n \t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n \t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n \t\t\t\t\t\tpropValue = getPropertyValue(actualName);\n \t\t\t\t\t}\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n-\t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass<?> requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n-\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n+\t\t\t\tPropertyHandler ph = getPropertyHandler(actualName);\n+\t\t\t\tClass<?> requiredType = ph.getCollectionType(tokens.keys.length);\n \t\t\t\tList<Object> list = (List<Object>) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n \t\t\t\tint size = list.size();\n \t\t\t\tif (index >= size && index < this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i = size; i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n-\t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n-\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n+\t\t\t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n+\t\t\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n-\t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass<?> mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n-\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n-\t\t\t\tClass<?> mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n-\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n+\t\t\t\tPropertyHandler ph = getLocalPropertyHandler(actualName);\n+\t\t\t\tClass<?> mapKeyType = ph.getMapKeyType(tokens.keys.length);\n+\t\t\t\tClass<?> mapValueType = ph.getMapValueType(tokens.keys.length);\n \t\t\t\tMap<Object, Object> map = (Map<Object, Object>) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(mapKeyType);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\t\tmapValueType, ph.nested(tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n-\t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n+\t\t\t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n-\t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n-\t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n-\t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n-\t\t\t\t\tif (pv.isOptional()) {\n+\t\t\tPropertyHandler ph = getLocalPropertyHandler(actualName);\n+\t\t\tif (ph == null || !ph.isWritable()) {\n+\t\t\t\tif (pv.isOptional()) {\n+\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n-\t\t\t\t\t\treturn;\n \t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n-\t\t\t\t\t\tthrow new NotWritablePropertyException(\n-\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n-\t\t\t\t\t}\n+\t\t\t\t\treturn;\n \t\t\t\t}\n-\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n+\t\t\t\telse {\n+\t\t\t\t\tthrow createNotWritablePropertyException(propertyName);\n+\t\t\t\t}\n \t\t\t}\n-\n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n-\t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n-\t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n-\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n-\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n-\t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n-\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n-\t\t\t\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n-\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n-\t\t\t\t\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t});\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n-\t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n-\t\t\t\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n-\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t}, acc);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tcatch (Exception ex) {\n-\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n-\t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n-\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (isExtractOldValueForEditor() && ph.isReadable()) {\n+\t\t\t\t\t\t\toldValue = ph.getValue();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(\n-\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n+\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, ph.toTypeDescriptor());\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n-\t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n-\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n-\t\t\t\t\t\tpd.getWriteMethod());\n-\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n-\t\t\t\t\tif (System.getSecurityManager()!= null) {\n-\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic Object run() {\n-\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n-\t\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\twriteMethod.setAccessible(true);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tfinal Object value = valueToApply;\n-\t\t\t\tif (System.getSecurityManager() != null) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic Object run() throws Exception {\n-\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n-\t\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}, acc);\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (PrivilegedActionException ex) {\n-\t\t\t\t\t\tthrow ex.getException();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\twriteMethod.invoke(this.object, value);\n-\t\t\t\t}\n+\t\t\t\tph.setValue(object, valueToApply);\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n-\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n+\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tThrowable cause = ex.getTargetException();\n \t\t\t\t\tif (cause instanceof UndeclaredThrowableException) {\n \t\t\t\t\t\t// May happen e.g. with Groovy-generated methods\n \t\t\t\t\t\tcause = cause.getCause();\n \t\t\t\t\t}\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, cause);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[private]",
						"newValue": "[protected]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Merge BeanWrapperImpl and DirectFieldAccessor\n\n`BeanWrapperImpl` and `DirectFieldAccessor` are two\n`ConfigurablePropertyAccessor` implementations with different features\nset.\n\nThis commit harmonizes the two implementations to use a common base class\nthat delegates the actual property handling to the sub-classes:\n\n* `BeanWrapperImpl`:  `PropertyDescriptor` and introspection utilities\n* `DirectFieldAccessor`: reflection on `java.lang.Field`\n\nIssues: SPR-12206 - SPR-12805\n",
					"commitDate": "2015-05-21, 4:49 AM",
					"commitName": "3d86f15a847d4567c3b08b21a21500398a394e31",
					"commitAuthor": "Stephane Nicoll",
					"commitDateOld": "2015-05-20, 2:06 PM",
					"commitNameOld": "ad4c8795ae13c94f942526765b5cf36ac6c3ae9b",
					"commitAuthorOld": "Rossen Stoyanchev",
					"daysBetweenCommits": 0.61,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,262 +1,182 @@\n-\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n+\tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n+\t\t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (isAutoGrowNestedPaths()) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n+\t\t\t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n-\t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n+\t\t\t\tPropertyHandler ph = getLocalPropertyHandler(actualName);\n \t\t\t\tClass<?> requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n \t\t\t\t\tint length = Array.getLength(propValue);\n \t\t\t\t\tif (arrayIndex >= length && arrayIndex < this.autoGrowCollectionLimit) {\n \t\t\t\t\t\tClass<?> componentType = propValue.getClass().getComponentType();\n \t\t\t\t\t\tObject newArray = Array.newInstance(componentType, arrayIndex + 1);\n \t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n \t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n \t\t\t\t\t\tpropValue = getPropertyValue(actualName);\n \t\t\t\t\t}\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n-\t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass<?> requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n-\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n+\t\t\t\tPropertyHandler ph = getPropertyHandler(actualName);\n+\t\t\t\tClass<?> requiredType = ph.getCollectionType(tokens.keys.length);\n \t\t\t\tList<Object> list = (List<Object>) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n \t\t\t\tint size = list.size();\n \t\t\t\tif (index >= size && index < this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i = size; i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n-\t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n-\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n+\t\t\t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n+\t\t\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n-\t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass<?> mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n-\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n-\t\t\t\tClass<?> mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n-\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n+\t\t\t\tPropertyHandler ph = getLocalPropertyHandler(actualName);\n+\t\t\t\tClass<?> mapKeyType = ph.getMapKeyType(tokens.keys.length);\n+\t\t\t\tClass<?> mapValueType = ph.getMapValueType(tokens.keys.length);\n \t\t\t\tMap<Object, Object> map = (Map<Object, Object>) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(mapKeyType);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\t\tmapValueType, ph.nested(tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n-\t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n+\t\t\t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n-\t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n-\t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n-\t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n-\t\t\t\t\tif (pv.isOptional()) {\n+\t\t\tPropertyHandler ph = getLocalPropertyHandler(actualName);\n+\t\t\tif (ph == null || !ph.isWritable()) {\n+\t\t\t\tif (pv.isOptional()) {\n+\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n-\t\t\t\t\t\treturn;\n \t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n-\t\t\t\t\t\tthrow new NotWritablePropertyException(\n-\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n-\t\t\t\t\t}\n+\t\t\t\t\treturn;\n \t\t\t\t}\n-\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n+\t\t\t\telse {\n+\t\t\t\t\tthrow createNotWritablePropertyException(propertyName);\n+\t\t\t\t}\n \t\t\t}\n-\n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n-\t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n-\t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n-\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n-\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n-\t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n-\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n-\t\t\t\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n-\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n-\t\t\t\t\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t});\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n-\t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n-\t\t\t\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n-\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t}, acc);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tcatch (Exception ex) {\n-\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n-\t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n-\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (isExtractOldValueForEditor() && ph.isReadable()) {\n+\t\t\t\t\t\t\toldValue = ph.getValue();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(\n-\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n+\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, ph.toTypeDescriptor());\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n-\t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n-\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n-\t\t\t\t\t\tpd.getWriteMethod());\n-\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n-\t\t\t\t\tif (System.getSecurityManager()!= null) {\n-\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic Object run() {\n-\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n-\t\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\twriteMethod.setAccessible(true);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tfinal Object value = valueToApply;\n-\t\t\t\tif (System.getSecurityManager() != null) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic Object run() throws Exception {\n-\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n-\t\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}, acc);\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (PrivilegedActionException ex) {\n-\t\t\t\t\t\tthrow ex.getException();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\twriteMethod.invoke(this.object, value);\n-\t\t\t\t}\n+\t\t\t\tph.setValue(object, valueToApply);\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n-\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n+\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tThrowable cause = ex.getTargetException();\n \t\t\t\t\tif (cause instanceof UndeclaredThrowableException) {\n \t\t\t\t\t\t// May happen e.g. with Groovy-generated methods\n \t\t\t\t\t\tcause = cause.getCause();\n \t\t\t\t\t}\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, cause);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"595cdf05e962299c19c34bbfb370316636d074f2": {
			"type": "Ybodychange",
			"commitMessage": "Polishing\n",
			"commitDate": "2015-04-03, 3:23 PM",
			"commitName": "595cdf05e962299c19c34bbfb370316636d074f2",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2015-03-31, 1:03 AM",
			"commitNameOld": "e377fc003d675a61a9643d149b0745314ad02d7d",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 3.6,
			"commitsBetweenForRepo": 24,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,257 +1,262 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (isAutoGrowNestedPaths()) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass<?> requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tint length = Array.getLength(propValue);\n \t\t\t\t\tif (arrayIndex >= length && arrayIndex < this.autoGrowCollectionLimit) {\n \t\t\t\t\t\tClass<?> componentType = propValue.getClass().getComponentType();\n \t\t\t\t\t\tObject newArray = Array.newInstance(componentType, arrayIndex + 1);\n \t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n \t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n \t\t\t\t\t\tpropValue = getPropertyValue(actualName);\n \t\t\t\t\t}\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass<?> requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList<Object> list = (List<Object>) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tint size = list.size();\n \t\t\t\tif (index >= size && index < this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i = size; i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass<?> mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass<?> mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap<Object, Object> map = (Map<Object, Object>) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(mapKeyType);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(\n \t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n+\t\t\t\t\tThrowable cause = ex.getTargetException();\n+\t\t\t\t\tif (cause instanceof UndeclaredThrowableException) {\n+\t\t\t\t\t\t// May happen e.g. with Groovy-generated methods\n+\t\t\t\t\t\tcause = cause.getCause();\n+\t\t\t\t\t}\n+\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, cause);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e377fc003d675a61a9643d149b0745314ad02d7d": {
			"type": "Ybodychange",
			"commitMessage": "BeanWrapperImpl.setPropertyValue throws InvalidPropertyException with correct property value for nested collection case\n\nIssue: SPR-12866\n",
			"commitDate": "2015-03-31, 1:03 AM",
			"commitName": "e377fc003d675a61a9643d149b0745314ad02d7d",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2015-02-11, 2:29 AM",
			"commitNameOld": "aa213396b4aa73501d44927d3fe016571bba7555",
			"commitAuthorOld": "Stephane Nicoll",
			"daysBetweenCommits": 47.9,
			"commitsBetweenForRepo": 238,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,257 +1,257 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (isAutoGrowNestedPaths()) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass<?> requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tint length = Array.getLength(propValue);\n \t\t\t\t\tif (arrayIndex >= length && arrayIndex < this.autoGrowCollectionLimit) {\n \t\t\t\t\t\tClass<?> componentType = propValue.getClass().getComponentType();\n \t\t\t\t\t\tObject newArray = Array.newInstance(componentType, arrayIndex + 1);\n \t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n \t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n \t\t\t\t\t\tpropValue = getPropertyValue(actualName);\n \t\t\t\t\t}\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass<?> requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList<Object> list = (List<Object>) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tint size = list.size();\n \t\t\t\tif (index >= size && index < this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i = size; i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass<?> mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass<?> mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap<Object, Object> map = (Map<Object, Object>) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(mapKeyType);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n-\t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n+\t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(\n \t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"aa213396b4aa73501d44927d3fe016571bba7555": {
			"type": "Ybodychange",
			"commitMessage": "BeanWrapper auto-grows arrays if necessary\n\nPreviously, only indexed access for collections were supported. When\nattempting to access the element of an array that had not the requested\nsize, the call would fail with an IndexOutOfBoundException\n\nThis commit harmonize the binding support so that the array is updated\naccording to the requested index if necessary.\n\nIssue: SPR-12706\n",
			"commitDate": "2015-02-11, 2:29 AM",
			"commitName": "aa213396b4aa73501d44927d3fe016571bba7555",
			"commitAuthor": "Stephane Nicoll",
			"commitDateOld": "2014-11-29, 11:49 AM",
			"commitNameOld": "bfbd25a0e94ab789171d331a121812468cbeb154",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 73.61,
			"commitsBetweenForRepo": 203,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,249 +1,257 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (isAutoGrowNestedPaths()) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass<?> requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\tint length = Array.getLength(propValue);\n+\t\t\t\t\tif (arrayIndex >= length && arrayIndex < this.autoGrowCollectionLimit) {\n+\t\t\t\t\t\tClass<?> componentType = propValue.getClass().getComponentType();\n+\t\t\t\t\t\tObject newArray = Array.newInstance(componentType, arrayIndex + 1);\n+\t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n+\t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n+\t\t\t\t\t\tpropValue = getPropertyValue(actualName);\n+\t\t\t\t\t}\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass<?> requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList<Object> list = (List<Object>) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tint size = list.size();\n \t\t\t\tif (index >= size && index < this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i = size; i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass<?> mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass<?> mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap<Object, Object> map = (Map<Object, Object>) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(mapKeyType);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(\n \t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1708a8a10d17b9c3dc203b90f181c1d55ad5facb": {
			"type": "Ybodychange",
			"commitMessage": "Remove unnecessary null check\n\nIssue: SPR-12378\n",
			"commitDate": "2014-10-27, 1:32 AM",
			"commitName": "1708a8a10d17b9c3dc203b90f181c1d55ad5facb",
			"commitAuthor": "Seo, Kyung-Seok",
			"commitDateOld": "2014-09-25, 8:00 AM",
			"commitNameOld": "cfc821d1799ca7c64b1bbc53811b712fdaa4776c",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 31.73,
			"commitsBetweenForRepo": 168,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,250 +1,249 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (isAutoGrowNestedPaths()) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass<?> requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass<?> requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList<Object> list = (List<Object>) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tint size = list.size();\n \t\t\t\tif (index >= size && index < this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i = size; i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass<?> mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass<?> mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap<Object, Object> map = (Map<Object, Object>) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n-\t\t\t\tTypeDescriptor typeDescriptor = (mapKeyType != null ?\n-\t\t\t\t\t\tTypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n+\t\t\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(mapKeyType);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(\n \t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8221c9abc5b5215bbf88e512f6f8060a9afd3ad3": {
			"type": "Ybodychange",
			"commitMessage": "Support for nested path using field access\n\nThis commit adds a nested path support for DirectFieldAccessor that is\nsimilar to what BeanWrapper provides. It is now possible to use\nexpressions such as \"person.address.city.name\" to access the name of\nthe city that a given person lives in using fields to traverse the\ngraph.\n\nDirectFieldAccessor also now supports an auto-grow option to create\na default instance for a \"null\" intermediate path. This option is\nfalse by default and leads to a NullValueInNestedPathException in such\na case.\n\nThis commit also harmonizes part of the tests suite so that core tests\nare shared between BeanWrapperImpl and DirectFieldAccessor.\n\nNote that map and list access is not implemented as part of this\ncommit.\n\nIssue: SPR-9705\n",
			"commitDate": "2014-06-26, 10:22 AM",
			"commitName": "8221c9abc5b5215bbf88e512f6f8060a9afd3ad3",
			"commitAuthor": "Stephane Nicoll",
			"commitDateOld": "2014-01-27, 4:25 PM",
			"commitNameOld": "fcbd3b121ba0d6fa8378fd0f0773ef2a652f1426",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 149.71,
			"commitsBetweenForRepo": 764,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,250 +1,250 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n-\t\t\t\tif (this.autoGrowNestedPaths) {\n+\t\t\t\tif (isAutoGrowNestedPaths()) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass<?> requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass<?> requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList<Object> list = (List<Object>) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tint size = list.size();\n \t\t\t\tif (index >= size && index < this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i = size; i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass<?> mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass<?> mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap<Object, Object> map = (Map<Object, Object>) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = (mapKeyType != null ?\n \t\t\t\t\t\tTypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(\n \t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d004b634a5215635d01234ca72ac1a60079f055d": {
			"type": "Ybodychange",
			"commitMessage": "Fixed type resolution in case of inconsistencies between read and write method\n\nIssue: SPR-11361\n",
			"commitDate": "2014-01-27, 3:46 PM",
			"commitName": "d004b634a5215635d01234ca72ac1a60079f055d",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2014-01-24, 7:22 AM",
			"commitNameOld": "8543b91c508d0eaf86212d148e63041eb38eeb3b",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 3.35,
			"commitsBetweenForRepo": 27,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,249 +1,250 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass<?> requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass<?> requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList<Object> list = (List<Object>) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tint size = list.size();\n \t\t\t\tif (index >= size && index < this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i = size; i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass<?> mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass<?> mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap<Object, Object> map = (Map<Object, Object>) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = (mapKeyType != null ?\n \t\t\t\t\t\tTypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd, new TypeDescriptor(property(pd)));\n+\t\t\t\t\t\tvalueToApply = convertForProperty(\n+\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c2b56c07e59aeb123fbe63b282c0ef98d7380f56": {
			"type": "Ybodychange",
			"commitMessage": "Cache property TypeDescriptors\n\nAttempt to improve performance by caching TypeDescriptors against bean\nPropertyDescriptors in CachedIntrospectionResults.\n\nThis change is an attempt to fix the failing performance test case\n`testPrototypeCreationWithOverriddenResourcePropertiesIsFastEnough` in\n`AnnotationProcessorPerformanceTests`.\n",
			"commitDate": "2013-12-02, 9:55 PM",
			"commitName": "c2b56c07e59aeb123fbe63b282c0ef98d7380f56",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2013-11-25, 12:52 PM",
			"commitNameOld": "59002f245623d758765b72d598cd78c326c6f5fa",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 7.38,
			"commitsBetweenForRepo": 44,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,249 +1,249 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass<?> requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass<?> requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList<Object> list = (List<Object>) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tint size = list.size();\n \t\t\t\tif (index >= size && index < this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i = size; i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass<?> mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass<?> mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap<Object, Object> map = (Map<Object, Object>) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = (mapKeyType != null ?\n \t\t\t\t\t\tTypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n+\t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd, new TypeDescriptor(property(pd)));\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"59002f245623d758765b72d598cd78c326c6f5fa": {
			"type": "Ybodychange",
			"commitMessage": "Fix remaining compiler warnings\n\nFix remaining Java compiler warnings, mainly around missing\ngenerics or deprecated code.\n\nAlso add the `-Werror` compiler option to ensure that any future\nwarnings will fail the build.\n\nIssue: SPR-11064\n",
			"commitDate": "2013-11-25, 12:52 PM",
			"commitName": "59002f245623d758765b72d598cd78c326c6f5fa",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2013-05-13, 3:04 PM",
			"commitNameOld": "94685481162a93666fc2f39b66223833a6bcb418",
			"commitAuthorOld": "Rob Winch",
			"daysBetweenCommits": 195.95,
			"commitsBetweenForRepo": 742,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,249 +1,249 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n+\t\t\t\tClass<?> requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n+\t\t\t\tClass<?> requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n-\t\t\t\tList list = (List) propValue;\n+\t\t\t\tList<Object> list = (List<Object>) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tint size = list.size();\n \t\t\t\tif (index >= size && index < this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i = size; i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n+\t\t\t\tClass<?> mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n-\t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n+\t\t\t\tClass<?> mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n-\t\t\t\tMap map = (Map) propValue;\n+\t\t\t\tMap<Object, Object> map = (Map<Object, Object>) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = (mapKeyType != null ?\n \t\t\t\t\t\tTypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"94685481162a93666fc2f39b66223833a6bcb418": {
			"type": "Ybodychange",
			"commitMessage": "Add @Override to remaining source files\n\nIssue: SPR-10130\n",
			"commitDate": "2013-05-13, 3:04 PM",
			"commitName": "94685481162a93666fc2f39b66223833a6bcb418",
			"commitAuthor": "Rob Winch",
			"commitDateOld": "2013-02-04, 10:35 AM",
			"commitNameOld": "f464a45ba481ff3e960ad3dd8b5edd4464a46289",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 98.15,
			"commitsBetweenForRepo": 366,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,245 +1,249 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tint size = list.size();\n \t\t\t\tif (index >= size && index < this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i = size; i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = (mapKeyType != null ?\n \t\t\t\t\t\tTypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n+\t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n+\t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n+\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n+\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"02a4473c62d8240837bec297f0a1f3cb67ef8a7b": {
			"type": "Yfilerename",
			"commitMessage": "Rename modules {org.springframework.*=>spring-*}\n\nThis renaming more intuitively expresses the relationship between\nsubprojects and the JAR artifacts they produce.\n\nTracking history across these renames is possible, but it requires\nuse of the --follow flag to `git log`, for example\n\n    $ git log spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history up until the renaming event, where\n\n    $ git log --follow spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history for all changes to the file, before and after the\nrenaming.\n\nSee http://chrisbeams.com/git-diff-across-renamed-directories\n",
			"commitDate": "2012-01-31, 5:37 AM",
			"commitName": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2012-01-31, 5:37 AM",
			"commitNameOld": "b6cb514d383dcef52ba6c609a863f19e1a4c1faf",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
				"newPath": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java"
			}
		},
		"569426dfdfec186e98a6ae4bd8ebf946720206b1": {
			"type": "Ybodychange",
			"commitMessage": "restored DataBinder's ability to bind to an auto-growing List with unknown element type (SPR-8828)\n",
			"commitDate": "2011-12-07, 1:27 PM",
			"commitName": "569426dfdfec186e98a6ae4bd8ebf946720206b1",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2011-07-03, 1:24 PM",
			"commitNameOld": "22939b6d05bc226f47e4714f9ebcdc709de3ab16",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 157.04,
			"commitsBetweenForRepo": 543,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,242 +1,245 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n-\t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n+\t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n-\t\t\t\tint size = list.size();\n \t\t\t\tObject oldValue = null;\n-\t\t\t\tif (isExtractOldValueForEditor() && index < size) {\n+\t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n-\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n+\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\tint size = list.size();\n \t\t\t\tif (index >= size && index < this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i = size; i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n-\t\t\t\tTypeDescriptor typeDescriptor = mapKeyType != null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n+\t\t\t\tTypeDescriptor typeDescriptor = (mapKeyType != null ?\n+\t\t\t\t\t\tTypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n-\t\t\t\tObject convertedMapValue = convertIfNecessary(\n-\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\tObject convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),\n+\t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"22939b6d05bc226f47e4714f9ebcdc709de3ab16": {
			"type": "Ybodychange",
			"commitMessage": "properly wrap IndexOutOfBoundsException even for List\n",
			"commitDate": "2011-07-03, 1:24 PM",
			"commitName": "22939b6d05bc226f47e4714f9ebcdc709de3ab16",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2011-07-03, 1:12 PM",
			"commitNameOld": "b8f7d324afe9891f7ba812eae431a7e38b254944",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,236 +1,242 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tint size = list.size();\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < size) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tif (index >= size && index < this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i = size; i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tlist.set(index, convertedValue);\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tlist.set(index, convertedValue);\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n+\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n+\t\t\t\t\t\t\t\t\"Invalid list index in property path '\" + propertyName + \"'\", ex);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = mapKeyType != null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue = convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b8f7d324afe9891f7ba812eae431a7e38b254944": {
			"type": "Ybodychange",
			"commitMessage": "regular IndexOutOfBoundsException if index beyond auto-grow limit\n",
			"commitDate": "2011-07-03, 1:12 PM",
			"commitName": "b8f7d324afe9891f7ba812eae431a7e38b254944",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2011-07-03, 1:05 PM",
			"commitNameOld": "b9fe1b325081f4ec7a5c1e905da00d3ed5223091",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,236 +1,236 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tint size = list.size();\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < size) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n-\t\t\t\tif (index < size) {\n-\t\t\t\t\tlist.set(index, convertedValue);\n-\t\t\t\t}\n-\t\t\t\telse if (index >= size && index < this.autoGrowCollectionLimit) {\n+\t\t\t\tif (index >= size && index < this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i = size; i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tlist.set(index, convertedValue);\n+\t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = mapKeyType != null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue = convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b9fe1b325081f4ec7a5c1e905da00d3ed5223091": {
			"type": "Ybodychange",
			"commitMessage": "restored original array behavior (no default growth of arrays)\n",
			"commitDate": "2011-07-03, 1:05 PM",
			"commitName": "b9fe1b325081f4ec7a5c1e905da00d3ed5223091",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2011-07-03, 12:26 PM",
			"commitNameOld": "4c75054f9041279423f31754aa23f9ca781e9d43",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,237 +1,236 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n-\t\t\t\t\t// TODO review this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n-\t\t\t\t\tpropValue = growArrayIfNecessary(propValue, arrayIndex, actualName);\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n+\t\t\t\tint size = list.size();\n \t\t\t\tObject oldValue = null;\n-\t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n+\t\t\t\tif (isExtractOldValueForEditor() && index < size) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n-\t\t\t\tif (index < list.size()) {\n+\t\t\t\tif (index < size) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n-\t\t\t\telse if (index >= list.size()) {\n-\t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n+\t\t\t\telse if (index >= size && index < this.autoGrowCollectionLimit) {\n+\t\t\t\t\tfor (int i = size; i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n-\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n+\t\t\t\t\t\t\t\t\tsize + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = mapKeyType != null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue = convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c09227a71265578a15bbf516abc523716490d1ac": {
			"type": "Ybodychange",
			"commitMessage": "removed dependency on java.beans\n",
			"commitDate": "2011-06-05, 1:29 AM",
			"commitName": "c09227a71265578a15bbf516abc523716490d1ac",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2011-06-02, 4:37 PM",
			"commitNameOld": "6f146737f475828b6d765784017773378c2c4922",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 2.37,
			"commitsBetweenForRepo": 31,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,237 +1,237 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n-\t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n+\t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\t// TODO review this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n \t\t\t\t\tpropValue = growArrayIfNecessary(propValue, arrayIndex, actualName);\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n-\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n+\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tif (index < list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = mapKeyType != null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue = convertIfNecessary(\n-\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n+\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6f146737f475828b6d765784017773378c2c4922": {
			"type": "Ybodychange",
			"commitMessage": "simplified TypeDescriptor usage and updated use of the API across BeanWrapper and SpEL; collapsed PropertyTypeDescriptor into TypeDescriptor for simplicity and ease of use; improved docs\n",
			"commitDate": "2011-06-02, 4:37 PM",
			"commitName": "6f146737f475828b6d765784017773378c2c4922",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2011-01-07, 1:25 PM",
			"commitNameOld": "2fcab44de08bd09159fb7adea2531b16dea3e69b",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 146.09,
			"commitsBetweenForRepo": 388,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,240 +1,237 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n-\t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n-\t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n+\t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n \t\t\t\t\t// TODO review this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n \t\t\t\t\tpropValue = growArrayIfNecessary(propValue, arrayIndex, actualName);\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n-\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n-\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n+\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n \t\t\t\tif (index < list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = mapKeyType != null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue = convertIfNecessary(\n-\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n-\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n+\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2fcab44de08bd09159fb7adea2531b16dea3e69b": {
			"type": "Ybodychange",
			"commitMessage": "remove addressed TODO\n",
			"commitDate": "2011-01-07, 1:25 PM",
			"commitName": "2fcab44de08bd09159fb7adea2531b16dea3e69b",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2011-01-07, 1:13 PM",
			"commitNameOld": "34fbd5affa10eb73cd82f32f1d6d1718950fc35e",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,241 +1,240 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\t\t// TODO review this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n \t\t\t\t\tpropValue = growArrayIfNecessary(propValue, arrayIndex, actualName);\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tif (index < list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = mapKeyType != null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n-\t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedMapValue = convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"34fbd5affa10eb73cd82f32f1d6d1718950fc35e": {
			"type": "Ybodychange",
			"commitMessage": "typo\n",
			"commitDate": "2011-01-07, 1:13 PM",
			"commitName": "34fbd5affa10eb73cd82f32f1d6d1718950fc35e",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2011-01-07, 11:22 AM",
			"commitNameOld": "414fcab899b4fdf0b0190227ac1699ef3f3b3f3f",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 0.08,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,241 +1,241 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n \t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n-\t\t\t\t\t// TODO reduce this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n+\t\t\t\t\t// TODO review this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n \t\t\t\t\tpropValue = growArrayIfNecessary(propValue, arrayIndex, actualName);\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tif (index < list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = mapKeyType != null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedMapValue = convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"414fcab899b4fdf0b0190227ac1699ef3f3b3f3f": {
			"type": "Ybodychange",
			"commitMessage": "sp7839 - map autogrow, including auto-grow support for map values\n",
			"commitDate": "2011-01-07, 11:22 AM",
			"commitName": "414fcab899b4fdf0b0190227ac1699ef3f3b3f3f",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2011-01-07, 9:54 AM",
			"commitNameOld": "90d8dade254b4f34fd28d498ce529efd2177c606",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 0.06,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,232 +1,241 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n-\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n+\t\t\t\t// null map value case\n+\t\t\t\tif (this.autoGrowNestedPaths) {\n+\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n+\t\t\t\t\tint lastKeyIndex = tokens.canonicalName.lastIndexOf('[');\n+\t\t\t\t\tgetterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);\n+\t\t\t\t\tpropValue = setDefaultValue(getterTokens);\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n+\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n+\t\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n+\t\t\t\t}\n \t\t\t}\n-\t\t\telse if (propValue.getClass().isArray()) {\n+\t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\t\t// TODO reduce this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n \t\t\t\t\tpropValue = growArrayIfNecessary(propValue, arrayIndex, actualName);\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tif (index < list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = mapKeyType != null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedMapValue = convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"90d8dade254b4f34fd28d498ce529efd2177c606": {
			"type": "Ybodychange",
			"commitMessage": "fixed bug related to array autogrow\n",
			"commitDate": "2011-01-07, 9:54 AM",
			"commitName": "90d8dade254b4f34fd28d498ce529efd2177c606",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2011-01-07, 9:28 AM",
			"commitNameOld": "5d6840e8770b441ae0676b309ba2021704e55a77",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,236 +1,232 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\t\t// TODO reduce this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n \t\t\t\t\tpropValue = growArrayIfNecessary(propValue, arrayIndex, actualName);\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n-\t\t\t\t\tPropertyValue newValue = new PropertyValue(actualName, propValue);\n-\t\t\t\t\tnewValue.resolvedDescriptor = pd;\n-\t\t\t\t\tnewValue.conversionNecessary = false;\n-\t\t\t\t\tsetPropertyValue(newValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tif (index < list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = mapKeyType != null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedMapValue = convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5d6840e8770b441ae0676b309ba2021704e55a77": {
			"type": "Ybodychange",
			"commitMessage": "array autogrow on set e.g. array[0]=foo\n",
			"commitDate": "2011-01-07, 9:28 AM",
			"commitName": "5d6840e8770b441ae0676b309ba2021704e55a77",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2011-01-07, 8:18 AM",
			"commitNameOld": "2ef629d5a8f5f933a614ba89e1b1e0d58ae04044",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 0.05,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,230 +1,236 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n-\t\t\t\t\tif (isExtractOldValueForEditor()) {\n+\t\t\t\t\tif (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n+\t\t\t\t\t// TODO reduce this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n+\t\t\t\t\tpropValue = growArrayIfNecessary(propValue, arrayIndex, actualName);\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n+\t\t\t\t\tPropertyValue newValue = new PropertyValue(actualName, propValue);\n+\t\t\t\t\tnewValue.resolvedDescriptor = pd;\n+\t\t\t\t\tnewValue.conversionNecessary = false;\n+\t\t\t\t\tsetPropertyValue(newValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tif (index < list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = mapKeyType != null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedMapValue = convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2ef629d5a8f5f933a614ba89e1b1e0d58ae04044": {
			"type": "Ybodychange",
			"commitMessage": "removed accidental system.out commit\n",
			"commitDate": "2011-01-07, 8:18 AM",
			"commitName": "2ef629d5a8f5f933a614ba89e1b1e0d58ae04044",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2011-01-07, 8:16 AM",
			"commitNameOld": "1ed03fc6caec159db6fe4a27f085f4effa130a1a",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,231 +1,230 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tif (index < list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n-\t\t\t\t\tSystem.out.println(list);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = mapKeyType != null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedMapValue = convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1ed03fc6caec159db6fe4a27f085f4effa130a1a": {
			"type": "Ybodychange",
			"commitMessage": "fetch property value again after setting default value to protect against object copy\n",
			"commitDate": "2011-01-07, 8:16 AM",
			"commitName": "1ed03fc6caec159db6fe4a27f085f4effa130a1a",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2011-01-06, 6:51 PM",
			"commitNameOld": "42403a37c3fcf159bdc574a7200396825d55fecf",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 0.56,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,230 +1,231 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tif (index < list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n+\t\t\t\t\tSystem.out.println(list);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = mapKeyType != null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedMapValue = convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c6c782df59c09a6a36c8283cbd725e9aef20e0e8": {
			"type": "Ybodychange",
			"commitMessage": "forNestedType usage clarification\n",
			"commitDate": "2011-01-06, 10:33 AM",
			"commitName": "c6c782df59c09a6a36c8283cbd725e9aef20e0e8",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2011-01-06, 4:00 AM",
			"commitNameOld": "7ec5f1694b2916eda9c4d873e22091a0c1f5d4f8",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 0.27,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,231 +1,230 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n-\t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n+\t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n-\t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n-\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n+\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tif (index < list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = mapKeyType != null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedMapValue = convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n-\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1), pd));\n+\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7ec5f1694b2916eda9c4d873e22091a0c1f5d4f8": {
			"type": "Ybodychange",
			"commitMessage": "temp added ignore on 2 new failing tests until time to investigate\n",
			"commitDate": "2011-01-06, 4:00 AM",
			"commitName": "7ec5f1694b2916eda9c4d873e22091a0c1f5d4f8",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2011-01-05, 9:14 PM",
			"commitNameOld": "01c98c3bfb6fc3f970dc66055b8435a47a876e31",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 0.28,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,229 +1,231 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n+\t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n \t\t\t\tif (index < list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = mapKeyType != null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n+\t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedMapValue = convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1), pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"01c98c3bfb6fc3f970dc66055b8435a47a876e31": {
			"type": "Ybodychange",
			"commitMessage": "added initial support for handling unknown nested type values when converting collections; now favor factory method for constructing nested type descriptors for clarity (made constructor private); improved javadoc\n",
			"commitDate": "2011-01-05, 9:14 PM",
			"commitName": "01c98c3bfb6fc3f970dc66055b8435a47a876e31",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2011-01-05, 11:18 AM",
			"commitNameOld": "cc91efecaee777604828669b1b14ff9ee6468dfe",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 0.41,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,235 +1,229 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n-\t\t\t\t\tMethodParameter methodParameter = new MethodParameter(pd.getReadMethod(), -1);\n-\t\t\t\t\tmethodParameter.increaseNestingLevel();\t\t\t\t\t\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n-\t\t\t\t\t\t\tnew PropertyTypeDescriptor(requiredType, methodParameter, pd));\n+\t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n-\t\t\t\tMethodParameter methodParameter = new MethodParameter(pd.getReadMethod(), -1);\n-\t\t\t\tmethodParameter.increaseNestingLevel();\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n-\t\t\t\t\t\tnew PropertyTypeDescriptor(requiredType, methodParameter, pd));\n+\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n \t\t\t\tif (index < list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor = mapKeyType != null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n-\t\t\t\tMethodParameter methodParameter = new MethodParameter(pd.getReadMethod(), -1);\n-\t\t\t\tmethodParameter.increaseNestingLevel();\n \t\t\t\tObject convertedMapValue = convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n-\t\t\t\t\t\tnew PropertyTypeDescriptor(mapValueType, methodParameter, pd));\n+\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1), pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cc91efecaee777604828669b1b14ff9ee6468dfe": {
			"type": "Ybodychange",
			"commitMessage": "Fixed bugs in bean wrapper related to nesting levels on method parameters\n",
			"commitDate": "2011-01-05, 11:18 AM",
			"commitName": "cc91efecaee777604828669b1b14ff9ee6468dfe",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2011-01-04, 9:49 PM",
			"commitNameOld": "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 0.56,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,229 +1,235 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n+\t\t\t\t\tMethodParameter methodParameter = new MethodParameter(pd.getReadMethod(), -1);\n+\t\t\t\t\tmethodParameter.increaseNestingLevel();\t\t\t\t\t\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n-\t\t\t\t\t\t\tnew PropertyTypeDescriptor(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n+\t\t\t\t\t\t\tnew PropertyTypeDescriptor(requiredType, methodParameter, pd));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n+\t\t\t\tMethodParameter methodParameter = new MethodParameter(pd.getReadMethod(), -1);\n+\t\t\t\tmethodParameter.increaseNestingLevel();\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n-\t\t\t\t\t\tnew PropertyTypeDescriptor(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n+\t\t\t\t\t\tnew PropertyTypeDescriptor(requiredType, methodParameter, pd));\n \t\t\t\tif (index < list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n-\t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType,\n-\t\t\t\t\t\tnew PropertyTypeDescriptor(mapKeyType, new MethodParameter(pd.getReadMethod(), -1), pd));\n+\t\t\t\tTypeDescriptor typeDescriptor = mapKeyType != null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n+\t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n+\t\t\t\tMethodParameter methodParameter = new MethodParameter(pd.getReadMethod(), -1);\n+\t\t\t\tmethodParameter.increaseNestingLevel();\n \t\t\t\tObject convertedMapValue = convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n-\t\t\t\t\t\tnew TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1)));\n+\t\t\t\t\t\tnew PropertyTypeDescriptor(mapValueType, methodParameter, pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6": {
			"type": "Ybodychange",
			"commitMessage": "TypeDescriptor cleanup and general polishing; fixed a number of bugs related to TypeDescriptor usage in client code across beans and spel packages\n",
			"commitDate": "2011-01-04, 9:49 PM",
			"commitName": "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2010-10-13, 5:14 PM",
			"commitNameOld": "0195b0da3c28b3a48b8f1fc8b0b5a354f1a56265",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 83.23,
			"commitsBetweenForRepo": 88,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,229 +1,229 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n-\t\t\t\t\t\t\tnew PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType));\n+\t\t\t\t\t\t\tnew PropertyTypeDescriptor(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n-\t\t\t\t\t\tnew PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType));\n+\t\t\t\t\t\tnew PropertyTypeDescriptor(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n \t\t\t\tif (index < list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType,\n-\t\t\t\t\t\tnew PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), mapKeyType));\n+\t\t\t\t\t\tnew PropertyTypeDescriptor(mapKeyType, new MethodParameter(pd.getReadMethod(), -1), pd));\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue = convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\tnew TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1)));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"66abad25400aab7e6211f75449ec6bde08cae659": {
			"type": "Ybodychange",
			"commitMessage": "BeanWrapper preserves annotation information for individual array/list/map elements (SPR-7348)\n",
			"commitDate": "2010-07-12, 1:56 PM",
			"commitName": "66abad25400aab7e6211f75449ec6bde08cae659",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2010-06-23, 10:27 AM",
			"commitNameOld": "7f91153bba5a76099889f83d411adc6a40e8276e",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 19.14,
			"commitsBetweenForRepo": 36,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,225 +1,229 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n+\t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n-\t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n+\t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n+\t\t\t\t\t\t\tnew PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n-\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n+\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n+\t\t\t\t\t\tnew PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType));\n \t\t\t\tif (index < list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n-\t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType);\n+\t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType,\n+\t\t\t\t\t\tnew PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), mapKeyType));\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue = convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\tnew TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1)));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2ad2022058d4a2e3d29ea793ede2cb8c09f9102e": {
			"type": "Ybodychange",
			"commitMessage": "revised BeanWrapper's exception wrapping to consistently handle ConversionExceptions (SPR-7177)\n",
			"commitDate": "2010-05-17, 2:59 PM",
			"commitName": "2ad2022058d4a2e3d29ea793ede2cb8c09f9102e",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2010-03-24, 10:40 AM",
			"commitNameOld": "53b6e1c1b0a9dc60dae2f495751e71cfff401b7e",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 54.18,
			"commitsBetweenForRepo": 173,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,282 +1,225 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n-\t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n-\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n-\t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n-\t\t\t\t}\n-\t\t\t\tcatch (IllegalArgumentException ex) {\n-\t\t\t\t\tPropertyChangeEvent pce =\n-\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n-\t\t\t\t}\n-\t\t\t\tcatch (IllegalStateException ex) {\n-\t\t\t\t\tPropertyChangeEvent pce =\n-\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n+\t\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n+\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n-\t\t\t\ttry {\n-\t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n-\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n-\t\t\t\t\tif (index < list.size()) {\n-\t\t\t\t\t\tlist.set(index, convertedValue);\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (index >= list.size()) {\n-\t\t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\tlist.add(null);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tcatch (NullPointerException ex) {\n-\t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n-\t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n-\t\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tlist.add(convertedValue);\n-\t\t\t\t\t}\n+\t\t\t\tObject convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n+\t\t\t\tif (index < list.size()) {\n+\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n-\t\t\t\tcatch (IllegalArgumentException ex) {\n-\t\t\t\t\tPropertyChangeEvent pce =\n-\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n+\t\t\t\telse if (index >= list.size()) {\n+\t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tlist.add(null);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tcatch (NullPointerException ex) {\n+\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n+\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n+\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n+\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n-\t\t\t\tObject convertedMapKey;\n-\t\t\t\tObject convertedMapValue;\n-\t\t\t\ttry {\n-\t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n-\t\t\t\t\t// must not kick in for map keys but rather only for map values.\n-\t\t\t\t\tconvertedMapKey = this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n-\t\t\t\t}\n-\t\t\t\tcatch (IllegalArgumentException ex) {\n-\t\t\t\t\tPropertyChangeEvent pce =\n-\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n-\t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n-\t\t\t\t}\n+\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n+\t\t\t\t// must not kick in for map keys but rather only for map values.\n+\t\t\t\tObject convertedMapKey = convertIfNecessary(null, null, key, mapKeyType);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n-\t\t\t\ttry {\n-\t\t\t\t\t// Pass full property name and old value in here, since we want full\n-\t\t\t\t\t// conversion ability for map values.\n-\t\t\t\t\tconvertedMapValue = this.typeConverterDelegate.convertIfNecessary(\n-\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n-\t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n-\t\t\t\t}\n-\t\t\t\tcatch (IllegalArgumentException ex) {\n-\t\t\t\t\tPropertyChangeEvent pce =\n-\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n-\t\t\t\t}\n+\t\t\t\t// Pass full property name and old value in here, since we want full\n+\t\t\t\t// conversion ability for map values.\n+\t\t\t\tObject convertedMapValue = convertIfNecessary(\n+\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n+\t\t\t\t\t\tnew TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1)));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n-\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) && !readMethod.isAccessible()) {\n+\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &&\n+\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t},acc);\n+\t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tvalueToApply = this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n+\t\t\t\t\t\tvalueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n-\t\t\t\t\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n-\t\t\t\t\t} catch (PrivilegedActionException ex) {\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\twriteMethod.invoke(object, value);\n+\t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n-\t\t\t\t\t\n+\t\t\t}\n+\t\t\tcatch (TypeMismatchException ex) {\n+\t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n-\t\t\tcatch (ConverterNotFoundException ex) {\n-\t\t\t\tPropertyChangeEvent pce =\n-\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n-\t\t\t}\n-\t\t\tcatch (ConversionException ex) {\n-\t\t\t\tPropertyChangeEvent pce =\n-\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n-\t\t\t}\n-\t\t\tcatch (IllegalStateException ex) {\n-\t\t\t\tPropertyChangeEvent pce =\n-\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n-\t\t\t}\n-\t\t\tcatch (IllegalArgumentException ex) {\n-\t\t\t\tPropertyChangeEvent pce =\n-\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n-\t\t\t}\n-\t\t\tcatch (IllegalAccessException ex) {\n-\t\t\t\tPropertyChangeEvent pce =\n-\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\tthrow new MethodInvocationException(pce, ex);\n-\t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n-\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1c33206042c09a4344e5e4a1c6b759eb6180274c": {
			"type": "Ybodychange",
			"commitMessage": "catch ConversionException and ConvertedNotFoundException in BeanWrapper's convertIfNecessary as well, in order to support constructor resolution (SPR-6563)\n",
			"commitDate": "2009-12-15, 4:53 AM",
			"commitName": "1c33206042c09a4344e5e4a1c6b759eb6180274c",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-12-07, 10:57 AM",
			"commitNameOld": "61f23710ebed6d7feb1e7b477d301d952d3cde5f",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 7.75,
			"commitsBetweenForRepo": 77,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,277 +1,282 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalStateException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index < list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\tObject convertedMapKey;\n \t\t\t\tObject convertedMapValue;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey = this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) && !readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t},acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\t\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t} catch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t}\n \t\t\t\t\t\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n-\t\t\tcatch (ConversionException ex) {\n+\t\t\tcatch (ConverterNotFoundException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n+\t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n-\t\t\tcatch (IllegalArgumentException ex) {\n+\t\t\tcatch (ConversionException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalStateException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n+\t\t\tcatch (IllegalArgumentException ex) {\n+\t\t\t\tPropertyChangeEvent pce =\n+\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n+\t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"61f23710ebed6d7feb1e7b477d301d952d3cde5f": {
			"type": "Ybodychange",
			"commitMessage": "relaxed warning about ambiguous setters to only be logged in case of actual write access (SPR-6399)\n",
			"commitDate": "2009-12-07, 10:57 AM",
			"commitName": "61f23710ebed6d7feb1e7b477d301d952d3cde5f",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-12-03, 4:34 PM",
			"commitNameOld": "e161c93f8dd9fdf7d7685e3ae7a31de03331ae86",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 3.77,
			"commitsBetweenForRepo": 26,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,275 +1,277 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalStateException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index < list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\tObject convertedMapKey;\n \t\t\t\tObject convertedMapValue;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey = this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) && !readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t},acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n-\t\t\t\tfinal Method writeMethod = pd.getWriteMethod();\n+\t\t\t\tfinal Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?\n+\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n+\t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\t\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t} catch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t}\n \t\t\t\t\t\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (ConversionException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalStateException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ac490114aee005a66eeb0fba6c3c853552fc6a94": {
			"type": "Ybodychange",
			"commitMessage": "propagate full TypeDescriptor for field-level conversion as well\n",
			"commitDate": "2009-11-26, 5:43 PM",
			"commitName": "ac490114aee005a66eeb0fba6c3c853552fc6a94",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-10-18, 6:06 PM",
			"commitNameOld": "e4f50f5b7396a88471869c387f2a7fbf2c424a65",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 39.03,
			"commitsBetweenForRepo": 368,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,275 +1,275 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalStateException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index < list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\tObject convertedMapKey;\n \t\t\t\tObject convertedMapValue;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey = this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue = this.typeConverterDelegate.convertIfNecessary(\n-\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n+\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n \t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) && !readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t},acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = pd.getWriteMethod();\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\t\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t} catch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t}\n \t\t\t\t\t\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (ConversionException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalStateException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ad492e906e4c9c994cad733d366ec9c30950ed92": {
			"type": "Ybodychange",
			"commitMessage": "PropertyOverrideConfigurer's \"ignoreInvalidKeys\" ignores invalid property names as well (SPR-5792)\n",
			"commitDate": "2009-09-24, 7:40 AM",
			"commitName": "ad492e906e4c9c994cad733d366ec9c30950ed92",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-09-18, 7:07 AM",
			"commitNameOld": "99753f0d1c40c6de81bd4bdcf446c2b6ebed4788",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 6.02,
			"commitsBetweenForRepo": 59,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,268 +1,275 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalStateException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index < list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\tObject convertedMapKey;\n \t\t\t\tObject convertedMapValue;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey = this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n-\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n-\t\t\t\t\tthrow new NotWritablePropertyException(\n-\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n+\t\t\t\t\tif (pv.isOptional()) {\n+\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property '\" + actualName +\n+\t\t\t\t\t\t\t\t\"' - property not found on bean class [\" + getRootClass().getName() + \"]\");\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n+\t\t\t\t\t\tthrow new NotWritablePropertyException(\n+\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n+\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) && !readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t},acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = pd.getWriteMethod();\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\t\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t} catch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t}\n \t\t\t\t\t\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (ConversionException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalStateException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"45a0cadf8e7fc5cc082c11ef03f77dc017af64c4": {
			"type": "Ybodychange",
			"commitMessage": "revised core conversion package for BeanWrapper/BeanFactory integration\n",
			"commitDate": "2009-08-08, 5:46 PM",
			"commitName": "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-08-06, 3:31 PM",
			"commitNameOld": "af8af8c633ba016eca671bc9468eba006e8834b1",
			"commitAuthorOld": "Costin Leau",
			"daysBetweenCommits": 2.09,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,263 +1,268 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalStateException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index < list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\tObject convertedMapKey;\n \t\t\t\tObject convertedMapValue;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey = this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) && !readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t},acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = pd.getWriteMethod();\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!= null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\t\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t},acc);\n \t\t\t\t\t} catch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t}\n \t\t\t\t\t\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n+\t\t\tcatch (ConversionException ex) {\n+\t\t\t\tPropertyChangeEvent pce =\n+\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n+\t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalStateException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"af8af8c633ba016eca671bc9468eba006e8834b1": {
			"type": "Ybodychange",
			"commitMessage": "+ added fine grained privileged blocks to preserve the caller security stack when invoking the callee\n",
			"commitDate": "2009-08-06, 3:31 PM",
			"commitName": "af8af8c633ba016eca671bc9468eba006e8834b1",
			"commitAuthor": "Costin Leau",
			"commitDateOld": "2009-08-06, 9:34 AM",
			"commitNameOld": "d5d3104b7b13ce249bf9c877f7160cd2137ec209",
			"commitAuthorOld": "Costin Leau",
			"daysBetweenCommits": 0.25,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,243 +1,263 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalStateException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index < list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\tObject convertedMapKey;\n \t\t\t\tObject convertedMapValue;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey = this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n-\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n-\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n+\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) && !readMethod.isAccessible()) {\n+\t\t\t\t\t\t\t\tif (System.getSecurityManager()!= null) {\n+\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n+\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n+\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n+\t\t\t\t\t\t\t\t\t\t\treturn null;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t});\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n+\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t},acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod = pd.getWriteMethod();\n-\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n-\t\t\t\t\twriteMethod.setAccessible(true);\n+\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n+\t\t\t\t\tif (System.getSecurityManager()!= null) {\n+\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n+\t\t\t\t\t\t\tpublic Object run() {\n+\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n+\t\t\t\t\t\t\t\treturn null;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\twriteMethod.setAccessible(true);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value = valueToApply;\n \t\t\t\t\n \t\t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t},acc);\n \t\t\t\t\t} catch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t}\n \t\t\t\t\t\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalStateException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d5d3104b7b13ce249bf9c877f7160cd2137ec209": {
			"type": "Ybodychange",
			"commitMessage": "+ interaction with user code uses now dedicated privileged when running under a security manager\n",
			"commitDate": "2009-08-06, 9:34 AM",
			"commitName": "d5d3104b7b13ce249bf9c877f7160cd2137ec209",
			"commitAuthor": "Costin Leau",
			"commitDateOld": "2009-05-12, 1:26 AM",
			"commitNameOld": "eca1cad7e1e78714d22681554474f887d9046632",
			"commitAuthorOld": "Arjen Poutsma",
			"daysBetweenCommits": 86.34,
			"commitsBetweenForRepo": 550,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,209 +1,243 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalStateException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index < list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\tObject convertedMapKey;\n \t\t\t\tObject convertedMapValue;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey = this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n-\t\t\t\t\t\t\tMethod readMethod = pd.getReadMethod();\n+\t\t\t\t\t\t\tfinal Method readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\toldValue = readMethod.invoke(this.object);\n+\t\t\t\t\t\t\t\tif (System.getSecurityManager() != null) {\n+\t\t\t\t\t\t\t\t\toldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n+\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n+\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t},acc);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t\t\toldValue = readMethod.invoke(object);\n+\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n+\t\t\t\t\t\t\t\t\tex = ((PrivilegedActionException) ex).getException();\n+\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n-\t\t\t\tMethod writeMethod = pd.getWriteMethod();\n+\t\t\t\tfinal Method writeMethod = pd.getWriteMethod();\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t}\n-\t\t\t\twriteMethod.invoke(this.object, valueToApply);\n+\t\t\t\tfinal Object value = valueToApply;\n+\t\t\t\t\n+\t\t\t\tif (System.getSecurityManager() != null) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n+\t\t\t\t\t\t\tpublic Object run() throws Exception {\n+\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n+\t\t\t\t\t\t\t\treturn null;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t},acc);\n+\t\t\t\t\t} catch (PrivilegedActionException ex) {\n+\t\t\t\t\t\tthrow ex.getException();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\twriteMethod.invoke(object, value);\n+\t\t\t\t}\n+\t\t\t\t\t\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalStateException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n+\t\t\tcatch (Exception ex) {\n+\t\t\t\tPropertyChangeEvent pce =\n+\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\tthrow new MethodInvocationException(pce, ex);\n+\t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"eca1cad7e1e78714d22681554474f887d9046632": {
			"type": "Ybodychange",
			"commitMessage": "Fixing build.\n",
			"commitDate": "2009-05-12, 1:26 AM",
			"commitName": "eca1cad7e1e78714d22681554474f887d9046632",
			"commitAuthor": "Arjen Poutsma",
			"commitDateOld": "2009-05-11, 7:52 AM",
			"commitNameOld": "bf7a947559d8f9918cc738780bf04caf8ea46962",
			"commitAuthorOld": "Arjen Poutsma",
			"daysBetweenCommits": 0.73,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,204 +1,209 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n+\t\t\t\tcatch (IllegalStateException ex) {\n+\t\t\t\t\tPropertyChangeEvent pce =\n+\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n+\t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index < list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\tObject convertedMapKey;\n \t\t\t\tObject convertedMapValue;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey = this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tMethod readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\toldValue = readMethod.invoke(this.object);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tMethod writeMethod = pd.getWriteMethod();\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t}\n \t\t\t\twriteMethod.invoke(this.object, valueToApply);\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalStateException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"bf7a947559d8f9918cc738780bf04caf8ea46962": {
			"type": "Ybodychange",
			"commitMessage": "SPR-5732 - When no type conversion strategy is found on a @Controller handler method bind target, a 500 error code should be returned not a 400.\n\n",
			"commitDate": "2009-05-11, 7:52 AM",
			"commitName": "bf7a947559d8f9918cc738780bf04caf8ea46962",
			"commitAuthor": "Arjen Poutsma",
			"commitDateOld": "2009-03-31, 1:34 PM",
			"commitNameOld": "9dd70ca9fe3775f7459e66695d6e21e112ff9611",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 40.76,
			"commitsBetweenForRepo": 240,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,199 +1,204 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index < list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\tObject convertedMapKey;\n \t\t\t\tObject convertedMapValue;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey = this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tMethod readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\toldValue = readMethod.invoke(this.object);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tMethod writeMethod = pd.getWriteMethod();\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t}\n \t\t\t\twriteMethod.invoke(this.object, valueToApply);\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n+\t\t\tcatch (IllegalStateException ex) {\n+\t\t\t\tPropertyChangeEvent pce =\n+\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n+\t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9dd70ca9fe3775f7459e66695d6e21e112ff9611": {
			"type": "Ybodychange",
			"commitMessage": "polishing\n",
			"commitDate": "2009-03-31, 1:34 PM",
			"commitName": "9dd70ca9fe3775f7459e66695d6e21e112ff9611",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2008-11-27, 9:35 AM",
			"commitNameOld": "85661c688218e09dbce629ba7880ee6d9617aa90",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 124.12,
			"commitsBetweenForRepo": 557,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,199 +1,199 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n-\t\t\tObject propValue = null;\n+\t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index < list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n-\t\t\t\tObject convertedMapKey = null;\n-\t\t\t\tObject convertedMapValue = null;\n+\t\t\t\tObject convertedMapKey;\n+\t\t\t\tObject convertedMapValue;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey = this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tMethod readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\toldValue = readMethod.invoke(this.object);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tMethod writeMethod = pd.getWriteMethod();\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t}\n \t\t\t\twriteMethod.invoke(this.object, valueToApply);\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b0790bf5e7b6091552ccf17a2e707ab438d129d7": {
			"type": "Ybodychange",
			"commitMessage": "Java 5 code style\n",
			"commitDate": "2008-11-26, 4:27 PM",
			"commitName": "b0790bf5e7b6091552ccf17a2e707ab438d129d7",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2008-11-19, 6:10 PM",
			"commitNameOld": "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 6.93,
			"commitsBetweenForRepo": 36,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,199 +1,199 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue = null;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index < list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\tObject convertedMapKey = null;\n \t\t\t\tObject convertedMapValue = null;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey = this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tMethod readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\toldValue = readMethod.invoke(this.object, new Object[0]);\n+\t\t\t\t\t\t\t\toldValue = readMethod.invoke(this.object);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n-\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = Boolean.valueOf(valueToApply != originalValue);\n+\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tMethod writeMethod = pd.getWriteMethod();\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t}\n-\t\t\t\twriteMethod.invoke(this.object, new Object[] {valueToApply});\n+\t\t\t\twriteMethod.invoke(this.object, valueToApply);\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"347f34c68a7a5bab46cf869e762fb3cee9a1fedc": {
			"type": "Ybodychange",
			"commitMessage": "EL container integration; support for contextual objects; removal of deprecated Spring 2.0 functionality; Java 5 code style\n",
			"commitDate": "2008-11-19, 6:10 PM",
			"commitName": "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2008-10-27, 4:30 PM",
			"commitNameOld": "c8e5aa07a543d8213f96194fea59fb9a1cc7e0e3",
			"commitAuthorOld": "Arjen Poutsma",
			"daysBetweenCommits": 23.11,
			"commitsBetweenForRepo": 156,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,206 +1,199 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName = tokens.canonicalName;\n \t\tString actualName = tokens.actualName;\n \n \t\tif (tokens.keys != null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n \t\t\tgetterTokens.actualName = tokens.actualName;\n \t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue = null;\n \t\t\ttry {\n \t\t\t\tpropValue = getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key = tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue == null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass requiredType = null;\n-\t\t\t\tif (JdkVersion.isAtLeastJava15()) {\n-\t\t\t\t\trequiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n-\t\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n-\t\t\t\t}\n+\t\t\t\tClass requiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n+\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list = (List) propValue;\n \t\t\t\tint index = Integer.parseInt(key);\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n \t\t\t\t\toldValue = list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index < list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index >= list.size()) {\n \t\t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass mapKeyType = null;\n-\t\t\t\tClass mapValueType = null;\n-\t\t\t\tif (JdkVersion.isAtLeastJava15()) {\n-\t\t\t\t\tmapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n-\t\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n-\t\t\t\t\tmapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n-\t\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n-\t\t\t\t}\n+\t\t\t\tClass mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n+\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n+\t\t\t\tClass mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n+\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map = (Map) propValue;\n \t\t\t\tObject convertedMapKey = null;\n \t\t\t\tObject convertedMapValue = null;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey = this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue = null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue = map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue = this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n \t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n \t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n \t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n \t\t\t}\n \n \t\t\tObject oldValue = null;\n \t\t\ttry {\n \t\t\t\tObject originalValue = pv.getValue();\n \t\t\t\tObject valueToApply = originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n \t\t\t\t\t\t\tMethod readMethod = pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\toldValue = readMethod.invoke(this.object, new Object[0]);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply = this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = Boolean.valueOf(valueToApply != originalValue);\n \t\t\t\t}\n \t\t\t\tMethod writeMethod = pd.getWriteMethod();\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t}\n \t\t\t\twriteMethod.invoke(this.object, new Object[] {valueToApply});\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce =\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f11d3436ed21d3908b9e0b569f2d783df161c0a3": {
			"type": "Yintroduced",
			"commitMessage": "Moved over initial version of beans bundle\n",
			"commitDate": "2008-10-22, 9:13 AM",
			"commitName": "f11d3436ed21d3908b9e0b569f2d783df161c0a3",
			"commitAuthor": "Arjen Poutsma",
			"diff": "@@ -0,0 +1,206 @@\n+\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n+\t\tString propertyName = tokens.canonicalName;\n+\t\tString actualName = tokens.actualName;\n+\n+\t\tif (tokens.keys != null) {\n+\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n+\t\t\tPropertyTokenHolder getterTokens = new PropertyTokenHolder();\n+\t\t\tgetterTokens.canonicalName = tokens.canonicalName;\n+\t\t\tgetterTokens.actualName = tokens.actualName;\n+\t\t\tgetterTokens.keys = new String[tokens.keys.length - 1];\n+\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n+\t\t\tObject propValue = null;\n+\t\t\ttry {\n+\t\t\t\tpropValue = getPropertyValue(getterTokens);\n+\t\t\t}\n+\t\t\tcatch (NotReadablePropertyException ex) {\n+\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n+\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n+\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"'\", ex);\n+\t\t\t}\n+\t\t\t// Set value for last key.\n+\t\t\tString key = tokens.keys[tokens.keys.length - 1];\n+\t\t\tif (propValue == null) {\n+\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n+\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n+\t\t\t\t\t\t\"in indexed property path '\" + propertyName + \"': returned null\");\n+\t\t\t}\n+\t\t\telse if (propValue.getClass().isArray()) {\n+\t\t\t\tClass requiredType = propValue.getClass().getComponentType();\n+\t\t\t\tint arrayIndex = Integer.parseInt(key);\n+\t\t\t\tObject oldValue = null;\n+\t\t\t\ttry {\n+\t\t\t\t\tif (isExtractOldValueForEditor()) {\n+\t\t\t\t\t\toldValue = Array.get(propValue, arrayIndex);\n+\t\t\t\t\t}\n+\t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n+\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n+\t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n+\t\t\t\t}\n+\t\t\t\tcatch (IllegalArgumentException ex) {\n+\t\t\t\t\tPropertyChangeEvent pce =\n+\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n+\t\t\t\t}\n+\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n+\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n+\t\t\t\t\t\t\t\"Invalid array index in property path '\" + propertyName + \"'\", ex);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse if (propValue instanceof List) {\n+\t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n+\t\t\t\tClass requiredType = null;\n+\t\t\t\tif (JdkVersion.isAtLeastJava15()) {\n+\t\t\t\t\trequiredType = GenericCollectionTypeResolver.getCollectionReturnType(\n+\t\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n+\t\t\t\t}\n+\t\t\t\tList list = (List) propValue;\n+\t\t\t\tint index = Integer.parseInt(key);\n+\t\t\t\tObject oldValue = null;\n+\t\t\t\tif (isExtractOldValueForEditor() && index < list.size()) {\n+\t\t\t\t\toldValue = list.get(index);\n+\t\t\t\t}\n+\t\t\t\ttry {\n+\t\t\t\t\tObject convertedValue = this.typeConverterDelegate.convertIfNecessary(\n+\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n+\t\t\t\t\tif (index < list.size()) {\n+\t\t\t\t\t\tlist.set(index, convertedValue);\n+\t\t\t\t\t}\n+\t\t\t\t\telse if (index >= list.size()) {\n+\t\t\t\t\t\tfor (int i = list.size(); i < index; i++) {\n+\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\tlist.add(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcatch (NullPointerException ex) {\n+\t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n+\t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n+\t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path '\" + propertyName +\n+\t\t\t\t\t\t\t\t\t\t\"': List does not support filling up gaps with null elements\");\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tlist.add(convertedValue);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tcatch (IllegalArgumentException ex) {\n+\t\t\t\t\tPropertyChangeEvent pce =\n+\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse if (propValue instanceof Map) {\n+\t\t\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n+\t\t\t\tClass mapKeyType = null;\n+\t\t\t\tClass mapValueType = null;\n+\t\t\t\tif (JdkVersion.isAtLeastJava15()) {\n+\t\t\t\t\tmapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(\n+\t\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n+\t\t\t\t\tmapValueType = GenericCollectionTypeResolver.getMapValueReturnType(\n+\t\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n+\t\t\t\t}\n+\t\t\t\tMap map = (Map) propValue;\n+\t\t\t\tObject convertedMapKey = null;\n+\t\t\t\tObject convertedMapValue = null;\n+\t\t\t\ttry {\n+\t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n+\t\t\t\t\t// must not kick in for map keys but rather only for map values.\n+\t\t\t\t\tconvertedMapKey = this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n+\t\t\t\t}\n+\t\t\t\tcatch (IllegalArgumentException ex) {\n+\t\t\t\t\tPropertyChangeEvent pce =\n+\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n+\t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n+\t\t\t\t}\n+\t\t\t\tObject oldValue = null;\n+\t\t\t\tif (isExtractOldValueForEditor()) {\n+\t\t\t\t\toldValue = map.get(convertedMapKey);\n+\t\t\t\t}\n+\t\t\t\ttry {\n+\t\t\t\t\t// Pass full property name and old value in here, since we want full\n+\t\t\t\t\t// conversion ability for map values.\n+\t\t\t\t\tconvertedMapValue = this.typeConverterDelegate.convertIfNecessary(\n+\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n+\t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n+\t\t\t\t}\n+\t\t\t\tcatch (IllegalArgumentException ex) {\n+\t\t\t\t\tPropertyChangeEvent pce =\n+\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n+\t\t\t\t}\n+\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n+\t\t\t\t\t\t\"Property referenced in indexed property path '\" + propertyName +\n+\t\t\t\t\t\t\"' is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n+\t\t\t}\n+\t\t}\n+\n+\t\telse {\n+\t\t\tPropertyDescriptor pd = pv.resolvedDescriptor;\n+\t\t\tif (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n+\t\t\t\tpd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n+\t\t\t\tif (pd == null || pd.getWriteMethod() == null) {\n+\t\t\t\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n+\t\t\t\t\tthrow new NotWritablePropertyException(\n+\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n+\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n+\t\t\t\t}\n+\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor = pd;\n+\t\t\t}\n+\n+\t\t\tObject oldValue = null;\n+\t\t\ttry {\n+\t\t\t\tObject originalValue = pv.getValue();\n+\t\t\t\tObject valueToApply = originalValue;\n+\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n+\t\t\t\t\tif (pv.isConverted()) {\n+\t\t\t\t\t\tvalueToApply = pv.getConvertedValue();\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tif (isExtractOldValueForEditor() && pd.getReadMethod() != null) {\n+\t\t\t\t\t\t\tMethod readMethod = pd.getReadMethod();\n+\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n+\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\toldValue = readMethod.invoke(this.object, new Object[0]);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property '\" +\n+\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"'\", ex);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tvalueToApply = this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n+\t\t\t\t\t}\n+\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary = Boolean.valueOf(valueToApply != originalValue);\n+\t\t\t\t}\n+\t\t\t\tMethod writeMethod = pd.getWriteMethod();\n+\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n+\t\t\t\t\twriteMethod.setAccessible(true);\n+\t\t\t\t}\n+\t\t\t\twriteMethod.invoke(this.object, new Object[] {valueToApply});\n+\t\t\t}\n+\t\t\tcatch (InvocationTargetException ex) {\n+\t\t\t\tPropertyChangeEvent propertyChangeEvent =\n+\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n+\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcatch (IllegalArgumentException ex) {\n+\t\t\t\tPropertyChangeEvent pce =\n+\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n+\t\t\t}\n+\t\t\tcatch (IllegalAccessException ex) {\n+\t\t\t\tPropertyChangeEvent pce =\n+\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\tthrow new MethodInvocationException(pce, ex);\n+\t\t\t}\n+\t\t}\n+\t}\n\\ No newline at end of file\n"
		}
	},
	"sha": "b325c74216fd9564a36602158fa1269e2e832874"
}