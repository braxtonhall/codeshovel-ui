{
	"repo": "https://github.com/apache/commons-io.git",
	"file": "src/main/java/org/apache/commons/io/input/Tailer.java",
	"method": {
		"longName": "public void run();",
		"startLine": 406,
		"methodName": "run",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"467386105ad855e793a09632142c00cd01c5dd10": {
			"type": "Ybodychange",
			"commitMessage": "Don't need to nest else clause.",
			"commitDate": "2018-03-06, 8:27 AM",
			"commitName": "467386105ad855e793a09632142c00cd01c5dd10",
			"commitAuthor": "Gary Gregory",
			"commitDateOld": "2017-09-28, 2:03 PM",
			"commitNameOld": "56f2a758983611adea7308e90ae9934c973efa72",
			"commitAuthorOld": "Gary Gregory",
			"daysBetweenCommits": 158.81,
			"commitsBetweenForRepo": 50,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,92 +1,91 @@\n     public void run() {\n         RandomAccessFile reader = null;\n         try {\n             long last = 0; // The last time the file was checked for changes\n             long position = 0; // position within the file\n             // Open the file\n             while (getRun() && reader == null) {\n                 try {\n                     reader = new RandomAccessFile(file, RAF_MODE);\n                 } catch (final FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n                 if (reader == null) {\n                     Thread.sleep(delayMillis);\n                 } else {\n                     // The current position in the file\n                     position = end ? file.length() : 0;\n                     last = file.lastModified();\n                     reader.seek(position);\n                 }\n             }\n             while (getRun()) {\n                 final boolean newer = FileUtils.isFileNewer(file, last); // IO-279, must be done first\n                 // Check the file length to see if it was rotated\n                 final long length = file.length();\n                 if (length < position) {\n                     // File was rotated\n                     listener.fileRotated();\n                     // Reopen the reader after rotation ensuring that the old file is closed iff we re-open it\n                     // successfully\n                     try (RandomAccessFile save = reader) {\n                         reader = new RandomAccessFile(file, RAF_MODE);\n                         // At this point, we're sure that the old file is rotated\n                         // Finish scanning the old file and then we'll start with the new one\n                         try {\n                             readLines(save);\n                         }  catch (final IOException ioe) {\n                             listener.handle(ioe);\n                         }\n                         position = 0;\n                     } catch (final FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                         Thread.sleep(delayMillis);\n                     }\n                     continue;\n-                } else {\n-                    // File was not rotated\n-                    // See if the file needs to be read again\n-                    if (length > position) {\n-                        // The file has more content than it did last time\n-                        position = readLines(reader);\n-                        last = file.lastModified();\n-                    } else if (newer) {\n-                        /*\n-                         * This can happen if the file is truncated or overwritten with the exact same length of\n-                         * information. In cases like this, the file position needs to be reset\n-                         */\n-                        position = 0;\n-                        reader.seek(position); // cannot be null here\n+                }\n+                // File was not rotated\n+                // See if the file needs to be read again\n+                if (length > position) {\n+                    // The file has more content than it did last time\n+                    position = readLines(reader);\n+                    last = file.lastModified();\n+                } else if (newer) {\n+                    /*\n+                     * This can happen if the file is truncated or overwritten with the exact same length of\n+                     * information. In cases like this, the file position needs to be reset\n+                     */\n+                    position = 0;\n+                    reader.seek(position); // cannot be null here\n \n-                        // Now we can read new lines\n-                        position = readLines(reader);\n-                        last = file.lastModified();\n-                    }\n+                    // Now we can read new lines\n+                    position = readLines(reader);\n+                    last = file.lastModified();\n                 }\n                 if (reOpen && reader != null) {\n                     reader.close();\n                 }\n                 Thread.sleep(delayMillis);\n                 if (getRun() && reOpen) {\n                     reader = new RandomAccessFile(file, RAF_MODE);\n                     reader.seek(position);\n                 }\n             }\n         } catch (final InterruptedException e) {\n             Thread.currentThread().interrupt();\n             listener.handle(e);\n         } catch (final Exception e) {\n             listener.handle(e);\n         } finally {\n             try {\n                 if (reader != null) {\n                     reader.close();\n                 }\n             }\n             catch (final IOException e) {\n                 listener.handle(e);\n             }\n             stop();\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"56f2a758983611adea7308e90ae9934c973efa72": {
			"type": "Ybodychange",
			"commitMessage": "Consistently use the final modifier with local variables.",
			"commitDate": "2017-09-28, 2:03 PM",
			"commitName": "56f2a758983611adea7308e90ae9934c973efa72",
			"commitAuthor": "Gary Gregory",
			"commitDateOld": "2017-09-27, 11:00 AM",
			"commitNameOld": "a768fe9aacf04cce58441ba5cbe6e0d03c2a11d8",
			"commitAuthorOld": "Gary Gregory",
			"daysBetweenCommits": 1.13,
			"commitsBetweenForRepo": 25,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,92 +1,92 @@\n     public void run() {\n         RandomAccessFile reader = null;\n         try {\n             long last = 0; // The last time the file was checked for changes\n             long position = 0; // position within the file\n             // Open the file\n             while (getRun() && reader == null) {\n                 try {\n                     reader = new RandomAccessFile(file, RAF_MODE);\n                 } catch (final FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n                 if (reader == null) {\n                     Thread.sleep(delayMillis);\n                 } else {\n                     // The current position in the file\n                     position = end ? file.length() : 0;\n                     last = file.lastModified();\n                     reader.seek(position);\n                 }\n             }\n             while (getRun()) {\n                 final boolean newer = FileUtils.isFileNewer(file, last); // IO-279, must be done first\n                 // Check the file length to see if it was rotated\n                 final long length = file.length();\n                 if (length < position) {\n                     // File was rotated\n                     listener.fileRotated();\n                     // Reopen the reader after rotation ensuring that the old file is closed iff we re-open it\n                     // successfully\n                     try (RandomAccessFile save = reader) {\n                         reader = new RandomAccessFile(file, RAF_MODE);\n                         // At this point, we're sure that the old file is rotated\n                         // Finish scanning the old file and then we'll start with the new one\n                         try {\n                             readLines(save);\n-                        }  catch (IOException ioe) {\n+                        }  catch (final IOException ioe) {\n                             listener.handle(ioe);\n                         }\n                         position = 0;\n                     } catch (final FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                         Thread.sleep(delayMillis);\n                     }\n                     continue;\n                 } else {\n                     // File was not rotated\n                     // See if the file needs to be read again\n                     if (length > position) {\n                         // The file has more content than it did last time\n                         position = readLines(reader);\n                         last = file.lastModified();\n                     } else if (newer) {\n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position = 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         position = readLines(reader);\n                         last = file.lastModified();\n                     }\n                 }\n                 if (reOpen && reader != null) {\n                     reader.close();\n                 }\n                 Thread.sleep(delayMillis);\n                 if (getRun() && reOpen) {\n                     reader = new RandomAccessFile(file, RAF_MODE);\n                     reader.seek(position);\n                 }\n             }\n         } catch (final InterruptedException e) {\n             Thread.currentThread().interrupt();\n             listener.handle(e);\n         } catch (final Exception e) {\n             listener.handle(e);\n         } finally {\n             try {\n                 if (reader != null) {\n                     reader.close();\n                 }\n             }\n             catch (final IOException e) {\n                 listener.handle(e);\n             }\n             stop();\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"45fbfb82fd1f5168a7183e78ece89da7a60e21fe": {
			"type": "Ybodychange",
			"commitMessage": "IO-528: fix Tailer.run race condition runaway logging (closes #29)\n",
			"commitDate": "2017-04-23, 2:29 AM",
			"commitName": "45fbfb82fd1f5168a7183e78ece89da7a60e21fe",
			"commitAuthor": "Dave Moten",
			"commitDateOld": "2017-02-15, 10:37 AM",
			"commitNameOld": "8b9fe1b01ce21003f6a6ff8391ad2a64f4d21030",
			"commitAuthorOld": "Sebastian KÃ¼rten",
			"daysBetweenCommits": 66.62,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,91 +1,92 @@\n     public void run() {\n         RandomAccessFile reader = null;\n         try {\n             long last = 0; // The last time the file was checked for changes\n             long position = 0; // position within the file\n             // Open the file\n             while (getRun() && reader == null) {\n                 try {\n                     reader = new RandomAccessFile(file, RAF_MODE);\n                 } catch (final FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n                 if (reader == null) {\n                     Thread.sleep(delayMillis);\n                 } else {\n                     // The current position in the file\n                     position = end ? file.length() : 0;\n                     last = file.lastModified();\n                     reader.seek(position);\n                 }\n             }\n             while (getRun()) {\n                 final boolean newer = FileUtils.isFileNewer(file, last); // IO-279, must be done first\n                 // Check the file length to see if it was rotated\n                 final long length = file.length();\n                 if (length < position) {\n                     // File was rotated\n                     listener.fileRotated();\n                     // Reopen the reader after rotation ensuring that the old file is closed iff we re-open it\n                     // successfully\n                     try (RandomAccessFile save = reader) {\n                         reader = new RandomAccessFile(file, RAF_MODE);\n                         // At this point, we're sure that the old file is rotated\n                         // Finish scanning the old file and then we'll start with the new one\n                         try {\n                             readLines(save);\n                         }  catch (IOException ioe) {\n                             listener.handle(ioe);\n                         }\n                         position = 0;\n                     } catch (final FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n+                        Thread.sleep(delayMillis);\n                     }\n                     continue;\n                 } else {\n                     // File was not rotated\n                     // See if the file needs to be read again\n                     if (length > position) {\n                         // The file has more content than it did last time\n                         position = readLines(reader);\n                         last = file.lastModified();\n                     } else if (newer) {\n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position = 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         position = readLines(reader);\n                         last = file.lastModified();\n                     }\n                 }\n                 if (reOpen && reader != null) {\n                     reader.close();\n                 }\n                 Thread.sleep(delayMillis);\n                 if (getRun() && reOpen) {\n                     reader = new RandomAccessFile(file, RAF_MODE);\n                     reader.seek(position);\n                 }\n             }\n         } catch (final InterruptedException e) {\n             Thread.currentThread().interrupt();\n             listener.handle(e);\n         } catch (final Exception e) {\n             listener.handle(e);\n         } finally {\n             try {\n                 if (reader != null) {\n                     reader.close();\n                 }\n             }\n             catch (final IOException e) {\n                 listener.handle(e);\n             }\n             stop();\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4dc97b64005f0083b2facaa70f661138a4fa3fc0": {
			"type": "Ybodychange",
			"commitMessage": "[IO-505] Deprecated of all IOUtils.closeQuietly() methods and use try-with-resources internally.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1742675 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2016-05-06, 5:06 PM",
			"commitName": "4dc97b64005f0083b2facaa70f661138a4fa3fc0",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2015-11-12, 8:06 AM",
			"commitNameOld": "e76397c0c7f7889f82a0a59203ad16a673f1e704",
			"commitAuthorOld": "Kristian Rosenvold",
			"daysBetweenCommits": 176.33,
			"commitsBetweenForRepo": 92,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,86 +1,91 @@\n     public void run() {\n         RandomAccessFile reader = null;\n         try {\n             long last = 0; // The last time the file was checked for changes\n             long position = 0; // position within the file\n             // Open the file\n             while (getRun() && reader == null) {\n                 try {\n                     reader = new RandomAccessFile(file, RAF_MODE);\n                 } catch (final FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n                 if (reader == null) {\n                     Thread.sleep(delayMillis);\n                 } else {\n                     // The current position in the file\n                     position = end ? file.length() : 0;\n                     last = file.lastModified();\n                     reader.seek(position);\n                 }\n             }\n             while (getRun()) {\n                 final boolean newer = FileUtils.isFileNewer(file, last); // IO-279, must be done first\n                 // Check the file length to see if it was rotated\n                 final long length = file.length();\n                 if (length < position) {\n                     // File was rotated\n                     listener.fileRotated();\n-                    // Reopen the reader after rotation\n-                    try {\n-                        // Ensure that the old file is closed iff we re-open it successfully\n-                        final RandomAccessFile save = reader;\n+                    // Reopen the reader after rotation ensuring that the old file is closed iff we re-open it\n+                    // successfully\n+                    try (RandomAccessFile save = reader) {\n                         reader = new RandomAccessFile(file, RAF_MODE);\n                         // At this point, we're sure that the old file is rotated\n                         // Finish scanning the old file and then we'll start with the new one\n                         try {\n                             readLines(save);\n                         }  catch (IOException ioe) {\n                             listener.handle(ioe);\n                         }\n                         position = 0;\n-                        // close old file explicitly rather than relying on GC picking up previous RAF\n-                        IOUtils.closeQuietly(save);\n                     } catch (final FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n                     // File was not rotated\n                     // See if the file needs to be read again\n                     if (length > position) {\n                         // The file has more content than it did last time\n                         position = readLines(reader);\n                         last = file.lastModified();\n                     } else if (newer) {\n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position = 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         position = readLines(reader);\n                         last = file.lastModified();\n                     }\n                 }\n-                if (reOpen) {\n-                    IOUtils.closeQuietly(reader);\n+                if (reOpen && reader != null) {\n+                    reader.close();\n                 }\n                 Thread.sleep(delayMillis);\n                 if (getRun() && reOpen) {\n                     reader = new RandomAccessFile(file, RAF_MODE);\n                     reader.seek(position);\n                 }\n             }\n         } catch (final InterruptedException e) {\n             Thread.currentThread().interrupt();\n-            stop(e);\n+            listener.handle(e);\n         } catch (final Exception e) {\n-            stop(e);\n+            listener.handle(e);\n         } finally {\n-            IOUtils.closeQuietly(reader);\n+            try {\n+                if (reader != null) {\n+                    reader.close();\n+                }\n+            }\n+            catch (final IOException e) {\n+                listener.handle(e);\n+            }\n+            stop();\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7705470ba1ca2bf95f6442f06f68f007f33a4aeb": {
			"type": "Ybodychange",
			"commitMessage": "IO-279  Tailer erroneously considers file as new.\n        Fix to use file.lastModified() rather than System.currentTimeMillis()\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1476097 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-04-26, 1:26 AM",
			"commitName": "7705470ba1ca2bf95f6442f06f68f007f33a4aeb",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2013-04-24, 4:24 PM",
			"commitNameOld": "effe551657921069b871519156a934e4ef3ae916",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 1.38,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,86 +1,86 @@\n     public void run() {\n         RandomAccessFile reader = null;\n         try {\n             long last = 0; // The last time the file was checked for changes\n             long position = 0; // position within the file\n             // Open the file\n             while (getRun() && reader == null) {\n                 try {\n                     reader = new RandomAccessFile(file, RAF_MODE);\n                 } catch (final FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n                 if (reader == null) {\n                     Thread.sleep(delayMillis);\n                 } else {\n                     // The current position in the file\n                     position = end ? file.length() : 0;\n-                    last = System.currentTimeMillis();\n+                    last = file.lastModified();\n                     reader.seek(position);\n                 }\n             }\n             while (getRun()) {\n                 final boolean newer = FileUtils.isFileNewer(file, last); // IO-279, must be done first\n                 // Check the file length to see if it was rotated\n                 final long length = file.length();\n                 if (length < position) {\n                     // File was rotated\n                     listener.fileRotated();\n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n                         final RandomAccessFile save = reader;\n                         reader = new RandomAccessFile(file, RAF_MODE);\n                         // At this point, we're sure that the old file is rotated\n                         // Finish scanning the old file and then we'll start with the new one\n                         try {\n                             readLines(save);\n                         }  catch (IOException ioe) {\n                             listener.handle(ioe);\n                         }\n                         position = 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n                     } catch (final FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n                     // File was not rotated\n                     // See if the file needs to be read again\n                     if (length > position) {\n                         // The file has more content than it did last time\n                         position = readLines(reader);\n-                        last = System.currentTimeMillis();\n+                        last = file.lastModified();\n                     } else if (newer) {\n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position = 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         position = readLines(reader);\n-                        last = System.currentTimeMillis();\n+                        last = file.lastModified();\n                     }\n                 }\n                 if (reOpen) {\n                     IOUtils.closeQuietly(reader);\n                 }\n                 Thread.sleep(delayMillis);\n                 if (getRun() && reOpen) {\n                     reader = new RandomAccessFile(file, RAF_MODE);\n                     reader.seek(position);\n                 }\n             }\n         } catch (final InterruptedException e) {\n             Thread.currentThread().interrupt();\n             stop(e);\n         } catch (final Exception e) {\n             stop(e);\n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"62a47bf10c42039875bc9bf7790feb470b3205aa": {
			"type": "Ybodychange",
			"commitMessage": "IO-338 When a file is rotated, finish reading previous file prior to starting new one\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1468723 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-04-16, 7:26 PM",
			"commitName": "62a47bf10c42039875bc9bf7790feb470b3205aa",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2013-04-16, 5:59 PM",
			"commitNameOld": "8d52f694da0484cb2783a8b35dad845322af0c07",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 0.06,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,79 +1,86 @@\n     public void run() {\n         RandomAccessFile reader = null;\n         try {\n             long last = 0; // The last time the file was checked for changes\n             long position = 0; // position within the file\n             // Open the file\n             while (getRun() && reader == null) {\n                 try {\n                     reader = new RandomAccessFile(file, RAF_MODE);\n                 } catch (final FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n                 if (reader == null) {\n                     Thread.sleep(delayMillis);\n                 } else {\n                     // The current position in the file\n                     position = end ? file.length() : 0;\n                     last = System.currentTimeMillis();\n                     reader.seek(position);\n                 }\n             }\n             while (getRun()) {\n                 final boolean newer = FileUtils.isFileNewer(file, last); // IO-279, must be done first\n                 // Check the file length to see if it was rotated\n                 final long length = file.length();\n                 if (length < position) {\n                     // File was rotated\n                     listener.fileRotated();\n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n                         final RandomAccessFile save = reader;\n                         reader = new RandomAccessFile(file, RAF_MODE);\n+                        // At this point, we're sure that the old file is rotated\n+                        // Finish scanning the old file and then we'll start with the new one\n+                        try {\n+                            readLines(save);\n+                        }  catch (IOException ioe) {\n+                            listener.handle(ioe);\n+                        }\n                         position = 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n                     } catch (final FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n                     // File was not rotated\n                     // See if the file needs to be read again\n                     if (length > position) {\n                         // The file has more content than it did last time\n                         position = readLines(reader);\n                         last = System.currentTimeMillis();\n                     } else if (newer) {\n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position = 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         position = readLines(reader);\n                         last = System.currentTimeMillis();\n                     }\n                 }\n                 if (reOpen) {\n                     IOUtils.closeQuietly(reader);\n                 }\n                 Thread.sleep(delayMillis);\n                 if (getRun() && reOpen) {\n                     reader = new RandomAccessFile(file, RAF_MODE);\n                     reader.seek(position);\n                 }\n             }\n         } catch (final InterruptedException e) {            \n             Thread.currentThread().interrupt();\n             stop(e);\n         } catch (final Exception e) {            \n             stop(e);\n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6aa00766b9103d75c763160280429af8e1f0549e": {
			"type": "Ybodychange",
			"commitMessage": "Use final where possible.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1415850 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2012-11-30, 12:51 PM",
			"commitName": "6aa00766b9103d75c763160280429af8e1f0549e",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2012-11-21, 4:36 PM",
			"commitNameOld": "3789b1aa9669cff2f434eba56f57c500662ead10",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 8.84,
			"commitsBetweenForRepo": 26,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,79 +1,79 @@\n     public void run() {\n         RandomAccessFile reader = null;\n         try {\n             long last = 0; // The last time the file was checked for changes\n             long position = 0; // position within the file\n             // Open the file\n             while (getRun() && reader == null) {\n                 try {\n                     reader = new RandomAccessFile(file, RAF_MODE);\n-                } catch (FileNotFoundException e) {\n+                } catch (final FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n                 if (reader == null) {\n                     Thread.sleep(delayMillis);\n                 } else {\n                     // The current position in the file\n                     position = end ? file.length() : 0;\n                     last = System.currentTimeMillis();\n                     reader.seek(position);\n                 }\n             }\n             while (getRun()) {\n-                boolean newer = FileUtils.isFileNewer(file, last); // IO-279, must be done first\n+                final boolean newer = FileUtils.isFileNewer(file, last); // IO-279, must be done first\n                 // Check the file length to see if it was rotated\n-                long length = file.length();\n+                final long length = file.length();\n                 if (length < position) {\n                     // File was rotated\n                     listener.fileRotated();\n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n-                        RandomAccessFile save = reader;\n+                        final RandomAccessFile save = reader;\n                         reader = new RandomAccessFile(file, RAF_MODE);\n                         position = 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n-                    } catch (FileNotFoundException e) {\n+                    } catch (final FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n                     // File was not rotated\n                     // See if the file needs to be read again\n                     if (length > position) {\n                         // The file has more content than it did last time\n                         position = readLines(reader);\n                         last = System.currentTimeMillis();\n                     } else if (newer) {\n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position = 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         position = readLines(reader);\n                         last = System.currentTimeMillis();\n                     }\n                 }\n                 if (reOpen) {\n                     IOUtils.closeQuietly(reader);\n                 }\n                 Thread.sleep(delayMillis);\n                 if (getRun() && reOpen) {\n                     reader = new RandomAccessFile(file, RAF_MODE);\n                     reader.seek(position);\n                 }\n             }\n-        } catch (InterruptedException e) {            \n+        } catch (final InterruptedException e) {            \n             Thread.currentThread().interrupt();\n             stop(e);\n-        } catch (Exception e) {            \n+        } catch (final Exception e) {            \n             stop(e);\n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3789b1aa9669cff2f434eba56f57c500662ead10": {
			"type": "Ybodychange",
			"commitMessage": "[IO-358][Tailer] InterruptedException while the thread is sleeping is silently ignored.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1412391 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2012-11-21, 4:36 PM",
			"commitName": "3789b1aa9669cff2f434eba56f57c500662ead10",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2012-11-20, 7:29 PM",
			"commitNameOld": "3225374e9f6362a4a59d0cf8b3da9b92905bbd27",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 0.88,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,82 +1,79 @@\n     public void run() {\n         RandomAccessFile reader = null;\n         try {\n             long last = 0; // The last time the file was checked for changes\n             long position = 0; // position within the file\n             // Open the file\n             while (getRun() && reader == null) {\n                 try {\n                     reader = new RandomAccessFile(file, RAF_MODE);\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n                 if (reader == null) {\n-                    try {\n-                        Thread.sleep(delayMillis);\n-                    } catch (InterruptedException e) {\n-                    }\n+                    Thread.sleep(delayMillis);\n                 } else {\n                     // The current position in the file\n                     position = end ? file.length() : 0;\n                     last = System.currentTimeMillis();\n                     reader.seek(position);\n                 }\n             }\n             while (getRun()) {\n                 boolean newer = FileUtils.isFileNewer(file, last); // IO-279, must be done first\n                 // Check the file length to see if it was rotated\n                 long length = file.length();\n                 if (length < position) {\n                     // File was rotated\n                     listener.fileRotated();\n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n                         RandomAccessFile save = reader;\n                         reader = new RandomAccessFile(file, RAF_MODE);\n                         position = 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n                     } catch (FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n                     // File was not rotated\n                     // See if the file needs to be read again\n                     if (length > position) {\n                         // The file has more content than it did last time\n                         position = readLines(reader);\n                         last = System.currentTimeMillis();\n                     } else if (newer) {\n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position = 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         position = readLines(reader);\n                         last = System.currentTimeMillis();\n                     }\n                 }\n                 if (reOpen) {\n                     IOUtils.closeQuietly(reader);\n                 }\n-                try {\n-                    Thread.sleep(delayMillis);\n-                } catch (InterruptedException e) {\n-                }\n+                Thread.sleep(delayMillis);\n                 if (getRun() && reOpen) {\n                     reader = new RandomAccessFile(file, RAF_MODE);\n                     reader.seek(position);\n                 }\n             }\n-        } catch (Exception e) {\n-            listener.handle(e);\n+        } catch (InterruptedException e) {            \n+            Thread.currentThread().interrupt();\n+            stop(e);\n+        } catch (Exception e) {            \n+            stop(e);\n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3db2debddb4840f415570f88fb4a7794724b7930": {
			"type": "Ybodychange",
			"commitMessage": "[IO-345] Supply a hook method allowing Tailer actively determining stop condition.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1391419 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2012-09-28, 5:10 AM",
			"commitName": "3db2debddb4840f415570f88fb4a7794724b7930",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2012-06-10, 6:09 PM",
			"commitNameOld": "c395904915ca330d8944d74f9502c0f4bcf65907",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 109.46,
			"commitsBetweenForRepo": 35,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,97 +1,97 @@\n     public void run() {\n         RandomAccessFile reader = null;\n         try {\n             long last = 0; // The last time the file was checked for changes\n             long position = 0; // position within the file\n             // Open the file\n-            while (run && reader == null) {\n+            while (getRun() && reader == null) {\n                 try {\n                     reader = new RandomAccessFile(file, RAF_MODE);\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader == null) {\n                     try {\n                         Thread.sleep(delayMillis);\n                     } catch (InterruptedException e) {\n                     }\n                 } else {\n                     // The current position in the file\n                     position = end ? file.length() : 0;\n                     last = System.currentTimeMillis();\n                     reader.seek(position);\n                 }\n             }\n \n-            while (run) {\n+            while (getRun()) {\n \n                 boolean newer = FileUtils.isFileNewer(file, last); // IO-279, must be done first\n \n                 // Check the file length to see if it was rotated\n                 long length = file.length();\n \n                 if (length < position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n                         RandomAccessFile save = reader;\n                         reader = new RandomAccessFile(file, RAF_MODE);\n                         position = 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n                     } catch (FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length > position) {\n \n                         // The file has more content than it did last time\n                         position = readLines(reader);\n                         last = System.currentTimeMillis();\n \n                     } else if (newer) {\n \n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position = 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         position = readLines(reader);\n                         last = System.currentTimeMillis();\n                     }\n                 }\n                 if (reOpen) {\n                     IOUtils.closeQuietly(reader);\n                 }\n                 try {\n                     Thread.sleep(delayMillis);\n                 } catch (InterruptedException e) {\n                 }\n-                if (run && reOpen) {\n+                if (getRun() && reOpen) {\n                     reader = new RandomAccessFile(file, RAF_MODE);\n                     reader.seek(position);\n                 }\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c395904915ca330d8944d74f9502c0f4bcf65907": {
			"type": "Ybodychange",
			"commitMessage": "[IO-269] Tailer locks file from deletion/rename on Windows.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1348698 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2012-06-10, 6:09 PM",
			"commitName": "c395904915ca330d8944d74f9502c0f4bcf65907",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2012-06-07, 4:54 PM",
			"commitNameOld": "199dd8dfd1cef867ad8712c7565f090f81be0e7f",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 3.05,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,90 +1,97 @@\n     public void run() {\n         RandomAccessFile reader = null;\n         try {\n             long last = 0; // The last time the file was checked for changes\n             long position = 0; // position within the file\n             // Open the file\n             while (run && reader == null) {\n                 try {\n                     reader = new RandomAccessFile(file, RAF_MODE);\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader == null) {\n                     try {\n                         Thread.sleep(delayMillis);\n                     } catch (InterruptedException e) {\n                     }\n                 } else {\n                     // The current position in the file\n                     position = end ? file.length() : 0;\n                     last = System.currentTimeMillis();\n                     reader.seek(position);\n                 }\n             }\n \n             while (run) {\n \n                 boolean newer = FileUtils.isFileNewer(file, last); // IO-279, must be done first\n \n                 // Check the file length to see if it was rotated\n                 long length = file.length();\n \n                 if (length < position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n                         RandomAccessFile save = reader;\n                         reader = new RandomAccessFile(file, RAF_MODE);\n                         position = 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n                     } catch (FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length > position) {\n \n                         // The file has more content than it did last time\n                         position = readLines(reader);\n                         last = System.currentTimeMillis();\n \n                     } else if (newer) {\n \n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position = 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         position = readLines(reader);\n                         last = System.currentTimeMillis();\n                     }\n                 }\n+                if (reOpen) {\n+                    IOUtils.closeQuietly(reader);\n+                }\n                 try {\n                     Thread.sleep(delayMillis);\n                 } catch (InterruptedException e) {\n                 }\n+                if (run && reOpen) {\n+                    reader = new RandomAccessFile(file, RAF_MODE);\n+                    reader.seek(position);\n+                }\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"199dd8dfd1cef867ad8712c7565f090f81be0e7f": {
			"type": "Ybodychange",
			"commitMessage": "IO-279 - Tailer erroneously considers file as new.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1347836 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2012-06-07, 4:54 PM",
			"commitName": "199dd8dfd1cef867ad8712c7565f090f81be0e7f",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2012-06-07, 4:23 PM",
			"commitNameOld": "41dfac731ef973b03f70d8f9c01afc67bc5f311d",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,88 +1,90 @@\n     public void run() {\n         RandomAccessFile reader = null;\n         try {\n             long last = 0; // The last time the file was checked for changes\n             long position = 0; // position within the file\n             // Open the file\n             while (run && reader == null) {\n                 try {\n                     reader = new RandomAccessFile(file, RAF_MODE);\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader == null) {\n                     try {\n                         Thread.sleep(delayMillis);\n                     } catch (InterruptedException e) {\n                     }\n                 } else {\n                     // The current position in the file\n                     position = end ? file.length() : 0;\n                     last = System.currentTimeMillis();\n                     reader.seek(position);\n                 }\n             }\n \n             while (run) {\n \n+                boolean newer = FileUtils.isFileNewer(file, last); // IO-279, must be done first\n+\n                 // Check the file length to see if it was rotated\n                 long length = file.length();\n \n                 if (length < position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n                         RandomAccessFile save = reader;\n                         reader = new RandomAccessFile(file, RAF_MODE);\n                         position = 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n                     } catch (FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length > position) {\n \n                         // The file has more content than it did last time\n-                        last = System.currentTimeMillis();\n                         position = readLines(reader);\n+                        last = System.currentTimeMillis();\n \n-                    } else if (FileUtils.isFileNewer(file, last)) {\n+                    } else if (newer) {\n \n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position = 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n-                        last = System.currentTimeMillis();\n                         position = readLines(reader);\n+                        last = System.currentTimeMillis();\n                     }\n                 }\n                 try {\n                     Thread.sleep(delayMillis);\n                 } catch (InterruptedException e) {\n                 }\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"24330e7703383c78411225dd9b99ebfe57b31ad5": {
			"type": "Ybodychange",
			"commitMessage": "Rename delay to delayMillis for param name, Javadoc, and private ivar; accessor remains the same.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1345280 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2012-06-01, 10:30 AM",
			"commitName": "24330e7703383c78411225dd9b99ebfe57b31ad5",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2012-06-01, 10:27 AM",
			"commitNameOld": "59ffcad15d220c2bc1f70f01d58bc31dec04b423",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,88 +1,88 @@\n     public void run() {\n         RandomAccessFile reader = null;\n         try {\n             long last = 0; // The last time the file was checked for changes\n             long position = 0; // position within the file\n             // Open the file\n             while (run && reader == null) {\n                 try {\n                     reader = new RandomAccessFile(file, RAF_MODE);\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader == null) {\n                     try {\n-                        Thread.sleep(delay);\n+                        Thread.sleep(delayMillis);\n                     } catch (InterruptedException e) {\n                     }\n                 } else {\n                     // The current position in the file\n                     position = end ? file.length() : 0;\n                     last = System.currentTimeMillis();\n                     reader.seek(position);\n                 }\n             }\n \n             while (run) {\n \n                 // Check the file length to see if it was rotated\n                 long length = file.length();\n \n                 if (length < position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n                         RandomAccessFile save = reader;\n                         reader = new RandomAccessFile(file, RAF_MODE);\n                         position = 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n                     } catch (FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length > position) {\n \n                         // The file has more content than it did last time\n                         last = System.currentTimeMillis();\n                         position = readLines(reader);\n \n                     } else if (FileUtils.isFileNewer(file, last)) {\n \n                         /*\n                          * This can happen if the file is truncated or overwritten with the exact same length of\n                          * information. In cases like this, the file position needs to be reset\n                          */\n                         position = 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         last = System.currentTimeMillis();\n                         position = readLines(reader);\n                     }\n                 }\n                 try {\n-                    Thread.sleep(delay);\n+                    Thread.sleep(delayMillis);\n                 } catch (InterruptedException e) {\n                 }\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"59ffcad15d220c2bc1f70f01d58bc31dec04b423": {
			"type": "Ybodychange",
			"commitMessage": "[IO-332] Improve tailer's reading performance.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1345279 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2012-06-01, 10:27 AM",
			"commitName": "59ffcad15d220c2bc1f70f01d58bc31dec04b423",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2012-03-22, 1:55 PM",
			"commitNameOld": "cf5c462807a137b823a3155dfe9800b3cbf2303d",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 70.86,
			"commitsBetweenForRepo": 92,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,89 +1,88 @@\n     public void run() {\n         RandomAccessFile reader = null;\n         try {\n             long last = 0; // The last time the file was checked for changes\n             long position = 0; // position within the file\n             // Open the file\n             while (run && reader == null) {\n                 try {\n-                    reader = new RandomAccessFile(file, \"r\");\n+                    reader = new RandomAccessFile(file, RAF_MODE);\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader == null) {\n                     try {\n                         Thread.sleep(delay);\n                     } catch (InterruptedException e) {\n                     }\n                 } else {\n                     // The current position in the file\n                     position = end ? file.length() : 0;\n                     last = System.currentTimeMillis();\n-                    reader.seek(position);                    \n+                    reader.seek(position);\n                 }\n             }\n \n-\n             while (run) {\n \n                 // Check the file length to see if it was rotated\n                 long length = file.length();\n \n                 if (length < position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n                         RandomAccessFile save = reader;\n-                        reader = new RandomAccessFile(file, \"r\");\n+                        reader = new RandomAccessFile(file, RAF_MODE);\n                         position = 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n                     } catch (FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length > position) {\n \n                         // The file has more content than it did last time\n                         last = System.currentTimeMillis();\n                         position = readLines(reader);\n \n                     } else if (FileUtils.isFileNewer(file, last)) {\n \n-                        /* This can happen if the file is truncated or overwritten\n-                         * with the exact same length of information. In cases like\n-                         * this, the file position needs to be reset\n+                        /*\n+                         * This can happen if the file is truncated or overwritten with the exact same length of\n+                         * information. In cases like this, the file position needs to be reset\n                          */\n                         position = 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         last = System.currentTimeMillis();\n                         position = readLines(reader);\n                     }\n                 }\n                 try {\n                     Thread.sleep(delay);\n                 } catch (InterruptedException e) {\n                 }\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f6c8dcc99db1929435fd8bb05dc0cf77e956e6e6": {
			"type": "Ybodychange",
			"commitMessage": "IO-177 Should be handling InterruptedException when sleeping - not calling the exception handler\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1005921 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-10-08, 10:41 AM",
			"commitName": "f6c8dcc99db1929435fd8bb05dc0cf77e956e6e6",
			"commitAuthor": "Niall Pemberton",
			"commitDateOld": "2010-10-04, 11:54 AM",
			"commitNameOld": "83f7246c3e9fe1d3f1ad6cf7ea0715a573fe2f2a",
			"commitAuthorOld": "Niall Pemberton",
			"daysBetweenCommits": 3.95,
			"commitsBetweenForRepo": 41,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,84 +1,89 @@\n     public void run() {\n         RandomAccessFile reader = null;\n         try {\n             long last = 0; // The last time the file was checked for changes\n             long position = 0; // position within the file\n             // Open the file\n             while (run && reader == null) {\n                 try {\n                     reader = new RandomAccessFile(file, \"r\");\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader == null) {\n-                    Thread.sleep(delay);\n+                    try {\n+                        Thread.sleep(delay);\n+                    } catch (InterruptedException e) {\n+                    }\n                 } else {\n                     // The current position in the file\n                     position = end ? file.length() : 0;\n                     last = System.currentTimeMillis();\n                     reader.seek(position);                    \n                 }\n             }\n \n \n             while (run) {\n \n                 // Check the file length to see if it was rotated\n                 long length = file.length();\n \n                 if (length < position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n                         RandomAccessFile save = reader;\n                         reader = new RandomAccessFile(file, \"r\");\n                         position = 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n                     } catch (FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length > position) {\n \n                         // The file has more content than it did last time\n                         last = System.currentTimeMillis();\n                         position = readLines(reader);\n \n                     } else if (FileUtils.isFileNewer(file, last)) {\n \n                         /* This can happen if the file is truncated or overwritten\n                          * with the exact same length of information. In cases like\n                          * this, the file position needs to be reset\n                          */\n                         position = 0;\n                         reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         last = System.currentTimeMillis();\n                         position = readLines(reader);\n                     }\n                 }\n-\n-                Thread.sleep(delay);\n+                try {\n+                    Thread.sleep(delay);\n+                } catch (InterruptedException e) {\n+                }\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"83f7246c3e9fe1d3f1ad6cf7ea0715a573fe2f2a": {
			"type": "Yfilerename",
			"commitMessage": "Build changes - re-organize to standard m2 layout, remove useless JIRA report and fix some Ant issues\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1004358 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-10-04, 11:54 AM",
			"commitName": "83f7246c3e9fe1d3f1ad6cf7ea0715a573fe2f2a",
			"commitAuthor": "Niall Pemberton",
			"commitDateOld": "2010-10-04, 10:54 AM",
			"commitNameOld": "19f48eb1711427a43a5e10c84bbbf1218a08bdd2",
			"commitAuthorOld": "Niall Pemberton",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/java/org/apache/commons/io/input/Tailer.java",
				"newPath": "src/main/java/org/apache/commons/io/input/Tailer.java"
			}
		},
		"4c17f2bcb464dc60c1937ee9ba5c5bbe2a84c2e8": {
			"type": "Ybodychange",
			"commitMessage": "Cannot be null\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1003696 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-10-01, 3:38 PM",
			"commitName": "4c17f2bcb464dc60c1937ee9ba5c5bbe2a84c2e8",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2010-09-30, 9:56 AM",
			"commitNameOld": "70f4ddc09819068a13fcb522ad08340140d48f37",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 1.24,
			"commitsBetweenForRepo": 18,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,84 +1,84 @@\n     public void run() {\n         RandomAccessFile reader = null;\n         try {\n             long last = 0; // The last time the file was checked for changes\n             long position = 0; // position within the file\n             // Open the file\n             while (run && reader == null) {\n                 try {\n                     reader = new RandomAccessFile(file, \"r\");\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader == null) {\n                     Thread.sleep(delay);\n                 } else {\n                     // The current position in the file\n                     position = end ? file.length() : 0;\n                     last = System.currentTimeMillis();\n                     reader.seek(position);                    \n                 }\n             }\n \n \n             while (run) {\n \n                 // Check the file length to see if it was rotated\n                 long length = file.length();\n \n                 if (length < position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n                         // Ensure that the old file is closed iff we re-open it successfully\n                         RandomAccessFile save = reader;\n                         reader = new RandomAccessFile(file, \"r\");\n                         position = 0;\n                         // close old file explicitly rather than relying on GC picking up previous RAF\n                         IOUtils.closeQuietly(save);\n                     } catch (FileNotFoundException e) {\n                         // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length > position) {\n \n                         // The file has more content than it did last time\n                         last = System.currentTimeMillis();\n                         position = readLines(reader);\n \n                     } else if (FileUtils.isFileNewer(file, last)) {\n \n                         /* This can happen if the file is truncated or overwritten\n                          * with the exact same length of information. In cases like\n                          * this, the file position needs to be reset\n                          */\n                         position = 0;\n-                        reader.seek(position);\n+                        reader.seek(position); // cannot be null here\n \n                         // Now we can read new lines\n                         last = System.currentTimeMillis();\n                         position = readLines(reader);\n                     }\n                 }\n \n                 Thread.sleep(delay);\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cdc2dadd24ee51a464cae08a98fb2da4f8ab4a76": {
			"type": "Ybodychange",
			"commitMessage": "Original code kept the RAF if the re-open failed.\nRevert to the same behaviour, but explicitly close the file\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1002933 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-09-29, 7:30 PM",
			"commitName": "cdc2dadd24ee51a464cae08a98fb2da4f8ab4a76",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2010-09-29, 7:06 PM",
			"commitNameOld": "230a3c292c67918a019d96f15f2fb30bbb261bc1",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,80 +1,84 @@\n     public void run() {\n         RandomAccessFile reader = null;\n         try {\n             long last = 0; // The last time the file was checked for changes\n             long position = 0; // position within the file\n             // Open the file\n             while (run && reader == null) {\n                 try {\n                     reader = new RandomAccessFile(file, \"r\");\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader == null) {\n                     Thread.sleep(delay);\n                 } else {\n                     // The current position in the file\n                     position = end ? file.length() : 0;\n                     last = System.currentTimeMillis();\n                     reader.seek(position);                    \n                 }\n             }\n \n \n             while (run) {\n \n                 // Check the file length to see if it was rotated\n                 long length = file.length();\n \n                 if (length < position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n-                        IOUtils.closeQuietly(reader);\n+                        // Ensure that the old file is closed iff we re-open it successfully\n+                        RandomAccessFile save = reader;\n                         reader = new RandomAccessFile(file, \"r\");\n                         position = 0;\n+                        // close old file explicitly rather than relying on GC picking up previous RAF\n+                        IOUtils.closeQuietly(save);\n                     } catch (FileNotFoundException e) {\n+                        // in this case we continue to use the previous reader and position values\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length > position) {\n \n                         // The file has more content than it did last time\n                         last = System.currentTimeMillis();\n                         position = readLines(reader);\n \n                     } else if (FileUtils.isFileNewer(file, last)) {\n \n                         /* This can happen if the file is truncated or overwritten\n                          * with the exact same length of information. In cases like\n                          * this, the file position needs to be reset\n                          */\n                         position = 0;\n                         reader.seek(position);\n \n                         // Now we can read new lines\n                         last = System.currentTimeMillis();\n                         position = readLines(reader);\n                     }\n                 }\n \n                 Thread.sleep(delay);\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n         } finally {\n             IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"230a3c292c67918a019d96f15f2fb30bbb261bc1": {
			"type": "Ybodychange",
			"commitMessage": "Ensure file is closed\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1002931 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-09-29, 7:06 PM",
			"commitName": "230a3c292c67918a019d96f15f2fb30bbb261bc1",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2010-09-29, 6:43 PM",
			"commitNameOld": "9f17760e3ea10bc221a006e10728c611f3b8ba01",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,77 +1,80 @@\n     public void run() {\n+        RandomAccessFile reader = null;\n         try {\n             long last = 0; // The last time the file was checked for changes\n             long position = 0; // position within the file\n-            RandomAccessFile reader = null;\n             // Open the file\n             while (run && reader == null) {\n                 try {\n                     reader = new RandomAccessFile(file, \"r\");\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader == null) {\n                     Thread.sleep(delay);\n                 } else {\n                     // The current position in the file\n                     position = end ? file.length() : 0;\n                     last = System.currentTimeMillis();\n                     reader.seek(position);                    \n                 }\n             }\n \n \n             while (run) {\n \n                 // Check the file length to see if it was rotated\n                 long length = file.length();\n \n                 if (length < position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n+                        IOUtils.closeQuietly(reader);\n                         reader = new RandomAccessFile(file, \"r\");\n                         position = 0;\n                     } catch (FileNotFoundException e) {\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length > position) {\n \n                         // The file has more content than it did last time\n                         last = System.currentTimeMillis();\n                         position = readLines(reader);\n \n                     } else if (FileUtils.isFileNewer(file, last)) {\n \n                         /* This can happen if the file is truncated or overwritten\n                          * with the exact same length of information. In cases like\n                          * this, the file position needs to be reset\n                          */\n                         position = 0;\n                         reader.seek(position);\n \n                         // Now we can read new lines\n                         last = System.currentTimeMillis();\n                         position = readLines(reader);\n                     }\n                 }\n \n                 Thread.sleep(delay);\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n+        } finally {\n+            IOUtils.closeQuietly(reader);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"25032e70cbf8cb14de334a5002811852867d16dd": {
			"type": "Ybodychange",
			"commitMessage": "Localise variables to run() method\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1002922 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-09-29, 6:40 PM",
			"commitName": "25032e70cbf8cb14de334a5002811852867d16dd",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2010-09-29, 6:08 PM",
			"commitNameOld": "a32a395a621098ce652ee8158e6320fa422f9fa3",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,72 +1,77 @@\n     public void run() {\n         try {\n+            long last = 0; // The last time the file was checked for changes\n+            long position = 0; // position within the file\n+            RandomAccessFile reader = null;\n             // Open the file\n             while (run && reader == null) {\n                 try {\n                     reader = new RandomAccessFile(file, \"r\");\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader == null) {\n                     Thread.sleep(delay);\n                 } else {\n                     // The current position in the file\n                     position = end ? file.length() : 0;\n                     last = System.currentTimeMillis();\n                     reader.seek(position);                    \n                 }\n             }\n \n \n             while (run) {\n \n                 // Check the file length to see if it was rotated\n                 long length = file.length();\n \n                 if (length < position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n                         reader = new RandomAccessFile(file, \"r\");\n                         position = 0;\n                     } catch (FileNotFoundException e) {\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length > position) {\n \n                         // The file has more content than it did last time\n-                        readLines();\n+                        last = System.currentTimeMillis();\n+                        position = readLines(reader);\n \n                     } else if (FileUtils.isFileNewer(file, last)) {\n \n                         /* This can happen if the file is truncated or overwritten\n                          * with the exact same length of information. In cases like\n                          * this, the file position needs to be reset\n                          */\n                         position = 0;\n                         reader.seek(position);\n \n                         // Now we can read new lines\n-                        readLines();\n+                        last = System.currentTimeMillis();\n+                        position = readLines(reader);\n                     }\n                 }\n \n                 Thread.sleep(delay);\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a32a395a621098ce652ee8158e6320fa422f9fa3": {
			"type": "Ybodychange",
			"commitMessage": "Add test for and fix NPE if thread stopped with no file found\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1002918 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-09-29, 6:08 PM",
			"commitName": "a32a395a621098ce652ee8158e6320fa422f9fa3",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2010-09-29, 5:33 PM",
			"commitNameOld": "317841f44a515e57356fe50d7eb1be15030dfb5b",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,71 +1,72 @@\n     public void run() {\n         try {\n             // Open the file\n             while (run && reader == null) {\n                 try {\n                     reader = new RandomAccessFile(file, \"r\");\n                 } catch (FileNotFoundException e) {\n                     listener.fileNotFound();\n                 }\n \n                 if (reader == null) {\n                     Thread.sleep(delay);\n+                } else {\n+                    // The current position in the file\n+                    position = end ? file.length() : 0;\n+                    last = System.currentTimeMillis();\n+                    reader.seek(position);                    \n                 }\n             }\n \n-            // The current position in the file\n-            position = end ? file.length() : 0;\n-            last = System.currentTimeMillis();\n-            reader.seek(position);\n \n             while (run) {\n \n                 // Check the file length to see if it was rotated\n                 long length = file.length();\n \n                 if (length < position) {\n \n                     // File was rotated\n                     listener.fileRotated();\n \n                     // Reopen the reader after rotation\n                     try {\n                         reader = new RandomAccessFile(file, \"r\");\n                         position = 0;\n                     } catch (FileNotFoundException e) {\n                         listener.fileNotFound();\n                     }\n                     continue;\n                 } else {\n \n                     // File was not rotated\n \n                     // See if the file needs to be read again\n                     if (length > position) {\n \n                         // The file has more content than it did last time\n                         readLines();\n \n                     } else if (FileUtils.isFileNewer(file, last)) {\n \n                         /* This can happen if the file is truncated or overwritten\n                          * with the exact same length of information. In cases like\n                          * this, the file position needs to be reset\n                          */\n                         position = 0;\n                         reader.seek(position);\n \n                         // Now we can read new lines\n                         readLines();\n                     }\n                 }\n \n                 Thread.sleep(delay);\n             }\n \n         } catch (Exception e) {\n \n             listener.handle(e);\n \n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"587f5571c6eb5a55b752fd7bfd66c2c535f5e566": {
			"type": "Yintroduced",
			"commitMessage": "IO-177 New Tailer class - Simple implementation of the unix \"tail -f\" functionality - thanks to Jeff Rodriguez for the patch\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1002844 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-09-29, 1:56 PM",
			"commitName": "587f5571c6eb5a55b752fd7bfd66c2c535f5e566",
			"commitAuthor": "Niall Pemberton",
			"diff": "@@ -0,0 +1,71 @@\n+    public void run() {\n+        try {\n+            // Open the file\n+            while (run && reader == null) {\n+                try {\n+                    reader = new RandomAccessFile(file, \"r\");\n+                } catch (FileNotFoundException e) {\n+                    listener.fileNotFound();\n+                }\n+\n+                if (reader == null) {\n+                    Thread.sleep(delay);\n+                }\n+            }\n+\n+            // The current position in the file\n+            position = end ? file.length() : 0;\n+            last = System.currentTimeMillis();\n+            reader.seek(position);\n+\n+            while (run) {\n+\n+                // Check the file length to see if it was rotated\n+                long length = file.length();\n+\n+                if (length < position) {\n+\n+                    // File was rotated\n+                    listener.fileRotated();\n+\n+                    // Reopen the reader after rotation\n+                    try {\n+                        reader = new RandomAccessFile(file, \"r\");\n+                        position = 0;\n+                    } catch (FileNotFoundException e) {\n+                        listener.fileNotFound();\n+                    }\n+                    continue;\n+                } else {\n+\n+                    // File was not rotated\n+\n+                    // See if the file needs to be read again\n+                    if (length > position) {\n+\n+                        // The file has more content than it did last time\n+                        readLines();\n+\n+                    } else if (FileUtils.isFileNewer(file, last)) {\n+\n+                        /* This can happen if the file is truncated or overwritten\n+                         * with the exact same length of information. In cases like\n+                         * this, the file position needs to be reset\n+                         */\n+                        position = 0;\n+                        reader.seek(position);\n+\n+                        // Now we can read new lines\n+                        readLines();\n+                    }\n+                }\n+\n+                Thread.sleep(delay);\n+            }\n+\n+        } catch (Exception e) {\n+\n+            listener.handle(e);\n+\n+        }\n+    }\n\\ No newline at end of file\n"
		}
	},
	"sha": "559de2c461e94ab636c959149c775bb27111fb48"
}