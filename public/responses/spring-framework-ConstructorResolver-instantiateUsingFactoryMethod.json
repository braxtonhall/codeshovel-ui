{
	"repo": "https://github.com/spring-projects/spring-framework.git",
	"file": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
	"method": {
		"longName": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs);",
		"startLine": 360,
		"methodName": "instantiateUsingFactoryMethod",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"1603c4ab2fc49d1bd65f55e35ca899044835ca94": {
			"type": "Ybodychange",
			"commitMessage": "Programmatic ObjectProvider retrieval through BeanFactory API\n\nIntroduces getBeanProvider(Class) and getBeanProvider(ResolvableType), also narrowing getBean(String, Class) and isTypeMatch(String, Class) to a non-null Class argument and enriching NoUniqueBeanDefinitionException with a full ResolvableType. In addition, ObjectProvider supports iterable/stream access for collection-style resolution of multiple matching beans now, and collection injection falls back to an empty collection in a single-constructor case with non-null arguments.\n\nIssue: SPR-17075\nIssue: SPR-11419\nIssue: SPR-15338\n",
			"commitDate": "2018-07-23, 3:42 PM",
			"commitName": "1603c4ab2fc49d1bd65f55e35ca899044835ca94",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2018-06-28, 1:28 AM",
			"commitNameOld": "0b53c1096af41ed25e8a5f9bd3f194f4d4f8513d",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 25.59,
			"commitsBetweenForRepo": 198,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,238 +1,238 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass<?> factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n-\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n+\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve, true);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n \t\t\tList<Method> candidateSet = new ArrayList<>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[0]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tif (mbd.hasConstructorArgumentValues()) {\n \t\t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tminNrOfArgs = 0;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tLinkedList<UnsatisfiedDependencyException> causes = null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (explicitArgs != null){\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\targsHolder = createArgumentArray(\n-\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n+\t\t\t\t\t\t\targsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw,\n+\t\t\t\t\t\t\t\t\tparamTypes, paramNames, candidate, autowiring, candidates.length == 1);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\tcauses = new LinkedList<>();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() &&\n \t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterCount() &&\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tif (causes != null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex = causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList<String> argTypes = new ArrayList<>(minNrOfArgs);\n \t\t\t\tif (explicitArgs != null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse if (resolvedValues != null){\n \t\t\t\t\tSet<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs > 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class == factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () ->\n \t\t\t\t\t\tthis.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, fb, factoryMethod, args),\n \t\t\t\t\t\tthis.beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0b53c1096af41ed25e8a5f9bd3f194f4d4f8513d": {
			"type": "Ybodychange",
			"commitMessage": "Always use 'this.' when accessing fields\n\nEnsure that `this.` is used consistently when accessing class\nfields.\n\nIssue: SPR-16968\n",
			"commitDate": "2018-06-28, 1:28 AM",
			"commitName": "0b53c1096af41ed25e8a5f9bd3f194f4d4f8513d",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2018-05-29, 12:51 PM",
			"commitNameOld": "74fcdea2d96e6c88d232c487e6e2ca6b9978773a",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 29.53,
			"commitsBetweenForRepo": 120,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,238 +1,238 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass<?> factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n \t\t\tList<Method> candidateSet = new ArrayList<>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[0]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tif (mbd.hasConstructorArgumentValues()) {\n \t\t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tminNrOfArgs = 0;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tLinkedList<UnsatisfiedDependencyException> causes = null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (explicitArgs != null){\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\tcauses = new LinkedList<>();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() &&\n \t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterCount() &&\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tif (causes != null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex = causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList<String> argTypes = new ArrayList<>(minNrOfArgs);\n \t\t\t\tif (explicitArgs != null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse if (resolvedValues != null){\n \t\t\t\t\tSet<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs > 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class == factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () ->\n-\t\t\t\t\t\tbeanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),\n-\t\t\t\t\t\tbeanFactory.getAccessControlContext());\n+\t\t\t\t\t\tthis.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, fb, factoryMethod, args),\n+\t\t\t\t\t\tthis.beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"74fcdea2d96e6c88d232c487e6e2ca6b9978773a": {
			"type": "Ybodychange",
			"commitMessage": "SimpleAliasRegistry logs info message for alias overriding\n\nIssue: SPR-16871\n",
			"commitDate": "2018-05-29, 12:51 PM",
			"commitName": "74fcdea2d96e6c88d232c487e6e2ca6b9978773a",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2018-02-25, 4:14 AM",
			"commitNameOld": "c782075a13596a20eb3877cced2421b40246392e",
			"commitAuthorOld": "igor-suhorukov",
			"daysBetweenCommits": 93.32,
			"commitsBetweenForRepo": 476,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,239 +1,238 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass<?> factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n \t\t\tList<Method> candidateSet = new ArrayList<>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[0]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tif (mbd.hasConstructorArgumentValues()) {\n \t\t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tminNrOfArgs = 0;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tLinkedList<UnsatisfiedDependencyException> causes = null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (explicitArgs != null){\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n-\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n-\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n-\t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n+\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n+\t\t\t\t\t\t\t\tlogger.trace(\"Ignoring factory method [\" + candidate + \"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\tcauses = new LinkedList<>();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() &&\n \t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterCount() &&\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tif (causes != null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex = causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList<String> argTypes = new ArrayList<>(minNrOfArgs);\n \t\t\t\tif (explicitArgs != null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse if (resolvedValues != null){\n \t\t\t\t\tSet<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs > 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class == factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () ->\n \t\t\t\t\t\tbeanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),\n \t\t\t\t\t\tbeanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a5cbf5fe246e362c939db006cb44793b22bdc741": {
			"type": "Ybodychange",
			"commitMessage": "Consistent use of Collection.toArray with zero-sized array argument\n\nIncludes consistent use of ClassUtils.toClassArray (as non-null variant)\n\nIssue: SPR-16523\n",
			"commitDate": "2018-02-22, 2:29 AM",
			"commitName": "a5cbf5fe246e362c939db006cb44793b22bdc741",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2017-11-13, 12:51 PM",
			"commitNameOld": "b5cedd43eb2b70510729696554bbc1f99003ac10",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 100.57,
			"commitsBetweenForRepo": 420,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,239 +1,239 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass<?> factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n \t\t\tList<Method> candidateSet = new ArrayList<>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n-\t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n+\t\t\tMethod[] candidates = candidateSet.toArray(new Method[0]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tif (mbd.hasConstructorArgumentValues()) {\n \t\t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tminNrOfArgs = 0;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tLinkedList<UnsatisfiedDependencyException> causes = null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (explicitArgs != null){\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\tcauses = new LinkedList<>();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() &&\n \t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterCount() &&\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tif (causes != null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex = causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList<String> argTypes = new ArrayList<>(minNrOfArgs);\n \t\t\t\tif (explicitArgs != null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse if (resolvedValues != null){\n \t\t\t\t\tSet<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs > 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class == factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () ->\n \t\t\t\t\t\tbeanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),\n \t\t\t\t\t\tbeanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b5cedd43eb2b70510729696554bbc1f99003ac10": {
			"type": "Ybodychange",
			"commitMessage": "Consistent and efficient access to BeanDefinition argument values\n\nIssue: SPR-16192\n",
			"commitDate": "2017-11-13, 12:51 PM",
			"commitName": "b5cedd43eb2b70510729696554bbc1f99003ac10",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2017-09-27, 3:31 PM",
			"commitNameOld": "ec345bf162285e397df774bdc2ad756e3aba155a",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 46.93,
			"commitsBetweenForRepo": 241,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,235 +1,239 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass<?> factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n \t\t\tList<Method> candidateSet = new ArrayList<>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n-\t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n-\t\t\t\tresolvedValues = new ConstructorArgumentValues();\n-\t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n+\t\t\t\tif (mbd.hasConstructorArgumentValues()) {\n+\t\t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n+\t\t\t\t\tresolvedValues = new ConstructorArgumentValues();\n+\t\t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tminNrOfArgs = 0;\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tLinkedList<UnsatisfiedDependencyException> causes = null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n-\t\t\t\t\tif (resolvedValues != null) {\n+\t\t\t\t\tif (explicitArgs != null){\n+\t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n+\t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\tcauses = new LinkedList<>();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n-\t\t\t\t\telse {\n-\t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n-\t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n-\t\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n-\t\t\t\t\t}\n-\n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() &&\n \t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterCount() &&\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tif (causes != null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex = causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList<String> argTypes = new ArrayList<>(minNrOfArgs);\n \t\t\t\tif (explicitArgs != null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\telse {\n+\t\t\t\telse if (resolvedValues != null){\n \t\t\t\t\tSet<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs > 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class == factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () ->\n \t\t\t\t\t\tbeanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),\n \t\t\t\t\t\tbeanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b94302b5bde7475b9926dacb9fb69f3c8c894444": {
			"type": "Ybodychange",
			"commitMessage": "Enforce non-null value from getBean and at injection points\n\nBean-derived null values may still get passed into bean properties and injection points but only if those are declared as non-required. Note that getBean will never return null; a manual bean.equals(null) / \"null\".equals(bean.toString()) check identifies expected null values now.  This will only ever happen with custom FactoryBeans or factory methods returning null - and since all common cases are handled by autowiring or bean property values in bean definitions, there should be no need to ever manually check for such a null value received from getBean.\n\nIssue: SPR-15829\n",
			"commitDate": "2017-08-17, 3:11 PM",
			"commitName": "b94302b5bde7475b9926dacb9fb69f3c8c894444",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2017-06-07, 5:19 AM",
			"commitNameOld": "f813712f5b413b354560cd7cc006352e9defa9a3",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 71.41,
			"commitsBetweenForRepo": 370,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,238 +1,235 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass<?> factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n \t\t\tList<Method> candidateSet = new ArrayList<>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tLinkedList<UnsatisfiedDependencyException> causes = null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\tcauses = new LinkedList<>();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() &&\n \t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterCount() &&\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tif (causes != null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex = causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList<String> argTypes = new ArrayList<>(minNrOfArgs);\n \t\t\t\tif (explicitArgs != null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs > 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class == factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () ->\n \t\t\t\t\t\tbeanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),\n \t\t\t\t\t\tbeanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n-\t\t\tif (beanInstance == null) {\n-\t\t\t\treturn null;\n-\t\t\t}\n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f813712f5b413b354560cd7cc006352e9defa9a3": {
			"type": "Ybodychange",
			"commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
			"commitDate": "2017-06-07, 5:19 AM",
			"commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2017-05-31, 12:42 PM",
			"commitNameOld": "1f28825f9da63a13aaf8940aadedcf81358dc506",
			"commitAuthorOld": "Sebastien Deleuze",
			"daysBetweenCommits": 6.69,
			"commitsBetweenForRepo": 26,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,246 +1,238 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass<?> factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n-\t\t\tif (factoryBean == null) {\n-\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n-\t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n-\t\t\t}\n \t\t\tif (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n \t\t\tList<Method> candidateSet = new ArrayList<>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tLinkedList<UnsatisfiedDependencyException> causes = null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\tcauses = new LinkedList<>();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() &&\n \t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterCount() &&\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tif (causes != null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex = causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList<String> argTypes = new ArrayList<>(minNrOfArgs);\n \t\t\t\tif (explicitArgs != null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs > 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class == factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n-\t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic Object run() {\n-\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n-\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n-\t\t\t\t\t}\n-\t\t\t\t}, beanFactory.getAccessControlContext());\n+\t\t\t\tbeanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () ->\n+\t\t\t\t\t\tbeanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),\n+\t\t\t\t\t\tbeanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"87598f48e41d483745aba56cbf4e998c6f6d680c": {
			"type": "Yparametermetachange",
			"commitMessage": "Introduce null-safety of Spring Framework API\n\nThis commit introduces 2 new @Nullable and @NonNullApi\nannotations that leverage JSR 305 (dormant but available via\nFindbugs jsr305 dependency and already used by libraries\nlike OkHttp) meta-annotations to specify explicitly\nnull-safety of Spring Framework parameters and return values.\n\nIn order to avoid adding too much annotations, the\ndefault is set at package level with @NonNullApi and\n@Nullable annotations are added when needed at parameter or\nreturn value level. These annotations are intended to be used\non Spring Framework itself but also by other Spring projects.\n\n@Nullable annotations have been introduced based on Javadoc\nand search of patterns like \"return null;\". It is expected that\nnullability of Spring Framework API will be polished with\ncomplementary commits.\n\nIn practice, this will make the whole Spring Framework API\nnull-safe for Kotlin projects (when KT-10942 will be fixed)\nsince Kotlin will be able to leverage these annotations to\nknow if a parameter or a return value is nullable or not. But\nthis is also useful for Java developers as well since IntelliJ\nIDEA, for example, also understands these annotations to\ngenerate warnings when unsafe nullable usages are detected.\n\nIssue: SPR-15540\n",
			"commitDate": "2017-05-26, 11:57 PM",
			"commitName": "87598f48e41d483745aba56cbf4e998c6f6d680c",
			"commitAuthor": "Sebastien Deleuze",
			"commitDateOld": "2016-11-07, 9:00 AM",
			"commitNameOld": "cf479bf893df758b54f1a7117a7eae9a32728ab7",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 200.58,
			"commitsBetweenForRepo": 1145,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,246 +1,246 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n-\t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n+\t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass<?> factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n \t\t\tif (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n \t\t\tList<Method> candidateSet = new ArrayList<>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tLinkedList<UnsatisfiedDependencyException> causes = null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\tcauses = new LinkedList<>();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() &&\n \t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterCount() &&\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tif (causes != null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex = causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList<String> argTypes = new ArrayList<>(minNrOfArgs);\n \t\t\t\tif (explicitArgs != null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs > 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class == factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[beanName-String(modifiers-final), mbd-RootBeanDefinition(modifiers-final), explicitArgs-Object[](modifiers-final)]",
				"newValue": "[beanName-String(modifiers-final), mbd-RootBeanDefinition(modifiers-final), explicitArgs-Object[](annotations-@Nullable__modifiers-final)]"
			}
		},
		"cf479bf893df758b54f1a7117a7eae9a32728ab7": {
			"type": "Ybodychange",
			"commitMessage": "Consistent throwing of BeanCreationExceptions (and reflection exceptions)\n\nIssue: SPR-14883\n(cherry picked from commit b42d731)\n",
			"commitDate": "2016-11-07, 9:00 AM",
			"commitName": "cf479bf893df758b54f1a7117a7eae9a32728ab7",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2016-07-24, 6:34 AM",
			"commitNameOld": "ed49ce838ee00df24e6aa89892ee168761c206d2",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 106.14,
			"commitsBetweenForRepo": 539,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,247 +1,246 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass<?> factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n \t\t\tif (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n-\t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n-\t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n+\t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n \t\t\tList<Method> candidateSet = new ArrayList<>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tLinkedList<UnsatisfiedDependencyException> causes = null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\tcauses = new LinkedList<>();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() &&\n \t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterCount() &&\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tif (causes != null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex = causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList<String> argTypes = new ArrayList<>(minNrOfArgs);\n \t\t\t\tif (explicitArgs != null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs > 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class == factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"39e3f2ebf6690b72b7a8af852a35df6ff6229515": {
			"type": "Ybodychange",
			"commitMessage": "MethodParameter supports Java 8 Executable/Parameter and validates parameter indexes\n\nAlso, equals insists on the same class now, differentiating from SynthesizingMethodParameter.\n\nIssue: SPR-14055\nIssue: SPR-13456\nIssue: SPR-14438\n",
			"commitDate": "2016-07-06, 3:37 PM",
			"commitName": "39e3f2ebf6690b72b7a8af852a35df6ff6229515",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2016-07-05, 8:00 AM",
			"commitNameOld": "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
			"commitAuthorOld": "Stephane Nicoll",
			"daysBetweenCommits": 1.32,
			"commitsBetweenForRepo": 17,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,247 +1,247 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass<?> factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n \t\t\tif (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n \t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n \t\t\tList<Method> candidateSet = new ArrayList<>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tLinkedList<UnsatisfiedDependencyException> causes = null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\tcauses = new LinkedList<>();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() &&\n-\t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterTypes().length &&\n+\t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterCount() &&\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tif (causes != null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex = causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList<String> argTypes = new ArrayList<>(minNrOfArgs);\n \t\t\t\tif (explicitArgs != null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs > 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class == factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"00d2606b000f9bdafbd7f4a16b6599fb51b53fa4": {
			"type": "Ybodychange",
			"commitMessage": "Explicit type can be replaced by <>\n\nIssue: SPR-13188\n",
			"commitDate": "2016-07-05, 8:00 AM",
			"commitName": "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
			"commitAuthor": "Stephane Nicoll",
			"commitDateOld": "2016-04-07, 5:18 AM",
			"commitNameOld": "5c1d3fca15d9c020a07a0130a3992926d7087f1a",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 89.11,
			"commitsBetweenForRepo": 357,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,247 +1,247 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass<?> factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n \t\t\tif (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n \t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n-\t\t\tList<Method> candidateSet = new ArrayList<Method>();\n+\t\t\tList<Method> candidateSet = new ArrayList<>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tLinkedList<UnsatisfiedDependencyException> causes = null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes == null) {\n-\t\t\t\t\t\t\t\tcauses = new LinkedList<UnsatisfiedDependencyException>();\n+\t\t\t\t\t\t\t\tcauses = new LinkedList<>();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() &&\n \t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterTypes().length &&\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n-\t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n+\t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tif (causes != null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex = causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n-\t\t\t\tList<String> argTypes = new ArrayList<String>(minNrOfArgs);\n+\t\t\t\tList<String> argTypes = new ArrayList<>(minNrOfArgs);\n \t\t\t\tif (explicitArgs != null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tSet<ValueHolder> valueHolders = new LinkedHashSet<ValueHolder>(resolvedValues.getArgumentCount());\n+\t\t\t\t\tSet<ValueHolder> valueHolders = new LinkedHashSet<>(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs > 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class == factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5c1d3fca15d9c020a07a0130a3992926d7087f1a": {
			"type": "Ybodychange",
			"commitMessage": "BeanFactory does not unwrap java.util.Optional for top-level bean\n\nIssue: SPR-14121\n",
			"commitDate": "2016-04-07, 5:18 AM",
			"commitName": "5c1d3fca15d9c020a07a0130a3992926d7087f1a",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2016-03-18, 10:51 AM",
			"commitNameOld": "431ca9314af6929a53b177640522323602e6d224",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 19.77,
			"commitsBetweenForRepo": 116,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,247 +1,247 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass<?> factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n \t\t\tif (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n \t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tLinkedList<UnsatisfiedDependencyException> causes = null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\tcauses = new LinkedList<UnsatisfiedDependencyException>();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() &&\n \t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterTypes().length &&\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tif (causes != null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex = causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList<String> argTypes = new ArrayList<String>(minNrOfArgs);\n \t\t\t\tif (explicitArgs != null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet<ValueHolder> valueHolders = new LinkedHashSet<ValueHolder>(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs > 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class == factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n-\t\t\tbw.setWrappedInstance(beanInstance);\n+\t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b944283354f0f340ffc7ec74b430d79703a4294a": {
			"type": "Ybodychange",
			"commitMessage": "ConstructorResolver exposes parameter signature from user-declared class (in case of a CGLIB-generated subclass)\n\nIssue: SPR-14015\n",
			"commitDate": "2016-03-11, 3:52 AM",
			"commitName": "b944283354f0f340ffc7ec74b430d79703a4294a",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2016-02-26, 3:31 AM",
			"commitNameOld": "8a83af55b8adf833683b8d9a6924eecf69709a12",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 14.02,
			"commitsBetweenForRepo": 63,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,248 +1,247 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass<?> factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n \t\t\tif (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n \t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tLinkedList<UnsatisfiedDependencyException> causes = null;\n \n-\t\t\tfor (int i = 0; i < candidates.length; i++) {\n-\t\t\t\tMethod candidate = candidates[i];\n+\t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\tcauses = new LinkedList<UnsatisfiedDependencyException>();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() &&\n \t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterTypes().length &&\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tif (causes != null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex = causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList<String> argTypes = new ArrayList<String>(minNrOfArgs);\n \t\t\t\tif (explicitArgs != null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet<ValueHolder> valueHolders = new LinkedHashSet<ValueHolder>(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs > 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class == factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8a83af55b8adf833683b8d9a6924eecf69709a12": {
			"type": "Ybodychange",
			"commitMessage": "Consistent resolution of factory method exceptions\n\nIssue: SPR-13985\n",
			"commitDate": "2016-02-26, 3:31 AM",
			"commitName": "8a83af55b8adf833683b8d9a6924eecf69709a12",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2016-02-25, 12:36 PM",
			"commitNameOld": "b6dd8a923365f021af636705e652a725e1cf0ebe",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 0.62,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,251 +1,248 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass<?> factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n \t\t\tif (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n \t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n-\t\t\tList<Exception> causes = null;\n+\t\t\tLinkedList<UnsatisfiedDependencyException> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tif (i == candidates.length - 1 && argsHolderToUse == null) {\n-\t\t\t\t\t\t\t\tif (causes != null) {\n-\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n-\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tthrow ex;\n+\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n+\t\t\t\t\t\t\tif (causes == null) {\n+\t\t\t\t\t\t\t\tcauses = new LinkedList<UnsatisfiedDependencyException>();\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n-\t\t\t\t\t\t\t\tif (causes == null) {\n-\t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tcauses.add(ex);\n-\t\t\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcauses.add(ex);\n+\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() &&\n \t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterTypes().length &&\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n+\t\t\t\tif (causes != null) {\n+\t\t\t\t\tUnsatisfiedDependencyException ex = causes.removeLast();\n+\t\t\t\t\tfor (Exception cause : causes) {\n+\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n+\t\t\t\t\t}\n+\t\t\t\t\tthrow ex;\n+\t\t\t\t}\n \t\t\t\tList<String> argTypes = new ArrayList<String>(minNrOfArgs);\n \t\t\t\tif (explicitArgs != null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet<ValueHolder> valueHolders = new LinkedHashSet<ValueHolder>(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs > 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class == factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c": {
			"type": "Ybodychange",
			"commitMessage": "Class identity comparisons wherever possible\n\nIssue: SPR-12926\n",
			"commitDate": "2015-05-20, 5:34 AM",
			"commitName": "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2014-12-23, 8:35 AM",
			"commitNameOld": "d55af2b445cd3b1c08a7038de4db8e903c36083f",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 147.83,
			"commitsBetweenForRepo": 632,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,251 +1,251 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass<?> factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n \t\t\tif (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n \t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && argsHolderToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() &&\n \t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterTypes().length &&\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tList<String> argTypes = new ArrayList<String>(minNrOfArgs);\n \t\t\t\tif (explicitArgs != null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet<ValueHolder> valueHolders = new LinkedHashSet<ValueHolder>(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs > 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n-\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n+\t\t\telse if (void.class == factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ad62b2afb145499d384cb76c5f254113db99796c": {
			"type": "Ybodychange",
			"commitMessage": "Consistent throwing of BeanInstantiationException for factory methods, including a hint about circular references\n\nIssue: SPR-12317\n",
			"commitDate": "2014-10-21, 12:40 PM",
			"commitName": "ad62b2afb145499d384cb76c5f254113db99796c",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2014-09-02, 1:13 PM",
			"commitNameOld": "8c9274e01743a87d7fb8519f7772c1b1677ecbe0",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 48.98,
			"commitsBetweenForRepo": 255,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,250 +1,251 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass<?> factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n \t\t\tif (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n \t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && argsHolderToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() &&\n \t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterTypes().length &&\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tList<String> argTypes = new ArrayList<String>(minNrOfArgs);\n \t\t\t\tif (explicitArgs != null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet<ValueHolder> valueHolders = new LinkedHashSet<ValueHolder>(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs > 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n-\t\t\t\tbeanInstance = beanFactory.getInstantiationStrategy().instantiate(\n-\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n+\t\t\t\tbeanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n+\t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n-\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n+\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n+\t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8c9274e01743a87d7fb8519f7772c1b1677ecbe0": {
			"type": "Ybodychange",
			"commitMessage": "LazyInitTargetSource works for @Bean targets as well\n\nIssue: SPR-10508\nIssue: SPR-8080\n",
			"commitDate": "2014-09-02, 1:13 PM",
			"commitName": "8c9274e01743a87d7fb8519f7772c1b1677ecbe0",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2014-07-04, 1:30 PM",
			"commitNameOld": "6c41cc354c1e6575ff5f56147c3fcbe5b52c2e9b",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 59.99,
			"commitsBetweenForRepo": 375,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,246 +1,250 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass<?> factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n+\t\t\tif (mbd.isSingleton() && this.beanFactory.containsSingleton(beanName)) {\n+\t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n+\t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n+\t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && argsHolderToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() &&\n \t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterTypes().length &&\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tList<String> argTypes = new ArrayList<String>(minNrOfArgs);\n \t\t\t\tif (explicitArgs != null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet<ValueHolder> valueHolders = new LinkedHashSet<ValueHolder>(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs > 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6c41cc354c1e6575ff5f56147c3fcbe5b52c2e9b": {
			"type": "Ybodychange",
			"commitMessage": "ConstructorResolver's exception message on null factory-bean hints at potential BeanPostProcessor involvement\n\nIssue: SPR-11951\n",
			"commitDate": "2014-07-04, 1:30 PM",
			"commitName": "6c41cc354c1e6575ff5f56147c3fcbe5b52c2e9b",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2014-03-05, 7:16 AM",
			"commitNameOld": "ad317774fb8e0b1f70e0135e5786c94c2521fb73",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 121.22,
			"commitsBetweenForRepo": 647,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,246 +1,246 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass<?> factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n-\t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n+\t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && argsHolderToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() &&\n \t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterTypes().length &&\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tList<String> argTypes = new ArrayList<String>(minNrOfArgs);\n \t\t\t\tif (explicitArgs != null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet<ValueHolder> valueHolders = new LinkedHashSet<ValueHolder>(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs > 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ad317774fb8e0b1f70e0135e5786c94c2521fb73": {
			"type": "Ybodychange",
			"commitMessage": "instantiateUsingFactoryMethod avoids NPE and reports argument types in case of explicitArgs and resolved generic arguments as well\n\nIssue: SPR-11517\n",
			"commitDate": "2014-03-05, 7:16 AM",
			"commitName": "ad317774fb8e0b1f70e0135e5786c94c2521fb73",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2014-02-12, 4:08 PM",
			"commitNameOld": "ce39146be8889409898264b8a9389d3d1f0d4258",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 20.63,
			"commitsBetweenForRepo": 93,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,240 +1,246 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass<?> factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && argsHolderToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() &&\n \t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterTypes().length &&\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n-\t\t\t\tboolean hasArgs = (resolvedValues.getArgumentCount() > 0);\n-\t\t\t\tString argDesc = \"\";\n-\t\t\t\tif (hasArgs) {\n-\t\t\t\t\tList<String> argTypes = new ArrayList<String>();\n-\t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n-\t\t\t\t\t\tString argType = (value.getType() != null ?\n-\t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n+\t\t\t\tList<String> argTypes = new ArrayList<String>(minNrOfArgs);\n+\t\t\t\tif (explicitArgs != null) {\n+\t\t\t\t\tfor (Object arg : explicitArgs) {\n+\t\t\t\t\t\targTypes.add(arg != null ? arg.getClass().getSimpleName() : \"null\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tSet<ValueHolder> valueHolders = new LinkedHashSet<ValueHolder>(resolvedValues.getArgumentCount());\n+\t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n+\t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n+\t\t\t\t\tfor (ValueHolder value : valueHolders) {\n+\t\t\t\t\t\tString argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :\n+\t\t\t\t\t\t\t\t(value.getValue() != null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n-\t\t\t\t\targDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\t}\n+\t\t\t\tString argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n-\t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n+\t\t\t\t\t\t(minNrOfArgs > 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"603cdea26e0880a46c697194bf5f1cbe60177f16": {
			"type": "Ybodychange",
			"commitMessage": "resolveFactoryMethodIfPossible considers nonPublicAccessAllowed and SecurityManager\n\nIssue: SPR-11422\n",
			"commitDate": "2014-02-12, 2:48 PM",
			"commitName": "603cdea26e0880a46c697194bf5f1cbe60177f16",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2013-11-25, 12:52 PM",
			"commitNameOld": "59002f245623d758765b72d598cd78c326c6f5fa",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 79.08,
			"commitsBetweenForRepo": 450,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,255 +1,240 @@\n-\tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n+\tpublic BeanWrapper instantiateUsingFactoryMethod(\n+\t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n+\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass<?> factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n-\t\t\tMethod[] rawCandidates;\n \n-\t\t\tfinal Class<?> factoryClazz = factoryClass;\n-\t\t\tif (System.getSecurityManager() != null) {\n-\t\t\t\trawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic Method[] run() {\n-\t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n-\t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\trawCandidates = (mbd.isNonPublicAccessAllowed() ?\n-\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n-\t\t\t}\n-\n+\t\t\tMethod[] rawCandidates = getCandidateMethods(factoryClass, mbd);\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n-\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n-\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n-\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n+\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && argsHolderToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() &&\n \t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterTypes().length &&\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tboolean hasArgs = (resolvedValues.getArgumentCount() > 0);\n \t\t\t\tString argDesc = \"\";\n \t\t\t\tif (hasArgs) {\n \t\t\t\t\tList<String> argTypes = new ArrayList<String>();\n \t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n \t\t\t\t\t\tString argType = (value.getType() != null ?\n \t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t\targDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\t}\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b093b8495416cd3f05a32add1c671174341bd595": {
			"type": "Ybodychange",
			"commitMessage": "Use non-lenient constructor resolution mode for @Bean methods\n\nSince @Bean methods are never used with externally specified constructor argument values but rather just with autowiring, the non-lenient constructor resolution mode is appropriate in case of an overloaded @Bean method, not performing any type difference weight checks. This change includes a refinement of Spring's existing non-lenient constructor resolution (which needs to be explicitly turned on and is therefore not well tested), narrowing the conditions for the ambiguity check (only in case of the same number of arguments and not for overridden methods).\n\nIssue: SPR-10988\n",
			"commitDate": "2013-11-03, 3:19 PM",
			"commitName": "b093b8495416cd3f05a32add1c671174341bd595",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2013-05-13, 3:04 PM",
			"commitNameOld": "94685481162a93666fc2f39b66223833a6bcb418",
			"commitAuthorOld": "Rob Winch",
			"daysBetweenCommits": 174.05,
			"commitsBetweenForRepo": 656,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,247 +1,255 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n-\t\tClass factoryClass;\n+\t\tClass<?> factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates;\n \n-\t\t\tfinal Class factoryClazz = factoryClass;\n+\t\t\tfinal Class<?> factoryClazz = factoryClass;\n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\trawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Method[] run() {\n \t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}\n \t\t\telse {\n \t\t\t\trawCandidates = (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t}\n \n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n-\t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n+\t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && argsHolderToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n-\t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n+\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n+\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n+\t\t\t\t\t// and eventually raise an ambiguity exception.\n+\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n+\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n+\t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight &&\n+\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() &&\n+\t\t\t\t\t\t\tparamTypes.length == factoryMethodToUse.getParameterTypes().length &&\n+\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tboolean hasArgs = (resolvedValues.getArgumentCount() > 0);\n \t\t\t\tString argDesc = \"\";\n \t\t\t\tif (hasArgs) {\n \t\t\t\t\tList<String> argTypes = new ArrayList<String>();\n \t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n \t\t\t\t\t\tString argType = (value.getType() != null ?\n \t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t\targDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\t}\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n-\t\t\telse if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n+\t\t\telse if (ambiguousFactoryMethods != null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"94685481162a93666fc2f39b66223833a6bcb418": {
			"type": "Ybodychange",
			"commitMessage": "Add @Override to remaining source files\n\nIssue: SPR-10130\n",
			"commitDate": "2013-05-13, 3:04 PM",
			"commitName": "94685481162a93666fc2f39b66223833a6bcb418",
			"commitAuthor": "Rob Winch",
			"commitDateOld": "2013-02-04, 10:35 AM",
			"commitNameOld": "f464a45ba481ff3e960ad3dd8b5edd4464a46289",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 98.15,
			"commitsBetweenForRepo": 366,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,245 +1,247 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates;\n \n \t\t\tfinal Class factoryClazz = factoryClass;\n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\trawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n+\t\t\t\t\t@Override\n \t\t\t\t\tpublic Method[] run() {\n \t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}\n \t\t\telse {\n \t\t\t\trawCandidates = (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t}\n \n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && argsHolderToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tboolean hasArgs = (resolvedValues.getArgumentCount() > 0);\n \t\t\t\tString argDesc = \"\";\n \t\t\t\tif (hasArgs) {\n \t\t\t\t\tList<String> argTypes = new ArrayList<String>();\n \t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n \t\t\t\t\t\tString argType = (value.getType() != null ?\n \t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t\targDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\t}\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n+\t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"02a4473c62d8240837bec297f0a1f3cb67ef8a7b": {
			"type": "Yfilerename",
			"commitMessage": "Rename modules {org.springframework.*=>spring-*}\n\nThis renaming more intuitively expresses the relationship between\nsubprojects and the JAR artifacts they produce.\n\nTracking history across these renames is possible, but it requires\nuse of the --follow flag to `git log`, for example\n\n    $ git log spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history up until the renaming event, where\n\n    $ git log --follow spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history for all changes to the file, before and after the\nrenaming.\n\nSee http://chrisbeams.com/git-diff-across-renamed-directories\n",
			"commitDate": "2012-01-31, 5:37 AM",
			"commitName": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2012-01-31, 5:37 AM",
			"commitNameOld": "b6cb514d383dcef52ba6c609a863f19e1a4c1faf",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
				"newPath": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java"
			}
		},
		"061063257ab8e16786d04eaddb5b5aba61dcd7f1": {
			"type": "Ybodychange",
			"commitMessage": "optimized @Bean error messages (SPR-7628, SPR-7629)\n",
			"commitDate": "2010-10-10, 11:31 AM",
			"commitName": "061063257ab8e16786d04eaddb5b5aba61dcd7f1",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2010-08-19, 2:30 AM",
			"commitNameOld": "a9da12325995ab03cef56e8f51870081e36a3c9e",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 52.38,
			"commitsBetweenForRepo": 107,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,245 +1,245 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates;\n \n \t\t\tfinal Class factoryClazz = factoryClass;\n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\trawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n \t\t\t\t\tpublic Method[] run() {\n \t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}\n \t\t\telse {\n \t\t\t\trawCandidates = (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t}\n \t\t\t\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n+\t\t\t\t\t\t\tif (i == candidates.length - 1 && argsHolderToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tboolean hasArgs = (resolvedValues.getArgumentCount() > 0);\n \t\t\t\tString argDesc = \"\";\n \t\t\t\tif (hasArgs) {\n \t\t\t\t\tList<String> argTypes = new ArrayList<String>();\n \t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n \t\t\t\t\t\tString argType = (value.getType() != null ?\n \t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t\targDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\t}\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n-\t\t\tif (explicitArgs == null) {\n+\t\t\tif (explicitArgs == null && argsHolderToUse != null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \t\t\t\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a9da12325995ab03cef56e8f51870081e36a3c9e": {
			"type": "Ybodychange",
			"commitMessage": "temporarily disabled constructor argument caching for converted values (SPR-7423)\n",
			"commitDate": "2010-08-19, 2:30 AM",
			"commitName": "a9da12325995ab03cef56e8f51870081e36a3c9e",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2010-08-18, 2:08 AM",
			"commitNameOld": "9857ba077b16312e78ca6dcf2a219326955daae5",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 1.01,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,245 +1,245 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve = null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse == null) {\n \t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve != null) {\n \t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates;\n \n \t\t\tfinal Class factoryClazz = factoryClass;\n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\trawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n \t\t\t\t\tpublic Method[] run() {\n \t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}\n \t\t\telse {\n \t\t\t\trawCandidates = (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t}\n \t\t\t\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n-\t\t\t\tboolean hasArgs  = resolvedValues.getArgumentCount() > 0;\n+\t\t\t\tboolean hasArgs = (resolvedValues.getArgumentCount() > 0);\n \t\t\t\tString argDesc = \"\";\n \t\t\t\tif (hasArgs) {\n \t\t\t\t\tList<String> argTypes = new ArrayList<String>();\n \t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n-\t\t\t\t\t\tString argType = value.getType() != null ?\n-\t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName();\n+\t\t\t\t\t\tString argType = (value.getType() != null ?\n+\t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t\targDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\t}\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \t\t\t\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9857ba077b16312e78ca6dcf2a219326955daae5": {
			"type": "Ybodychange",
			"commitMessage": "revised constructor argument caching for highly concurrent creation scenarios (follow-up to SPR-7423)\n",
			"commitDate": "2010-08-18, 2:08 AM",
			"commitName": "9857ba077b16312e78ca6dcf2a219326955daae5",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2010-08-11, 12:24 PM",
			"commitNameOld": "8a23ce917afb6cd19996508521a27f8ea97db29d",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 6.57,
			"commitsBetweenForRepo": 38,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,240 +1,245 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n-\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n-\t\t\tif (factoryMethodToUse != null) {\n-\t\t\t\t// Found a cached factory method...\n-\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n-\t\t\t\tif (argsToUse == null && mbd.preparedConstructorArguments != null) {\n-\t\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n+\t\t\tObject[] argsToResolve = null;\n+\t\t\tsynchronized (mbd.constructorArgumentLock) {\n+\t\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n+\t\t\t\tif (factoryMethodToUse != null && mbd.constructorArgumentsResolved) {\n+\t\t\t\t\t// Found a cached factory method...\n+\t\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n+\t\t\t\t\tif (argsToUse == null) {\n+\t\t\t\t\t\targsToResolve = mbd.preparedConstructorArguments;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tif (argsToResolve != null) {\n+\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n+\t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates;\n \n \t\t\tfinal Class factoryClazz = factoryClass;\n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\trawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n \t\t\t\t\tpublic Method[] run() {\n \t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}\n \t\t\telse {\n \t\t\t\trawCandidates = (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t}\n \t\t\t\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsHolderToUse = argsHolder;\n \t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tboolean hasArgs  = resolvedValues.getArgumentCount() > 0;\n \t\t\t\tString argDesc = \"\";\n \t\t\t\tif (hasArgs) {\n \t\t\t\t\tList<String> argTypes = new ArrayList<String>();\n \t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n \t\t\t\t\t\tString argType = value.getType() != null ?\n \t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName();\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t\targDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\t}\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null) {\n-\t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n-\t\t\t\targsHolderToUse.storeCache(mbd);\n+\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \t\t\t\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"12ce250c6ce911774a7983905fd6e006b5a1eac1": {
			"type": "Ybodychange",
			"commitMessage": "fixed constructor argument caching for prototypes with multiple constructor matches (SPR-7084)\n",
			"commitDate": "2010-04-14, 5:11 AM",
			"commitName": "12ce250c6ce911774a7983905fd6e006b5a1eac1",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2010-03-26, 5:05 AM",
			"commitNameOld": "351e72b6e258bd030fb21be253f6348319f81d0e",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 19,
			"commitsBetweenForRepo": 62,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,237 +1,240 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n+\t\tArgumentsHolder argsHolderToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse != null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse == null && mbd.preparedConstructorArguments != null) {\n \t\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates;\n \n \t\t\tfinal Class factoryClazz = factoryClass;\n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\trawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n \t\t\t\t\tpublic Method[] run() {\n \t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}\n \t\t\telse {\n \t\t\t\trawCandidates = (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t}\n \t\t\t\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n-\t\t\t\t\tArgumentsHolder args;\n+\t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\targs = createArgumentArray(\n+\t\t\t\t\t\t\targsHolder = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n-\t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n+\t\t\t\t\t\targsHolder = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n-\t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n+\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n-\t\t\t\t\t\targsToUse = args.arguments;\n+\t\t\t\t\t\targsHolderToUse = argsHolder;\n+\t\t\t\t\t\targsToUse = argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tboolean hasArgs  = resolvedValues.getArgumentCount() > 0;\n \t\t\t\tString argDesc = \"\";\n \t\t\t\tif (hasArgs) {\n \t\t\t\t\tList<String> argTypes = new ArrayList<String>();\n \t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n \t\t\t\t\t\tString argType = value.getType() != null ?\n \t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName();\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t\targDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\t}\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n+\t\t\t\targsHolderToUse.storeCache(mbd);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \t\t\t\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"351e72b6e258bd030fb21be253f6348319f81d0e": {
			"type": "Ybodychange",
			"commitMessage": "incorrectly invoked factory methods now result in exceptions with more descriptive messages (SPR-5475)\n",
			"commitDate": "2010-03-26, 5:05 AM",
			"commitName": "351e72b6e258bd030fb21be253f6348319f81d0e",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2010-02-15, 5:01 AM",
			"commitNameOld": "18bd4a83375a1815dbf83aca384cf7f5c27e93f5",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 38.96,
			"commitsBetweenForRepo": 176,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,224 +1,237 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse != null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse == null && mbd.preparedConstructorArguments != null) {\n \t\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates;\n \n \t\t\tfinal Class factoryClazz = factoryClass;\n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\trawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n \t\t\t\t\tpublic Method[] run() {\n \t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}\n \t\t\telse {\n \t\t\t\trawCandidates = (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t}\n \t\t\t\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsToUse = args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n+\t\t\t\tboolean hasArgs  = resolvedValues.getArgumentCount() > 0;\n+\t\t\t\tString argDesc = \"\";\n+\t\t\t\tif (hasArgs) {\n+\t\t\t\t\tList<String> argTypes = new ArrayList<String>();\n+\t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n+\t\t\t\t\t\tString argType = value.getType() != null ?\n+\t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName();\n+\t\t\t\t\t\targTypes.add(argType);\n+\t\t\t\t\t}\n+\t\t\t\t\targDesc = StringUtils.collectionToCommaDelimitedString(argTypes);\n+\t\t\t\t}\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n-\t\t\t\t\t\t \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n-\t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'. \" +\n-\t\t\t\t\t\t\"Check that a method of the specified name exists and that it is \" +\n+\t\t\t\t\t\t\t\"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n+\t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")'. \" +\n+\t\t\t\t\t\t\"Check that a method with the specified name \" +\n+\t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n+\t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \t\t\t\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"18bd4a83375a1815dbf83aca384cf7f5c27e93f5": {
			"type": "Ybodychange",
			"commitMessage": "improved \"no matching factory method found\" exception message (SPR-6837)\n",
			"commitDate": "2010-02-15, 5:01 AM",
			"commitName": "18bd4a83375a1815dbf83aca384cf7f5c27e93f5",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2010-01-20, 1:29 AM",
			"commitNameOld": "45448463b87629bdd85cb375d3faa391bfaf147f",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 26.15,
			"commitsBetweenForRepo": 139,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,222 +1,224 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse != null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse == null && mbd.preparedConstructorArguments != null) {\n \t\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates;\n \n \t\t\tfinal Class factoryClazz = factoryClass;\n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\trawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n \t\t\t\t\tpublic Method[] run() {\n \t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}\n \t\t\telse {\n \t\t\t\trawCandidates = (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t}\n \t\t\t\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsToUse = args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n-\t\t\t\t\t\t\tambiguousFactoryMethods = null;\n+\t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n-\t\t\t\t\t\tif (\tambiguousFactoryMethods == null) {\n-\t\t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n-\t\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n+\t\t\t\t\t\tif (ambiguousFactoryMethods == null) {\n+\t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n+\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n-\t\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n+\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n-\t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n+\t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'. \" +\n+\t\t\t\t\t\t\"Check that a method of the specified name exists and that it is \" +\n+\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \t\t\t\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"45448463b87629bdd85cb375d3faa391bfaf147f": {
			"type": "Ybodychange",
			"commitMessage": "collect exceptions across all constructors that have been tried (SPR-6720)\n",
			"commitDate": "2010-01-20, 1:29 AM",
			"commitName": "45448463b87629bdd85cb375d3faa391bfaf147f",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-08-27, 3:45 AM",
			"commitNameOld": "904c2358cdfd9cd8337da0950b8c8d6fc7099839",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 145.95,
			"commitsBetweenForRepo": 967,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,222 +1,222 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse != null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse == null && mbd.preparedConstructorArguments != null) {\n \t\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n-\t\t\tMethod[] rawCandidates = null; \n+\t\t\tMethod[] rawCandidates;\n \n \t\t\tfinal Class factoryClazz = factoryClass;\n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\trawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n \t\t\t\t\tpublic Method[] run() {\n \t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}\n \t\t\telse {\n \t\t\t\trawCandidates = (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t}\n \t\t\t\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsToUse = args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n \t\t\t\t\t\tif (\tambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n \t\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \t\t\t\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"904c2358cdfd9cd8337da0950b8c8d6fc7099839": {
			"type": "Ybodychange",
			"commitMessage": "adapted to changes in non-lenient mode\n",
			"commitDate": "2009-08-27, 3:45 AM",
			"commitName": "904c2358cdfd9cd8337da0950b8c8d6fc7099839",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-08-27, 2:47 AM",
			"commitNameOld": "015284af7cf8eff979cd0c5e5ad3d189915e98a9",
			"commitAuthorOld": "Costin Leau",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,226 +1,222 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse != null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse == null && mbd.preparedConstructorArguments != null) {\n \t\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates = null; \n \n \t\t\tfinal Class factoryClazz = factoryClass;\n \t\t\tif (System.getSecurityManager() != null) {\n-\t\t\t\t\n \t\t\t\trawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n \t\t\t\t\tpublic Method[] run() {\n \t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}\n \t\t\telse {\n \t\t\t\trawCandidates = (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t}\n \t\t\t\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n-\t\t\tSet<Method> \tambiguousFactoryMethods = null;\n+\t\t\tSet<Method> ambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsToUse = args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n \t\t\t\t\t\tif (\tambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n \t\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n-\t\t\t\n-\t\t\tObject beanInstance = null;\n-\t\t\t\n+\t\t\tObject beanInstance;\n+\n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n-\t\t\t\t\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-\t\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \t\t\t\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"af8af8c633ba016eca671bc9468eba006e8834b1": {
			"type": "Ybodychange",
			"commitMessage": "+ added fine grained privileged blocks to preserve the caller security stack when invoking the callee\n",
			"commitDate": "2009-08-06, 3:31 PM",
			"commitName": "af8af8c633ba016eca671bc9468eba006e8834b1",
			"commitAuthor": "Costin Leau",
			"commitDateOld": "2009-08-06, 12:08 PM",
			"commitNameOld": "81eb11486dad59e4a42566f9f7760d85396790b0",
			"commitAuthorOld": "Costin Leau",
			"daysBetweenCommits": 0.14,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,211 +1,226 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse != null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse == null && mbd.preparedConstructorArguments != null) {\n \t\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n-\t\t\tMethod[] rawCandidates = (mbd.isNonPublicAccessAllowed() ?\n-\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n+\t\t\tMethod[] rawCandidates = null; \n+\n+\t\t\tfinal Class factoryClazz = factoryClass;\n+\t\t\tif (System.getSecurityManager() != null) {\n+\t\t\t\t\n+\t\t\t\trawCandidates = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n+\t\t\t\t\tpublic Method[] run() {\n+\t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n+\t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\trawCandidates = (mbd.isNonPublicAccessAllowed() ?\n+\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n+\t\t\t}\n+\t\t\t\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> \tambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsToUse = args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n \t\t\t\t\t\tif (\tambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n \t\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\t\n \t\t\tObject beanInstance = null;\n \t\t\t\n \t\t\tif (System.getSecurityManager() != null) {\n \t\t\t\tfinal Object fb = factoryBean;\n \t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n \t\t\t\tfinal Object[] args = argsToUse;\n \t\t\t\t\n \t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n \t\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance = beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \t\t\t\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d5d3104b7b13ce249bf9c877f7160cd2137ec209": {
			"type": "Ymultichange(Ybodychange,Yparametermetachange)",
			"commitMessage": "+ interaction with user code uses now dedicated privileged when running under a security manager\n",
			"commitDate": "2009-08-06, 9:34 AM",
			"commitName": "d5d3104b7b13ce249bf9c877f7160cd2137ec209",
			"commitAuthor": "Costin Leau",
			"subchanges": [
				{
					"type": "Ybodychange",
					"commitMessage": "+ interaction with user code uses now dedicated privileged when running under a security manager\n",
					"commitDate": "2009-08-06, 9:34 AM",
					"commitName": "d5d3104b7b13ce249bf9c877f7160cd2137ec209",
					"commitAuthor": "Costin Leau",
					"commitDateOld": "2009-07-29, 9:43 AM",
					"commitNameOld": "17dfc8b0fcf3e2a02ab0db48af1d309981bbe6c2",
					"commitAuthorOld": "Juergen Hoeller",
					"daysBetweenCommits": 7.99,
					"commitsBetweenForRepo": 47,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,192 +1,211 @@\n-\tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n+\tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse != null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse == null && mbd.preparedConstructorArguments != null) {\n \t\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates = (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> \tambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsToUse = args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n \t\t\t\t\t\tif (\tambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n \t\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n-\t\t\tObject beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n-\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n+\t\t\t\n+\t\t\tObject beanInstance = null;\n+\t\t\t\n+\t\t\tif (System.getSecurityManager() != null) {\n+\t\t\t\tfinal Object fb = factoryBean;\n+\t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n+\t\t\t\tfinal Object[] args = argsToUse;\n+\t\t\t\t\n+\t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n+\t\n+\t\t\t\t\tpublic Object run() {\n+\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n+\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n+\t\t\t\t\t}\n+\t\t\t\t}, beanFactory.getAccessControlContext());\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tbeanInstance = beanFactory.getInstantiationStrategy().instantiate(\n+\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n+\t\t\t}\n+\t\t\t\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				},
				{
					"type": "Yparametermetachange",
					"commitMessage": "+ interaction with user code uses now dedicated privileged when running under a security manager\n",
					"commitDate": "2009-08-06, 9:34 AM",
					"commitName": "d5d3104b7b13ce249bf9c877f7160cd2137ec209",
					"commitAuthor": "Costin Leau",
					"commitDateOld": "2009-07-29, 9:43 AM",
					"commitNameOld": "17dfc8b0fcf3e2a02ab0db48af1d309981bbe6c2",
					"commitAuthorOld": "Juergen Hoeller",
					"daysBetweenCommits": 7.99,
					"commitsBetweenForRepo": 47,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,192 +1,211 @@\n-\tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n+\tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse != null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse == null && mbd.preparedConstructorArguments != null) {\n \t\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates = (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tSet<Method> \tambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsToUse = args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n \t\t\t\t\t\tif (\tambiguousFactoryMethods == null) {\n \t\t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n \t\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs == null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n-\t\t\tObject beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n-\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n+\t\t\t\n+\t\t\tObject beanInstance = null;\n+\t\t\t\n+\t\t\tif (System.getSecurityManager() != null) {\n+\t\t\t\tfinal Object fb = factoryBean;\n+\t\t\t\tfinal Method factoryMethod = factoryMethodToUse;\n+\t\t\t\tfinal Object[] args = argsToUse;\n+\t\t\t\t\n+\t\t\t\tbeanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n+\t\n+\t\t\t\t\tpublic Object run() {\n+\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n+\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n+\t\t\t\t\t}\n+\t\t\t\t}, beanFactory.getAccessControlContext());\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tbeanInstance = beanFactory.getInstantiationStrategy().instantiate(\n+\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n+\t\t\t}\n+\t\t\t\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[beanName-String, mbd-RootBeanDefinition, explicitArgs-Object[]]",
						"newValue": "[beanName-String(modifiers-final), mbd-RootBeanDefinition(modifiers-final), explicitArgs-Object[](modifiers-final)]"
					}
				}
			]
		},
		"17dfc8b0fcf3e2a02ab0db48af1d309981bbe6c2": {
			"type": "Ybodychange",
			"commitMessage": "fixed constructor resolution algorithm to trigger ambiguity exception as late as possible\n",
			"commitDate": "2009-07-29, 9:43 AM",
			"commitName": "17dfc8b0fcf3e2a02ab0db48af1d309981bbe6c2",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-07-28, 7:43 AM",
			"commitNameOld": "3cb073abce659c130abc9adc0662b75380fcc7f3",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 1.08,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,183 +1,192 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse != null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse == null && mbd.preparedConstructorArguments != null) {\n \t\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates = (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n+\t\t\tConstructorArgumentValues resolvedValues = null;\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n-\t\t\tConstructorArgumentValues resolvedValues = null;\n+\t\t\tSet<Method> \tambiguousFactoryMethods = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsToUse = args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n+\t\t\t\t\t\t\tambiguousFactoryMethods = null;\n \t\t\t\t\t}\n-\t\t\t\t\telse if (typeDiffWeight < Integer.MAX_VALUE && typeDiffWeight == minTypeDiffWeight &&\n-\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution()) {\n-\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n-\t\t\t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n-\t\t\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)\");\n+\t\t\t\t\telse if (factoryMethodToUse != null && typeDiffWeight == minTypeDiffWeight) {\n+\t\t\t\t\t\tif (\tambiguousFactoryMethods == null) {\n+\t\t\t\t\t\t\t\tambiguousFactoryMethods = new LinkedHashSet<Method>();\n+\t\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n \t\t\t}\n-\t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n+\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n+\t\t\telse if (ambiguousFactoryMethods != null && !mbd.isLenientConstructorResolution()) {\n+\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n+\t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n+\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n+\t\t\t\t\t\tambiguousFactoryMethods);\n+\t\t\t}\n \n \t\t\tif (explicitArgs == null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3cb073abce659c130abc9adc0662b75380fcc7f3": {
			"type": "Ybodychange",
			"commitMessage": "revised non-lenient resolution\n",
			"commitDate": "2009-07-28, 7:43 AM",
			"commitName": "3cb073abce659c130abc9adc0662b75380fcc7f3",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-07-27, 7:09 AM",
			"commitNameOld": "1eabe2b4416ee7619bd863fcdc1e6f6ada766400",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 1.02,
			"commitsBetweenForRepo": 10,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,182 +1,183 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse != null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse == null && mbd.preparedConstructorArguments != null) {\n \t\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates = (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tConstructorArgumentValues resolvedValues = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n-\t\t\t\t\tint typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n-\t\t\t\t\t// Choose this constructor if it represents the closest match.\n+\t\t\t\t\tint typeDiffWeight = (mbd.isLenientConstructorResolution() ?\n+\t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n+\t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsToUse = args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t}\n \t\t\t\t\telse if (typeDiffWeight < Integer.MAX_VALUE && typeDiffWeight == minTypeDiffWeight &&\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution()) {\n \t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n \t\t\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n \t\t\t}\n \t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \n \t\t\tif (explicitArgs == null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1eabe2b4416ee7619bd863fcdc1e6f6ada766400": {
			"type": "Ybodychange",
			"commitMessage": "lenientConstructorResolution flag applies to factory methods as well\n",
			"commitDate": "2009-07-27, 7:09 AM",
			"commitName": "1eabe2b4416ee7619bd863fcdc1e6f6ada766400",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-07-16, 10:22 AM",
			"commitNameOld": "8e2797153bf3d4eb7fbc679907dc06700c0595f4",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 10.87,
			"commitsBetweenForRepo": 86,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,176 +1,182 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse != null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse == null && mbd.preparedConstructorArguments != null) {\n \t\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates = (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tConstructorArgumentValues resolvedValues = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n \t\t\t\t\t// Choose this constructor if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsToUse = args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t}\n+\t\t\t\t\telse if (typeDiffWeight < Integer.MAX_VALUE && typeDiffWeight == minTypeDiffWeight &&\n+\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution()) {\n+\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n+\t\t\t\t\t\t\t\t\"Ambiguous factory method matches found in bean '\" + beanName + \"' \" +\n+\t\t\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)\");\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n \t\t\t}\n \t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \n \t\t\tif (explicitArgs == null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7eabd2da563a4e95928e89f72f7a207804eef0ab": {
			"type": "Ybodychange",
			"commitMessage": "introduced \"nonPublicAccessAllowed\" flag (SPR-5882)\n",
			"commitDate": "2009-07-16, 8:52 AM",
			"commitName": "7eabd2da563a4e95928e89f72f7a207804eef0ab",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-07-16, 6:27 AM",
			"commitNameOld": "a9254b34d19237f5fde7ceedec2126b08cf48e4d",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 0.1,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,175 +1,176 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse != null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse == null && mbd.preparedConstructorArguments != null) {\n \t\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n-\t\t\tMethod[] rawCandidates = ReflectionUtils.getAllDeclaredMethods(factoryClass);\n+\t\t\tMethod[] rawCandidates = (mbd.isNonPublicAccessAllowed() ?\n+\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tConstructorArgumentValues resolvedValues = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames = null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd != null) {\n \t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n \t\t\t\t\t// Choose this constructor if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsToUse = args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n \t\t\t}\n \t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \n \t\t\tif (explicitArgs == null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"53333c3ed06e465a55592a0f351ffab40110e5b3": {
			"type": "Ybodychange",
			"commitMessage": "XML constructor-arg element allows for specifying a constructor argument by name now, with target argument names read from the class file via ASM or from Java 6's @ConstructorProperties annotation (SPR-3313)\n",
			"commitDate": "2009-06-03, 3:21 AM",
			"commitName": "53333c3ed06e465a55592a0f351ffab40110e5b3",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-04-22, 3:46 AM",
			"commitNameOld": "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 41.98,
			"commitsBetweenForRepo": 258,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,170 +1,175 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse != null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse == null && mbd.preparedConstructorArguments != null) {\n \t\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates = ReflectionUtils.getAllDeclaredMethods(factoryClass);\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tConstructorArgumentValues resolvedValues = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues != null) {\n-\t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n+\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tString[] paramNames = null;\n+\t\t\t\t\t\t\tParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();\n+\t\t\t\t\t\t\tif (pnd != null) {\n+\t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs = createArgumentArray(\n-\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n+\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n \t\t\t\t\t// Choose this constructor if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsToUse = args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n \t\t\t}\n \t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \n \t\t\tif (explicitArgs == null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n-\t\t\tObject beanInstance = this.instantiationStrategy.instantiate(\n+\t\t\tObject beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ea9d8925a27e80d31d924826cf54f70b2bbcc638": {
			"type": "Ybodychange",
			"commitMessage": "next cut of JavaConfig metadata reading revision: using cached MetadataReaders\n",
			"commitDate": "2009-04-22, 3:46 AM",
			"commitName": "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-04-19, 4:45 PM",
			"commitNameOld": "14bd47551900ced88eeacf2a5f63c187ff72028c",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 2.46,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,169 +1,170 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse != null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n-\t\t\t\tif (argsToUse == null) {\n+\t\t\t\tif (argsToUse == null && mbd.preparedConstructorArguments != null) {\n \t\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\tif (factoryMethodToUse == null) {\n+\t\tif (factoryMethodToUse == null || argsToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates = ReflectionUtils.getAllDeclaredMethods(factoryClass);\n \t\t\tList<Method> candidateSet = new ArrayList<Method>();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n-\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName())) {\n+\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n+\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tConstructorArgumentValues resolvedValues = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\targs = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n \t\t\t\t\t// Choose this constructor if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsToUse = args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n \t\t\t}\n \t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \n \t\t\tif (explicitArgs == null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance = this.instantiationStrategy.instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"14bd47551900ced88eeacf2a5f63c187ff72028c": {
			"type": "Ybodychange",
			"commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
			"commitDate": "2009-04-19, 4:45 PM",
			"commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-03-23, 7:13 AM",
			"commitNameOld": "4344832a479831e7e67de1a9e81d52d023cd59ac",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 27.4,
			"commitsBetweenForRepo": 234,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,157 +1,169 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n+\t\t\tif (!mbd.hasBeanClass()) {\n+\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n+\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n+\t\t\t}\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse != null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse == null) {\n \t\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n-\t\t\tMethod[] candidates = ReflectionUtils.getAllDeclaredMethods(factoryClass);\n+\t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n+\t\t\tMethod[] rawCandidates = ReflectionUtils.getAllDeclaredMethods(factoryClass);\n+\t\t\tList<Method> candidateSet = new ArrayList<Method>();\n+\t\t\tfor (Method candidate : rawCandidates) {\n+\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n+\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName())) {\n+\t\t\t\t\tcandidateSet.add(candidate);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tMethod[] candidates = candidateSet.toArray(new Method[candidateSet.size()]);\n+\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n+\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tConstructorArgumentValues resolvedValues = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n-\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n-\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n-\t\t\t\t\t\tparamTypes.length >= minNrOfArgs) {\n-\n+\t\t\t\tif (paramTypes.length >= minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\targs = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n \t\t\t\t\t// Choose this constructor if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsToUse = args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n \t\t\t}\n \t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \n \t\t\tif (explicitArgs == null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance = this.instantiationStrategy.instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4344832a479831e7e67de1a9e81d52d023cd59ac": {
			"type": "Ybodychange",
			"commitMessage": "qualifier annotations and @Value can be used at method level as well (applying to all parameters); \nfixed EL evaluation of prepared constructor arguments for repeated prototype creation\n",
			"commitDate": "2009-03-23, 7:13 AM",
			"commitName": "4344832a479831e7e67de1a9e81d52d023cd59ac",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-02-25, 2:07 AM",
			"commitNameOld": "092de0107cd876d7f8207da7a9fc9ba163cfadfe",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 26.17,
			"commitsBetweenForRepo": 110,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,174 +1,157 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse != null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse == null) {\n-\t\t\t\t\tClass[] paramTypes = factoryMethodToUse.getParameterTypes();\n-\t\t\t\t\tObject[] argsToResolve = mbd.preparedConstructorArguments;\n-\t\t\t\t\tTypeConverter converter = (this.typeConverter != null ? this.typeConverter : bw);\n-\t\t\t\t\tBeanDefinitionValueResolver valueResolver =\n-\t\t\t\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n-\t\t\t\t\targsToUse = new Object[argsToResolve.length];\n-\t\t\t\t\tfor (int i = 0; i < argsToResolve.length; i++) {\n-\t\t\t\t\t\tObject argValue = argsToResolve[i];\n-\t\t\t\t\t\tMethodParameter methodParam = new MethodParameter(factoryMethodToUse, i);\n-\t\t\t\t\t\tGenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n-\t\t\t\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n-\t\t\t\t\t\t\targValue = resolveAutowiredArgument(methodParam, beanName, null, converter);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse if (argValue instanceof BeanMetadataElement) {\n-\t\t\t\t\t\t\targValue = valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\targsToUse[i] = converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n-\t\t\t\t\t}\n+\t\t\t\t\targsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tMethod[] candidates = ReflectionUtils.getAllDeclaredMethods(factoryClass);\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tConstructorArgumentValues resolvedValues = null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tparamTypes.length >= minNrOfArgs) {\n \n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\targs = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n \t\t\t\t\t// Choose this constructor if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsToUse = args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n \t\t\t}\n \t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \n \t\t\tif (explicitArgs == null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance = this.instantiationStrategy.instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"092de0107cd876d7f8207da7a9fc9ba163cfadfe": {
			"type": "Ybodychange",
			"commitMessage": "improved NoClassDefFoundError handling during constructor resolution (SPR-5522)\n",
			"commitDate": "2009-02-25, 2:07 AM",
			"commitName": "092de0107cd876d7f8207da7a9fc9ba163cfadfe",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2008-11-20, 9:33 AM",
			"commitNameOld": "05bebb0c056714d97b479cf6c5552ba3c5b06d9c",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 96.69,
			"commitsBetweenForRepo": 373,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,172 +1,174 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n-\t\tClass factoryClass = null;\n-\t\tObject factoryBean = null;\n-\t\tboolean isStatic = true;\n+\t\tObject factoryBean;\n+\t\tClass factoryClass;\n+\t\tboolean isStatic;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n+\t\t\tfactoryBean = null;\n \t\t\tfactoryClass = mbd.getBeanClass();\n+\t\t\tisStatic = true;\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse != null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse == null) {\n \t\t\t\t\tClass[] paramTypes = factoryMethodToUse.getParameterTypes();\n \t\t\t\t\tObject[] argsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\tTypeConverter converter = (this.typeConverter != null ? this.typeConverter : bw);\n \t\t\t\t\tBeanDefinitionValueResolver valueResolver =\n \t\t\t\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n \t\t\t\t\targsToUse = new Object[argsToResolve.length];\n \t\t\t\t\tfor (int i = 0; i < argsToResolve.length; i++) {\n \t\t\t\t\t\tObject argValue = argsToResolve[i];\n \t\t\t\t\t\tMethodParameter methodParam = new MethodParameter(factoryMethodToUse, i);\n \t\t\t\t\t\tGenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n \t\t\t\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n \t\t\t\t\t\t\targValue = resolveAutowiredArgument(methodParam, beanName, null, converter);\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse if (argValue instanceof BeanMetadataElement) {\n \t\t\t\t\t\t\targValue = valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsToUse[i] = converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tMethod[] candidates = ReflectionUtils.getAllDeclaredMethods(factoryClass);\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tConstructorArgumentValues resolvedValues = null;\n \n-\t\t\tint minNrOfArgs = 0;\n+\t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tparamTypes.length >= minNrOfArgs) {\n \n-\t\t\t\t\tArgumentsHolder args = null;\n+\t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\targs = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n \t\t\t\t\t// Choose this constructor if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsToUse = args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n \t\t\t}\n \t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \n \t\t\tif (explicitArgs == null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance = this.instantiationStrategy.instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"05bebb0c056714d97b479cf6c5552ba3c5b06d9c": {
			"type": "Ybodychange",
			"commitMessage": "completed value annotation support; Java 5 code style updates\n",
			"commitDate": "2008-11-20, 9:33 AM",
			"commitName": "05bebb0c056714d97b479cf6c5552ba3c5b06d9c",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2008-11-19, 6:10 PM",
			"commitNameOld": "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 0.64,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,172 +1,172 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tClass factoryClass = null;\n \t\tObject factoryBean = null;\n \t\tboolean isStatic = true;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse != null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse == null) {\n \t\t\t\t\tClass[] paramTypes = factoryMethodToUse.getParameterTypes();\n \t\t\t\t\tObject[] argsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\tTypeConverter converter = (this.typeConverter != null ? this.typeConverter : bw);\n \t\t\t\t\tBeanDefinitionValueResolver valueResolver =\n \t\t\t\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n \t\t\t\t\targsToUse = new Object[argsToResolve.length];\n \t\t\t\t\tfor (int i = 0; i < argsToResolve.length; i++) {\n \t\t\t\t\t\tObject argValue = argsToResolve[i];\n \t\t\t\t\t\tMethodParameter methodParam = new MethodParameter(factoryMethodToUse, i);\n \t\t\t\t\t\tGenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n \t\t\t\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n \t\t\t\t\t\t\targValue = resolveAutowiredArgument(methodParam, beanName, null, converter);\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse if (argValue instanceof BeanMetadataElement) {\n \t\t\t\t\t\t\targValue = valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsToUse[i] = converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tMethod[] candidates = ReflectionUtils.getAllDeclaredMethods(factoryClass);\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tConstructorArgumentValues resolvedValues = null;\n \n \t\t\tint minNrOfArgs = 0;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n-\t\t\tList causes = null;\n+\t\t\tList<Exception> causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tparamTypes.length >= minNrOfArgs) {\n \n \t\t\t\t\tArgumentsHolder args = null;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\targs = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n-\t\t\t\t\t\t\t\t\tfor (Iterator it = causes.iterator(); it.hasNext();) {\n-\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException((Exception) it.next());\n+\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n+\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n-\t\t\t\t\t\t\t\t\tcauses = new LinkedList();\n+\t\t\t\t\t\t\t\t\tcauses = new LinkedList<Exception>();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n \t\t\t\t\t// Choose this constructor if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsToUse = args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n \t\t\t}\n \t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \n \t\t\tif (explicitArgs == null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance = this.instantiationStrategy.instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"347f34c68a7a5bab46cf869e762fb3cee9a1fedc": {
			"type": "Ybodychange",
			"commitMessage": "EL container integration; support for contextual objects; removal of deprecated Spring 2.0 functionality; Java 5 code style\n",
			"commitDate": "2008-11-19, 6:10 PM",
			"commitName": "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2008-10-22, 9:13 AM",
			"commitNameOld": "f11d3436ed21d3908b9e0b569f2d783df161c0a3",
			"commitAuthorOld": "Arjen Poutsma",
			"daysBetweenCommits": 28.41,
			"commitsBetweenForRepo": 194,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,174 +1,172 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tClass factoryClass = null;\n \t\tObject factoryBean = null;\n \t\tboolean isStatic = true;\n \n \t\tString factoryBeanName = mbd.getFactoryBeanName();\n \t\tif (factoryBeanName != null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n \t\t\t}\n \t\t\tfactoryClass = factoryBean.getClass();\n \t\t\tisStatic = false;\n \t\t}\n \t\telse {\n \t\t\t// It's a static factory method on the bean class.\n \t\t\tfactoryClass = mbd.getBeanClass();\n \t\t}\n \n \t\tMethod factoryMethodToUse = null;\n \t\tObject[] argsToUse = null;\n \n \t\tif (explicitArgs != null) {\n \t\t\targsToUse = explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse != null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse == null) {\n \t\t\t\t\tClass[] paramTypes = factoryMethodToUse.getParameterTypes();\n \t\t\t\t\tObject[] argsToResolve = mbd.preparedConstructorArguments;\n \t\t\t\t\tTypeConverter converter = (this.typeConverter != null ? this.typeConverter : bw);\n \t\t\t\t\tBeanDefinitionValueResolver valueResolver =\n \t\t\t\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n \t\t\t\t\targsToUse = new Object[argsToResolve.length];\n \t\t\t\t\tfor (int i = 0; i < argsToResolve.length; i++) {\n \t\t\t\t\t\tObject argValue = argsToResolve[i];\n \t\t\t\t\t\tMethodParameter methodParam = new MethodParameter(factoryMethodToUse, i);\n-\t\t\t\t\t\tif (JdkVersion.isAtLeastJava15()) {\n-\t\t\t\t\t\t\tGenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n-\t\t\t\t\t\t}\n+\t\t\t\t\t\tGenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n \t\t\t\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n \t\t\t\t\t\t\targValue = resolveAutowiredArgument(methodParam, beanName, null, converter);\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse if (argValue instanceof BeanMetadataElement) {\n \t\t\t\t\t\t\targValue = valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsToUse[i] = converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse == null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tMethod[] candidates = ReflectionUtils.getAllDeclaredMethods(factoryClass);\n \t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n \t\t\tConstructorArgumentValues resolvedValues = null;\n \n \t\t\tint minNrOfArgs = 0;\n \t\t\tif (explicitArgs != null) {\n \t\t\t\tminNrOfArgs = explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues = new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList causes = null;\n \n \t\t\tfor (int i = 0; i < candidates.length; i++) {\n \t\t\t\tMethod candidate = candidates[i];\n \t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n \n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n \t\t\t\t\t\tparamTypes.length >= minNrOfArgs) {\n \n \t\t\t\t\tArgumentsHolder args = null;\n \n \t\t\t\t\tif (resolvedValues != null) {\n \t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\targs = createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n \t\t\t\t\t\t\t\tif (causes != null) {\n \t\t\t\t\t\t\t\t\tfor (Iterator it = causes.iterator(); it.hasNext();) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException((Exception) it.next());\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes == null) {\n \t\t\t\t\t\t\t\t\tcauses = new LinkedList();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n \t\t\t\t\t// Choose this constructor if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse = candidate;\n \t\t\t\t\t\targsToUse = args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse == null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n \t\t\t\t\t\t \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n \t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n \t\t\t}\n \t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"': needs to have a non-void return type!\");\n \t\t\t}\n \n \t\t\tif (explicitArgs == null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance = this.instantiationStrategy.instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f11d3436ed21d3908b9e0b569f2d783df161c0a3": {
			"type": "Yintroduced",
			"commitMessage": "Moved over initial version of beans bundle\n",
			"commitDate": "2008-10-22, 9:13 AM",
			"commitName": "f11d3436ed21d3908b9e0b569f2d783df161c0a3",
			"commitAuthor": "Arjen Poutsma",
			"diff": "@@ -0,0 +1,174 @@\n+\tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n+\t\tBeanWrapperImpl bw = new BeanWrapperImpl();\n+\t\tthis.beanFactory.initBeanWrapper(bw);\n+\n+\t\tClass factoryClass = null;\n+\t\tObject factoryBean = null;\n+\t\tboolean isStatic = true;\n+\n+\t\tString factoryBeanName = mbd.getFactoryBeanName();\n+\t\tif (factoryBeanName != null) {\n+\t\t\tif (factoryBeanName.equals(beanName)) {\n+\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n+\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n+\t\t\t}\n+\t\t\tfactoryBean = this.beanFactory.getBean(factoryBeanName);\n+\t\t\tif (factoryBean == null) {\n+\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n+\t\t\t\t\t\t\"factory-bean '\" + factoryBeanName + \"' returned null\");\n+\t\t\t}\n+\t\t\tfactoryClass = factoryBean.getClass();\n+\t\t\tisStatic = false;\n+\t\t}\n+\t\telse {\n+\t\t\t// It's a static factory method on the bean class.\n+\t\t\tfactoryClass = mbd.getBeanClass();\n+\t\t}\n+\n+\t\tMethod factoryMethodToUse = null;\n+\t\tObject[] argsToUse = null;\n+\n+\t\tif (explicitArgs != null) {\n+\t\t\targsToUse = explicitArgs;\n+\t\t}\n+\t\telse {\n+\t\t\tfactoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;\n+\t\t\tif (factoryMethodToUse != null) {\n+\t\t\t\t// Found a cached factory method...\n+\t\t\t\targsToUse = mbd.resolvedConstructorArguments;\n+\t\t\t\tif (argsToUse == null) {\n+\t\t\t\t\tClass[] paramTypes = factoryMethodToUse.getParameterTypes();\n+\t\t\t\t\tObject[] argsToResolve = mbd.preparedConstructorArguments;\n+\t\t\t\t\tTypeConverter converter = (this.typeConverter != null ? this.typeConverter : bw);\n+\t\t\t\t\tBeanDefinitionValueResolver valueResolver =\n+\t\t\t\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n+\t\t\t\t\targsToUse = new Object[argsToResolve.length];\n+\t\t\t\t\tfor (int i = 0; i < argsToResolve.length; i++) {\n+\t\t\t\t\t\tObject argValue = argsToResolve[i];\n+\t\t\t\t\t\tMethodParameter methodParam = new MethodParameter(factoryMethodToUse, i);\n+\t\t\t\t\t\tif (JdkVersion.isAtLeastJava15()) {\n+\t\t\t\t\t\t\tGenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n+\t\t\t\t\t\t\targValue = resolveAutowiredArgument(methodParam, beanName, null, converter);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse if (argValue instanceof BeanMetadataElement) {\n+\t\t\t\t\t\t\targValue = valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\targsToUse[i] = converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (factoryMethodToUse == null) {\n+\t\t\t// Need to determine the factory method...\n+\t\t\t// Try all methods with this name to see if they match the given arguments.\n+\t\t\tMethod[] candidates = ReflectionUtils.getAllDeclaredMethods(factoryClass);\n+\t\t\tboolean autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n+\t\t\tint minTypeDiffWeight = Integer.MAX_VALUE;\n+\t\t\tConstructorArgumentValues resolvedValues = null;\n+\n+\t\t\tint minNrOfArgs = 0;\n+\t\t\tif (explicitArgs != null) {\n+\t\t\t\tminNrOfArgs = explicitArgs.length;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\t// We don't have arguments passed in programmatically, so we need to resolve the\n+\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n+\t\t\t\tConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();\n+\t\t\t\tresolvedValues = new ConstructorArgumentValues();\n+\t\t\t\tminNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n+\t\t\t}\n+\n+\t\t\tList causes = null;\n+\n+\t\t\tfor (int i = 0; i < candidates.length; i++) {\n+\t\t\t\tMethod candidate = candidates[i];\n+\t\t\t\tClass[] paramTypes = candidate.getParameterTypes();\n+\n+\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic &&\n+\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) &&\n+\t\t\t\t\t\tparamTypes.length >= minNrOfArgs) {\n+\n+\t\t\t\t\tArgumentsHolder args = null;\n+\n+\t\t\t\t\tif (resolvedValues != null) {\n+\t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\targs = createArgumentArray(\n+\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n+\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n+\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n+\t\t\t\t\t\t\t\t\t\t\"] of bean '\" + beanName + \"': \" + ex);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (i == candidates.length - 1 && factoryMethodToUse == null) {\n+\t\t\t\t\t\t\t\tif (causes != null) {\n+\t\t\t\t\t\t\t\t\tfor (Iterator it = causes.iterator(); it.hasNext();) {\n+\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException((Exception) it.next());\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tthrow ex;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n+\t\t\t\t\t\t\t\tif (causes == null) {\n+\t\t\t\t\t\t\t\t\tcauses = new LinkedList();\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcauses.add(ex);\n+\t\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\telse {\n+\t\t\t\t\t\t// Explicit arguments given -> arguments length must match exactly.\n+\t\t\t\t\t\tif (paramTypes.length != explicitArgs.length) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\targs = new ArgumentsHolder(explicitArgs);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tint typeDiffWeight = args.getTypeDifferenceWeight(paramTypes);\n+\t\t\t\t\t// Choose this constructor if it represents the closest match.\n+\t\t\t\t\tif (typeDiffWeight < minTypeDiffWeight) {\n+\t\t\t\t\t\tfactoryMethodToUse = candidate;\n+\t\t\t\t\t\targsToUse = args.arguments;\n+\t\t\t\t\t\tminTypeDiffWeight = typeDiffWeight;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (factoryMethodToUse == null) {\n+\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n+\t\t\t\t\t\t\"No matching factory method found: \" +\n+\t\t\t\t\t\t(mbd.getFactoryBeanName() != null ?\n+\t\t\t\t\t\t \"factory bean '\" + mbd.getFactoryBeanName() + \"'; \" : \"\") +\n+\t\t\t\t\t\t\"factory method '\" + mbd.getFactoryMethodName() + \"'\");\n+\t\t\t}\n+\t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n+\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n+\t\t\t\t\t\t\"Invalid factory method '\" + mbd.getFactoryMethodName() +\n+\t\t\t\t\t\t\"': needs to have a non-void return type!\");\n+\t\t\t}\n+\n+\t\t\tif (explicitArgs == null) {\n+\t\t\t\tmbd.resolvedConstructorOrFactoryMethod = factoryMethodToUse;\n+\t\t\t}\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tObject beanInstance = this.instantiationStrategy.instantiate(\n+\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n+\t\t\tif (beanInstance == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tbw.setWrappedInstance(beanInstance);\n+\t\t\treturn bw;\n+\t\t}\n+\t\tcatch (Throwable ex) {\n+\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n+\t\t}\n+\t}\n\\ No newline at end of file\n"
		}
	},
	"sha": "b325c74216fd9564a36602158fa1269e2e832874"
}