{
	"repo": "https://github.com/eclipse/jgit.git",
	"file": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
	"method": {
		"longName": "RepoCommand::call()",
		"startLine": 487,
		"methodName": "call",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"6658f367682932c0a77061a5aa37c06e480a0c62": {
			"type": "Ybodychange",
			"commitMessage": "Use project names instead of paths for the submodule name\n\nTwo submodules at the same path on different branches need not represent\nthe same repository, and two submodules at different paths can represent\nthe same one.\n\nThe C Git implementation uses the submodule name to internally manage\nthe submodule repositories under .git/modules. When a submodule\nrepresents different repositories in different branches, it makes a\nconflict inside .git/modules.\n\nThe current RepoCommand implementation uses submodule paths as the\nsubmodule names. When the manifest file mounts different repositories to\nthe same path in different branches, this makes a situation described\nabove. To solve this issue, we can use the project name instead of\nthe path as the submodule name.\n\nOn the other hand, since repo v1.12.8~3^2 (repo: Support multiple\nbranches for the same project., 2013-10-11), a manifest file can mount\nthe same project to different paths. If we naively use the project\nname as the submodule name, it makes a conflict in .git/modules, too.\n\nThis patch uses the project name as the submodule name basically, but\nwhen the same project is mounted to different paths, it uses the project\nname and path as the submodule name.\n\nChange-Id: I09dc7d62ba59016fe28852d3139a56ef7ef49b8f\nSigned-off-by: Masaya Suzuki <masayasuzuki@google.com>\nReported-by: JP Sugarbroad <jpsugar@google.com>\n",
			"commitDate": "2018-07-27, 4:07 PM",
			"commitName": "6658f367682932c0a77061a5aa37c06e480a0c62",
			"commitAuthor": "Masaya Suzuki",
			"commitDateOld": "2018-07-20, 1:48 AM",
			"commitNameOld": "fb9031c9566308794f888695cafd108f19d835be",
			"commitAuthorOld": "Jonathan Nieder",
			"daysBetweenCommits": 7.6,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,217 +1,214 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\tcheckCallable();\n \t\tif (baseUri == null) {\n \t\t\tbaseUri = \"\"; //$NON-NLS-1$\n \t\t}\n \t\tif (inputStream == null) {\n \t\t\tif (manifestPath == null || manifestPath.length() == 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\ttry {\n \t\t\t\tinputStream = new FileInputStream(manifestPath);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t}\n \t\t}\n \n \t\tList<RepoProject> filteredProjects;\n \t\ttry {\n \t\t\tManifestParser parser = new ManifestParser(includedReader,\n \t\t\t\t\tmanifestPath, branch, baseUri, groupsParam, repo);\n \t\t\tparser.read(inputStream);\n \t\t\tfilteredProjects = parser.getFilteredProjects();\n \t\t} catch (IOException e) {\n \t\t\tthrow new ManifestErrorException(e);\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it's not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n-\t\t\tbareProjects = new ArrayList<>();\n \t\t\tif (author == null)\n \t\t\t\tauthor = new PersonIdent(repo);\n \t\t\tif (callback == null)\n \t\t\t\tcallback = new DefaultRemoteReader();\n-\t\t\tfor (RepoProject proj : filteredProjects) {\n-\t\t\t\taddSubmoduleBare(proj.getUrl(), proj.getPath(),\n-\t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n-\t\t\t\t\t\tproj.getLinkFiles(), proj.getGroups(),\n-\t\t\t\t\t\tproj.getRecommendShallow());\n-\t\t\t}\n+\t\t\tList<RepoProject> renamedProjects = renameProjects(filteredProjects);\n+\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tStringBuilder attributes = new StringBuilder();\n-\t\t\t\tfor (RepoProject proj : bareProjects) {\n+\t\t\t\tfor (RepoProject proj : renamedProjects) {\n+\t\t\t\t\tString name = proj.getName();\n \t\t\t\t\tString path = proj.getPath();\n-\t\t\t\t\tString nameUri = proj.getName();\n+\t\t\t\t\tString url = proj.getUrl();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())) {\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n-\t\t\t\t\t\tobjectId = callback.sha1(nameUri, proj.getRevision());\n+\t\t\t\t\t\tobjectId = callback.sha1(url, proj.getRevision());\n \t\t\t\t\t\tif (objectId == null && !ignoreRemoteFailures) {\n-\t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n+\t\t\t\t\t\t\tthrow new RemoteUnavailableException(url);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n-\t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the 'clone-depth' field, while\n \t\t\t\t\t\t\t// git core only uses a binary 'shallow = true/false'\n \t\t\t\t\t\t\t// hint, we'll map any depth to 'shallow = true'\n-\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", name, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec = new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(path);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n \n-\t\t\t\t\tURI submodUrl = URI.create(nameUri);\n+\t\t\t\t\tURI submodUrl = URI.create(url);\n \t\t\t\t\tif (targetUri != null) {\n \t\t\t\t\t\tsubmodUrl = relativize(targetUri, submodUrl);\n \t\t\t\t\t}\n-\t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n-\t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", submodUrl.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\t\t\tsubmodUrl.toString());\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tif (objectId != null) {\n \t\t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(path);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\t\tbyte[] src = callback.readFile(\n-\t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n+\t\t\t\t\t\t\t\turl, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tfor (LinkFile linkfile : proj.getLinkFiles()) {\n \t\t\t\t\t\t\tString link;\n \t\t\t\t\t\t\tif (linkfile.dest.contains(\"/\")) { //$NON-NLS-1$\n \t\t\t\t\t\t\t\tlink = FileUtils.relativizeGitPath(\n \t\t\t\t\t\t\t\t\tlinkfile.dest.substring(0,\n \t\t\t\t\t\t\t\t\t\tlinkfile.dest.lastIndexOf('/')),\n \t\t\t\t\t\t\t\t\tproj.getPath() + \"/\" + linkfile.src); //$NON-NLS-1$\n \t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\tlink = proj.getPath() + \"/\" + linkfile.src; //$NON-NLS-1$\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\t\tlink.getBytes(\n \t\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n \t\t\t\t\t\t\tdcEntry = new DirCacheEntry(linkfile.dest);\n \t\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\t\tdcEntry.setFileMode(FileMode.SYMLINK);\n \t\t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tif (headId != null && rw.parseCommit(headId).getTree().getId().equals(treeId)) {\n \t\t\t\t\t// No change. Do nothing.\n \t\t\t\t\treturn rw.parseCommit(headId);\n \t\t\t\t}\n \n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\ttry (Git git = new Git(repo)) {\n \t\t\t\tfor (RepoProject proj : filteredProjects) {\n-\t\t\t\t\taddSubmodule(proj.getUrl(), proj.getPath(),\n+\t\t\t\t\taddSubmodule(proj.getName(), proj.getUrl(), proj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n \t\t\t\t\t\t\tproj.getLinkFiles(), git);\n \t\t\t\t}\n \t\t\t\treturn git.commit().setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t\t\t.call();\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3214171decf596f003c154685638b01faba31ff3": {
			"type": "Ybodychange",
			"commitMessage": "RepoCommand: don't record new commit if tree did not change\n\nSigned-off-by: Han-Wen Nienhuys <hanwen@google.com>\nChange-Id: Ib6509e816684256d723558d5e8f3c37de58a2ff8\n",
			"commitDate": "2018-02-19, 4:24 AM",
			"commitName": "3214171decf596f003c154685638b01faba31ff3",
			"commitAuthor": "Han-Wen Nienhuys",
			"commitDateOld": "2018-02-19, 4:24 AM",
			"commitNameOld": "446a7096ef01c0e3bb56736403d91b125b2ee6ba",
			"commitAuthorOld": "Han-Wen Nienhuys",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,212 +1,217 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\tcheckCallable();\n \t\tif (baseUri == null) {\n \t\t\tbaseUri = \"\"; //$NON-NLS-1$\n \t\t}\n \t\tif (inputStream == null) {\n \t\t\tif (manifestPath == null || manifestPath.length() == 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\ttry {\n \t\t\t\tinputStream = new FileInputStream(manifestPath);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t}\n \t\t}\n \n \t\tList<RepoProject> filteredProjects;\n \t\ttry {\n \t\t\tManifestParser parser = new ManifestParser(includedReader,\n \t\t\t\t\tmanifestPath, branch, baseUri, groupsParam, repo);\n \t\t\tparser.read(inputStream);\n \t\t\tfilteredProjects = parser.getFilteredProjects();\n \t\t} catch (IOException e) {\n \t\t\tthrow new ManifestErrorException(e);\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it's not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tbareProjects = new ArrayList<>();\n \t\t\tif (author == null)\n \t\t\t\tauthor = new PersonIdent(repo);\n \t\t\tif (callback == null)\n \t\t\t\tcallback = new DefaultRemoteReader();\n \t\t\tfor (RepoProject proj : filteredProjects) {\n \t\t\t\taddSubmoduleBare(proj.getUrl(), proj.getPath(),\n \t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n \t\t\t\t\t\tproj.getLinkFiles(), proj.getGroups(),\n \t\t\t\t\t\tproj.getRecommendShallow());\n \t\t\t}\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tStringBuilder attributes = new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString path = proj.getPath();\n \t\t\t\t\tString nameUri = proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())) {\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId = callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId == null && !ignoreRemoteFailures) {\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the 'clone-depth' field, while\n \t\t\t\t\t\t\t// git core only uses a binary 'shallow = true/false'\n \t\t\t\t\t\t\t// hint, we'll map any depth to 'shallow = true'\n \t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec = new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(path);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n \n \t\t\t\t\tURI submodUrl = URI.create(nameUri);\n \t\t\t\t\tif (targetUri != null) {\n \t\t\t\t\t\tsubmodUrl = relativize(targetUri, submodUrl);\n \t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", submodUrl.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tif (objectId != null) {\n \t\t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(path);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\t\tbyte[] src = callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tfor (LinkFile linkfile : proj.getLinkFiles()) {\n \t\t\t\t\t\t\tString link;\n \t\t\t\t\t\t\tif (linkfile.dest.contains(\"/\")) { //$NON-NLS-1$\n \t\t\t\t\t\t\t\tlink = FileUtils.relativizeGitPath(\n \t\t\t\t\t\t\t\t\tlinkfile.dest.substring(0,\n \t\t\t\t\t\t\t\t\t\tlinkfile.dest.lastIndexOf('/')),\n \t\t\t\t\t\t\t\t\tproj.getPath() + \"/\" + linkfile.src); //$NON-NLS-1$\n \t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\tlink = proj.getPath() + \"/\" + linkfile.src; //$NON-NLS-1$\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\t\tlink.getBytes(\n \t\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n \t\t\t\t\t\t\tdcEntry = new DirCacheEntry(linkfile.dest);\n \t\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\t\tdcEntry.setFileMode(FileMode.SYMLINK);\n \t\t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n+\t\t\t\tif (headId != null && rw.parseCommit(headId).getTree().getId().equals(treeId)) {\n+\t\t\t\t\t// No change. Do nothing.\n+\t\t\t\t\treturn rw.parseCommit(headId);\n+\t\t\t\t}\n+\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\ttry (Git git = new Git(repo)) {\n \t\t\t\tfor (RepoProject proj : filteredProjects) {\n \t\t\t\t\taddSubmodule(proj.getUrl(), proj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n \t\t\t\t\t\t\tproj.getLinkFiles(), git);\n \t\t\t\t}\n \t\t\t\treturn git.commit().setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t\t\t.call();\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"446a7096ef01c0e3bb56736403d91b125b2ee6ba": {
			"type": "Ybodychange",
			"commitMessage": "RepoCommand: persist unreadable submodules in .gitmodules\n\nIn cases where a manifest file mixes different remotes, a Gerrit\nserver process may not have access to all remotes, and won't be able\nto produce a full submodule tree.\n\nPreserving this information in .gitmodules will let downstream clients\nreconstruct the full tree.\n\nSigned-off-by: Han-Wen Nienhuys <hanwen@google.com>\nChange-Id: I52f5d3f288e771dca0af2b4dd3f3fa0f940dcf15\n",
			"commitDate": "2018-02-19, 4:24 AM",
			"commitName": "446a7096ef01c0e3bb56736403d91b125b2ee6ba",
			"commitAuthor": "Han-Wen Nienhuys",
			"commitDateOld": "2018-02-15, 12:59 AM",
			"commitNameOld": "9bebb1eae78401e1d3289dc3d84006c10d10c0ef",
			"commitAuthorOld": "David Pursehouse",
			"daysBetweenCommits": 4.14,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,213 +1,212 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\tcheckCallable();\n \t\tif (baseUri == null) {\n \t\t\tbaseUri = \"\"; //$NON-NLS-1$\n \t\t}\n \t\tif (inputStream == null) {\n \t\t\tif (manifestPath == null || manifestPath.length() == 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\ttry {\n \t\t\t\tinputStream = new FileInputStream(manifestPath);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t}\n \t\t}\n \n \t\tList<RepoProject> filteredProjects;\n \t\ttry {\n \t\t\tManifestParser parser = new ManifestParser(includedReader,\n \t\t\t\t\tmanifestPath, branch, baseUri, groupsParam, repo);\n \t\t\tparser.read(inputStream);\n \t\t\tfilteredProjects = parser.getFilteredProjects();\n \t\t} catch (IOException e) {\n \t\t\tthrow new ManifestErrorException(e);\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it's not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tbareProjects = new ArrayList<>();\n \t\t\tif (author == null)\n \t\t\t\tauthor = new PersonIdent(repo);\n \t\t\tif (callback == null)\n \t\t\t\tcallback = new DefaultRemoteReader();\n \t\t\tfor (RepoProject proj : filteredProjects) {\n \t\t\t\taddSubmoduleBare(proj.getUrl(), proj.getPath(),\n \t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n \t\t\t\t\t\tproj.getLinkFiles(), proj.getGroups(),\n \t\t\t\t\t\tproj.getRecommendShallow());\n \t\t\t}\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tStringBuilder attributes = new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString path = proj.getPath();\n \t\t\t\t\tString nameUri = proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())) {\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId = callback.sha1(nameUri, proj.getRevision());\n-\t\t\t\t\t\tif (objectId == null) {\n-\t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n-\t\t\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (objectId == null && !ignoreRemoteFailures) {\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the 'clone-depth' field, while\n \t\t\t\t\t\t\t// git core only uses a binary 'shallow = true/false'\n \t\t\t\t\t\t\t// hint, we'll map any depth to 'shallow = true'\n \t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec = new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(path);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n \n \t\t\t\t\tURI submodUrl = URI.create(nameUri);\n \t\t\t\t\tif (targetUri != null) {\n \t\t\t\t\t\tsubmodUrl = relativize(targetUri, submodUrl);\n \t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", submodUrl.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n-\t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(path);\n-\t\t\t\t\tdcEntry.setObjectId(objectId);\n-\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n-\t\t\t\t\tbuilder.add(dcEntry);\n+\t\t\t\t\tif (objectId != null) {\n+\t\t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(path);\n+\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n+\t\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n+\t\t\t\t\t\tbuilder.add(dcEntry);\n \n-\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n-\t\t\t\t\t\tbyte[] src = callback.readFile(\n+\t\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n+\t\t\t\t\t\t\tbyte[] src = callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n-\t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n-\t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n-\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n-\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n-\t\t\t\t\t\tbuilder.add(dcEntry);\n-\t\t\t\t\t}\n-\t\t\t\t\tfor (LinkFile linkfile : proj.getLinkFiles()) {\n-\t\t\t\t\t\tString link;\n-\t\t\t\t\t\tif (linkfile.dest.contains(\"/\")) { //$NON-NLS-1$\n-\t\t\t\t\t\t\tlink = FileUtils.relativizeGitPath(\n-\t\t\t\t\t\t\t\t\tlinkfile.dest.substring(0,\n-\t\t\t\t\t\t\t\t\t\t\tlinkfile.dest.lastIndexOf('/')),\n-\t\t\t\t\t\t\t\t\tproj.getPath() + \"/\" + linkfile.src); //$NON-NLS-1$\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tlink = proj.getPath() + \"/\" + linkfile.src; //$NON-NLS-1$\n+\t\t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n+\t\t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n+\t\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n+\t\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n+\t\t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t\t}\n+\t\t\t\t\t\tfor (LinkFile linkfile : proj.getLinkFiles()) {\n+\t\t\t\t\t\t\tString link;\n+\t\t\t\t\t\t\tif (linkfile.dest.contains(\"/\")) { //$NON-NLS-1$\n+\t\t\t\t\t\t\t\tlink = FileUtils.relativizeGitPath(\n+\t\t\t\t\t\t\t\t\tlinkfile.dest.substring(0,\n+\t\t\t\t\t\t\t\t\t\tlinkfile.dest.lastIndexOf('/')),\n+\t\t\t\t\t\t\t\t\tproj.getPath() + \"/\" + linkfile.src); //$NON-NLS-1$\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tlink = proj.getPath() + \"/\" + linkfile.src; //$NON-NLS-1$\n+\t\t\t\t\t\t\t}\n \n-\t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB,\n+\t\t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\t\tlink.getBytes(\n-\t\t\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n-\t\t\t\t\t\tdcEntry = new DirCacheEntry(linkfile.dest);\n-\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n-\t\t\t\t\t\tdcEntry.setFileMode(FileMode.SYMLINK);\n-\t\t\t\t\t\tbuilder.add(dcEntry);\n+\t\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n+\t\t\t\t\t\t\tdcEntry = new DirCacheEntry(linkfile.dest);\n+\t\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n+\t\t\t\t\t\t\tdcEntry.setFileMode(FileMode.SYMLINK);\n+\t\t\t\t\t\t\tbuilder.add(dcEntry);\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\ttry (Git git = new Git(repo)) {\n \t\t\t\tfor (RepoProject proj : filteredProjects) {\n \t\t\t\t\taddSubmodule(proj.getUrl(), proj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n \t\t\t\t\t\t\tproj.getLinkFiles(), git);\n \t\t\t\t}\n \t\t\t\treturn git.commit().setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t\t\t.call();\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9bebb1eae78401e1d3289dc3d84006c10d10c0ef": {
			"type": "Ybodychange",
			"commitMessage": "RepoCommand: Don't leave Git open\n\nWhen the command is run on a non-bare repository, an instance of\nGit is created to execute the commit, and is left open when the\ncommand has finished.\n\nRefactor to not use a class scope Git instance, and make sure it\ngets closed before returning.\n\nChange-Id: Ic623ae0fd8b9e264b5dfd434da0de6bb4f910984\nSigned-off-by: David Pursehouse <david.pursehouse@gmail.com>\n",
			"commitDate": "2018-02-15, 12:59 AM",
			"commitName": "9bebb1eae78401e1d3289dc3d84006c10d10c0ef",
			"commitAuthor": "David Pursehouse",
			"commitDateOld": "2017-12-18, 5:19 AM",
			"commitNameOld": "5e2e111280898e47959996a1a1e016e9fcb21179",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 58.82,
			"commitsBetweenForRepo": 109,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,214 +1,213 @@\n \tpublic RevCommit call() throws GitAPIException {\n-\t\ttry {\n-\t\t\tcheckCallable();\n-\t\t\tif (baseUri == null) {\n-\t\t\t\tbaseUri = \"\"; //$NON-NLS-1$\n-\t\t\t}\n-\t\t\tif (inputStream == null) {\n-\t\t\t\tif (manifestPath == null || manifestPath.length() == 0)\n-\t\t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n-\t\t\t\ttry {\n-\t\t\t\t\tinputStream = new FileInputStream(manifestPath);\n-\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (repo.isBare()) {\n-\t\t\t\tbareProjects = new ArrayList<>();\n-\t\t\t\tif (author == null)\n-\t\t\t\t\tauthor = new PersonIdent(repo);\n-\t\t\t\tif (callback == null)\n-\t\t\t\t\tcallback = new DefaultRemoteReader();\n-\t\t\t} else\n-\t\t\t\tgit = new Git(repo);\n-\n-\t\t\tManifestParser parser = new ManifestParser(\n-\t\t\t\t\tincludedReader, manifestPath, branch, baseUri, groupsParam, repo);\n+\t\tcheckCallable();\n+\t\tif (baseUri == null) {\n+\t\t\tbaseUri = \"\"; //$NON-NLS-1$\n+\t\t}\n+\t\tif (inputStream == null) {\n+\t\t\tif (manifestPath == null || manifestPath.length() == 0)\n+\t\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\ttry {\n-\t\t\t\tparser.read(inputStream);\n-\t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n-\t\t\t\t\taddSubmodule(proj.getUrl(),\n-\t\t\t\t\t\t\tproj.getPath(),\n-\t\t\t\t\t\t\tproj.getRevision(),\n-\t\t\t\t\t\t\tproj.getCopyFiles(),\n-\t\t\t\t\t\t\tproj.getLinkFiles(),\n-\t\t\t\t\t\t\tproj.getGroups(),\n-\t\t\t\t\t\t\tproj.getRecommendShallow());\n-\t\t\t\t}\n-\t\t\t} catch (GitAPIException | IOException e) {\n-\t\t\t\tthrow new ManifestErrorException(e);\n+\t\t\t\tinputStream = new FileInputStream(manifestPath);\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t}\n+\t\t}\n+\n+\t\tList<RepoProject> filteredProjects;\n+\t\ttry {\n+\t\t\tManifestParser parser = new ManifestParser(includedReader,\n+\t\t\t\t\tmanifestPath, branch, baseUri, groupsParam, repo);\n+\t\t\tparser.read(inputStream);\n+\t\t\tfilteredProjects = parser.getFilteredProjects();\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new ManifestErrorException(e);\n \t\t} finally {\n \t\t\ttry {\n-\t\t\t\tif (inputStream != null)\n-\t\t\t\t\tinputStream.close();\n+\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it's not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n+\t\t\tbareProjects = new ArrayList<>();\n+\t\t\tif (author == null)\n+\t\t\t\tauthor = new PersonIdent(repo);\n+\t\t\tif (callback == null)\n+\t\t\t\tcallback = new DefaultRemoteReader();\n+\t\t\tfor (RepoProject proj : filteredProjects) {\n+\t\t\t\taddSubmoduleBare(proj.getUrl(), proj.getPath(),\n+\t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n+\t\t\t\t\t\tproj.getLinkFiles(), proj.getGroups(),\n+\t\t\t\t\t\tproj.getRecommendShallow());\n+\t\t\t}\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tStringBuilder attributes = new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString path = proj.getPath();\n \t\t\t\t\tString nameUri = proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())) {\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId = callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId == null) {\n \t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the 'clone-depth' field, while\n \t\t\t\t\t\t\t// git core only uses a binary 'shallow = true/false'\n \t\t\t\t\t\t\t// hint, we'll map any depth to 'shallow = true'\n \t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec = new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(path);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n \n \t\t\t\t\tURI submodUrl = URI.create(nameUri);\n \t\t\t\t\tif (targetUri != null) {\n \t\t\t\t\t\tsubmodUrl = relativize(targetUri, submodUrl);\n \t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", submodUrl.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(path);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src = callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t\tfor (LinkFile linkfile : proj.getLinkFiles()) {\n \t\t\t\t\t\tString link;\n \t\t\t\t\t\tif (linkfile.dest.contains(\"/\")) { //$NON-NLS-1$\n \t\t\t\t\t\t\tlink = FileUtils.relativizeGitPath(\n \t\t\t\t\t\t\t\t\tlinkfile.dest.substring(0,\n \t\t\t\t\t\t\t\t\t\t\tlinkfile.dest.lastIndexOf('/')),\n \t\t\t\t\t\t\t\t\tproj.getPath() + \"/\" + linkfile.src); //$NON-NLS-1$\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tlink = proj.getPath() + \"/\" + linkfile.src; //$NON-NLS-1$\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\t\tlink.getBytes(\n \t\t\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n \t\t\t\t\t\tdcEntry = new DirCacheEntry(linkfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.SYMLINK);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n-\t\t\t} catch (IOException e) {\n+\t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n-\t\t\treturn git\n-\t\t\t\t.commit()\n-\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n-\t\t\t\t.call();\n+\t\t\ttry (Git git = new Git(repo)) {\n+\t\t\t\tfor (RepoProject proj : filteredProjects) {\n+\t\t\t\t\taddSubmodule(proj.getUrl(), proj.getPath(),\n+\t\t\t\t\t\t\tproj.getRevision(), proj.getCopyFiles(),\n+\t\t\t\t\t\t\tproj.getLinkFiles(), git);\n+\t\t\t\t}\n+\t\t\t\treturn git.commit().setMessage(RepoText.get().repoCommitMessage)\n+\t\t\t\t\t\t.call();\n+\t\t\t} catch (GitAPIException | IOException e) {\n+\t\t\t\tthrow new ManifestErrorException(e);\n+\t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"04b8168beb5fb9c7d4e9768cc99a82d0e6176dc2": {
			"type": "Ybodychange",
			"commitMessage": "RepoCommand: Skip RemoteReader when encountering a full SHA-1\n\nThere is no point in calling back to the RemoteReader to resolve a\n40-digit hex SHA-1 to itself.  We already skip that call when not\nignoring remote failures; skip it when ignoring remote failures, too.\n\nThis should simplify RemoteReader implementations.\n\nReported-by: Han-Wen Nienhuys <hanwen@google.com>\nChange-Id: I7566968ed1f39b1ad73574fa903faf3ee308eb87\n",
			"commitDate": "2017-11-28, 9:17 AM",
			"commitName": "04b8168beb5fb9c7d4e9768cc99a82d0e6176dc2",
			"commitAuthor": "Jonathan Nieder",
			"commitDateOld": "2017-08-29, 7:07 PM",
			"commitNameOld": "e9fb111182b55cc82c530d82f13176c7a85cd958",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 90.63,
			"commitsBetweenForRepo": 118,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,215 +1,214 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (baseUri == null) {\n \t\t\t\tbaseUri = \"\"; //$NON-NLS-1$\n \t\t\t}\n \t\t\tif (inputStream == null) {\n \t\t\t\tif (manifestPath == null || manifestPath.length() == 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream = new FileInputStream(manifestPath);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects = new ArrayList<>();\n \t\t\t\tif (author == null)\n \t\t\t\t\tauthor = new PersonIdent(repo);\n \t\t\t\tif (callback == null)\n \t\t\t\t\tcallback = new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit = new Git(repo);\n \n \t\t\tManifestParser parser = new ManifestParser(\n \t\t\t\t\tincludedReader, manifestPath, branch, baseUri, groupsParam, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles(),\n \t\t\t\t\t\t\tproj.getLinkFiles(),\n \t\t\t\t\t\t\tproj.getGroups(),\n \t\t\t\t\t\t\tproj.getRecommendShallow());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream != null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it's not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tStringBuilder attributes = new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString path = proj.getPath();\n \t\t\t\t\tString nameUri = proj.getName();\n \t\t\t\t\tObjectId objectId;\n-\t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n-\t\t\t\t\t\t\t&& !ignoreRemoteFailures) {\n+\t\t\t\t\tif (ObjectId.isId(proj.getRevision())) {\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId = callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId == null) {\n \t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the 'clone-depth' field, while\n \t\t\t\t\t\t\t// git core only uses a binary 'shallow = true/false'\n \t\t\t\t\t\t\t// hint, we'll map any depth to 'shallow = true'\n \t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec = new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(path);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n \n \t\t\t\t\tURI submodUrl = URI.create(nameUri);\n \t\t\t\t\tif (targetUri != null) {\n \t\t\t\t\t\tsubmodUrl = relativize(targetUri, submodUrl);\n \t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", submodUrl.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(path);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src = callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t\tfor (LinkFile linkfile : proj.getLinkFiles()) {\n \t\t\t\t\t\tString link;\n \t\t\t\t\t\tif (linkfile.dest.contains(\"/\")) { //$NON-NLS-1$\n \t\t\t\t\t\t\tlink = FileUtils.relativizeGitPath(\n \t\t\t\t\t\t\t\t\tlinkfile.dest.substring(0,\n \t\t\t\t\t\t\t\t\t\t\tlinkfile.dest.lastIndexOf('/')),\n \t\t\t\t\t\t\t\t\tproj.getPath() + \"/\" + linkfile.src); //$NON-NLS-1$\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tlink = proj.getPath() + \"/\" + linkfile.src; //$NON-NLS-1$\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\t\tlink.getBytes(\n \t\t\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n \t\t\t\t\t\tdcEntry = new DirCacheEntry(linkfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.SYMLINK);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b6fc8e2f3cb1af6f7cbc624acfac01bec002baf8": {
			"type": "Ybodychange",
			"commitMessage": "RepoCommand: Add linkfile support.\n\nAndroid wants them to work, and we're only interested in them for bare\nrepos, so add them just for that.\n\nMake sure to use symlinks instead of just using the copyfile\nimplementation. Some scripts look up where they're actually located in\norder to find related files, so they need the link back to their\nproject.\n\nChange-Id: I929b69b2505f03036f69e25a55daf93842871f30\nSigned-off-by: Dan Willemsen <dwillemsen@google.com>\nSigned-off-by: Stefan Beller <sbeller@google.com>\nSigned-off-by: Jeff Gaston <jeffrygaston@google.com>\nSigned-off-by: David Pursehouse <david.pursehouse@gmail.com>\n",
			"commitDate": "2017-04-18, 2:33 AM",
			"commitName": "b6fc8e2f3cb1af6f7cbc624acfac01bec002baf8",
			"commitAuthor": "Dan Willemsen",
			"commitDateOld": "2017-04-14, 11:49 AM",
			"commitNameOld": "3af4afdfbfed7ed97424b91d08bf55c3b23c0b9b",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 3.61,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,195 +1,215 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (baseUri == null) {\n \t\t\t\tbaseUri = \"\"; //$NON-NLS-1$\n \t\t\t}\n \t\t\tif (inputStream == null) {\n \t\t\t\tif (manifestPath == null || manifestPath.length() == 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream = new FileInputStream(manifestPath);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects = new ArrayList<>();\n \t\t\t\tif (author == null)\n \t\t\t\t\tauthor = new PersonIdent(repo);\n \t\t\t\tif (callback == null)\n \t\t\t\t\tcallback = new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit = new Git(repo);\n \n \t\t\tManifestParser parser = new ManifestParser(\n \t\t\t\t\tincludedReader, manifestPath, branch, baseUri, groupsParam, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles(),\n+\t\t\t\t\t\t\tproj.getLinkFiles(),\n \t\t\t\t\t\t\tproj.getGroups(),\n \t\t\t\t\t\t\tproj.getRecommendShallow());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream != null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it's not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tStringBuilder attributes = new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString path = proj.getPath();\n \t\t\t\t\tString nameUri = proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n \t\t\t\t\t\t\t&& !ignoreRemoteFailures) {\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId = callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId == null) {\n \t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the 'clone-depth' field, while\n \t\t\t\t\t\t\t// git core only uses a binary 'shallow = true/false'\n \t\t\t\t\t\t\t// hint, we'll map any depth to 'shallow = true'\n \t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec = new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(path);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n \n \t\t\t\t\tURI submodUrl = URI.create(nameUri);\n \t\t\t\t\tif (targetUri != null) {\n \t\t\t\t\t\tsubmodUrl = relativize(targetUri, submodUrl);\n \t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", submodUrl.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(path);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src = callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n+\t\t\t\t\tfor (LinkFile linkfile : proj.getLinkFiles()) {\n+\t\t\t\t\t\tString link;\n+\t\t\t\t\t\tif (linkfile.dest.contains(\"/\")) { //$NON-NLS-1$\n+\t\t\t\t\t\t\tlink = FileUtils.relativizeGitPath(\n+\t\t\t\t\t\t\t\t\tlinkfile.dest.substring(0,\n+\t\t\t\t\t\t\t\t\t\t\tlinkfile.dest.lastIndexOf('/')),\n+\t\t\t\t\t\t\t\t\tproj.getPath() + \"/\" + linkfile.src); //$NON-NLS-1$\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tlink = proj.getPath() + \"/\" + linkfile.src; //$NON-NLS-1$\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB,\n+\t\t\t\t\t\t\t\tlink.getBytes(\n+\t\t\t\t\t\t\t\t\t\tConstants.CHARACTER_ENCODING));\n+\t\t\t\t\t\tdcEntry = new DirCacheEntry(linkfile.dest);\n+\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n+\t\t\t\t\t\tdcEntry.setFileMode(FileMode.SYMLINK);\n+\t\t\t\t\t\tbuilder.add(dcEntry);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fe5437e96b91222e30d9105e7bab490fd68c2d52": {
			"type": "Ybodychange",
			"commitMessage": "Fix RepoCommand to allow for relative URLs\n\nThis is necessary for deploying submodules on android.googlesource.com.\n\n* Allow an empty base URL. This is useful if the 'fetch' field is \".\"\n  and all names are relative to some host root.\n\n* The URLs in the resulting superproject are relative to the\n  superproject's URL. Add RepoCommand#setDestinationURI to\n  set this. If unset, the existing behavior is maintained.\n\n* Add two tests for the Android and Gerrit case, checking the URL\n  format in .gitmodules; the tests use a custom RemoteReader which is\n  representative of the use of this class in Gerrit's Supermanifest\n  plugin.\n\nChange-Id: Ia75530226120d75aa0017c5410fd65d0563e91b\nSigned-off-by: Han-Wen Nienhuys <hanwen@google.com>\nSigned-off-by: David Pursehouse <david.pursehouse@gmail.com>\n",
			"commitDate": "2017-04-12, 7:53 PM",
			"commitName": "fe5437e96b91222e30d9105e7bab490fd68c2d52",
			"commitAuthor": "Han-Wen Nienhuys",
			"commitDateOld": "2017-03-29, 8:54 AM",
			"commitNameOld": "f32d65759c9afdcbec28eb3051ed9138b8e03271",
			"commitAuthorOld": "Han-Wen Nienhuys",
			"daysBetweenCommits": 14.46,
			"commitsBetweenForRepo": 33,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,191 +1,195 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n-\t\t\tif (uri == null || uri.length() == 0) {\n-\t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\tJGitText.get().uriNotConfigured);\n+\t\t\tif (baseUri == null) {\n+\t\t\t\tbaseUri = \"\"; //$NON-NLS-1$\n \t\t\t}\n \t\t\tif (inputStream == null) {\n \t\t\t\tif (manifestPath == null || manifestPath.length() == 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream = new FileInputStream(manifestPath);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects = new ArrayList<>();\n \t\t\t\tif (author == null)\n \t\t\t\t\tauthor = new PersonIdent(repo);\n \t\t\t\tif (callback == null)\n \t\t\t\t\tcallback = new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit = new Git(repo);\n \n \t\t\tManifestParser parser = new ManifestParser(\n-\t\t\t\t\tincludedReader, manifestPath, branch, uri, groupsParam, repo);\n+\t\t\t\t\tincludedReader, manifestPath, branch, baseUri, groupsParam, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles(),\n \t\t\t\t\t\t\tproj.getGroups(),\n \t\t\t\t\t\t\tproj.getRecommendShallow());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream != null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it's not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tStringBuilder attributes = new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString path = proj.getPath();\n \t\t\t\t\tString nameUri = proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n \t\t\t\t\t\t\t&& !ignoreRemoteFailures) {\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId = callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId == null) {\n \t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the 'clone-depth' field, while\n \t\t\t\t\t\t\t// git core only uses a binary 'shallow = true/false'\n \t\t\t\t\t\t\t// hint, we'll map any depth to 'shallow = true'\n \t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec = new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(path);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n+\n+\t\t\t\t\tURI submodUrl = URI.create(nameUri);\n+\t\t\t\t\tif (targetUri != null) {\n+\t\t\t\t\t\tsubmodUrl = relativize(targetUri, submodUrl);\n+\t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n-\t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", submodUrl.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(path);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src = callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f32d65759c9afdcbec28eb3051ed9138b8e03271": {
			"type": "Ybodychange",
			"commitMessage": "Document the intended use of RepoCommand#setURI()\n\nSigned-off-by: Han-Wen Nienhuys <hanwen@google.com>\nChange-Id: I4a59dd8278b7b0026094692127b7f55e89c10bae\n",
			"commitDate": "2017-03-29, 8:54 AM",
			"commitName": "f32d65759c9afdcbec28eb3051ed9138b8e03271",
			"commitAuthor": "Han-Wen Nienhuys",
			"commitDateOld": "2017-03-27, 3:36 PM",
			"commitNameOld": "27b05c7d719754427a97c141b44bec7de3acb8db",
			"commitAuthorOld": "Han-Wen Nienhuys",
			"daysBetweenCommits": 1.72,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,190 +1,191 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n-\t\t\tif (uri == null || uri.length() == 0)\n+\t\t\tif (uri == null || uri.length() == 0) {\n \t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\tJGitText.get().uriNotConfigured);\n+\t\t\t\t\tJGitText.get().uriNotConfigured);\n+\t\t\t}\n \t\t\tif (inputStream == null) {\n \t\t\t\tif (manifestPath == null || manifestPath.length() == 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream = new FileInputStream(manifestPath);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects = new ArrayList<>();\n \t\t\t\tif (author == null)\n \t\t\t\t\tauthor = new PersonIdent(repo);\n \t\t\t\tif (callback == null)\n \t\t\t\t\tcallback = new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit = new Git(repo);\n \n \t\t\tManifestParser parser = new ManifestParser(\n \t\t\t\t\tincludedReader, manifestPath, branch, uri, groupsParam, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles(),\n \t\t\t\t\t\t\tproj.getGroups(),\n \t\t\t\t\t\t\tproj.getRecommendShallow());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream != null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it's not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tStringBuilder attributes = new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString path = proj.getPath();\n \t\t\t\t\tString nameUri = proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n \t\t\t\t\t\t\t&& !ignoreRemoteFailures) {\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId = callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId == null) {\n \t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the 'clone-depth' field, while\n \t\t\t\t\t\t\t// git core only uses a binary 'shallow = true/false'\n \t\t\t\t\t\t\t// hint, we'll map any depth to 'shallow = true'\n \t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec = new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(path);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(path);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src = callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"27b05c7d719754427a97c141b44bec7de3acb8db": {
			"type": "Ybodychange",
			"commitMessage": "Consistently use 'path' for the path to a subrepo in RepoCommand\n\nSigned-off-by: Han-Wen Nienhuys <hanwen@google.com>\nChange-Id: I79ea7eb7b4d319e0100e3121aca5ef82eb8ad92a\n",
			"commitDate": "2017-03-27, 3:36 PM",
			"commitName": "27b05c7d719754427a97c141b44bec7de3acb8db",
			"commitAuthor": "Han-Wen Nienhuys",
			"commitDateOld": "2017-02-20, 2:47 PM",
			"commitNameOld": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
			"commitAuthorOld": "David Pursehouse",
			"daysBetweenCommits": 34.99,
			"commitsBetweenForRepo": 46,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,190 +1,190 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri == null || uri.length() == 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream == null) {\n-\t\t\t\tif (path == null || path.length() == 0)\n+\t\t\t\tif (manifestPath == null || manifestPath.length() == 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n-\t\t\t\t\tinputStream = new FileInputStream(path);\n+\t\t\t\t\tinputStream = new FileInputStream(manifestPath);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects = new ArrayList<>();\n \t\t\t\tif (author == null)\n \t\t\t\t\tauthor = new PersonIdent(repo);\n \t\t\t\tif (callback == null)\n \t\t\t\t\tcallback = new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit = new Git(repo);\n \n \t\t\tManifestParser parser = new ManifestParser(\n-\t\t\t\t\tincludedReader, path, branch, uri, groupsParam, repo);\n+\t\t\t\t\tincludedReader, manifestPath, branch, uri, groupsParam, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles(),\n \t\t\t\t\t\t\tproj.getGroups(),\n \t\t\t\t\t\t\tproj.getRecommendShallow());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream != null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it's not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tStringBuilder attributes = new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n-\t\t\t\t\tString name = proj.getPath();\n+\t\t\t\t\tString path = proj.getPath();\n \t\t\t\t\tString nameUri = proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n \t\t\t\t\t\t\t&& !ignoreRemoteFailures) {\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId = callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId == null) {\n \t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n-\t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\t\t\tcfg.setString(\"submodule\", path, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the 'clone-depth' field, while\n \t\t\t\t\t\t\t// git core only uses a binary 'shallow = true/false'\n \t\t\t\t\t\t\t// hint, we'll map any depth to 'shallow = true'\n-\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", name, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", path, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec = new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n-\t\t\t\t\t\trec.append(name);\n+\t\t\t\t\t\trec.append(path);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n-\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n-\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\tcfg.setString(\"submodule\", path, \"path\", path); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\tcfg.setString(\"submodule\", path, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n-\t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(name);\n+\t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(path);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src = callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": {
			"type": "Ybodychange",
			"commitMessage": "Enable and fix warnings about redundant specification of type arguments\n\nSince the introduction of generic type parameter inference in Java 7,\nit's not necessary to explicitly specify the type of generic parameters.\n\nEnable the warning in Eclipse, and fix all occurrences.\n\nChange-Id: I9158caf1beca5e4980b6240ac401f3868520aad0\nSigned-off-by: David Pursehouse <david.pursehouse@gmail.com>\n",
			"commitDate": "2017-02-20, 2:47 PM",
			"commitName": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
			"commitAuthor": "David Pursehouse",
			"commitDateOld": "2017-02-19, 5:05 PM",
			"commitNameOld": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
			"commitAuthorOld": "David Pursehouse",
			"daysBetweenCommits": 0.9,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,190 +1,190 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri == null || uri.length() == 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream == null) {\n \t\t\t\tif (path == null || path.length() == 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream = new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n-\t\t\t\tbareProjects = new ArrayList<RepoProject>();\n+\t\t\t\tbareProjects = new ArrayList<>();\n \t\t\t\tif (author == null)\n \t\t\t\t\tauthor = new PersonIdent(repo);\n \t\t\t\tif (callback == null)\n \t\t\t\t\tcallback = new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit = new Git(repo);\n \n \t\t\tManifestParser parser = new ManifestParser(\n \t\t\t\t\tincludedReader, path, branch, uri, groupsParam, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles(),\n \t\t\t\t\t\t\tproj.getGroups(),\n \t\t\t\t\t\t\tproj.getRecommendShallow());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream != null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it's not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tStringBuilder attributes = new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString name = proj.getPath();\n \t\t\t\t\tString nameUri = proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n \t\t\t\t\t\t\t&& !ignoreRemoteFailures) {\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId = callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId == null) {\n \t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the 'clone-depth' field, while\n \t\t\t\t\t\t\t// git core only uses a binary 'shallow = true/false'\n \t\t\t\t\t\t\t// hint, we'll map any depth to 'shallow = true'\n \t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", name, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec = new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(name);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(name);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src = callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a9b87de97090b4f7d25ace0525edc1268cfa737f": {
			"type": "Ybodychange",
			"commitMessage": "RepoCommand: Avoid group lists shadowing groups strings\n\nReported-by: David Pursehouse <david.pursehouse@gmail.com>\nChange-Id: I9e9b021d335bda4d58b6bcc30f59b81ac5b37724\nSigned-off-by: Jonathan Nieder <jrn@google.com>\n",
			"commitDate": "2016-08-08, 7:51 PM",
			"commitName": "a9b87de97090b4f7d25ace0525edc1268cfa737f",
			"commitAuthor": "Jonathan Nieder",
			"commitDateOld": "2016-06-01, 2:17 AM",
			"commitNameOld": "525baa1213097aa8635d846ce024635b1f33931a",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 68.73,
			"commitsBetweenForRepo": 92,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,190 +1,190 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri == null || uri.length() == 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream == null) {\n \t\t\t\tif (path == null || path.length() == 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream = new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects = new ArrayList<RepoProject>();\n \t\t\t\tif (author == null)\n \t\t\t\t\tauthor = new PersonIdent(repo);\n \t\t\t\tif (callback == null)\n \t\t\t\t\tcallback = new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit = new Git(repo);\n \n \t\t\tManifestParser parser = new ManifestParser(\n-\t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n+\t\t\t\t\tincludedReader, path, branch, uri, groupsParam, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles(),\n \t\t\t\t\t\t\tproj.getGroups(),\n \t\t\t\t\t\t\tproj.getRecommendShallow());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream != null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it's not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tStringBuilder attributes = new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString name = proj.getPath();\n \t\t\t\t\tString nameUri = proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n \t\t\t\t\t\t\t&& !ignoreRemoteFailures) {\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId = callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId == null) {\n \t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n \t\t\t\t\t\t\t// The shallow recommendation is losing information.\n \t\t\t\t\t\t\t// As the repo manifests stores the recommended\n \t\t\t\t\t\t\t// depth in the 'clone-depth' field, while\n \t\t\t\t\t\t\t// git core only uses a binary 'shallow = true/false'\n \t\t\t\t\t\t\t// hint, we'll map any depth to 'shallow = true'\n \t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", name, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\ttrue);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec = new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(name);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(name);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src = callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6ae4ed0f7da996bde2ba5cdc26daff979c9f6866": {
			"type": "Ybodychange",
			"commitMessage": "RepoCommand: record manifest shallow recommendation in .gitmodules\n\nGit core learned about the submodule.<name>.shallow option in\n.gitmodules files, which is a recommendation to clone a submodule\nshallow. A repo manifest may record a clone depth recommendation as\nan optional field, which contains more information than a binary\nshallow/nonshallow recommendation, so any attempted conversion may be\nlossy. In practice the clone depth recommendation is either '1' or doesn't\nexist, which is the binary behavior we have in Git core.\n\nChange-Id: I51aa9cb6d1d9660dae6ab6d21ad7bae9bc5325e6\nSigned-off-by: Stefan Beller <sbeller@google.com>\n",
			"commitDate": "2016-05-31, 4:19 PM",
			"commitName": "6ae4ed0f7da996bde2ba5cdc26daff979c9f6866",
			"commitAuthor": "Stefan Beller",
			"commitDateOld": "2016-05-31, 4:18 PM",
			"commitNameOld": "ddd0fe257bc78dc9646407e7121769d0c03e0d94",
			"commitAuthorOld": "Stefan Beller",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,179 +1,190 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri == null || uri.length() == 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream == null) {\n \t\t\t\tif (path == null || path.length() == 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream = new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects = new ArrayList<RepoProject>();\n \t\t\t\tif (author == null)\n \t\t\t\t\tauthor = new PersonIdent(repo);\n \t\t\t\tif (callback == null)\n \t\t\t\t\tcallback = new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit = new Git(repo);\n \n \t\t\tManifestParser parser = new ManifestParser(\n \t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles(),\n-\t\t\t\t\t\t\tproj.getGroups());\n+\t\t\t\t\t\t\tproj.getGroups(),\n+\t\t\t\t\t\t\tproj.getRecommendShallow());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream != null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it's not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tStringBuilder attributes = new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString name = proj.getPath();\n \t\t\t\t\tString nameUri = proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n \t\t\t\t\t\t\t&& !ignoreRemoteFailures) {\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId = callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId == null) {\n \t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif (recordShallowSubmodules && proj.getRecommendShallow() != null) {\n+\t\t\t\t\t\t\t// The shallow recommendation is losing information.\n+\t\t\t\t\t\t\t// As the repo manifests stores the recommended\n+\t\t\t\t\t\t\t// depth in the 'clone-depth' field, while\n+\t\t\t\t\t\t\t// git core only uses a binary 'shallow = true/false'\n+\t\t\t\t\t\t\t// hint, we'll map any depth to 'shallow = true'\n+\t\t\t\t\t\t\tcfg.setBoolean(\"submodule\", name, \"shallow\", //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\t\t\t\t\ttrue);\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t\tStringBuilder rec = new StringBuilder();\n \t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n \t\t\t\t\t\trec.append(name);\n \t\t\t\t\t\tfor (String group : proj.getGroups()) {\n \t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n \t\t\t\t\t\t\trec.append(group);\n \t\t\t\t\t\t}\n \t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n \t\t\t\t\t\tattributes.append(rec.toString());\n \t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(name);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src = callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tif (recordSubmoduleLabels) {\n \t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n \t\t\t\t\tfinal DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n \t\t\t\t\tObjectId attrId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n \t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\tbuilder.add(dcEntryAttr);\n \t\t\t\t}\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ddd0fe257bc78dc9646407e7121769d0c03e0d94": {
			"type": "Ybodychange",
			"commitMessage": "RepoCommand: record manifest groups as submodule labels\n\nGit core learned about attributes in pathspecs:\n\n    pathspec: allow querying for attributes\n\n    The pathspec mechanism is extended via the new\n    \":(attr:eol=input)pattern/to/match\" syntax to filter paths so that it\n    requires paths to not just match the given pattern but also have the\n    specified attrs attached for them to be chosen.\n\n(177161a5f7, 2016-05-20)\n\nWe intend to use these pathspec attribute patterns for submodule\ngrouping, similar to the grouping in repo. So the RepoCommand which\ntranslates repo manifest files into submodules should propagate this\ninformation along. This requires writing information to the\n.gitattributes file instead of the .gitmodules file. For now we just\noverwrite any existing .gitattributes file and do not care about prior\nattributes set. If this becomes an issue we need to figure out how to\ncorrectly amend the grouping information to an existing .gitattributes\nfile.\n\nChange-Id: I0f55b45786b6b8fc3d5be62d7f6aab9ac00ed60e\nSigned-off-by: Stefan Beller <sbeller@google.com>\n",
			"commitDate": "2016-05-31, 4:18 PM",
			"commitName": "ddd0fe257bc78dc9646407e7121769d0c03e0d94",
			"commitAuthor": "Stefan Beller",
			"commitDateOld": "2016-03-11, 3:37 PM",
			"commitNameOld": "7507d9e2a967e9c978e1fab3ca22deec1b5632c5",
			"commitAuthorOld": "Yuxuan 'fishy' Wang",
			"daysBetweenCommits": 80.99,
			"commitsBetweenForRepo": 63,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,156 +1,179 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri == null || uri.length() == 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream == null) {\n \t\t\t\tif (path == null || path.length() == 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream = new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects = new ArrayList<RepoProject>();\n \t\t\t\tif (author == null)\n \t\t\t\t\tauthor = new PersonIdent(repo);\n \t\t\t\tif (callback == null)\n \t\t\t\t\tcallback = new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit = new Git(repo);\n \n \t\t\tManifestParser parser = new ManifestParser(\n \t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n-\t\t\t\t\t\t\tproj.getCopyFiles());\n+\t\t\t\t\t\t\tproj.getCopyFiles(),\n+\t\t\t\t\t\t\tproj.getGroups());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream != null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it's not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\t\tConfig cfg = new Config();\n+\t\t\t\tStringBuilder attributes = new StringBuilder();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString name = proj.getPath();\n \t\t\t\t\tString nameUri = proj.getName();\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n \t\t\t\t\t\t\t&& !ignoreRemoteFailures) {\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId = callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t\tif (objectId == null) {\n \t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n+\t\t\t\t\tif (recordSubmoduleLabels) {\n+\t\t\t\t\t\tStringBuilder rec = new StringBuilder();\n+\t\t\t\t\t\trec.append(\"/\"); //$NON-NLS-1$\n+\t\t\t\t\t\trec.append(name);\n+\t\t\t\t\t\tfor (String group : proj.getGroups()) {\n+\t\t\t\t\t\t\trec.append(\" \"); //$NON-NLS-1$\n+\t\t\t\t\t\t\trec.append(group);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\trec.append(\"\\n\"); //$NON-NLS-1$\n+\t\t\t\t\t\tattributes.append(rec.toString());\n+\t\t\t\t\t}\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(name);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src = callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n+\t\t\t\tif (recordSubmoduleLabels) {\n+\t\t\t\t\t// create a new DirCacheEntry for .gitattributes file.\n+\t\t\t\t\tfinal DirCacheEntry dcEntryAttr = new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n+\t\t\t\t\tObjectId attrId = inserter.insert(Constants.OBJ_BLOB,\n+\t\t\t\t\t\t\tattributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n+\t\t\t\t\tdcEntryAttr.setObjectId(attrId);\n+\t\t\t\t\tdcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n+\t\t\t\t\tbuilder.add(dcEntryAttr);\n+\t\t\t\t}\n+\n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0ecb016d7db42ab83584cab3c1554d4d28cc5062": {
			"type": "Ybodychange",
			"commitMessage": "Add ignoreRemoteFailures option to RepoCommand\n\nWith ignoreRemoteFailures set to true, we can ignore remote failures\n(e.g. the branch of a project described in the manifest file does not\nexist), skip that project and continue to the next one, instead of fail\nthe whole operation.\n\nChange-Id: I8b3765713599e34f1411f9bbc7f575ec7c2384e0\nSigned-off-by: Yuxuan 'fishy' Wang <fishywang@google.com>\n",
			"commitDate": "2016-03-11, 3:20 PM",
			"commitName": "0ecb016d7db42ab83584cab3c1554d4d28cc5062",
			"commitAuthor": "Yuxuan 'fishy' Wang",
			"commitDateOld": "2015-11-25, 3:05 PM",
			"commitNameOld": "fe98218e0df85012cb9b901c71c44f232f65cb3a",
			"commitAuthorOld": "Jonathan Nieder",
			"daysBetweenCommits": 107.01,
			"commitsBetweenForRepo": 267,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,149 +1,156 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri == null || uri.length() == 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream == null) {\n \t\t\t\tif (path == null || path.length() == 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream = new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects = new ArrayList<RepoProject>();\n \t\t\t\tif (author == null)\n \t\t\t\t\tauthor = new PersonIdent(repo);\n \t\t\t\tif (callback == null)\n \t\t\t\t\tcallback = new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit = new Git(repo);\n \n \t\t\tManifestParser parser = new ManifestParser(\n \t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream != null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it's not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString name = proj.getPath();\n \t\t\t\t\tString nameUri = proj.getName();\n-\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n-\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n-\t\t\t\t\t// create gitlink\n-\t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n-\t\t\t\t\tif (ObjectId.isId(proj.getRevision())) {\n+\t\t\t\t\tif (ObjectId.isId(proj.getRevision())\n+\t\t\t\t\t\t\t&& !ignoreRemoteFailures) {\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.getRevision());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId = callback.sha1(nameUri, proj.getRevision());\n-\t\t\t\t\t\tif (recordRemoteBranch)\n+\t\t\t\t\t\tif (objectId == null) {\n+\t\t\t\t\t\t\tif (ignoreRemoteFailures) {\n+\t\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (recordRemoteBranch) {\n \t\t\t\t\t\t\t// can be branch or tag\n \t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t\t\t\t\tproj.getRevision());\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t\tif (objectId == null)\n-\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n+\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n+\n+\t\t\t\t\t// create gitlink\n+\t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(name);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src = callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cdd7c23446a0030e5b521d91cbb2d3a9c522ccc2": {
			"type": "Ybodychange",
			"commitMessage": "RepoCommand: Add setRecordRemoteBranch option to record upstream branch\n\nOn a server also running Gerrit that is using RepoCommand to\nconvert from an XML manifest to a git submodule superproject\nperiodically, it would be handy to be able to use Gerrit's\nsubmodule subscription feature[1] to update the superproject\nautomatically between RepoCommand runs as changes are merged\nin each subprojects.\n\nThis requires setting the 'branch' field for each submodule\nso that Gerrit knows what branch to watch.  Add an option to\ndo that.\n\nSetting the branch field also is useful for plain Git users,\nsince it allows them to use \"git submodule update --remote\" to\nmanually update all submodules between RepoCommand runs.\n\n[1] https://gerrit-review.googlesource.com/Documentation/user-submodules.html\n\nChange-Id: I1a10861bcd0df3b3673fc2d481c8129b2bdac5f9\nSigned-off-by: Stefan Beller <sbeller@google.com>\n",
			"commitDate": "2015-10-05, 5:01 PM",
			"commitName": "cdd7c23446a0030e5b521d91cbb2d3a9c522ccc2",
			"commitAuthor": "Stefan Beller",
			"commitDateOld": "2015-07-10, 12:39 PM",
			"commitNameOld": "217b2a7cc5366491be5317d20f3f3c1b6e3475bf",
			"commitAuthorOld": "Yuxuan 'fishy' Wang",
			"daysBetweenCommits": 87.18,
			"commitsBetweenForRepo": 77,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,145 +1,149 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri == null || uri.length() == 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream == null) {\n \t\t\t\tif (path == null || path.length() == 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream = new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects = new ArrayList<RepoProject>();\n \t\t\t\tif (author == null)\n \t\t\t\t\tauthor = new PersonIdent(repo);\n \t\t\t\tif (callback == null)\n \t\t\t\t\tcallback = new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit = new Git(repo);\n \n \t\t\tManifestParser parser = new ManifestParser(\n \t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream != null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it's not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString name = proj.getPath();\n \t\t\t\t\tString nameUri = proj.getName();\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n-\t\t\t\t\tif (ObjectId.isId(proj.getRevision()))\n+\t\t\t\t\tif (ObjectId.isId(proj.getRevision())) {\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.getRevision());\n-\t\t\t\t\telse {\n+\t\t\t\t\t} else {\n \t\t\t\t\t\tobjectId = callback.sha1(nameUri, proj.getRevision());\n+\t\t\t\t\t\tif (recordRemoteBranch)\n+\t\t\t\t\t\t\t// can be branch or tag\n+\t\t\t\t\t\t\tcfg.setString(\"submodule\", name, \"branch\", //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\t\t\t\t\tproj.getRevision());\n \t\t\t\t\t}\n \t\t\t\t\tif (objectId == null)\n \t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src = callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tMessageFormat.format(\n \t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n \t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"217b2a7cc5366491be5317d20f3f3c1b6e3475bf": {
			"type": "Ybodychange",
			"commitMessage": "Add setTargetBranch in RepoCommand.\n\nThis will allow us to write the super project in a branch other than\nmaster.\n\nChange-Id: I578ed9ecbc6423416239e31ad644531dae9fb5c3\nSigned-off-by: Yuxuan 'fishy' Wang <fishywang@google.com>\n",
			"commitDate": "2015-07-10, 12:39 PM",
			"commitName": "217b2a7cc5366491be5317d20f3f3c1b6e3475bf",
			"commitAuthor": "Yuxuan 'fishy' Wang",
			"commitDateOld": "2015-05-26, 10:58 AM",
			"commitNameOld": "744c370c1be8044d1ccaaf84cd164324961fea1a",
			"commitAuthorOld": "Yuxuan 'fishy' Wang",
			"daysBetweenCommits": 45.07,
			"commitsBetweenForRepo": 104,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,143 +1,145 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri == null || uri.length() == 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream == null) {\n \t\t\t\tif (path == null || path.length() == 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream = new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects = new ArrayList<RepoProject>();\n \t\t\t\tif (author == null)\n \t\t\t\t\tauthor = new PersonIdent(repo);\n \t\t\t\tif (callback == null)\n \t\t\t\t\tcallback = new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit = new Git(repo);\n \n \t\t\tManifestParser parser = new ManifestParser(\n \t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n \t\t\t\t\taddSubmodule(proj.getUrl(),\n \t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n \t\t\t\t\t\t\tproj.getCopyFiles());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream != null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it's not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString name = proj.getPath();\n \t\t\t\t\tString nameUri = proj.getName();\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.getRevision()))\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.getRevision());\n \t\t\t\t\telse {\n \t\t\t\t\t\tobjectId = callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t}\n \t\t\t\t\tif (objectId == null)\n \t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src = callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n-\t\t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n+\t\t\t\tObjectId headId = repo.resolve(targetBranch + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n-\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n+\t\t\t\tRefUpdate ru = repo.updateRef(targetBranch);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n-\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n+\t\t\t\t\t\t\t\tMessageFormat.format(\n+\t\t\t\t\t\t\t\t\t\tJGitText.get().cannotLock, targetBranch),\n+\t\t\t\t\t\t\t\tru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n-\t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n+\t\t\t\t\t\t\t\ttargetBranch, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"744c370c1be8044d1ccaaf84cd164324961fea1a": {
			"type": "Ybodychange",
			"commitMessage": "Add getters to RepoProject.\n\nChange-Id: I74ded6c2c3f5985568cd77bd8799b45017fb1d09\nSigned-off-by: Yuxuan 'fishy' Wang <fishywang@google.com>\n",
			"commitDate": "2015-05-26, 10:58 AM",
			"commitName": "744c370c1be8044d1ccaaf84cd164324961fea1a",
			"commitAuthor": "Yuxuan 'fishy' Wang",
			"commitDateOld": "2015-05-24, 2:27 AM",
			"commitNameOld": "1773002a3446c93ab03997b65139fc7d014599b9",
			"commitAuthorOld": "Andrey Loskutov",
			"daysBetweenCommits": 2.36,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,143 +1,143 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri == null || uri.length() == 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream == null) {\n \t\t\t\tif (path == null || path.length() == 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream = new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects = new ArrayList<RepoProject>();\n \t\t\t\tif (author == null)\n \t\t\t\t\tauthor = new PersonIdent(repo);\n \t\t\t\tif (callback == null)\n \t\t\t\t\tcallback = new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit = new Git(repo);\n \n \t\t\tManifestParser parser = new ManifestParser(\n \t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n \t\t\ttry {\n \t\t\t\tparser.read(inputStream);\n \t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n-\t\t\t\t\taddSubmodule(proj.url,\n-\t\t\t\t\t\t\tproj.path,\n+\t\t\t\t\taddSubmodule(proj.getUrl(),\n+\t\t\t\t\t\t\tproj.getPath(),\n \t\t\t\t\t\t\tproj.getRevision(),\n-\t\t\t\t\t\t\tproj.copyfiles);\n+\t\t\t\t\t\t\tproj.getCopyFiles());\n \t\t\t\t}\n \t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream != null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it's not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tfor (RepoProject proj : bareProjects) {\n-\t\t\t\t\tString name = proj.path;\n-\t\t\t\t\tString nameUri = proj.name;\n+\t\t\t\t\tString name = proj.getPath();\n+\t\t\t\t\tString nameUri = proj.getName();\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n-\t\t\t\t\tif (ObjectId.isId(proj.revision))\n-\t\t\t\t\t\tobjectId = ObjectId.fromString(proj.revision);\n+\t\t\t\t\tif (ObjectId.isId(proj.getRevision()))\n+\t\t\t\t\t\tobjectId = ObjectId.fromString(proj.getRevision());\n \t\t\t\t\telse {\n-\t\t\t\t\t\tobjectId = callback.sha1(nameUri, proj.revision);\n+\t\t\t\t\t\tobjectId = callback.sha1(nameUri, proj.getRevision());\n \t\t\t\t\t}\n \t\t\t\t\tif (objectId == null)\n \t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n-\t\t\t\t\tfor (CopyFile copyfile : proj.copyfiles) {\n+\t\t\t\t\tfor (CopyFile copyfile : proj.getCopyFiles()) {\n \t\t\t\t\t\tbyte[] src = callback.readFile(\n-\t\t\t\t\t\t\t\tnameUri, proj.revision, copyfile.src);\n+\t\t\t\t\t\t\t\tnameUri, proj.getRevision(), copyfile.src);\n \t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d3348e5623a2abf7b2f1356ea077d6eb9bf7760c": {
			"type": "Ybodychange",
			"commitMessage": "Refactor to expose ManifestParser.\n\nThe repo xml manifest parser used in RepoCommand could also be useful for\nothers, so refactor to make it public.\n\nAlso this breaks backward compatibility slightly.\n\nChange-Id: I5001bd2fe77541109fe32dbe2597a065e6ad585e\nSigned-off-by: Yuxuan 'fishy' Wang <fishywang@google.com>\n",
			"commitDate": "2015-05-22, 12:08 PM",
			"commitName": "d3348e5623a2abf7b2f1356ea077d6eb9bf7760c",
			"commitAuthor": "Yuxuan 'fishy' Wang",
			"commitDateOld": "2015-05-20, 4:01 PM",
			"commitNameOld": "0e73d395061d1bfee365acaa2f79c392175d13bf",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 1.84,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,137 +1,143 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri == null || uri.length() == 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream == null) {\n \t\t\t\tif (path == null || path.length() == 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream = new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n-\t\t\t\tbareProjects = new ArrayList<Project>();\n+\t\t\t\tbareProjects = new ArrayList<RepoProject>();\n \t\t\t\tif (author == null)\n \t\t\t\t\tauthor = new PersonIdent(repo);\n \t\t\t\tif (callback == null)\n \t\t\t\t\tcallback = new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit = new Git(repo);\n \n-\t\t\tXmlManifest manifest = new XmlManifest(\n-\t\t\t\t\tthis, includedReader, path, uri, groups);\n+\t\t\tManifestParser parser = new ManifestParser(\n+\t\t\t\t\tincludedReader, path, branch, uri, groups, repo);\n \t\t\ttry {\n-\t\t\t\tmanifest.read(inputStream);\n-\t\t\t} catch (IOException e) {\n+\t\t\t\tparser.read(inputStream);\n+\t\t\t\tfor (RepoProject proj : parser.getFilteredProjects()) {\n+\t\t\t\t\taddSubmodule(proj.url,\n+\t\t\t\t\t\t\tproj.path,\n+\t\t\t\t\t\t\tproj.getRevision(),\n+\t\t\t\t\t\t\tproj.copyfiles);\n+\t\t\t\t}\n+\t\t\t} catch (GitAPIException | IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream != null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it's not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\t\tConfig cfg = new Config();\n-\t\t\t\tfor (Project proj : bareProjects) {\n+\t\t\t\tfor (RepoProject proj : bareProjects) {\n \t\t\t\t\tString name = proj.path;\n \t\t\t\t\tString nameUri = proj.name;\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.revision))\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.revision);\n \t\t\t\t\telse {\n \t\t\t\t\t\tobjectId = callback.sha1(nameUri, proj.revision);\n \t\t\t\t\t}\n \t\t\t\t\tif (objectId == null)\n \t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.copyfiles) {\n \t\t\t\t\t\tbyte[] src = callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.revision, copyfile.src);\n \t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0e73d395061d1bfee365acaa2f79c392175d13bf": {
			"type": "Ybodychange",
			"commitMessage": "Use AutoClosable to close resources in bundle org.eclipse.jgit\n\n- use try-with-resource where possible\n- replace use of deprecated release() by close()\n\nChange-Id: I0f139c3535679087b7fa09649166bca514750b81\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2015-05-20, 4:01 PM",
			"commitName": "0e73d395061d1bfee365acaa2f79c392175d13bf",
			"commitAuthor": "Matthias Sohn",
			"commitDateOld": "2015-01-21, 4:42 PM",
			"commitNameOld": "9ffe6deced8dd79dd283fff650a8ac19ce3d9a08",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 118.93,
			"commitsBetweenForRepo": 171,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,140 +1,137 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri == null || uri.length() == 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream == null) {\n \t\t\t\tif (path == null || path.length() == 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream = new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects = new ArrayList<Project>();\n \t\t\t\tif (author == null)\n \t\t\t\t\tauthor = new PersonIdent(repo);\n \t\t\t\tif (callback == null)\n \t\t\t\t\tcallback = new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit = new Git(repo);\n \n \t\t\tXmlManifest manifest = new XmlManifest(\n \t\t\t\t\tthis, includedReader, path, uri, groups);\n \t\t\ttry {\n \t\t\t\tmanifest.read(inputStream);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream != null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it's not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n-\t\t\tRevWalk rw = new RevWalk(repo);\n-\t\t\ttry {\n+\t\t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tfor (Project proj : bareProjects) {\n \t\t\t\t\tString name = proj.path;\n \t\t\t\t\tString nameUri = proj.name;\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.revision))\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.revision);\n \t\t\t\t\telse {\n \t\t\t\t\t\tobjectId = callback.sha1(nameUri, proj.revision);\n \t\t\t\t\t}\n \t\t\t\t\tif (objectId == null)\n \t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.copyfiles) {\n \t\t\t\t\t\tbyte[] src = callback.readFile(\n \t\t\t\t\t\t\t\tnameUri, proj.revision, copyfile.src);\n \t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n-\t\t\t} finally {\n-\t\t\t\trw.release();\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2f6372337cfd5944e2179f5ec5e2dbe0cbc96386": {
			"type": "Ybodychange",
			"commitMessage": "Rename local variables/parameters to remove warnings about hiding\n\nChange-Id: I73f38492b6a2e7fd6e77005efd0a8a8c65763e74\n",
			"commitDate": "2014-09-04, 3:35 AM",
			"commitName": "2f6372337cfd5944e2179f5ec5e2dbe0cbc96386",
			"commitAuthor": "Robin Rosenberg",
			"commitDateOld": "2014-09-04, 3:28 AM",
			"commitNameOld": "0bc98f17b2b3504b1b180a605e45654ace49ef1a",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,140 +1,140 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri == null || uri.length() == 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream == null) {\n \t\t\t\tif (path == null || path.length() == 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream = new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects = new ArrayList<Project>();\n \t\t\t\tif (author == null)\n \t\t\t\t\tauthor = new PersonIdent(repo);\n \t\t\t\tif (callback == null)\n \t\t\t\t\tcallback = new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit = new Git(repo);\n \n \t\t\tXmlManifest manifest = new XmlManifest(\n \t\t\t\t\tthis, includedReader, path, uri, groups);\n \t\t\ttry {\n \t\t\t\tmanifest.read(inputStream);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream != null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it's not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\tRevWalk rw = new RevWalk(repo);\n \t\t\ttry {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tfor (Project proj : bareProjects) {\n \t\t\t\t\tString name = proj.path;\n-\t\t\t\t\tString uri = proj.name;\n+\t\t\t\t\tString nameUri = proj.name;\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n-\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", uri); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", nameUri); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.revision))\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.revision);\n \t\t\t\t\telse {\n-\t\t\t\t\t\tobjectId = callback.sha1(uri, proj.revision);\n+\t\t\t\t\t\tobjectId = callback.sha1(nameUri, proj.revision);\n \t\t\t\t\t}\n \t\t\t\t\tif (objectId == null)\n-\t\t\t\t\t\tthrow new RemoteUnavailableException(uri);\n+\t\t\t\t\t\tthrow new RemoteUnavailableException(nameUri);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.copyfiles) {\n \t\t\t\t\t\tbyte[] src = callback.readFile(\n-\t\t\t\t\t\t\t\turi, proj.revision, copyfile.src);\n+\t\t\t\t\t\t\t\tnameUri, proj.revision, copyfile.src);\n \t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t} finally {\n \t\t\t\trw.release();\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"34dd64f6fe36ace1a90b0b503e2e37d877b7c621": {
			"type": "Ybodychange",
			"commitMessage": "Add support to <include> tag in repo manifest xml.\n\nChange-Id: I32d468f92e24701ea680435bf3417e3850857303\nSigned-off-by: Yuxuan 'fishy' Wang <fishywang@google.com>\n",
			"commitDate": "2014-08-13, 2:04 PM",
			"commitName": "34dd64f6fe36ace1a90b0b503e2e37d877b7c621",
			"commitAuthor": "Yuxuan 'fishy' Wang",
			"commitDateOld": "2014-08-13, 11:36 AM",
			"commitNameOld": "38a24bc7990bfa76e5dbd905434341a28e8e543f",
			"commitAuthorOld": "Yuxuan 'fishy' Wang",
			"daysBetweenCommits": 0.1,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,140 +1,140 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\ttry {\n \t\t\tcheckCallable();\n \t\t\tif (uri == null || uri.length() == 0)\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\tJGitText.get().uriNotConfigured);\n \t\t\tif (inputStream == null) {\n \t\t\t\tif (path == null || path.length() == 0)\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\ttry {\n \t\t\t\t\tinputStream = new FileInputStream(path);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (repo.isBare()) {\n \t\t\t\tbareProjects = new ArrayList<Project>();\n \t\t\t\tif (author == null)\n \t\t\t\t\tauthor = new PersonIdent(repo);\n \t\t\t\tif (callback == null)\n \t\t\t\t\tcallback = new DefaultRemoteReader();\n \t\t\t} else\n \t\t\t\tgit = new Git(repo);\n \n \t\t\tXmlManifest manifest = new XmlManifest(\n-\t\t\t\t\tthis, inputStream, path, uri, groups);\n+\t\t\t\t\tthis, includedReader, path, uri, groups);\n \t\t\ttry {\n-\t\t\t\tmanifest.read();\n+\t\t\t\tmanifest.read(inputStream);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t}\n \t\t} finally {\n \t\t\ttry {\n \t\t\t\tif (inputStream != null)\n \t\t\t\t\tinputStream.close();\n \t\t\t} catch (IOException e) {\n \t\t\t\t// Just ignore it, it's not important.\n \t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\tRevWalk rw = new RevWalk(repo);\n \t\t\ttry {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tfor (Project proj : bareProjects) {\n \t\t\t\t\tString name = proj.path;\n \t\t\t\t\tString uri = proj.name;\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", uri); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.revision))\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.revision);\n \t\t\t\t\telse {\n \t\t\t\t\t\tobjectId = callback.sha1(uri, proj.revision);\n \t\t\t\t\t}\n \t\t\t\t\tif (objectId == null)\n \t\t\t\t\t\tthrow new RemoteUnavailableException(uri);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.copyfiles) {\n \t\t\t\t\t\tbyte[] src = callback.readFile(\n \t\t\t\t\t\t\t\turi, proj.revision, copyfile.src);\n \t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t} finally {\n \t\t\t\trw.release();\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"acd7ed52692bb7155333efea6dead712b7156ab9": {
			"type": "Ybodychange",
			"commitMessage": "Added setInputStream to RepoCommand.\n\nSometimes an input stream is more useful than the filename of the xml manifest.\n\nChange-Id: Icb09ac751b3d8d7eb14427ad1aac8cee0c371c5f\nSigned-off-by: Yuxuan 'fishy' Wang <fishywang@google.com>\n",
			"commitDate": "2014-06-09, 11:26 AM",
			"commitName": "acd7ed52692bb7155333efea6dead712b7156ab9",
			"commitAuthor": "Yuxuan 'fishy' Wang",
			"commitDateOld": "2014-06-05, 6:40 PM",
			"commitNameOld": "39001eacc1158050d6f1deaea259b4fe4af136dc",
			"commitAuthorOld": "Yuxuan 'fishy' Wang",
			"daysBetweenCommits": 3.7,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,120 +1,140 @@\n \tpublic RevCommit call() throws GitAPIException {\n-\t\tcheckCallable();\n-\t\tif (path == null || path.length() == 0)\n-\t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n-\t\tif (uri == null || uri.length() == 0)\n-\t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n-\n-\t\tif (repo.isBare()) {\n-\t\t\tbareProjects = new ArrayList<Project>();\n-\t\t\tif (author == null)\n-\t\t\t\tauthor = new PersonIdent(repo);\n-\t\t\tif (callback == null)\n-\t\t\t\tcallback = new DefaultRemoteReader();\n-\t\t} else\n-\t\t\tgit = new Git(repo);\n-\n-\t\tXmlManifest manifest = new XmlManifest(this, path, uri, groups);\n \t\ttry {\n-\t\t\tmanifest.read();\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new ManifestErrorException(e);\n+\t\t\tcheckCallable();\n+\t\t\tif (uri == null || uri.length() == 0)\n+\t\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\tJGitText.get().uriNotConfigured);\n+\t\t\tif (inputStream == null) {\n+\t\t\t\tif (path == null || path.length() == 0)\n+\t\t\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n+\t\t\t\ttry {\n+\t\t\t\t\tinputStream = new FileInputStream(path);\n+\t\t\t\t} catch (IOException e) {\n+\t\t\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\t\tJGitText.get().pathNotConfigured);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (repo.isBare()) {\n+\t\t\t\tbareProjects = new ArrayList<Project>();\n+\t\t\t\tif (author == null)\n+\t\t\t\t\tauthor = new PersonIdent(repo);\n+\t\t\t\tif (callback == null)\n+\t\t\t\t\tcallback = new DefaultRemoteReader();\n+\t\t\t} else\n+\t\t\t\tgit = new Git(repo);\n+\n+\t\t\tXmlManifest manifest = new XmlManifest(\n+\t\t\t\t\tthis, inputStream, path, uri, groups);\n+\t\t\ttry {\n+\t\t\t\tmanifest.read();\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new ManifestErrorException(e);\n+\t\t\t}\n+\t\t} finally {\n+\t\t\ttry {\n+\t\t\t\tif (inputStream != null)\n+\t\t\t\t\tinputStream.close();\n+\t\t\t} catch (IOException e) {\n+\t\t\t\t// Just ignore it, it's not important.\n+\t\t\t}\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\tRevWalk rw = new RevWalk(repo);\n \t\t\ttry {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tfor (Project proj : bareProjects) {\n \t\t\t\t\tString name = proj.path;\n \t\t\t\t\tString uri = proj.name;\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", uri); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t// create gitlink\n \t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.revision))\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.revision);\n \t\t\t\t\telse {\n \t\t\t\t\t\tobjectId = callback.sha1(uri, proj.revision);\n \t\t\t\t\t}\n \t\t\t\t\tif (objectId == null)\n \t\t\t\t\t\tthrow new RemoteUnavailableException(uri);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\t\tfor (CopyFile copyfile : proj.copyfiles) {\n \t\t\t\t\t\tbyte[] src = callback.readFile(\n \t\t\t\t\t\t\t\turi, proj.revision, copyfile.src);\n \t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n \t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n \t\t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t} finally {\n \t\t\t\trw.release();\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0b15b48f741f87277e0d1c7d29637430b880dbde": {
			"type": "Ybodychange",
			"commitMessage": "Handle repo copyfile in bare repositories.\n\nChange-Id: Ie06f0c3d1bc9b2123102efaa5542ec3c232b72cd\nSigned-off-by: Yuxuan 'fishy' Wang <fishywang@google.com>\n",
			"commitDate": "2014-05-09, 6:25 PM",
			"commitName": "0b15b48f741f87277e0d1c7d29637430b880dbde",
			"commitAuthor": "Yuxuan 'fishy' Wang",
			"commitDateOld": "2014-05-09, 6:25 PM",
			"commitNameOld": "d998bc938a21cb3871b442a3bb54b5807b6e4ed2",
			"commitAuthorOld": "Yuxuan 'fishy' Wang",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,111 +1,121 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\tcheckCallable();\n \t\tif (path == null || path.length() == 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n \t\tif (uri == null || uri.length() == 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n \n \t\tif (repo.isBare()) {\n \t\t\tbareProjects = new ArrayList<Project>();\n \t\t\tif (author == null)\n \t\t\t\tauthor = new PersonIdent(repo);\n \t\t\tif (callback == null)\n \t\t\t\tcallback = new DefaultRemoteReader();\n \t\t} else\n \t\t\tgit = new Git(repo);\n \n \t\tXmlManifest manifest = new XmlManifest(this, path, uri, groups);\n \t\ttry {\n \t\t\tmanifest.read();\n \t\t} catch (IOException e) {\n \t\t\tthrow new ManifestErrorException(e);\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\tRevWalk rw = new RevWalk(repo);\n \n \t\t\ttry {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tfor (Project proj : bareProjects) {\n \t\t\t\t\tString name = proj.path;\n \t\t\t\t\tString uri = proj.name;\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", uri); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t// create gitlink\n-\t\t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(name);\n+\t\t\t\t\tDirCacheEntry dcEntry = new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n \t\t\t\t\tif (ObjectId.isId(proj.revision))\n \t\t\t\t\t\tobjectId = ObjectId.fromString(proj.revision);\n \t\t\t\t\telse {\n \t\t\t\t\t\tobjectId = callback.sha1(uri, proj.revision);\n \t\t\t\t\t}\n \t\t\t\t\tif (objectId == null)\n \t\t\t\t\t\tthrow new RemoteUnavailableException(uri);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n+\n+\t\t\t\t\tfor (CopyFile copyfile : proj.copyfiles) {\n+\t\t\t\t\t\tbyte[] src = callback.readFile(\n+\t\t\t\t\t\t\t\turi, proj.revision, copyfile.src);\n+\t\t\t\t\t\tobjectId = inserter.insert(Constants.OBJ_BLOB, src);\n+\t\t\t\t\t\tdcEntry = new DirCacheEntry(copyfile.dest);\n+\t\t\t\t\t\tdcEntry.setObjectId(objectId);\n+\t\t\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n+\t\t\t\t\t\tbuilder.add(dcEntry);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t} finally {\n \t\t\t\trw.release();\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d998bc938a21cb3871b442a3bb54b5807b6e4ed2": {
			"type": "Ybodychange",
			"commitMessage": "Handle the revision attribute in repo manifest.\n\nChange-Id: I77fe073aeb13c58029551b7d6e1451a9b62dc766\nSigned-off-by: Yuxuan 'fishy' Wang <fishywang@google.com>\n",
			"commitDate": "2014-05-09, 6:25 PM",
			"commitName": "d998bc938a21cb3871b442a3bb54b5807b6e4ed2",
			"commitAuthor": "Yuxuan 'fishy' Wang",
			"commitDateOld": "2014-05-07, 12:03 PM",
			"commitNameOld": "056135a1482a9d56ee5055d6bc2df5bea032b5e5",
			"commitAuthorOld": "Yuxuan 'fishy' Wang",
			"daysBetweenCommits": 2.27,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,115 +1,111 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\tcheckCallable();\n \t\tif (path == null || path.length() == 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n \t\tif (uri == null || uri.length() == 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n \n \t\tif (repo.isBare()) {\n \t\t\tbareProjects = new ArrayList<Project>();\n \t\t\tif (author == null)\n \t\t\t\tauthor = new PersonIdent(repo);\n \t\t\tif (callback == null)\n \t\t\t\tcallback = new DefaultRemoteReader();\n \t\t} else\n \t\t\tgit = new Git(repo);\n \n \t\tXmlManifest manifest = new XmlManifest(this, path, uri, groups);\n \t\ttry {\n \t\t\tmanifest.read();\n \t\t} catch (IOException e) {\n \t\t\tthrow new ManifestErrorException(e);\n \t\t}\n \n \t\tif (repo.isBare()) {\n \t\t\tDirCache index = DirCache.newInCore();\n \t\t\tDirCacheBuilder builder = index.builder();\n \t\t\tObjectInserter inserter = repo.newObjectInserter();\n \t\t\tRevWalk rw = new RevWalk(repo);\n \n \t\t\ttry {\n \t\t\t\tConfig cfg = new Config();\n \t\t\t\tfor (Project proj : bareProjects) {\n \t\t\t\t\tString name = proj.path;\n \t\t\t\t\tString uri = proj.name;\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", uri); //$NON-NLS-1$ //$NON-NLS-2$\n \t\t\t\t\t// create gitlink\n \t\t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(name);\n \t\t\t\t\tObjectId objectId;\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tobjectId = callback.sha1(uri);\n-\t\t\t\t\t} catch (GitAPIException e) {\n-\t\t\t\t\t\t// Something wrong getting the head sha1\n-\t\t\t\t\t\tthrow new RemoteUnavailableException(uri, e);\n-\t\t\t\t\t} catch (IllegalArgumentException e) {\n-\t\t\t\t\t\t// The revision from the manifest is malformed.\n-\t\t\t\t\t\tthrow new ManifestErrorException(e);\n+\t\t\t\t\tif (ObjectId.isId(proj.revision))\n+\t\t\t\t\t\tobjectId = ObjectId.fromString(proj.revision);\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tobjectId = callback.sha1(uri, proj.revision);\n \t\t\t\t\t}\n \t\t\t\t\tif (objectId == null)\n-\t\t\t\t\t\tthrow new RemoteUnavailableException(uri, null);\n+\t\t\t\t\t\tthrow new RemoteUnavailableException(uri);\n \t\t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n \t\t\t\t\tbuilder.add(dcEntry);\n \t\t\t\t}\n \t\t\t\tString content = cfg.toText();\n \n \t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n \t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n \t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n \t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n \t\t\t\tdcEntry.setObjectId(objectId);\n \t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n \t\t\t\tbuilder.add(dcEntry);\n \n \t\t\t\tbuilder.finish();\n \t\t\t\tObjectId treeId = index.writeTree(inserter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setTreeId(treeId);\n \t\t\t\tif (headId != null)\n \t\t\t\t\tcommit.setParentIds(headId);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setCommitter(author);\n \t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n \n \t\t\t\tObjectId commitId = inserter.insert(commit);\n \t\t\t\tinserter.flush();\n \n \t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n \t\t\t\tResult rc = ru.update(rw);\n \n \t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\t\t// Successful. Do nothing.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n \t\t\t\t}\n \n \t\t\t\treturn rw.parseCommit(commitId);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new ManifestErrorException(e);\n \t\t\t} finally {\n \t\t\t\trw.release();\n \t\t\t}\n \t\t} else {\n \t\t\treturn git\n \t\t\t\t.commit()\n \t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n \t\t\t\t.call();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"056135a1482a9d56ee5055d6bc2df5bea032b5e5": {
			"type": "Ybodychange",
			"commitMessage": "Handle repo submodules for bare repositories.\n\nChange-Id: Id028a7bc9600baf0f3e2316a1f4b99e53ccc746a\nSigned-off-by: Yuxuan 'fishy' Wang <fishywang@google.com>\n",
			"commitDate": "2014-05-07, 12:03 PM",
			"commitName": "056135a1482a9d56ee5055d6bc2df5bea032b5e5",
			"commitAuthor": "Yuxuan 'fishy' Wang",
			"commitDateOld": "2014-04-25, 11:42 AM",
			"commitNameOld": "dc4c673902a0847b270faf1771595d7c189a1943",
			"commitAuthorOld": "Yuxuan 'fishy' Wang",
			"daysBetweenCommits": 12.01,
			"commitsBetweenForRepo": 21,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,20 +1,115 @@\n \tpublic RevCommit call() throws GitAPIException {\n \t\tcheckCallable();\n \t\tif (path == null || path.length() == 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n \t\tif (uri == null || uri.length() == 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n \n-\t\tgit = new Git(repo);\n+\t\tif (repo.isBare()) {\n+\t\t\tbareProjects = new ArrayList<Project>();\n+\t\t\tif (author == null)\n+\t\t\t\tauthor = new PersonIdent(repo);\n+\t\t\tif (callback == null)\n+\t\t\t\tcallback = new DefaultRemoteReader();\n+\t\t} else\n+\t\t\tgit = new Git(repo);\n+\n \t\tXmlManifest manifest = new XmlManifest(this, path, uri, groups);\n \t\ttry {\n \t\t\tmanifest.read();\n \t\t} catch (IOException e) {\n \t\t\tthrow new ManifestErrorException(e);\n \t\t}\n \n-\t\treturn git\n-\t\t\t.commit()\n-\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n-\t\t\t.call();\n+\t\tif (repo.isBare()) {\n+\t\t\tDirCache index = DirCache.newInCore();\n+\t\t\tDirCacheBuilder builder = index.builder();\n+\t\t\tObjectInserter inserter = repo.newObjectInserter();\n+\t\t\tRevWalk rw = new RevWalk(repo);\n+\n+\t\t\ttry {\n+\t\t\t\tConfig cfg = new Config();\n+\t\t\t\tfor (Project proj : bareProjects) {\n+\t\t\t\t\tString name = proj.path;\n+\t\t\t\t\tString uri = proj.name;\n+\t\t\t\t\tcfg.setString(\"submodule\", name, \"path\", name); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\tcfg.setString(\"submodule\", name, \"url\", uri); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\t\t\t\t// create gitlink\n+\t\t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(name);\n+\t\t\t\t\tObjectId objectId;\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tobjectId = callback.sha1(uri);\n+\t\t\t\t\t} catch (GitAPIException e) {\n+\t\t\t\t\t\t// Something wrong getting the head sha1\n+\t\t\t\t\t\tthrow new RemoteUnavailableException(uri, e);\n+\t\t\t\t\t} catch (IllegalArgumentException e) {\n+\t\t\t\t\t\t// The revision from the manifest is malformed.\n+\t\t\t\t\t\tthrow new ManifestErrorException(e);\n+\t\t\t\t\t}\n+\t\t\t\t\tif (objectId == null)\n+\t\t\t\t\t\tthrow new RemoteUnavailableException(uri, null);\n+\t\t\t\t\tdcEntry.setObjectId(objectId);\n+\t\t\t\t\tdcEntry.setFileMode(FileMode.GITLINK);\n+\t\t\t\t\tbuilder.add(dcEntry);\n+\t\t\t\t}\n+\t\t\t\tString content = cfg.toText();\n+\n+\t\t\t\t// create a new DirCacheEntry for .gitmodules file.\n+\t\t\t\tfinal DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);\n+\t\t\t\tObjectId objectId = inserter.insert(Constants.OBJ_BLOB,\n+\t\t\t\t\t\tcontent.getBytes(Constants.CHARACTER_ENCODING));\n+\t\t\t\tdcEntry.setObjectId(objectId);\n+\t\t\t\tdcEntry.setFileMode(FileMode.REGULAR_FILE);\n+\t\t\t\tbuilder.add(dcEntry);\n+\n+\t\t\t\tbuilder.finish();\n+\t\t\t\tObjectId treeId = index.writeTree(inserter);\n+\n+\t\t\t\t// Create a Commit object, populate it and write it\n+\t\t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n+\t\t\t\tCommitBuilder commit = new CommitBuilder();\n+\t\t\t\tcommit.setTreeId(treeId);\n+\t\t\t\tif (headId != null)\n+\t\t\t\t\tcommit.setParentIds(headId);\n+\t\t\t\tcommit.setAuthor(author);\n+\t\t\t\tcommit.setCommitter(author);\n+\t\t\t\tcommit.setMessage(RepoText.get().repoCommitMessage);\n+\n+\t\t\t\tObjectId commitId = inserter.insert(commit);\n+\t\t\t\tinserter.flush();\n+\n+\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n+\t\t\t\tru.setNewObjectId(commitId);\n+\t\t\t\tru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());\n+\t\t\t\tResult rc = ru.update(rw);\n+\n+\t\t\t\tswitch (rc) {\n+\t\t\t\t\tcase NEW:\n+\t\t\t\t\tcase FORCED:\n+\t\t\t\t\tcase FAST_FORWARD:\n+\t\t\t\t\t\t// Successful. Do nothing.\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase REJECTED:\n+\t\t\t\t\tcase LOCK_FAILURE:\n+\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n+\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n+\t\t\t\t\t\t\t\trc);\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n+\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n+\t\t\t\t\t\t\t\tConstants.HEAD, commitId.name(), rc));\n+\t\t\t\t}\n+\n+\t\t\t\treturn rw.parseCommit(commitId);\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new ManifestErrorException(e);\n+\t\t\t} finally {\n+\t\t\t\trw.release();\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn git\n+\t\t\t\t.commit()\n+\t\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n+\t\t\t\t.call();\n+\t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dc4c673902a0847b270faf1771595d7c189a1943": {
			"type": "Ymultichange(Yreturntypechange,Ybodychange)",
			"commitMessage": "Commit changes generated during repo command\n\nChange-Id: Ia4df9808294d2069dcc5973bcb69b4499c7dcacd\nSigned-off-by: Yuxuan 'fishy' Wang <fishywang@google.com>",
			"commitDate": "2014-04-25, 11:42 AM",
			"commitName": "dc4c673902a0847b270faf1771595d7c189a1943",
			"commitAuthor": "Yuxuan 'fishy' Wang",
			"subchanges": [
				{
					"type": "Yreturntypechange",
					"commitMessage": "Commit changes generated during repo command\n\nChange-Id: Ia4df9808294d2069dcc5973bcb69b4499c7dcacd\nSigned-off-by: Yuxuan 'fishy' Wang <fishywang@google.com>",
					"commitDate": "2014-04-25, 11:42 AM",
					"commitName": "dc4c673902a0847b270faf1771595d7c189a1943",
					"commitAuthor": "Yuxuan 'fishy' Wang",
					"commitDateOld": "2014-04-24, 12:03 AM",
					"commitNameOld": "51cccc9dae3191567a2972a7ebe692b1629808c1",
					"commitAuthorOld": "Yuxuan 'fishy' Wang",
					"daysBetweenCommits": 1.49,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,16 +1,20 @@\n-\tpublic Void call() throws GitAPIException {\n+\tpublic RevCommit call() throws GitAPIException {\n \t\tcheckCallable();\n \t\tif (path == null || path.length() == 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n \t\tif (uri == null || uri.length() == 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n \n+\t\tgit = new Git(repo);\n \t\tXmlManifest manifest = new XmlManifest(this, path, uri, groups);\n \t\ttry {\n \t\t\tmanifest.read();\n \t\t} catch (IOException e) {\n \t\t\tthrow new ManifestErrorException(e);\n \t\t}\n \n-\t\treturn null;\n+\t\treturn git\n+\t\t\t.commit()\n+\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n+\t\t\t.call();\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "Void",
						"newValue": "RevCommit"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Commit changes generated during repo command\n\nChange-Id: Ia4df9808294d2069dcc5973bcb69b4499c7dcacd\nSigned-off-by: Yuxuan 'fishy' Wang <fishywang@google.com>",
					"commitDate": "2014-04-25, 11:42 AM",
					"commitName": "dc4c673902a0847b270faf1771595d7c189a1943",
					"commitAuthor": "Yuxuan 'fishy' Wang",
					"commitDateOld": "2014-04-24, 12:03 AM",
					"commitNameOld": "51cccc9dae3191567a2972a7ebe692b1629808c1",
					"commitAuthorOld": "Yuxuan 'fishy' Wang",
					"daysBetweenCommits": 1.49,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,16 +1,20 @@\n-\tpublic Void call() throws GitAPIException {\n+\tpublic RevCommit call() throws GitAPIException {\n \t\tcheckCallable();\n \t\tif (path == null || path.length() == 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n \t\tif (uri == null || uri.length() == 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n \n+\t\tgit = new Git(repo);\n \t\tXmlManifest manifest = new XmlManifest(this, path, uri, groups);\n \t\ttry {\n \t\t\tmanifest.read();\n \t\t} catch (IOException e) {\n \t\t\tthrow new ManifestErrorException(e);\n \t\t}\n \n-\t\treturn null;\n+\t\treturn git\n+\t\t\t.commit()\n+\t\t\t.setMessage(RepoText.get().repoCommitMessage)\n+\t\t\t.call();\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"a44a687fedbf1559277b8e6706819aa9be7bce39": {
			"type": "Ybodychange",
			"commitMessage": "Added groups support to repo subcommand.\n\nChange-Id: Id0e7663b6ac4f6938fdcacaf2158107b6285fc25\nSigned-off-by: Yuxuan 'fishy' Wang <fishywang@google.com>\n",
			"commitDate": "2014-04-24, 12:03 AM",
			"commitName": "a44a687fedbf1559277b8e6706819aa9be7bce39",
			"commitAuthor": "Yuxuan 'fishy' Wang",
			"commitDateOld": "2014-04-23, 11:48 PM",
			"commitNameOld": "0ad8fa7b36dafbea07da15897cc2f2b601772e24",
			"commitAuthorOld": "Yuxuan 'fishy' Wang",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,16 +1,16 @@\n \tpublic Void call() throws GitAPIException {\n \t\tcheckCallable();\n \t\tif (path == null || path.length() == 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().pathNotConfigured);\n \t\tif (uri == null || uri.length() == 0)\n \t\t\tthrow new IllegalArgumentException(JGitText.get().uriNotConfigured);\n \n-\t\tXmlManifest manifest = new XmlManifest(this, path, uri);\n+\t\tXmlManifest manifest = new XmlManifest(this, path, uri, groups);\n \t\ttry {\n \t\t\tmanifest.read();\n \t\t} catch (IOException e) {\n \t\t\tthrow new ManifestErrorException(e);\n \t\t}\n \n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0ad8fa7b36dafbea07da15897cc2f2b601772e24": {
			"type": "Yintroduced",
			"commitMessage": "Implemented first part of the repo sub-command.\n\nCurrently the repo sub-command only \"works\", but the submodules will have .git\ndirectories themselves, and lacks group support.\n\nChange-Id: I88a6ee07109187c6c9bfd92a044775fcfb5befa6\nSigned-off-by: Yuxuan 'fishy' Wang <fishywang@google.com>\n",
			"commitDate": "2014-04-23, 11:48 PM",
			"commitName": "0ad8fa7b36dafbea07da15897cc2f2b601772e24",
			"commitAuthor": "Yuxuan 'fishy' Wang"
		}
	},
	"sha": "bd1a82502680b5de5bf86f6c4470185fd1602386"
}