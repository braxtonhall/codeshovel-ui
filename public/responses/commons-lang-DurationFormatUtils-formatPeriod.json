{
	"repo": "https://github.com/apache/commons-lang.git",
	"file": "src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java",
	"method": {
		"longName": "DurationFormatUtils::formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone)",
		"startLine": 279,
		"methodName": "formatPeriod",
		"isStatic": true,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"9a16b763d9c51b788415c5f83b6e9221a3cf5d0d": {
			"type": "Ybodychange",
			"commitMessage": "Using Validate where possible in time package.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1594373 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2014-05-13, 2:31 PM",
			"commitName": "9a16b763d9c51b788415c5f83b6e9221a3cf5d0d",
			"commitAuthor": "Duncan Jones",
			"commitDateOld": "2014-05-05, 12:02 PM",
			"commitNameOld": "7d6e0beccb1345078b3051504e623f399c012fd4",
			"commitAuthorOld": "Benedikt Ritter",
			"daysBetweenCommits": 8.1,
			"commitsBetweenForRepo": 21,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,132 +1,131 @@\n     public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n             final TimeZone timezone) {\n-        if(startMillis > endMillis) {\n-            throw new IllegalArgumentException(\"startMillis must not be greater than endMillis\");\n-        }\n+        Validate.isTrue(startMillis <= endMillis, \"startMillis must not be greater than endMillis\");\n+        \n \n         // Used to optimise for differences under 28 days and \n         // called formatDuration(millis, format); however this did not work \n         // over leap years. \n         // TODO: Compare performance to see if anything was lost by \n         // losing this optimisation. \n         \n         final Token[] tokens = lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         final Calendar start = Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         final Calendar end = Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds < 0) {\n             milliseconds += 1000;\n             seconds -= 1;\n         }\n         while (seconds < 0) {\n             seconds += 60;\n             minutes -= 1;\n         }\n         while (minutes < 0) {\n             minutes += 60;\n             hours -= 1;\n         }\n         while (hours < 0) {\n             hours += 24;\n             days -= 1;\n         }\n        \n         if (Token.containsTokenWithValue(tokens, M)) {\n             while (days < 0) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -= 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n \n             while (months < 0) {\n                 months += 12;\n                 years -= 1;\n             }\n \n             if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                 while (years != 0) {\n                     months += 12 * years;\n                     years = 0;\n                 }\n             }\n         } else {\n             // there are no M's in the format string\n \n             if( !Token.containsTokenWithValue(tokens, y) ) {\n                 int target = end.get(Calendar.YEAR);\n                 if (months < 0) {\n                     // target is end-year -1\n                     target -= 1;\n                 }\n                 \n                 while (start.get(Calendar.YEAR) != target) {\n                     days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                     \n                     // Not sure I grok why this is needed, but the brutal tests show it is\n                     if (start instanceof GregorianCalendar &&\n                             start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                             start.get(Calendar.DAY_OF_MONTH) == 29) {\n                         days += 1;\n                     }\n                     \n                     start.add(Calendar.YEAR, 1);\n                     \n                     days += start.get(Calendar.DAY_OF_YEAR);\n                 }\n                 \n                 years = 0;\n             }\n             \n             while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n             months = 0;            \n \n             while (days < 0) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -= 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n         }\n \n         // The rest of this code adds in values that \n         // aren't requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0->11.\n \n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours += 24 * days;\n             days = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes += 60 * hours;\n             hours = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds += 60 * minutes;\n             minutes = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds += 1000 * seconds;\n             seconds = 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4b74c385628ed1766209a79705a2d5986c23d02c": {
			"type": "Ybodychange",
			"commitMessage": "LANG-1003: DurationFormatUtils are not able to handle negative duration/periods. Document new behavior for negative inputs.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1592324 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2014-05-04, 2:49 AM",
			"commitName": "4b74c385628ed1766209a79705a2d5986c23d02c",
			"commitAuthor": "Benedikt Ritter",
			"commitDateOld": "2014-05-02, 3:21 AM",
			"commitNameOld": "64ef8a80224443c81dfb198cbc567e1b2b9356a2",
			"commitAuthorOld": "Benedikt Ritter",
			"daysBetweenCommits": 1.98,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,132 +1,132 @@\n     public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n             final TimeZone timezone) {\n         if(startMillis > endMillis) {\n-            throw new IllegalArgumentException(\"endMillis must be greater than startMillis\");\n+            throw new IllegalArgumentException(\"startMillis must not be greater than endMillis\");\n         }\n \n         // Used to optimise for differences under 28 days and \n         // called formatDuration(millis, format); however this did not work \n         // over leap years. \n         // TODO: Compare performance to see if anything was lost by \n         // losing this optimisation. \n         \n         final Token[] tokens = lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         final Calendar start = Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         final Calendar end = Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds < 0) {\n             milliseconds += 1000;\n             seconds -= 1;\n         }\n         while (seconds < 0) {\n             seconds += 60;\n             minutes -= 1;\n         }\n         while (minutes < 0) {\n             minutes += 60;\n             hours -= 1;\n         }\n         while (hours < 0) {\n             hours += 24;\n             days -= 1;\n         }\n        \n         if (Token.containsTokenWithValue(tokens, M)) {\n             while (days < 0) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -= 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n \n             while (months < 0) {\n                 months += 12;\n                 years -= 1;\n             }\n \n             if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                 while (years != 0) {\n                     months += 12 * years;\n                     years = 0;\n                 }\n             }\n         } else {\n             // there are no M's in the format string\n \n             if( !Token.containsTokenWithValue(tokens, y) ) {\n                 int target = end.get(Calendar.YEAR);\n                 if (months < 0) {\n                     // target is end-year -1\n                     target -= 1;\n                 }\n                 \n                 while (start.get(Calendar.YEAR) != target) {\n                     days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                     \n                     // Not sure I grok why this is needed, but the brutal tests show it is\n                     if (start instanceof GregorianCalendar &&\n                             start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                             start.get(Calendar.DAY_OF_MONTH) == 29) {\n                         days += 1;\n                     }\n                     \n                     start.add(Calendar.YEAR, 1);\n                     \n                     days += start.get(Calendar.DAY_OF_YEAR);\n                 }\n                 \n                 years = 0;\n             }\n             \n             while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n             months = 0;            \n \n             while (days < 0) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -= 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n         }\n \n         // The rest of this code adds in values that \n         // aren't requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0->11.\n \n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours += 24 * days;\n             days = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes += 60 * hours;\n             hours = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds += 60 * minutes;\n             minutes = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds += 1000 * seconds;\n             seconds = 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"64ef8a80224443c81dfb198cbc567e1b2b9356a2": {
			"type": "Ybodychange",
			"commitMessage": "LANG-1003: DurationFormatUtils are not able to handle negative durations/periods. Reported by Michael Osipov.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1591840 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2014-05-02, 3:21 AM",
			"commitName": "64ef8a80224443c81dfb198cbc567e1b2b9356a2",
			"commitAuthor": "Benedikt Ritter",
			"commitDateOld": "2014-04-30, 3:49 PM",
			"commitNameOld": "b4b51a8fc9eed7274a045b2f3192d77782b0e4fa",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 1.48,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,129 +1,132 @@\n     public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n             final TimeZone timezone) {\n+        if(startMillis > endMillis) {\n+            throw new IllegalArgumentException(\"endMillis must be greater than startMillis\");\n+        }\n \n         // Used to optimise for differences under 28 days and \n         // called formatDuration(millis, format); however this did not work \n         // over leap years. \n         // TODO: Compare performance to see if anything was lost by \n         // losing this optimisation. \n         \n         final Token[] tokens = lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         final Calendar start = Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         final Calendar end = Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds < 0) {\n             milliseconds += 1000;\n             seconds -= 1;\n         }\n         while (seconds < 0) {\n             seconds += 60;\n             minutes -= 1;\n         }\n         while (minutes < 0) {\n             minutes += 60;\n             hours -= 1;\n         }\n         while (hours < 0) {\n             hours += 24;\n             days -= 1;\n         }\n        \n         if (Token.containsTokenWithValue(tokens, M)) {\n             while (days < 0) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -= 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n \n             while (months < 0) {\n                 months += 12;\n                 years -= 1;\n             }\n \n             if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                 while (years != 0) {\n                     months += 12 * years;\n                     years = 0;\n                 }\n             }\n         } else {\n             // there are no M's in the format string\n \n             if( !Token.containsTokenWithValue(tokens, y) ) {\n                 int target = end.get(Calendar.YEAR);\n                 if (months < 0) {\n                     // target is end-year -1\n                     target -= 1;\n                 }\n                 \n                 while (start.get(Calendar.YEAR) != target) {\n                     days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                     \n                     // Not sure I grok why this is needed, but the brutal tests show it is\n                     if (start instanceof GregorianCalendar &&\n                             start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                             start.get(Calendar.DAY_OF_MONTH) == 29) {\n                         days += 1;\n                     }\n                     \n                     start.add(Calendar.YEAR, 1);\n                     \n                     days += start.get(Calendar.DAY_OF_YEAR);\n                 }\n                 \n                 years = 0;\n             }\n             \n             while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n             months = 0;            \n \n             while (days < 0) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -= 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n         }\n \n         // The rest of this code adds in values that \n         // aren't requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0->11.\n \n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours += 24 * days;\n             days = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes += 60 * hours;\n             hours = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds += 60 * minutes;\n             minutes = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds += 1000 * seconds;\n             seconds = 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f33fba71c5ab38ebff98b5bea9291807c4999483": {
			"type": "Ybodychange",
			"commitMessage": "Remove useless parentheses (PMD).\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1455893 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-03-13, 5:41 AM",
			"commitName": "f33fba71c5ab38ebff98b5bea9291807c4999483",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2013-01-22, 12:09 AM",
			"commitNameOld": "5292526e476ffbb19c6613a98464054236c86ace",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 50.19,
			"commitsBetweenForRepo": 22,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,129 +1,129 @@\n     public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n             final TimeZone timezone) {\n \n         // Used to optimise for differences under 28 days and \n         // called formatDuration(millis, format); however this did not work \n         // over leap years. \n         // TODO: Compare performance to see if anything was lost by \n         // losing this optimisation. \n         \n         final Token[] tokens = lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         final Calendar start = Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         final Calendar end = Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds < 0) {\n             milliseconds += 1000;\n             seconds -= 1;\n         }\n         while (seconds < 0) {\n             seconds += 60;\n             minutes -= 1;\n         }\n         while (minutes < 0) {\n             minutes += 60;\n             hours -= 1;\n         }\n         while (hours < 0) {\n             hours += 24;\n             days -= 1;\n         }\n        \n         if (Token.containsTokenWithValue(tokens, M)) {\n             while (days < 0) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -= 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n \n             while (months < 0) {\n                 months += 12;\n                 years -= 1;\n             }\n \n             if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                 while (years != 0) {\n                     months += 12 * years;\n                     years = 0;\n                 }\n             }\n         } else {\n             // there are no M's in the format string\n \n             if( !Token.containsTokenWithValue(tokens, y) ) {\n                 int target = end.get(Calendar.YEAR);\n                 if (months < 0) {\n                     // target is end-year -1\n                     target -= 1;\n                 }\n                 \n-                while ( (start.get(Calendar.YEAR) != target)) {\n+                while (start.get(Calendar.YEAR) != target) {\n                     days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                     \n                     // Not sure I grok why this is needed, but the brutal tests show it is\n                     if (start instanceof GregorianCalendar &&\n                             start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                             start.get(Calendar.DAY_OF_MONTH) == 29) {\n                         days += 1;\n                     }\n                     \n                     start.add(Calendar.YEAR, 1);\n                     \n                     days += start.get(Calendar.DAY_OF_YEAR);\n                 }\n                 \n                 years = 0;\n             }\n             \n             while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n             months = 0;            \n \n             while (days < 0) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -= 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n         }\n \n         // The rest of this code adds in values that \n         // aren't requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0->11.\n \n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours += 24 * days;\n             days = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes += 60 * hours;\n             hours = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds += 60 * minutes;\n             minutes = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds += 1000 * seconds;\n             seconds = 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5292526e476ffbb19c6613a98464054236c86ace": {
			"type": "Ybodychange",
			"commitMessage": "Add final modifier to local variables.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436770 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-01-22, 12:09 AM",
			"commitName": "5292526e476ffbb19c6613a98464054236c86ace",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2013-01-22, 12:07 AM",
			"commitNameOld": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,129 +1,129 @@\n     public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n             final TimeZone timezone) {\n \n         // Used to optimise for differences under 28 days and \n         // called formatDuration(millis, format); however this did not work \n         // over leap years. \n         // TODO: Compare performance to see if anything was lost by \n         // losing this optimisation. \n         \n-        Token[] tokens = lexx(format);\n+        final Token[] tokens = lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n-        Calendar start = Calendar.getInstance(timezone);\n+        final Calendar start = Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n-        Calendar end = Calendar.getInstance(timezone);\n+        final Calendar end = Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds < 0) {\n             milliseconds += 1000;\n             seconds -= 1;\n         }\n         while (seconds < 0) {\n             seconds += 60;\n             minutes -= 1;\n         }\n         while (minutes < 0) {\n             minutes += 60;\n             hours -= 1;\n         }\n         while (hours < 0) {\n             hours += 24;\n             days -= 1;\n         }\n        \n         if (Token.containsTokenWithValue(tokens, M)) {\n             while (days < 0) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -= 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n \n             while (months < 0) {\n                 months += 12;\n                 years -= 1;\n             }\n \n             if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                 while (years != 0) {\n                     months += 12 * years;\n                     years = 0;\n                 }\n             }\n         } else {\n             // there are no M's in the format string\n \n             if( !Token.containsTokenWithValue(tokens, y) ) {\n                 int target = end.get(Calendar.YEAR);\n                 if (months < 0) {\n                     // target is end-year -1\n                     target -= 1;\n                 }\n                 \n                 while ( (start.get(Calendar.YEAR) != target)) {\n                     days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                     \n                     // Not sure I grok why this is needed, but the brutal tests show it is\n                     if (start instanceof GregorianCalendar &&\n                             start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                             start.get(Calendar.DAY_OF_MONTH) == 29) {\n                         days += 1;\n                     }\n                     \n                     start.add(Calendar.YEAR, 1);\n                     \n                     days += start.get(Calendar.DAY_OF_YEAR);\n                 }\n                 \n                 years = 0;\n             }\n             \n             while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n             months = 0;            \n \n             while (days < 0) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -= 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n         }\n \n         // The rest of this code adds in values that \n         // aren't requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0->11.\n \n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours += 24 * days;\n             days = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes += 60 * hours;\n             hours = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds += 60 * minutes;\n             minutes = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds += 1000 * seconds;\n             seconds = 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5bd622dab027ef37001a630a7c825c5b8c19d1db": {
			"type": "Yparametermetachange",
			"commitMessage": "Add final modifier to method parameters.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436768 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-01-22, 12:07 AM",
			"commitName": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2012-09-27, 11:21 AM",
			"commitNameOld": "89c64972282f39ecd48b3774963d7a541ca3c0f4",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 116.57,
			"commitsBetweenForRepo": 77,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,129 +1,129 @@\n-    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n-            TimeZone timezone) {\n+    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n+            final TimeZone timezone) {\n \n         // Used to optimise for differences under 28 days and \n         // called formatDuration(millis, format); however this did not work \n         // over leap years. \n         // TODO: Compare performance to see if anything was lost by \n         // losing this optimisation. \n         \n         Token[] tokens = lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start = Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end = Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds < 0) {\n             milliseconds += 1000;\n             seconds -= 1;\n         }\n         while (seconds < 0) {\n             seconds += 60;\n             minutes -= 1;\n         }\n         while (minutes < 0) {\n             minutes += 60;\n             hours -= 1;\n         }\n         while (hours < 0) {\n             hours += 24;\n             days -= 1;\n         }\n        \n         if (Token.containsTokenWithValue(tokens, M)) {\n             while (days < 0) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -= 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n \n             while (months < 0) {\n                 months += 12;\n                 years -= 1;\n             }\n \n             if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                 while (years != 0) {\n                     months += 12 * years;\n                     years = 0;\n                 }\n             }\n         } else {\n             // there are no M's in the format string\n \n             if( !Token.containsTokenWithValue(tokens, y) ) {\n                 int target = end.get(Calendar.YEAR);\n                 if (months < 0) {\n                     // target is end-year -1\n                     target -= 1;\n                 }\n                 \n                 while ( (start.get(Calendar.YEAR) != target)) {\n                     days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                     \n                     // Not sure I grok why this is needed, but the brutal tests show it is\n                     if (start instanceof GregorianCalendar &&\n                             start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n                             start.get(Calendar.DAY_OF_MONTH) == 29) {\n                         days += 1;\n                     }\n                     \n                     start.add(Calendar.YEAR, 1);\n                     \n                     days += start.get(Calendar.DAY_OF_YEAR);\n                 }\n                 \n                 years = 0;\n             }\n             \n             while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n             months = 0;            \n \n             while (days < 0) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -= 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n         }\n \n         // The rest of this code adds in values that \n         // aren't requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0->11.\n \n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours += 24 * days;\n             days = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes += 60 * hours;\n             hours = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds += 60 * minutes;\n             minutes = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds += 1000 * seconds;\n             seconds = 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[startMillis-long, endMillis-long, format-String, padWithZeros-boolean, timezone-TimeZone]",
				"newValue": "[startMillis-long(modifiers-final), endMillis-long(modifiers-final), format-String(modifiers-final), padWithZeros-boolean(modifiers-final), timezone-TimeZone(modifiers-final)]"
			}
		},
		"79cddd4ea5b4fad17f74878e40b3dcd0c54d9cf6": {
			"type": "Ybodychange",
			"commitMessage": "Fix brace positions\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1077921 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2011-03-04, 5:54 AM",
			"commitName": "79cddd4ea5b4fad17f74878e40b3dcd0c54d9cf6",
			"commitAuthor": "Stephen Colebourne",
			"commitDateOld": "2010-01-02, 7:11 PM",
			"commitNameOld": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
			"commitAuthorOld": "Paul C. Benedict Jr",
			"daysBetweenCommits": 425.45,
			"commitsBetweenForRepo": 413,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,131 +1,129 @@\n     public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n             TimeZone timezone) {\n \n         // Used to optimise for differences under 28 days and \n         // called formatDuration(millis, format); however this did not work \n         // over leap years. \n         // TODO: Compare performance to see if anything was lost by \n         // losing this optimisation. \n         \n         Token[] tokens = lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start = Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end = Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds < 0) {\n             milliseconds += 1000;\n             seconds -= 1;\n         }\n         while (seconds < 0) {\n             seconds += 60;\n             minutes -= 1;\n         }\n         while (minutes < 0) {\n             minutes += 60;\n             hours -= 1;\n         }\n         while (hours < 0) {\n             hours += 24;\n             days -= 1;\n         }\n        \n         if (Token.containsTokenWithValue(tokens, M)) {\n             while (days < 0) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -= 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n \n             while (months < 0) {\n                 months += 12;\n                 years -= 1;\n             }\n \n             if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n                 while (years != 0) {\n                     months += 12 * years;\n                     years = 0;\n                 }\n             }\n         } else {\n             // there are no M's in the format string\n \n             if( !Token.containsTokenWithValue(tokens, y) ) {\n                 int target = end.get(Calendar.YEAR);\n                 if (months < 0) {\n                     // target is end-year -1\n                     target -= 1;\n                 }\n                 \n                 while ( (start.get(Calendar.YEAR) != target)) {\n                     days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                     \n                     // Not sure I grok why this is needed, but the brutal tests show it is\n-                    if(start instanceof GregorianCalendar) {\n-                        if( (start.get(Calendar.MONTH) == Calendar.FEBRUARY) &&\n-                            (start.get(Calendar.DAY_OF_MONTH) == 29 ) )\n-                        {\n-                            days += 1;\n-                        }\n+                    if (start instanceof GregorianCalendar &&\n+                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n+                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n+                        days += 1;\n                     }\n                     \n                     start.add(Calendar.YEAR, 1);\n                     \n                     days += start.get(Calendar.DAY_OF_YEAR);\n                 }\n                 \n                 years = 0;\n             }\n             \n             while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n             months = 0;            \n \n             while (days < 0) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 months -= 1;\n                 start.add(Calendar.MONTH, 1);\n             }\n             \n         }\n \n         // The rest of this code adds in values that \n         // aren't requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0->11.\n \n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours += 24 * days;\n             days = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes += 60 * hours;\n             hours = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds += 60 * minutes;\n             minutes = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds += 1000 * seconds;\n             seconds = 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fc5c081e22a61bb5a6810af302be3f22f7966df4": {
			"type": "Yfilerename",
			"commitMessage": "Move main source to src/main/java\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@895322 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-01-02, 7:11 PM",
			"commitName": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
			"commitAuthor": "Paul C. Benedict Jr",
			"commitDateOld": "2010-01-02, 7:09 PM",
			"commitNameOld": "6b32246f5f9f77c74b32a5290cdbdd4e0f5c71c6",
			"commitAuthorOld": "Paul C. Benedict Jr",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/java/org/apache/commons/lang3/time/DurationFormatUtils.java",
				"newPath": "src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java"
			}
		},
		"debc02c6d9b94c717b4182ae4dd7a97d47293a52": {
			"type": "Yfilerename",
			"commitMessage": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@889202 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2009-12-10, 4:33 AM",
			"commitName": "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2009-12-10, 4:31 AM",
			"commitNameOld": "375d7d0954cae60c4c7292cc65abbc972178857c",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/java/org/apache/commons/lang/time/DurationFormatUtils.java",
				"newPath": "src/java/org/apache/commons/lang3/time/DurationFormatUtils.java"
			}
		},
		"4f514d5eb3e80703012df9be190ae42d35d25bdc": {
			"type": "Ybodychange",
			"commitMessage": "More tests, more bugfixes (aka rewrite of the guts). \n\nIt's looking much better, the only edge case that throws it for a loop is if things start on the 29th of February in a year. I've hacked it in the day mode, but I'm not sure why I had to do that - however I trust the brute force test to be right in day mode. \nIn month mode, it's even trickier as to what the correct answer is. How many months between 29th Feb and 28th of Feb the next year? The answer is 11, or with days included it's 11 months and 28 days. I can't see any reason to define that better, so I'm declaring that law. \n\nThings are weird if you start on Feb 29 :)\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@488926 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2006-12-19, 11:10 PM",
			"commitName": "4f514d5eb3e80703012df9be190ae42d35d25bdc",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2006-12-19, 4:59 PM",
			"commitNameOld": "93aa88fded0cb63a8634cf8021cb889bc38505bf",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 0.26,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,123 +1,131 @@\n     public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n             TimeZone timezone) {\n \n-        long millis = endMillis - startMillis;\n-        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n-            return formatDuration(millis, format, padWithZeros);\n-        }\n-\n+        // Used to optimise for differences under 28 days and \n+        // called formatDuration(millis, format); however this did not work \n+        // over leap years. \n+        // TODO: Compare performance to see if anything was lost by \n+        // losing this optimisation. \n+        \n         Token[] tokens = lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start = Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end = Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds < 0) {\n             milliseconds += 1000;\n             seconds -= 1;\n         }\n         while (seconds < 0) {\n             seconds += 60;\n             minutes -= 1;\n         }\n         while (minutes < 0) {\n             minutes += 60;\n             hours -= 1;\n         }\n         while (hours < 0) {\n             hours += 24;\n             days -= 1;\n         }\n-        // TODO: Create a test to see if this should be while. ie) one that makes hours above \n-        //       overflow and pushes this above the maximum # of days in a month?\n-        int leapDays = 0;\n-        if (days < 0) {\n-            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n-            // Multiple answers possible. \n-            // For example, for Jan 15th to March 10th. If I count days-first it is \n-            // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-            // Here we choose the former. \n-            months -= 1;\n-            start.add(Calendar.MONTH, 1);\n-        }\n-        while (months < 0) {\n-            months += 12;\n-            years -= 1;\n-            if (start instanceof GregorianCalendar) {\n-                if ( ((GregorianCalendar) start).isLeapYear(start.get(Calendar.YEAR) + 1) &&\n-                     ( end.get(Calendar.MONTH) > 1) )  \n-                {\n-                    leapDays += 1;\n-                }\n+       \n+        if (Token.containsTokenWithValue(tokens, M)) {\n+            while (days < 0) {\n+                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n+                months -= 1;\n+                start.add(Calendar.MONTH, 1);\n             }\n-            if (end instanceof GregorianCalendar) {\n-                if ( ((GregorianCalendar) end).isLeapYear(end.get(Calendar.YEAR)) &&\n-                     ( end.get(Calendar.MONTH) < 1) )  \n-                {\n-                    leapDays -= 1;\n-                }\n-            }\n-            start.add(Calendar.YEAR, 1);\n-        }\n \n-        // This rest of this code adds in values that \n-        // aren't requested. This allows the user to ask for the \n-        // number of months and get the real count and not just 0->11.\n-        \n-        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n-            if (Token.containsTokenWithValue(tokens, M)) {\n-                months += 12 * years;\n-                years = 0;\n-            } else {\n-                while ( (start.get(Calendar.YEAR) != end.get(Calendar.YEAR))) {\n-                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR);\n-                    start.add(Calendar.YEAR, 1);\n+            while (months < 0) {\n+                months += 12;\n+                years -= 1;\n+            }\n+\n+            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n+                while (years != 0) {\n+                    months += 12 * years;\n+                    years = 0;\n                 }\n+            }\n+        } else {\n+            // there are no M's in the format string\n+\n+            if( !Token.containsTokenWithValue(tokens, y) ) {\n+                int target = end.get(Calendar.YEAR);\n+                if (months < 0) {\n+                    // target is end-year -1\n+                    target -= 1;\n+                }\n+                \n+                while ( (start.get(Calendar.YEAR) != target)) {\n+                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n+                    \n+                    // Not sure I grok why this is needed, but the brutal tests show it is\n+                    if(start instanceof GregorianCalendar) {\n+                        if( (start.get(Calendar.MONTH) == Calendar.FEBRUARY) &&\n+                            (start.get(Calendar.DAY_OF_MONTH) == 29 ) )\n+                        {\n+                            days += 1;\n+                        }\n+                    }\n+                    \n+                    start.add(Calendar.YEAR, 1);\n+                    \n+                    days += start.get(Calendar.DAY_OF_YEAR);\n+                }\n+                \n                 years = 0;\n             }\n-        }\n-        start.set(Calendar.YEAR, end.get(Calendar.YEAR));\n-                \n-        if (!Token.containsTokenWithValue(tokens, M) && months != 0) {   \n-            while(start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {\n-                String date = start.getTime().toString();\n+            \n+            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 start.add(Calendar.MONTH, 1);\n             }\n-            days += leapDays;\n+            \n             months = 0;            \n+\n+            while (days < 0) {\n+                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n+                months -= 1;\n+                start.add(Calendar.MONTH, 1);\n+            }\n+            \n         }\n-        start.set(Calendar.MONTH, end.get(Calendar.MONTH));\n+\n+        // The rest of this code adds in values that \n+        // aren't requested. This allows the user to ask for the \n+        // number of months and get the real count and not just 0->11.\n \n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours += 24 * days;\n             days = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes += 60 * hours;\n             hours = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds += 60 * minutes;\n             minutes = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds += 1000 * seconds;\n             seconds = 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"93aa88fded0cb63a8634cf8021cb889bc38505bf": {
			"type": "Ybodychange",
			"commitMessage": "Updated comment\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@488858 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2006-12-19, 4:59 PM",
			"commitName": "93aa88fded0cb63a8634cf8021cb889bc38505bf",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2006-12-13, 12:12 AM",
			"commitNameOld": "868dd284443b6f950a2f360b0422dbf09a599ae9",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 6.7,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,124 +1,123 @@\n     public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n             TimeZone timezone) {\n \n         long millis = endMillis - startMillis;\n         if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n             return formatDuration(millis, format, padWithZeros);\n         }\n \n         Token[] tokens = lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start = Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end = Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds < 0) {\n             milliseconds += 1000;\n             seconds -= 1;\n         }\n         while (seconds < 0) {\n             seconds += 60;\n             minutes -= 1;\n         }\n         while (minutes < 0) {\n             minutes += 60;\n             hours -= 1;\n         }\n         while (hours < 0) {\n             hours += 24;\n             days -= 1;\n         }\n         // TODO: Create a test to see if this should be while. ie) one that makes hours above \n         //       overflow and pushes this above the maximum # of days in a month?\n         int leapDays = 0;\n         if (days < 0) {\n             days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n-            // It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n+            // Multiple answers possible. \n+            // For example, for Jan 15th to March 10th. If I count days-first it is \n             // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n             // Here we choose the former. \n-            // Also it's contextual - if asked for no M in the format then I should probably \n-            // be doing no calculating here.\n             months -= 1;\n             start.add(Calendar.MONTH, 1);\n         }\n         while (months < 0) {\n             months += 12;\n             years -= 1;\n             if (start instanceof GregorianCalendar) {\n                 if ( ((GregorianCalendar) start).isLeapYear(start.get(Calendar.YEAR) + 1) &&\n                      ( end.get(Calendar.MONTH) > 1) )  \n                 {\n                     leapDays += 1;\n                 }\n             }\n             if (end instanceof GregorianCalendar) {\n                 if ( ((GregorianCalendar) end).isLeapYear(end.get(Calendar.YEAR)) &&\n                      ( end.get(Calendar.MONTH) < 1) )  \n                 {\n                     leapDays -= 1;\n                 }\n             }\n             start.add(Calendar.YEAR, 1);\n         }\n \n         // This rest of this code adds in values that \n         // aren't requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0->11.\n         \n         if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n             if (Token.containsTokenWithValue(tokens, M)) {\n                 months += 12 * years;\n                 years = 0;\n             } else {\n                 while ( (start.get(Calendar.YEAR) != end.get(Calendar.YEAR))) {\n                     days += start.getActualMaximum(Calendar.DAY_OF_YEAR);\n                     start.add(Calendar.YEAR, 1);\n                 }\n                 years = 0;\n             }\n         }\n         start.set(Calendar.YEAR, end.get(Calendar.YEAR));\n                 \n         if (!Token.containsTokenWithValue(tokens, M) && months != 0) {   \n             while(start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {\n                 String date = start.getTime().toString();\n                 days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n                 start.add(Calendar.MONTH, 1);\n             }\n             days += leapDays;\n             months = 0;            \n         }\n         start.set(Calendar.MONTH, end.get(Calendar.MONTH));\n \n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours += 24 * days;\n             days = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes += 60 * hours;\n             hours = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds += 60 * minutes;\n             minutes = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds += 1000 * seconds;\n             seconds = 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dd23ae863a8910581362b69c660b26d8e8f699b7": {
			"type": "Ybodychange",
			"commitMessage": "More unit tests and bugfixes. The currently failing test is commented out, so more bugfixes to come.\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@486523 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2006-12-13, 12:09 AM",
			"commitName": "dd23ae863a8910581362b69c660b26d8e8f699b7",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2006-12-10, 8:33 PM",
			"commitNameOld": "5fb6521ab990c0c9ec655ca71d8c77060aedb0e5",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 2.15,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,106 +1,124 @@\n     public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n             TimeZone timezone) {\n \n         long millis = endMillis - startMillis;\n         if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n             return formatDuration(millis, format, padWithZeros);\n         }\n \n         Token[] tokens = lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start = Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end = Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds < 0) {\n             milliseconds += 1000;\n             seconds -= 1;\n         }\n         while (seconds < 0) {\n             seconds += 60;\n             minutes -= 1;\n         }\n         while (minutes < 0) {\n             minutes += 60;\n             hours -= 1;\n         }\n         while (hours < 0) {\n             hours += 24;\n             days -= 1;\n         }\n+        // TODO: Create a test to see if this should be while. ie) one that makes hours above \n+        //       overflow and pushes this above the maximum # of days in a month?\n+        int leapDays = 0;\n         if (days < 0) {\n             days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n             // It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n             // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n             // Here we choose the former. \n             // Also it's contextual - if asked for no M in the format then I should probably \n             // be doing no calculating here.\n             months -= 1;\n+            start.add(Calendar.MONTH, 1);\n         }\n         while (months < 0) {\n             months += 12;\n             years -= 1;\n+            if (start instanceof GregorianCalendar) {\n+                if ( ((GregorianCalendar) start).isLeapYear(start.get(Calendar.YEAR) + 1) &&\n+                     ( end.get(Calendar.MONTH) > 1) )  \n+                {\n+                    leapDays += 1;\n+                }\n+            }\n+            if (end instanceof GregorianCalendar) {\n+                if ( ((GregorianCalendar) end).isLeapYear(end.get(Calendar.YEAR)) &&\n+                     ( end.get(Calendar.MONTH) < 1) )  \n+                {\n+                    leapDays -= 1;\n+                }\n+            }\n             start.add(Calendar.YEAR, 1);\n         }\n \n         // This rest of this code adds in values that \n         // aren't requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0->11.\n         \n-        if (!Token.containsTokenWithValue(tokens, y)) {\n+        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n             if (Token.containsTokenWithValue(tokens, M)) {\n                 months += 12 * years;\n                 years = 0;\n             } else {\n-            \twhile(start.get(Calendar.YEAR) != end.get(Calendar.YEAR)) {\n-            \t\tdays += start.getActualMaximum(Calendar.DAY_OF_YEAR);\n-            \t\tstart.add(Calendar.YEAR, 1);\n+            \twhile ( (start.get(Calendar.YEAR) != end.get(Calendar.YEAR))) {\n+                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR);\n+                    start.add(Calendar.YEAR, 1);\n             \t}\n                 years = 0;\n             }\n         }\n+        start.set(Calendar.YEAR, end.get(Calendar.YEAR));\n                 \n-        if (!Token.containsTokenWithValue(tokens, M) && months != 0) {\n-        \tstart.set(start.get(Calendar.YEAR), start.get(Calendar.MONTH), 0, 0, 0, 0);\n+        if (!Token.containsTokenWithValue(tokens, M) && months != 0) {   \n+            while(start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {\n+        \tString date = start.getTime().toString();\n+        \tdays += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n         \tstart.add(Calendar.MONTH, 1);\n-        \tend.set(end.get(Calendar.YEAR), end.get(Calendar.MONTH), 0, 0, 0, 0);\n-            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n-            months = 0;\n-            \n-        \t// WARNING: For performance sake the Calendar instances are not being \n-        \t// cloned but modified inline. They should not be trusted after this point\n-            start = null;\n-            end = null;\n+            }\n+            days += leapDays;\n+            months = 0;            \n         }\n+        start.set(Calendar.MONTH, end.get(Calendar.MONTH));\n+\n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours += 24 * days;\n             days = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes += 60 * hours;\n             hours = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds += 60 * minutes;\n             minutes = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds += 1000 * seconds;\n             seconds = 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5fb6521ab990c0c9ec655ca71d8c77060aedb0e5": {
			"type": "Ybodychange",
			"commitMessage": "More tests added to DurationFormatUtilsTest and discovered bugs fixed in the DurationFormatUtils.formatPeriod method. \n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@485481 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2006-12-10, 8:33 PM",
			"commitName": "5fb6521ab990c0c9ec655ca71d8c77060aedb0e5",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2006-12-08, 2:05 AM",
			"commitNameOld": "ee4ad2727fcfb949e258e0f215a79d56ea41a173",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 2.77,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,94 +1,106 @@\n     public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n             TimeZone timezone) {\n \n         long millis = endMillis - startMillis;\n         if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n             return formatDuration(millis, format, padWithZeros);\n         }\n \n         Token[] tokens = lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start = Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end = Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds < 0) {\n             milliseconds += 1000;\n             seconds -= 1;\n         }\n         while (seconds < 0) {\n             seconds += 60;\n             minutes -= 1;\n         }\n         while (minutes < 0) {\n             minutes += 60;\n             hours -= 1;\n         }\n         while (hours < 0) {\n             hours += 24;\n             days -= 1;\n         }\n-        while (days < 0) {\n-            end.add(Calendar.MONTH, -1);\n-            days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n-            // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n+        if (days < 0) {\n+            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n+            // It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n             // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n+            // Here we choose the former. \n             // Also it's contextual - if asked for no M in the format then I should probably \n             // be doing no calculating here.\n             months -= 1;\n-            end.add(Calendar.MONTH, 1);\n         }\n         while (months < 0) {\n             months += 12;\n             years -= 1;\n+            start.add(Calendar.YEAR, 1);\n         }\n \n-        // This next block of code adds in values that \n+        // This rest of this code adds in values that \n         // aren't requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0->11.\n+        \n         if (!Token.containsTokenWithValue(tokens, y)) {\n             if (Token.containsTokenWithValue(tokens, M)) {\n                 months += 12 * years;\n                 years = 0;\n             } else {\n-                // TODO: this is a bit weak, needs work to know about leap years\n-                days += 365 * years;\n+            \twhile(start.get(Calendar.YEAR) != end.get(Calendar.YEAR)) {\n+            \t\tdays += start.getActualMaximum(Calendar.DAY_OF_YEAR);\n+            \t\tstart.add(Calendar.YEAR, 1);\n+            \t}\n                 years = 0;\n             }\n         }\n-        if (!Token.containsTokenWithValue(tokens, M)) {\n+                \n+        if (!Token.containsTokenWithValue(tokens, M) && months != 0) {\n+        \tstart.set(start.get(Calendar.YEAR), start.get(Calendar.MONTH), 0, 0, 0, 0);\n+        \tstart.add(Calendar.MONTH, 1);\n+        \tend.set(end.get(Calendar.YEAR), end.get(Calendar.MONTH), 0, 0, 0, 0);\n             days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             months = 0;\n+            \n+        \t// WARNING: For performance sake the Calendar instances are not being \n+        \t// cloned but modified inline. They should not be trusted after this point\n+            start = null;\n+            end = null;\n         }\n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours += 24 * days;\n             days = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes += 60 * hours;\n             hours = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds += 60 * minutes;\n             minutes = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds += 1000 * seconds;\n             seconds = 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ee4ad2727fcfb949e258e0f215a79d56ea41a173": {
			"type": "Ybodychange",
			"commitMessage": "Added javadoc to explain the quandry in how to count month/day differences\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@483891 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2006-12-08, 2:05 AM",
			"commitName": "ee4ad2727fcfb949e258e0f215a79d56ea41a173",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2006-11-05, 9:02 PM",
			"commitNameOld": "d8a6e05b5f23458ddd57ad838f43936520689ff7",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 32.21,
			"commitsBetweenForRepo": 10,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,95 +1,94 @@\n     public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n             TimeZone timezone) {\n \n         long millis = endMillis - startMillis;\n         if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n             return formatDuration(millis, format, padWithZeros);\n         }\n \n         Token[] tokens = lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start = Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end = Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds < 0) {\n             milliseconds += 1000;\n             seconds -= 1;\n         }\n         while (seconds < 0) {\n             seconds += 60;\n             minutes -= 1;\n         }\n         while (minutes < 0) {\n             minutes += 60;\n             hours -= 1;\n         }\n         while (hours < 0) {\n             hours += 24;\n             days -= 1;\n         }\n         while (days < 0) {\n             end.add(Calendar.MONTH, -1);\n             days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n-//days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-// HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n-// 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-// Also it's contextual - if asked for no M in the format then I should probably \n-// be doing no calculating here.\n+            // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n+            // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n+            // Also it's contextual - if asked for no M in the format then I should probably \n+            // be doing no calculating here.\n             months -= 1;\n             end.add(Calendar.MONTH, 1);\n         }\n         while (months < 0) {\n             months += 12;\n             years -= 1;\n         }\n \n         // This next block of code adds in values that \n         // aren't requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0->11.\n         if (!Token.containsTokenWithValue(tokens, y)) {\n             if (Token.containsTokenWithValue(tokens, M)) {\n                 months += 12 * years;\n                 years = 0;\n             } else {\n                 // TODO: this is a bit weak, needs work to know about leap years\n                 days += 365 * years;\n                 years = 0;\n             }\n         }\n         if (!Token.containsTokenWithValue(tokens, M)) {\n             days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             months = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours += 24 * days;\n             days = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes += 60 * hours;\n             hours = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds += 60 * minutes;\n             minutes = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds += 1000 * seconds;\n             seconds = 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1d5c03fac601d6ce291c3fe3e5e51a11881e2fc0": {
			"type": "Ybodychange",
			"commitMessage": "Adding a unit test for #LANG-281 and a fix. The fix involves removing the reduceAndCorrect method. It appears that this method was doing sod all - which is worrying as it used to be important. I'm guessing that it was a bad fix for a bug that was then subsequently fixed with other code. I'll create a JIRA issue to create more tests to test out the +31 block of code. \n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@453818 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2006-10-06, 6:22 PM",
			"commitName": "1d5c03fac601d6ce291c3fe3e5e51a11881e2fc0",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2006-08-28, 12:21 AM",
			"commitNameOld": "a5a4f9067a0b22e629463b1ef059818ccda6f37e",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 39.75,
			"commitsBetweenForRepo": 37,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,97 +1,95 @@\n     public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n             TimeZone timezone) {\n \n         long millis = endMillis - startMillis;\n         if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n             return formatDuration(millis, format, padWithZeros);\n         }\n \n         Token[] tokens = lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start = Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end = Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds < 0) {\n             milliseconds += 1000;\n             seconds -= 1;\n         }\n         while (seconds < 0) {\n             seconds += 60;\n             minutes -= 1;\n         }\n         while (minutes < 0) {\n             minutes += 60;\n             hours -= 1;\n         }\n         while (hours < 0) {\n             hours += 24;\n             days -= 1;\n         }\n         while (days < 0) {\n-            days += 31; // such overshooting is taken care of later on\n+            end.add(Calendar.MONTH, -1);\n+            days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n+//days += 31; // TODO: Need tests to show this is bad and the new code is good.\n+// HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n+// 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n+// Also it's contextual - if asked for no M in the format then I should probably \n+// be doing no calculating here.\n             months -= 1;\n+            end.add(Calendar.MONTH, 1);\n         }\n         while (months < 0) {\n             months += 12;\n             years -= 1;\n         }\n \n-        // take estimates off of end to see if we can equal start, when it overshoots recalculate\n-        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n-        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n-        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n-        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n-        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n-        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n-        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n-\n         // This next block of code adds in values that \n         // aren't requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0->11.\n         if (!Token.containsTokenWithValue(tokens, y)) {\n             if (Token.containsTokenWithValue(tokens, M)) {\n                 months += 12 * years;\n                 years = 0;\n             } else {\n                 // TODO: this is a bit weak, needs work to know about leap years\n                 days += 365 * years;\n                 years = 0;\n             }\n         }\n         if (!Token.containsTokenWithValue(tokens, M)) {\n             days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             months = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours += 24 * days;\n             days = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes += 60 * hours;\n             hours = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds += 60 * minutes;\n             minutes = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds += 1000 * seconds;\n             seconds = 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b7d3fd9e4d435eb155570f326e8c799ead6c1901": {
			"type": "Ybodychange",
			"commitMessage": "Committing fix for LANG-140. By reversing the order of field calculation, Yu Peng's bug goes away\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@415317 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2006-06-19, 6:48 AM",
			"commitName": "b7d3fd9e4d435eb155570f326e8c799ead6c1901",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2006-03-06, 12:18 AM",
			"commitNameOld": "9f4f79fe3fab819d45ded49b74773731705a0a6f",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 105.23,
			"commitsBetweenForRepo": 52,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,96 +1,97 @@\n     public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n             TimeZone timezone) {\n \n         long millis = endMillis - startMillis;\n         if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n             return formatDuration(millis, format, padWithZeros);\n         }\n \n         Token[] tokens = lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start = Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end = Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n-        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n-        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n-        // each initial estimate is adjusted in case it is under 0\n-        while (months < 0) {\n-            months += 12;\n-            years -= 1;\n-        }\n-        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n-        while (days < 0) {\n-            days += 31; // such overshooting is taken care of later on\n-            months -= 1;\n-        }\n-        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n-        while (hours < 0) {\n-            hours += 24;\n-            days -= 1;\n-        }\n-        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n-        while (minutes < 0) {\n-            minutes += 60;\n-            hours -= 1;\n-        }\n+        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n+        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n+        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n+        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n+        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n+        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n+\n+        // each initial estimate is adjusted in case it is under 0\n+        while (milliseconds < 0) {\n+            milliseconds += 1000;\n+            seconds -= 1;\n+        }\n         while (seconds < 0) {\n             seconds += 60;\n             minutes -= 1;\n         }\n-        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n-        while (milliseconds < 0) {\n-            milliseconds += 1000;\n-            seconds -= 1;\n+        while (minutes < 0) {\n+            minutes += 60;\n+            hours -= 1;\n+        }\n+        while (hours < 0) {\n+            hours += 24;\n+            days -= 1;\n+        }\n+        while (days < 0) {\n+            days += 31; // such overshooting is taken care of later on\n+            months -= 1;\n+        }\n+        while (months < 0) {\n+            months += 12;\n+            years -= 1;\n         }\n \n         // take estimates off of end to see if we can equal start, when it overshoots recalculate\n         milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n         seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n         hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n         days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n         months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n         years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n \n         // This next block of code adds in values that \n         // aren't requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0->11.\n         if (!Token.containsTokenWithValue(tokens, y)) {\n             if (Token.containsTokenWithValue(tokens, M)) {\n                 months += 12 * years;\n                 years = 0;\n             } else {\n                 // TODO: this is a bit weak, needs work to know about leap years\n                 days += 365 * years;\n                 years = 0;\n             }\n         }\n         if (!Token.containsTokenWithValue(tokens, M)) {\n             days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             months = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours += 24 * days;\n             days = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes += 60 * hours;\n             hours = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds += 60 * minutes;\n             minutes = 0;\n         }\n         if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds += 1000 * seconds;\n             seconds = 0;\n         }\n \n         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5111ae7db08a70323a51a21df0bbaf46f21e072e": {
			"type": "Ymultichange(Yrename,Ybodychange)",
			"commitMessage": "Rework DurationFormatUtils to have clearer API based on two types of formatting\nFix millisecond formatting bug\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137977 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2004-10-15, 5:11 PM",
			"commitName": "5111ae7db08a70323a51a21df0bbaf46f21e072e",
			"commitAuthor": "Stephen Colebourne",
			"subchanges": [
				{
					"type": "Yrename",
					"commitMessage": "Rework DurationFormatUtils to have clearer API based on two types of formatting\nFix millisecond formatting bug\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137977 13f79535-47bb-0310-9956-ffa450edef68\n",
					"commitDate": "2004-10-15, 5:11 PM",
					"commitName": "5111ae7db08a70323a51a21df0bbaf46f21e072e",
					"commitAuthor": "Stephen Colebourne",
					"commitDateOld": "2004-10-01, 7:40 PM",
					"commitNameOld": "dd2a1841fc7c9c95af1ce1e6ed3ed0ee3587df19",
					"commitAuthorOld": "Henri Yandell",
					"daysBetweenCommits": 13.9,
					"commitsBetweenForRepo": 23,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,95 +1,95 @@\n-    public static String format(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n+    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n \n         long millis = endMillis - startMillis;\n-        if(millis < 28 * DateUtils.MILLIS_PER_DAY) {\n-            return format(millis, format, padWithZeros, timezone);\n+        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n+            return formatDuration(millis, format, padWithZeros);\n         }\n \n         Token[] tokens = lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start = Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end = Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n         int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         // each initial estimate is adjusted in case it is under 0\n-        while(months < 0) {\n+        while (months < 0) {\n             months += 12;\n             years -= 1;\n         }\n         int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n-        while(days < 0) {\n-            days += 31;  // such overshooting is taken care of later on\n+        while (days < 0) {\n+            days += 31; // such overshooting is taken care of later on\n             months -= 1;\n         }\n         int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n-        while(hours < 0) {\n+        while (hours < 0) {\n             hours += 24;\n             days -= 1;\n         }\n         int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n-        while(minutes < 0) {\n+        while (minutes < 0) {\n             minutes += 60;\n             hours -= 1;\n         }\n         int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n-        while(seconds < 0) {\n+        while (seconds < 0) {\n             seconds += 60;\n             minutes -= 1;\n         }\n         int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n-        while(milliseconds < 0) {\n+        while (milliseconds < 0) {\n             milliseconds += 1000;\n             seconds -= 1;\n         }\n \n         // take estimates off of end to see if we can equal start, when it overshoots recalculate\n-        milliseconds -= reduceAndCorrect( start, end, Calendar.MILLISECOND, milliseconds );\n-        seconds -= reduceAndCorrect( start, end, Calendar.SECOND, seconds );\n-        minutes -= reduceAndCorrect( start, end, Calendar.MINUTE, minutes );\n-        hours -= reduceAndCorrect( start, end, Calendar.HOUR_OF_DAY, hours );\n-        days -= reduceAndCorrect( start, end, Calendar.DAY_OF_MONTH, days );\n-        months -= reduceAndCorrect( start, end, Calendar.MONTH, months );\n-        years -= reduceAndCorrect( start, end, Calendar.YEAR, years );\n+        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n+        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n+        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n+        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n+        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n+        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n+        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n \n         // This next block of code adds in values that \n         // aren't requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0->11.\n-        if(!Token.containsTokenWithValue(tokens, y) ) {\n-            if(Token.containsTokenWithValue(tokens, M) ) {\n+        if (!Token.containsTokenWithValue(tokens, y)) {\n+            if (Token.containsTokenWithValue(tokens, M)) {\n                 months += 12 * years;\n                 years = 0;\n             } else {\n                 // TODO: this is a bit weak, needs work to know about leap years\n                 days += 365 * years;\n                 years = 0;\n             }\n         }\n-        if(!Token.containsTokenWithValue(tokens, M) ) {\n+        if (!Token.containsTokenWithValue(tokens, M)) {\n             days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             months = 0;\n         }\n-        if(!Token.containsTokenWithValue(tokens, d) ) {\n+        if (!Token.containsTokenWithValue(tokens, d)) {\n             hours += 24 * days;\n             days = 0;\n         }\n-        if(!Token.containsTokenWithValue(tokens, H) ) {\n+        if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes += 60 * hours;\n             hours = 0;\n         }\n-        if(!Token.containsTokenWithValue(tokens, m) ) {\n+        if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds += 60 * minutes;\n             minutes = 0;\n         }\n-        if(!Token.containsTokenWithValue(tokens, s) ) {\n+        if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds += 1000 * seconds;\n             seconds = 0;\n         }\n \n-        return formatDuration(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n+        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "format",
						"newValue": "formatPeriod"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Rework DurationFormatUtils to have clearer API based on two types of formatting\nFix millisecond formatting bug\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137977 13f79535-47bb-0310-9956-ffa450edef68\n",
					"commitDate": "2004-10-15, 5:11 PM",
					"commitName": "5111ae7db08a70323a51a21df0bbaf46f21e072e",
					"commitAuthor": "Stephen Colebourne",
					"commitDateOld": "2004-10-01, 7:40 PM",
					"commitNameOld": "dd2a1841fc7c9c95af1ce1e6ed3ed0ee3587df19",
					"commitAuthorOld": "Henri Yandell",
					"daysBetweenCommits": 13.9,
					"commitsBetweenForRepo": 23,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,95 +1,95 @@\n-    public static String format(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n+    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n \n         long millis = endMillis - startMillis;\n-        if(millis < 28 * DateUtils.MILLIS_PER_DAY) {\n-            return format(millis, format, padWithZeros, timezone);\n+        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n+            return formatDuration(millis, format, padWithZeros);\n         }\n \n         Token[] tokens = lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start = Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n         Calendar end = Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n         int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         // each initial estimate is adjusted in case it is under 0\n-        while(months < 0) {\n+        while (months < 0) {\n             months += 12;\n             years -= 1;\n         }\n         int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n-        while(days < 0) {\n-            days += 31;  // such overshooting is taken care of later on\n+        while (days < 0) {\n+            days += 31; // such overshooting is taken care of later on\n             months -= 1;\n         }\n         int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n-        while(hours < 0) {\n+        while (hours < 0) {\n             hours += 24;\n             days -= 1;\n         }\n         int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n-        while(minutes < 0) {\n+        while (minutes < 0) {\n             minutes += 60;\n             hours -= 1;\n         }\n         int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n-        while(seconds < 0) {\n+        while (seconds < 0) {\n             seconds += 60;\n             minutes -= 1;\n         }\n         int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n-        while(milliseconds < 0) {\n+        while (milliseconds < 0) {\n             milliseconds += 1000;\n             seconds -= 1;\n         }\n \n         // take estimates off of end to see if we can equal start, when it overshoots recalculate\n-        milliseconds -= reduceAndCorrect( start, end, Calendar.MILLISECOND, milliseconds );\n-        seconds -= reduceAndCorrect( start, end, Calendar.SECOND, seconds );\n-        minutes -= reduceAndCorrect( start, end, Calendar.MINUTE, minutes );\n-        hours -= reduceAndCorrect( start, end, Calendar.HOUR_OF_DAY, hours );\n-        days -= reduceAndCorrect( start, end, Calendar.DAY_OF_MONTH, days );\n-        months -= reduceAndCorrect( start, end, Calendar.MONTH, months );\n-        years -= reduceAndCorrect( start, end, Calendar.YEAR, years );\n+        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n+        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n+        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n+        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n+        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n+        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n+        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n \n         // This next block of code adds in values that \n         // aren't requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0->11.\n-        if(!Token.containsTokenWithValue(tokens, y) ) {\n-            if(Token.containsTokenWithValue(tokens, M) ) {\n+        if (!Token.containsTokenWithValue(tokens, y)) {\n+            if (Token.containsTokenWithValue(tokens, M)) {\n                 months += 12 * years;\n                 years = 0;\n             } else {\n                 // TODO: this is a bit weak, needs work to know about leap years\n                 days += 365 * years;\n                 years = 0;\n             }\n         }\n-        if(!Token.containsTokenWithValue(tokens, M) ) {\n+        if (!Token.containsTokenWithValue(tokens, M)) {\n             days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             months = 0;\n         }\n-        if(!Token.containsTokenWithValue(tokens, d) ) {\n+        if (!Token.containsTokenWithValue(tokens, d)) {\n             hours += 24 * days;\n             days = 0;\n         }\n-        if(!Token.containsTokenWithValue(tokens, H) ) {\n+        if (!Token.containsTokenWithValue(tokens, H)) {\n             minutes += 60 * hours;\n             hours = 0;\n         }\n-        if(!Token.containsTokenWithValue(tokens, m) ) {\n+        if (!Token.containsTokenWithValue(tokens, m)) {\n             seconds += 60 * minutes;\n             minutes = 0;\n         }\n-        if(!Token.containsTokenWithValue(tokens, s) ) {\n+        if (!Token.containsTokenWithValue(tokens, s)) {\n             milliseconds += 1000 * seconds;\n             seconds = 0;\n         }\n \n-        return formatDuration(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n+        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"dd2a1841fc7c9c95af1ce1e6ed3ed0ee3587df19": {
			"type": "Ybodychange",
			"commitMessage": "Calendar.setTimeInMillis(long) is a JDK 1.4 method, so reverting to an older variant\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137954 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2004-10-01, 7:40 PM",
			"commitName": "dd2a1841fc7c9c95af1ce1e6ed3ed0ee3587df19",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2004-09-26, 10:49 PM",
			"commitNameOld": "f80cb56da1316d5cb977c07937c2794efc87a522",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 4.87,
			"commitsBetweenForRepo": 14,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,95 +1,95 @@\n     public static String format(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n \n         long millis = endMillis - startMillis;\n         if(millis < 28 * DateUtils.MILLIS_PER_DAY) {\n             return format(millis, format, padWithZeros, timezone);\n         }\n \n         Token[] tokens = lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start = Calendar.getInstance(timezone);\n-        start.setTimeInMillis(startMillis);\n+        start.setTime(new Date(startMillis));\n         Calendar end = Calendar.getInstance(timezone);\n-        end.setTimeInMillis(endMillis);\n+        end.setTime(new Date(endMillis));\n \n         // initial estimates\n         int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n         int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         // each initial estimate is adjusted in case it is under 0\n         while(months < 0) {\n             months += 12;\n             years -= 1;\n         }\n         int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         while(days < 0) {\n             days += 31;  // such overshooting is taken care of later on\n             months -= 1;\n         }\n         int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         while(hours < 0) {\n             hours += 24;\n             days -= 1;\n         }\n         int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         while(minutes < 0) {\n             minutes += 60;\n             hours -= 1;\n         }\n         int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         while(seconds < 0) {\n             seconds += 60;\n             minutes -= 1;\n         }\n         int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         while(milliseconds < 0) {\n             milliseconds += 1000;\n             seconds -= 1;\n         }\n \n         // take estimates off of end to see if we can equal start, when it overshoots recalculate\n         milliseconds -= reduceAndCorrect( start, end, Calendar.MILLISECOND, milliseconds );\n         seconds -= reduceAndCorrect( start, end, Calendar.SECOND, seconds );\n         minutes -= reduceAndCorrect( start, end, Calendar.MINUTE, minutes );\n         hours -= reduceAndCorrect( start, end, Calendar.HOUR_OF_DAY, hours );\n         days -= reduceAndCorrect( start, end, Calendar.DAY_OF_MONTH, days );\n         months -= reduceAndCorrect( start, end, Calendar.MONTH, months );\n         years -= reduceAndCorrect( start, end, Calendar.YEAR, years );\n \n         // This next block of code adds in values that \n         // aren't requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0->11.\n         if(!Token.containsTokenWithValue(tokens, y) ) {\n             if(Token.containsTokenWithValue(tokens, M) ) {\n                 months += 12 * years;\n                 years = 0;\n             } else {\n                 // TODO: this is a bit weak, needs work to know about leap years\n                 days += 365 * years;\n                 years = 0;\n             }\n         }\n         if(!Token.containsTokenWithValue(tokens, M) ) {\n             days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             months = 0;\n         }\n         if(!Token.containsTokenWithValue(tokens, d) ) {\n             hours += 24 * days;\n             days = 0;\n         }\n         if(!Token.containsTokenWithValue(tokens, H) ) {\n             minutes += 60 * hours;\n             hours = 0;\n         }\n         if(!Token.containsTokenWithValue(tokens, m) ) {\n             seconds += 60 * minutes;\n             minutes = 0;\n         }\n         if(!Token.containsTokenWithValue(tokens, s) ) {\n             milliseconds += 1000 * seconds;\n             seconds = 0;\n         }\n \n         return formatDuration(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f80cb56da1316d5cb977c07937c2794efc87a522": {
			"type": "Ybodychange",
			"commitMessage": "typo fixed, a couple of extra overload methods added (need javadoc) and formatting for start->end changed to match millis implementation, for a pattern of M, 4 years is reported as 48 months and not 0 months.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137940 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2004-09-26, 10:49 PM",
			"commitName": "f80cb56da1316d5cb977c07937c2794efc87a522",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2004-09-26, 9:40 PM",
			"commitNameOld": "69ec8f4668a67921b6788837621e8f88cbcd7762",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 0.05,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,61 +1,95 @@\n     public static String format(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n \n         long millis = endMillis - startMillis;\n         if(millis < 28 * DateUtils.MILLIS_PER_DAY) {\n             return format(millis, format, padWithZeros, timezone);\n         }\n \n         Token[] tokens = lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n         Calendar start = Calendar.getInstance(timezone);\n         start.setTimeInMillis(startMillis);\n         Calendar end = Calendar.getInstance(timezone);\n         end.setTimeInMillis(endMillis);\n \n         // initial estimates\n         int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n         int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n         // each initial estimate is adjusted in case it is under 0\n         while(months < 0) {\n             months += 12;\n             years -= 1;\n         }\n         int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         while(days < 0) {\n             days += 31;  // such overshooting is taken care of later on\n-            days -= 1;\n+            months -= 1;\n         }\n         int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         while(hours < 0) {\n             hours += 24;\n             days -= 1;\n         }\n         int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n         while(minutes < 0) {\n             minutes += 60;\n             hours -= 1;\n         }\n         int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n         while(seconds < 0) {\n             seconds += 60;\n             minutes -= 1;\n         }\n         int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n         while(milliseconds < 0) {\n             milliseconds += 1000;\n             seconds -= 1;\n         }\n \n         // take estimates off of end to see if we can equal start, when it overshoots recalculate\n         milliseconds -= reduceAndCorrect( start, end, Calendar.MILLISECOND, milliseconds );\n         seconds -= reduceAndCorrect( start, end, Calendar.SECOND, seconds );\n         minutes -= reduceAndCorrect( start, end, Calendar.MINUTE, minutes );\n         hours -= reduceAndCorrect( start, end, Calendar.HOUR_OF_DAY, hours );\n         days -= reduceAndCorrect( start, end, Calendar.DAY_OF_MONTH, days );\n         months -= reduceAndCorrect( start, end, Calendar.MONTH, months );\n         years -= reduceAndCorrect( start, end, Calendar.YEAR, years );\n \n+        // This next block of code adds in values that \n+        // aren't requested. This allows the user to ask for the \n+        // number of months and get the real count and not just 0->11.\n+        if(!Token.containsTokenWithValue(tokens, y) ) {\n+            if(Token.containsTokenWithValue(tokens, M) ) {\n+                months += 12 * years;\n+                years = 0;\n+            } else {\n+                // TODO: this is a bit weak, needs work to know about leap years\n+                days += 365 * years;\n+                years = 0;\n+            }\n+        }\n+        if(!Token.containsTokenWithValue(tokens, M) ) {\n+            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n+            months = 0;\n+        }\n+        if(!Token.containsTokenWithValue(tokens, d) ) {\n+            hours += 24 * days;\n+            days = 0;\n+        }\n+        if(!Token.containsTokenWithValue(tokens, H) ) {\n+            minutes += 60 * hours;\n+            hours = 0;\n+        }\n+        if(!Token.containsTokenWithValue(tokens, m) ) {\n+            seconds += 60 * minutes;\n+            minutes = 0;\n+        }\n+        if(!Token.containsTokenWithValue(tokens, s) ) {\n+            milliseconds += 1000 * seconds;\n+            seconds = 0;\n+        }\n+\n         return formatDuration(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"177d40989f45197fd9f9669f4eeb6033b73bc16e": {
			"type": "Yintroduced",
			"commitMessage": "removed the weak assumptions for number of millis in a month/year from DateUtils. Implemented a second format method that relies on a start and an end in DurationFormatUtils, though I found that TimeZone was very important in the overloaded millis version. The two methods hand off to each other depending on whether the time is > or < than 28 days\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137935 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2004-09-26, 9:14 PM",
			"commitName": "177d40989f45197fd9f9669f4eeb6033b73bc16e",
			"commitAuthor": "Henri Yandell"
		}
	},
	"sha": "a36c903d4f1065bc59f5e6d2bb0f9d92a5e71d83"
}