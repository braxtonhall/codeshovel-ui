{
	"repo": "https://github.com/apache/flink.git",
	"file": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
	"method": {
		"longName": "FileSystem::getUnguardedFileSystem(URI fsUri)",
		"startLine": 322,
		"methodName": "getUnguardedFileSystem",
		"isStatic": true,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"d7c2c417213502130b1aeab1868313df178555cc": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-8125] [core] Introduce limiting of outgoing file system connections\n",
			"commitDate": "2017-11-24, 3:41 AM",
			"commitName": "d7c2c417213502130b1aeab1868313df178555cc",
			"commitAuthor": "Stephan Ewen",
			"commitDateOld": "2017-11-24, 3:41 AM",
			"commitNameOld": "f04b32b02900181db82c6c518ffbd6430a0a369a",
			"commitAuthorOld": "Stephan Ewen",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,87 +1,94 @@\n \tpublic static FileSystem getUnguardedFileSystem(final URI fsUri) throws IOException {\n \t\tcheckNotNull(fsUri, \"file system URI\");\n \n \t\tLOCK.lock();\n \t\ttry {\n \t\t\tfinal URI uri;\n \n \t\t\tif (fsUri.getScheme() != null) {\n \t\t\t\turi = fsUri;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// Apply the default fs scheme\n \t\t\t\tfinal URI defaultUri = getDefaultFsUri();\n \t\t\t\tURI rewrittenUri = null;\n \n \t\t\t\ttry {\n \t\t\t\t\trewrittenUri = new URI(defaultUri.getScheme(), null, defaultUri.getHost(),\n \t\t\t\t\t\t\tdefaultUri.getPort(), fsUri.getPath(), null, null);\n \t\t\t\t}\n \t\t\t\tcatch (URISyntaxException e) {\n \t\t\t\t\t// for local URIs, we make one more try to repair the path by making it absolute\n \t\t\t\t\tif (defaultUri.getScheme().equals(\"file\")) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\trewrittenUri = new URI(\n \t\t\t\t\t\t\t\t\t\"file\", null,\n \t\t\t\t\t\t\t\t\tnew Path(new File(fsUri.getPath()).getAbsolutePath()).toUri().getPath(),\n \t\t\t\t\t\t\t\t\tnull);\n \t\t\t\t\t\t} catch (URISyntaxException ignored) {\n \t\t\t\t\t\t\t// could not help it...\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (rewrittenUri != null) {\n \t\t\t\t\turi = rewrittenUri;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new IOException(\"The file system URI '\" + fsUri +\n \t\t\t\t\t\t\t\"' declares no scheme and cannot be interpreted relative to the default file system URI (\"\n \t\t\t\t\t\t\t+ defaultUri + \").\");\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t// print a helpful pointer for malformed local URIs (happens a lot to new users)\n \t\t\tif (uri.getScheme().equals(\"file\") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri = \"file:///\" + uri.getAuthority() + uri.getPath();\n \n \t\t\t\tthrow new IOException(\"Found local file path with authority '\" + uri.getAuthority() + \"' in path '\"\n \t\t\t\t\t\t+ uri.toString() + \"'. Hint: Did you forget a slash? (correct path would be '\" + supposedUri + \"')\");\n \t\t\t}\n \n \t\t\tfinal FSKey key = new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\t{\n \t\t\t\tFileSystem cached = CACHE.get(key);\n \t\t\t\tif (cached != null) {\n \t\t\t\t\treturn cached;\n \t\t\t\t}\n \t\t\t}\n \n+\t\t\t// this \"default\" initialization makes sure that the FileSystem class works\n+\t\t\t// even when not configured with an explicit Flink configuration, like on\n+\t\t\t// JobManager or TaskManager setup\n+\t\t\tif (FS_FACTORIES.isEmpty()) {\n+\t\t\t\tinitialize(new Configuration());\n+\t\t\t}\n+\n \t\t\t// Try to create a new file system\n \t\t\tfinal FileSystem fs;\n \t\t\tfinal FileSystemFactory factory = FS_FACTORIES.get(uri.getScheme());\n \n \t\t\tif (factory != null) {\n \t\t\t\tfs = factory.create(uri);\n \t\t\t}\n \t\t\telse {\n \t\t\t\ttry {\n \t\t\t\t\tfs = FALLBACK_FACTORY.create(uri);\n \t\t\t\t}\n \t\t\t\tcatch (UnsupportedFileSystemSchemeException e) {\n \t\t\t\t\tthrow new UnsupportedFileSystemSchemeException(\n \t\t\t\t\t\t\t\"Could not find a file system implementation for scheme '\" + uri.getScheme() +\n \t\t\t\t\t\t\t\t\t\"'. The scheme is not directly supported by Flink and no Hadoop file \" +\n \t\t\t\t\t\t\t\t\t\"system to support this scheme could be loaded.\", e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tCACHE.put(key, fs);\n \t\t\treturn fs;\n \t\t}\n \t\tfinally {\n \t\t\tLOCK.unlock();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"536675b03a5050fda9c3e1fd403818cb50dcc6ff": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "[FLINK-7643] [core] Rework FileSystem loading to use factories\n\nThis makes sure that configurations are loaded once and file system instances are\nproperly reused by scheme and authority.\n\nThis also factors out a lot of the special treatment of Hadoop file systems and simply\nmakes the Hadoop File System factory the default fallback factory.\n",
			"commitDate": "2017-10-06, 3:16 AM",
			"commitName": "536675b03a5050fda9c3e1fd403818cb50dcc6ff",
			"commitAuthor": "Stephan Ewen",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "[FLINK-7643] [core] Rework FileSystem loading to use factories\n\nThis makes sure that configurations are loaded once and file system instances are\nproperly reused by scheme and authority.\n\nThis also factors out a lot of the special treatment of Hadoop file systems and simply\nmakes the Hadoop File System factory the default fallback factory.\n",
					"commitDate": "2017-10-06, 3:16 AM",
					"commitName": "536675b03a5050fda9c3e1fd403818cb50dcc6ff",
					"commitAuthor": "Stephan Ewen",
					"commitDateOld": "2017-10-05, 11:14 AM",
					"commitNameOld": "a5ef09bb601cdd77fcb94e9ce633fdf979031aaf",
					"commitAuthorOld": "Stephan Ewen",
					"daysBetweenCommits": 0.67,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,93 +1,87 @@\n-\tpublic static FileSystem getUnguardedFileSystem(URI uri) throws IOException {\n-\t\tfinal URI asked = uri;\n+\tpublic static FileSystem getUnguardedFileSystem(final URI fsUri) throws IOException {\n+\t\tcheckNotNull(fsUri, \"file system URI\");\n \n \t\tLOCK.lock();\n \t\ttry {\n+\t\t\tfinal URI uri;\n \n-\t\t\tif (uri.getScheme() == null) {\n+\t\t\tif (fsUri.getScheme() != null) {\n+\t\t\t\turi = fsUri;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\t// Apply the default fs scheme\n+\t\t\t\tfinal URI defaultUri = getDefaultFsUri();\n+\t\t\t\tURI rewrittenUri = null;\n+\n \t\t\t\ttry {\n-\t\t\t\t\tif (defaultScheme == null) {\n-\t\t\t\t\t\tdefaultScheme = new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\turi = new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(),\n-\t\t\t\t\t\t\tdefaultScheme.getPort(), uri.getPath(), null, null);\n-\n-\t\t\t\t} catch (URISyntaxException e) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tif (defaultScheme.getScheme().equals(\"file\")) {\n-\t\t\t\t\t\t\turi = new URI(\"file\", null,\n-\t\t\t\t\t\t\t\t\tnew Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n+\t\t\t\t\trewrittenUri = new URI(defaultUri.getScheme(), null, defaultUri.getHost(),\n+\t\t\t\t\t\t\tdefaultUri.getPort(), fsUri.getPath(), null, null);\n+\t\t\t\t}\n+\t\t\t\tcatch (URISyntaxException e) {\n+\t\t\t\t\t// for local URIs, we make one more try to repair the path by making it absolute\n+\t\t\t\t\tif (defaultUri.getScheme().equals(\"file\")) {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\trewrittenUri = new URI(\n+\t\t\t\t\t\t\t\t\t\"file\", null,\n+\t\t\t\t\t\t\t\t\tnew Path(new File(fsUri.getPath()).getAbsolutePath()).toUri().getPath(),\n+\t\t\t\t\t\t\t\t\tnull);\n+\t\t\t\t\t\t} catch (URISyntaxException ignored) {\n+\t\t\t\t\t\t\t// could not help it...\n \t\t\t\t\t\t}\n-\t\t\t\t\t} catch (URISyntaxException ex) {\n-\t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n-\t\t\t\t\t\tthrow new IOException(\"The URI '\" + uri.toString() + \"' is not valid.\");\n \t\t\t\t\t}\n \t\t\t\t}\n+\n+\t\t\t\tif (rewrittenUri != null) {\n+\t\t\t\t\turi = rewrittenUri;\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tthrow new IOException(\"The file system URI '\" + fsUri +\n+\t\t\t\t\t\t\t\"' declares no scheme and cannot be interpreted relative to the default file system URI (\"\n+\t\t\t\t\t\t\t+ defaultUri + \").\");\n+\t\t\t\t}\n \t\t\t}\n \n-\t\t\tif(uri.getScheme() == null) {\n-\t\t\t\tthrow new IOException(\"The URI '\" + uri + \"' is invalid.\\n\" +\n-\t\t\t\t\t\t\"The fs.default-scheme = \" + defaultScheme + \", the requested URI = \" + asked +\n-\t\t\t\t\t\t\", and the final URI = \" + uri + \".\");\n-\t\t\t}\n-\n+\t\t\t// print a helpful pointer for malformed local URIs (happens a lot to new users) \n \t\t\tif (uri.getScheme().equals(\"file\") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri = \"file:///\" + uri.getAuthority() + uri.getPath();\n \n \t\t\t\tthrow new IOException(\"Found local file path with authority '\" + uri.getAuthority() + \"' in path '\"\n \t\t\t\t\t\t+ uri.toString() + \"'. Hint: Did you forget a slash? (correct path would be '\" + supposedUri + \"')\");\n \t\t\t}\n \n \t\t\tfinal FSKey key = new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n-\t\t\tif (CACHE.containsKey(key)) {\n-\t\t\t\treturn CACHE.get(key);\n+\t\t\t{\n+\t\t\t\tFileSystem cached = CACHE.get(key);\n+\t\t\t\tif (cached != null) {\n+\t\t\t\t\treturn cached;\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \t\t\tfinal FileSystem fs;\n+\t\t\tfinal FileSystemFactory factory = FS_FACTORIES.get(uri.getScheme());\n \n-\t\t\tif (!isFlinkSupportedScheme(uri.getScheme())) {\n-\t\t\t\t// no build in support for this file system. Falling back to Hadoop's FileSystem impl.\n-\t\t\t\tClass<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n-\t\t\t\tif (wrapperClass != null) {\n-\t\t\t\t\t// hadoop has support for the FileSystem\n-\t\t\t\t\tFSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n-\t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n-\t\t\t\t\t\treturn CACHE.get(wrappedKey);\n-\t\t\t\t\t}\n-\t\t\t\t\t// cache didn't contain the file system. instantiate it:\n-\n-\t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n-\t\t\t\t\tfs = instantiateHadoopFileSystemWrapper(wrapperClass);\n-\t\t\t\t\tfs.initialize(uri);\n-\t\t\t\t\tCACHE.put(wrappedKey, fs);\n-\n-\t\t\t\t} else {\n-\t\t\t\t\t// we can not read from this file system.\n-\t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n-\t\t\t\t\t\t\t+ \", referenced in file URI '\" + uri.toString() + \"'.\");\n+\t\t\tif (factory != null) {\n+\t\t\t\tfs = factory.create(uri);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\ttry {\n+\t\t\t\t\tfs = FALLBACK_FACTORY.create(uri);\n \t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t// we end up here if we have a file system with build-in flink support.\n-\t\t\t\tString fsClass = FSDIRECTORY.get(uri.getScheme());\n-\t\t\t\tif (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n-\t\t\t\t\tfs = instantiateHadoopFileSystemWrapper(null);\n-\t\t\t\t} else {\n-\t\t\t\t\tfs = instantiateFileSystem(fsClass);\n+\t\t\t\tcatch (UnsupportedFileSystemSchemeException e) {\n+\t\t\t\t\tthrow new UnsupportedFileSystemSchemeException(\n+\t\t\t\t\t\t\t\"Could not find a file system implementation for scheme '\" + uri.getScheme() + \n+\t\t\t\t\t\t\t\t\t\"'. The scheme is not directly supported by Flink and no Hadoop file \" +\n+\t\t\t\t\t\t\t\t\t\"system to support this scheme could be loaded.\", e);\n \t\t\t\t}\n-\t\t\t\t// Initialize new file system object\n-\t\t\t\tfs.initialize(uri);\n-\n-\t\t\t\t// Add new file system object to cache\n-\t\t\t\tCACHE.put(key, fs);\n \t\t\t}\n \n+\t\t\tCACHE.put(key, fs);\n \t\t\treturn fs;\n \t\t}\n \t\tfinally {\n \t\t\tLOCK.unlock();\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[uri-URI]",
						"newValue": "[fsUri-URI(modifiers-final)]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "[FLINK-7643] [core] Rework FileSystem loading to use factories\n\nThis makes sure that configurations are loaded once and file system instances are\nproperly reused by scheme and authority.\n\nThis also factors out a lot of the special treatment of Hadoop file systems and simply\nmakes the Hadoop File System factory the default fallback factory.\n",
					"commitDate": "2017-10-06, 3:16 AM",
					"commitName": "536675b03a5050fda9c3e1fd403818cb50dcc6ff",
					"commitAuthor": "Stephan Ewen",
					"commitDateOld": "2017-10-05, 11:14 AM",
					"commitNameOld": "a5ef09bb601cdd77fcb94e9ce633fdf979031aaf",
					"commitAuthorOld": "Stephan Ewen",
					"daysBetweenCommits": 0.67,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,93 +1,87 @@\n-\tpublic static FileSystem getUnguardedFileSystem(URI uri) throws IOException {\n-\t\tfinal URI asked = uri;\n+\tpublic static FileSystem getUnguardedFileSystem(final URI fsUri) throws IOException {\n+\t\tcheckNotNull(fsUri, \"file system URI\");\n \n \t\tLOCK.lock();\n \t\ttry {\n+\t\t\tfinal URI uri;\n \n-\t\t\tif (uri.getScheme() == null) {\n+\t\t\tif (fsUri.getScheme() != null) {\n+\t\t\t\turi = fsUri;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\t// Apply the default fs scheme\n+\t\t\t\tfinal URI defaultUri = getDefaultFsUri();\n+\t\t\t\tURI rewrittenUri = null;\n+\n \t\t\t\ttry {\n-\t\t\t\t\tif (defaultScheme == null) {\n-\t\t\t\t\t\tdefaultScheme = new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\turi = new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(),\n-\t\t\t\t\t\t\tdefaultScheme.getPort(), uri.getPath(), null, null);\n-\n-\t\t\t\t} catch (URISyntaxException e) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tif (defaultScheme.getScheme().equals(\"file\")) {\n-\t\t\t\t\t\t\turi = new URI(\"file\", null,\n-\t\t\t\t\t\t\t\t\tnew Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n+\t\t\t\t\trewrittenUri = new URI(defaultUri.getScheme(), null, defaultUri.getHost(),\n+\t\t\t\t\t\t\tdefaultUri.getPort(), fsUri.getPath(), null, null);\n+\t\t\t\t}\n+\t\t\t\tcatch (URISyntaxException e) {\n+\t\t\t\t\t// for local URIs, we make one more try to repair the path by making it absolute\n+\t\t\t\t\tif (defaultUri.getScheme().equals(\"file\")) {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\trewrittenUri = new URI(\n+\t\t\t\t\t\t\t\t\t\"file\", null,\n+\t\t\t\t\t\t\t\t\tnew Path(new File(fsUri.getPath()).getAbsolutePath()).toUri().getPath(),\n+\t\t\t\t\t\t\t\t\tnull);\n+\t\t\t\t\t\t} catch (URISyntaxException ignored) {\n+\t\t\t\t\t\t\t// could not help it...\n \t\t\t\t\t\t}\n-\t\t\t\t\t} catch (URISyntaxException ex) {\n-\t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n-\t\t\t\t\t\tthrow new IOException(\"The URI '\" + uri.toString() + \"' is not valid.\");\n \t\t\t\t\t}\n \t\t\t\t}\n+\n+\t\t\t\tif (rewrittenUri != null) {\n+\t\t\t\t\turi = rewrittenUri;\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tthrow new IOException(\"The file system URI '\" + fsUri +\n+\t\t\t\t\t\t\t\"' declares no scheme and cannot be interpreted relative to the default file system URI (\"\n+\t\t\t\t\t\t\t+ defaultUri + \").\");\n+\t\t\t\t}\n \t\t\t}\n \n-\t\t\tif(uri.getScheme() == null) {\n-\t\t\t\tthrow new IOException(\"The URI '\" + uri + \"' is invalid.\\n\" +\n-\t\t\t\t\t\t\"The fs.default-scheme = \" + defaultScheme + \", the requested URI = \" + asked +\n-\t\t\t\t\t\t\", and the final URI = \" + uri + \".\");\n-\t\t\t}\n-\n+\t\t\t// print a helpful pointer for malformed local URIs (happens a lot to new users) \n \t\t\tif (uri.getScheme().equals(\"file\") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri = \"file:///\" + uri.getAuthority() + uri.getPath();\n \n \t\t\t\tthrow new IOException(\"Found local file path with authority '\" + uri.getAuthority() + \"' in path '\"\n \t\t\t\t\t\t+ uri.toString() + \"'. Hint: Did you forget a slash? (correct path would be '\" + supposedUri + \"')\");\n \t\t\t}\n \n \t\t\tfinal FSKey key = new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n-\t\t\tif (CACHE.containsKey(key)) {\n-\t\t\t\treturn CACHE.get(key);\n+\t\t\t{\n+\t\t\t\tFileSystem cached = CACHE.get(key);\n+\t\t\t\tif (cached != null) {\n+\t\t\t\t\treturn cached;\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \t\t\tfinal FileSystem fs;\n+\t\t\tfinal FileSystemFactory factory = FS_FACTORIES.get(uri.getScheme());\n \n-\t\t\tif (!isFlinkSupportedScheme(uri.getScheme())) {\n-\t\t\t\t// no build in support for this file system. Falling back to Hadoop's FileSystem impl.\n-\t\t\t\tClass<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n-\t\t\t\tif (wrapperClass != null) {\n-\t\t\t\t\t// hadoop has support for the FileSystem\n-\t\t\t\t\tFSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n-\t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n-\t\t\t\t\t\treturn CACHE.get(wrappedKey);\n-\t\t\t\t\t}\n-\t\t\t\t\t// cache didn't contain the file system. instantiate it:\n-\n-\t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n-\t\t\t\t\tfs = instantiateHadoopFileSystemWrapper(wrapperClass);\n-\t\t\t\t\tfs.initialize(uri);\n-\t\t\t\t\tCACHE.put(wrappedKey, fs);\n-\n-\t\t\t\t} else {\n-\t\t\t\t\t// we can not read from this file system.\n-\t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n-\t\t\t\t\t\t\t+ \", referenced in file URI '\" + uri.toString() + \"'.\");\n+\t\t\tif (factory != null) {\n+\t\t\t\tfs = factory.create(uri);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\ttry {\n+\t\t\t\t\tfs = FALLBACK_FACTORY.create(uri);\n \t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t// we end up here if we have a file system with build-in flink support.\n-\t\t\t\tString fsClass = FSDIRECTORY.get(uri.getScheme());\n-\t\t\t\tif (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n-\t\t\t\t\tfs = instantiateHadoopFileSystemWrapper(null);\n-\t\t\t\t} else {\n-\t\t\t\t\tfs = instantiateFileSystem(fsClass);\n+\t\t\t\tcatch (UnsupportedFileSystemSchemeException e) {\n+\t\t\t\t\tthrow new UnsupportedFileSystemSchemeException(\n+\t\t\t\t\t\t\t\"Could not find a file system implementation for scheme '\" + uri.getScheme() + \n+\t\t\t\t\t\t\t\t\t\"'. The scheme is not directly supported by Flink and no Hadoop file \" +\n+\t\t\t\t\t\t\t\t\t\"system to support this scheme could be loaded.\", e);\n \t\t\t\t}\n-\t\t\t\t// Initialize new file system object\n-\t\t\t\tfs.initialize(uri);\n-\n-\t\t\t\t// Add new file system object to cache\n-\t\t\t\tCACHE.put(key, fs);\n \t\t\t}\n \n+\t\t\tCACHE.put(key, fs);\n \t\t\treturn fs;\n \t\t}\n \t\tfinally {\n \t\t\tLOCK.unlock();\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"3b786844dd9c0ce176eac98c8a05ebe50cb1ebe7": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-7643] [core] Misc. cleanups in FileSystem\n\n  - Simplify access to local file system\n  - Use a fair lock for all FileSystem.get() operations\n  - Robust falback to local fs for default scheme (avoids URI parsing error on Windows)\n  - Deprecate 'getDefaultBlockSize()'\n  - Deprecate create(...) with block sizes and replication factor, which is not applicable to many FS\n",
			"commitDate": "2017-10-05, 11:14 AM",
			"commitName": "3b786844dd9c0ce176eac98c8a05ebe50cb1ebe7",
			"commitAuthor": "Stephan Ewen",
			"commitDateOld": "2017-02-19, 5:01 PM",
			"commitNameOld": "5902ea0e88c70f330c23b9ace94033ae34c84445",
			"commitAuthorOld": "Stephan Ewen",
			"daysBetweenCommits": 227.72,
			"commitsBetweenForRepo": 1498,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,89 +1,93 @@\n \tpublic static FileSystem getUnguardedFileSystem(URI uri) throws IOException {\n-\t\tFileSystem fs;\n+\t\tfinal URI asked = uri;\n \n-\t\tURI asked = uri;\n-\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n+\t\tLOCK.lock();\n+\t\ttry {\n \n \t\t\tif (uri.getScheme() == null) {\n \t\t\t\ttry {\n \t\t\t\t\tif (defaultScheme == null) {\n \t\t\t\t\t\tdefaultScheme = new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n \t\t\t\t\t}\n \n \t\t\t\t\turi = new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(),\n \t\t\t\t\t\t\tdefaultScheme.getPort(), uri.getPath(), null, null);\n \n \t\t\t\t} catch (URISyntaxException e) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tif (defaultScheme.getScheme().equals(\"file\")) {\n \t\t\t\t\t\t\turi = new URI(\"file\", null,\n \t\t\t\t\t\t\t\t\tnew Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n \t\t\t\t\t\t}\n \t\t\t\t\t} catch (URISyntaxException ex) {\n \t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n \t\t\t\t\t\tthrow new IOException(\"The URI '\" + uri.toString() + \"' is not valid.\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif(uri.getScheme() == null) {\n \t\t\t\tthrow new IOException(\"The URI '\" + uri + \"' is invalid.\\n\" +\n \t\t\t\t\t\t\"The fs.default-scheme = \" + defaultScheme + \", the requested URI = \" + asked +\n \t\t\t\t\t\t\", and the final URI = \" + uri + \".\");\n \t\t\t}\n \n \t\t\tif (uri.getScheme().equals(\"file\") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri = \"file:///\" + uri.getAuthority() + uri.getPath();\n \n \t\t\t\tthrow new IOException(\"Found local file path with authority '\" + uri.getAuthority() + \"' in path '\"\n \t\t\t\t\t\t+ uri.toString() + \"'. Hint: Did you forget a slash? (correct path would be '\" + supposedUri + \"')\");\n \t\t\t}\n \n \t\t\tfinal FSKey key = new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n+\t\t\tfinal FileSystem fs;\n \n \t\t\tif (!isFlinkSupportedScheme(uri.getScheme())) {\n \t\t\t\t// no build in support for this file system. Falling back to Hadoop's FileSystem impl.\n \t\t\t\tClass<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n \t\t\t\tif (wrapperClass != null) {\n \t\t\t\t\t// hadoop has support for the FileSystem\n \t\t\t\t\tFSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n \t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n \t\t\t\t\t\treturn CACHE.get(wrappedKey);\n \t\t\t\t\t}\n \t\t\t\t\t// cache didn't contain the file system. instantiate it:\n \n \t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n \t\t\t\t\tfs = instantiateHadoopFileSystemWrapper(wrapperClass);\n \t\t\t\t\tfs.initialize(uri);\n \t\t\t\t\tCACHE.put(wrappedKey, fs);\n \n \t\t\t\t} else {\n \t\t\t\t\t// we can not read from this file system.\n \t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n \t\t\t\t\t\t\t+ \", referenced in file URI '\" + uri.toString() + \"'.\");\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// we end up here if we have a file system with build-in flink support.\n \t\t\t\tString fsClass = FSDIRECTORY.get(uri.getScheme());\n \t\t\t\tif (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n \t\t\t\t\tfs = instantiateHadoopFileSystemWrapper(null);\n \t\t\t\t} else {\n \t\t\t\t\tfs = instantiateFileSystem(fsClass);\n \t\t\t\t}\n \t\t\t\t// Initialize new file system object\n \t\t\t\tfs.initialize(uri);\n \n \t\t\t\t// Add new file system object to cache\n \t\t\t\tCACHE.put(key, fs);\n \t\t\t}\n-\t\t}\n \n-\t\treturn fs;\n+\t\t\treturn fs;\n+\t\t}\n+\t\tfinally {\n+\t\t\tLOCK.unlock();\n+\t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ba8ed263695d16eacb4bdfdf195dd22c83bb53ed": {
			"type": "Yrename",
			"commitMessage": "[FLINK-4910] Introduce safety net for closing file system streams\n\nThis closes #2691.\n",
			"commitDate": "2016-11-22, 3:16 PM",
			"commitName": "ba8ed263695d16eacb4bdfdf195dd22c83bb53ed",
			"commitAuthor": "Stefan Richter",
			"commitDateOld": "2016-07-05, 2:39 AM",
			"commitNameOld": "a3d1a17406749e41185a77a64c23fc1cb3eabc76",
			"commitAuthorOld": "Josh",
			"daysBetweenCommits": 140.57,
			"commitsBetweenForRepo": 710,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,89 +1,89 @@\n-\tpublic static FileSystem get(URI uri) throws IOException {\n+\tpublic static FileSystem getUnguardedFileSystem(URI uri) throws IOException {\n \t\tFileSystem fs;\n \n \t\tURI asked = uri;\n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() == null) {\n \t\t\t\ttry {\n \t\t\t\t\tif (defaultScheme == null) {\n \t\t\t\t\t\tdefaultScheme = new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n \t\t\t\t\t}\n \n \t\t\t\t\turi = new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(),\n-\t\t\t\t\t\tdefaultScheme.getPort(), uri.getPath(), null, null);\n+\t\t\t\t\t\t\tdefaultScheme.getPort(), uri.getPath(), null, null);\n \n \t\t\t\t} catch (URISyntaxException e) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tif (defaultScheme.getScheme().equals(\"file\")) {\n \t\t\t\t\t\t\turi = new URI(\"file\", null,\n-\t\t\t\t\t\t\t\tnew Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n+\t\t\t\t\t\t\t\t\tnew Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n \t\t\t\t\t\t}\n \t\t\t\t\t} catch (URISyntaxException ex) {\n \t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n \t\t\t\t\t\tthrow new IOException(\"The URI '\" + uri.toString() + \"' is not valid.\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif(uri.getScheme() == null) {\n \t\t\t\tthrow new IOException(\"The URI '\" + uri + \"' is invalid.\\n\" +\n-\t\t\t\t\t\"The fs.default-scheme = \" + defaultScheme + \", the requested URI = \" + asked +\n-\t\t\t\t\t\", and the final URI = \" + uri + \".\");\n+\t\t\t\t\t\t\"The fs.default-scheme = \" + defaultScheme + \", the requested URI = \" + asked +\n+\t\t\t\t\t\t\", and the final URI = \" + uri + \".\");\n \t\t\t}\n \n \t\t\tif (uri.getScheme().equals(\"file\") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri = \"file:///\" + uri.getAuthority() + uri.getPath();\n \n \t\t\t\tthrow new IOException(\"Found local file path with authority '\" + uri.getAuthority() + \"' in path '\"\n \t\t\t\t\t\t+ uri.toString() + \"'. Hint: Did you forget a slash? (correct path would be '\" + supposedUri + \"')\");\n \t\t\t}\n \n \t\t\tfinal FSKey key = new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \n \t\t\tif (!isFlinkSupportedScheme(uri.getScheme())) {\n \t\t\t\t// no build in support for this file system. Falling back to Hadoop's FileSystem impl.\n \t\t\t\tClass<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n \t\t\t\tif (wrapperClass != null) {\n \t\t\t\t\t// hadoop has support for the FileSystem\n \t\t\t\t\tFSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n \t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n \t\t\t\t\t\treturn CACHE.get(wrappedKey);\n \t\t\t\t\t}\n \t\t\t\t\t// cache didn't contain the file system. instantiate it:\n \n \t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n \t\t\t\t\tfs = instantiateHadoopFileSystemWrapper(wrapperClass);\n \t\t\t\t\tfs.initialize(uri);\n \t\t\t\t\tCACHE.put(wrappedKey, fs);\n \n \t\t\t\t} else {\n \t\t\t\t\t// we can not read from this file system.\n \t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n-\t\t\t\t\t\t+ \", referenced in file URI '\" + uri.toString() + \"'.\");\n+\t\t\t\t\t\t\t+ \", referenced in file URI '\" + uri.toString() + \"'.\");\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// we end up here if we have a file system with build-in flink support.\n \t\t\t\tString fsClass = FSDIRECTORY.get(uri.getScheme());\n \t\t\t\tif (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n \t\t\t\t\tfs = instantiateHadoopFileSystemWrapper(null);\n \t\t\t\t} else {\n \t\t\t\t\tfs = instantiateFileSystem(fsClass);\n \t\t\t\t}\n \t\t\t\t// Initialize new file system object\n \t\t\t\tfs.initialize(uri);\n \n \t\t\t\t// Add new file system object to cache\n \t\t\t\tCACHE.put(key, fs);\n \t\t\t}\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "get",
				"newValue": "getUnguardedFileSystem"
			}
		},
		"a3d1a17406749e41185a77a64c23fc1cb3eabc76": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-4115] Skip filesystem checks for filesystems with no built-in support\n",
			"commitDate": "2016-07-05, 2:39 AM",
			"commitName": "a3d1a17406749e41185a77a64c23fc1cb3eabc76",
			"commitAuthor": "Josh",
			"commitDateOld": "2016-02-16, 7:23 AM",
			"commitNameOld": "76d3a6353a0a3f8960dc2b49d9eac6a4a279ea9e",
			"commitAuthorOld": "Kostas Kloudas",
			"daysBetweenCommits": 139.76,
			"commitsBetweenForRepo": 702,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,89 +1,89 @@\n \tpublic static FileSystem get(URI uri) throws IOException {\n \t\tFileSystem fs;\n \n \t\tURI asked = uri;\n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() == null) {\n \t\t\t\ttry {\n \t\t\t\t\tif (defaultScheme == null) {\n \t\t\t\t\t\tdefaultScheme = new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n \t\t\t\t\t}\n \n \t\t\t\t\turi = new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(),\n \t\t\t\t\t\tdefaultScheme.getPort(), uri.getPath(), null, null);\n \n \t\t\t\t} catch (URISyntaxException e) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tif (defaultScheme.getScheme().equals(\"file\")) {\n \t\t\t\t\t\t\turi = new URI(\"file\", null,\n \t\t\t\t\t\t\t\tnew Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n \t\t\t\t\t\t}\n \t\t\t\t\t} catch (URISyntaxException ex) {\n \t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n \t\t\t\t\t\tthrow new IOException(\"The URI '\" + uri.toString() + \"' is not valid.\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif(uri.getScheme() == null) {\n \t\t\t\tthrow new IOException(\"The URI '\" + uri + \"' is invalid.\\n\" +\n \t\t\t\t\t\"The fs.default-scheme = \" + defaultScheme + \", the requested URI = \" + asked +\n \t\t\t\t\t\", and the final URI = \" + uri + \".\");\n \t\t\t}\n \n \t\t\tif (uri.getScheme().equals(\"file\") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri = \"file:///\" + uri.getAuthority() + uri.getPath();\n \n \t\t\t\tthrow new IOException(\"Found local file path with authority '\" + uri.getAuthority() + \"' in path '\"\n \t\t\t\t\t\t+ uri.toString() + \"'. Hint: Did you forget a slash? (correct path would be '\" + supposedUri + \"')\");\n \t\t\t}\n \n \t\t\tfinal FSKey key = new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \n-\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n+\t\t\tif (!isFlinkSupportedScheme(uri.getScheme())) {\n \t\t\t\t// no build in support for this file system. Falling back to Hadoop's FileSystem impl.\n \t\t\t\tClass<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n \t\t\t\tif (wrapperClass != null) {\n \t\t\t\t\t// hadoop has support for the FileSystem\n \t\t\t\t\tFSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n \t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n \t\t\t\t\t\treturn CACHE.get(wrappedKey);\n \t\t\t\t\t}\n \t\t\t\t\t// cache didn't contain the file system. instantiate it:\n \n \t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n \t\t\t\t\tfs = instantiateHadoopFileSystemWrapper(wrapperClass);\n \t\t\t\t\tfs.initialize(uri);\n \t\t\t\t\tCACHE.put(wrappedKey, fs);\n \n \t\t\t\t} else {\n \t\t\t\t\t// we can not read from this file system.\n \t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n \t\t\t\t\t\t+ \", referenced in file URI '\" + uri.toString() + \"'.\");\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// we end up here if we have a file system with build-in flink support.\n \t\t\t\tString fsClass = FSDIRECTORY.get(uri.getScheme());\n \t\t\t\tif (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n \t\t\t\t\tfs = instantiateHadoopFileSystemWrapper(null);\n \t\t\t\t} else {\n \t\t\t\t\tfs = instantiateFileSystem(fsClass);\n \t\t\t\t}\n \t\t\t\t// Initialize new file system object\n \t\t\t\tfs.initialize(uri);\n \n \t\t\t\t// Add new file system object to cache\n \t\t\t\tCACHE.put(key, fs);\n \t\t\t}\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"76d3a6353a0a3f8960dc2b49d9eac6a4a279ea9e": {
			"type": "Ybodychange",
			"commitMessage": "FLINK-2380: allow the specification of a default filesystem scheme in the flink configuration file.\n\nThis closes #1524\n",
			"commitDate": "2016-02-16, 7:23 AM",
			"commitName": "76d3a6353a0a3f8960dc2b49d9eac6a4a279ea9e",
			"commitAuthor": "Kostas Kloudas",
			"commitDateOld": "2016-01-07, 8:01 AM",
			"commitNameOld": "c674a6558e07f1d918961a21ddaad4a6148698a0",
			"commitAuthorOld": "Robert Metzger",
			"daysBetweenCommits": 39.97,
			"commitsBetweenForRepo": 256,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,89 @@\n \tpublic static FileSystem get(URI uri) throws IOException {\n \t\tFileSystem fs;\n \n+\t\tURI asked = uri;\n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() == null) {\n \t\t\t\ttry {\n-\t\t\t\t\turi = new URI(\"file\", null, uri.getPath(), null);\n-\t\t\t\t}\n-\t\t\t\tcatch (URISyntaxException e) {\n+\t\t\t\t\tif (defaultScheme == null) {\n+\t\t\t\t\t\tdefaultScheme = new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\turi = new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(),\n+\t\t\t\t\t\tdefaultScheme.getPort(), uri.getPath(), null, null);\n+\n+\t\t\t\t} catch (URISyntaxException e) {\n \t\t\t\t\ttry {\n-\t\t\t\t\t\turi = new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n+\t\t\t\t\t\tif (defaultScheme.getScheme().equals(\"file\")) {\n+\t\t\t\t\t\t\turi = new URI(\"file\", null,\n+\t\t\t\t\t\t\t\tnew Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n+\t\t\t\t\t\t}\n \t\t\t\t\t} catch (URISyntaxException ex) {\n \t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n-\t\t\t\t\t\tthrow new IOException(\"The file URI '\" + uri.toString() + \"' is not valid.\");\n+\t\t\t\t\t\tthrow new IOException(\"The URI '\" + uri.toString() + \"' is not valid.\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\t\n+\n+\t\t\tif(uri.getScheme() == null) {\n+\t\t\t\tthrow new IOException(\"The URI '\" + uri + \"' is invalid.\\n\" +\n+\t\t\t\t\t\"The fs.default-scheme = \" + defaultScheme + \", the requested URI = \" + asked +\n+\t\t\t\t\t\", and the final URI = \" + uri + \".\");\n+\t\t\t}\n+\n \t\t\tif (uri.getScheme().equals(\"file\") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri = \"file:///\" + uri.getAuthority() + uri.getPath();\n-\t\t\t\t\n+\n \t\t\t\tthrow new IOException(\"Found local file path with authority '\" + uri.getAuthority() + \"' in path '\"\n \t\t\t\t\t\t+ uri.toString() + \"'. Hint: Did you forget a slash? (correct path would be '\" + supposedUri + \"')\");\n \t\t\t}\n \n \t\t\tfinal FSKey key = new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n \t\t\t\t// no build in support for this file system. Falling back to Hadoop's FileSystem impl.\n \t\t\t\tClass<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n \t\t\t\tif (wrapperClass != null) {\n \t\t\t\t\t// hadoop has support for the FileSystem\n \t\t\t\t\tFSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n \t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n \t\t\t\t\t\treturn CACHE.get(wrappedKey);\n \t\t\t\t\t}\n \t\t\t\t\t// cache didn't contain the file system. instantiate it:\n \n \t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n \t\t\t\t\tfs = instantiateHadoopFileSystemWrapper(wrapperClass);\n \t\t\t\t\tfs.initialize(uri);\n \t\t\t\t\tCACHE.put(wrappedKey, fs);\n \n \t\t\t\t} else {\n \t\t\t\t\t// we can not read from this file system.\n \t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n-\t\t\t\t\t\t\t+ \", referenced in file URI '\" + uri.toString() + \"'.\");\n+\t\t\t\t\t\t+ \", referenced in file URI '\" + uri.toString() + \"'.\");\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// we end up here if we have a file system with build-in flink support.\n \t\t\t\tString fsClass = FSDIRECTORY.get(uri.getScheme());\n \t\t\t\tif (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n \t\t\t\t\tfs = instantiateHadoopFileSystemWrapper(null);\n \t\t\t\t} else {\n \t\t\t\t\tfs = instantiateFileSystem(fsClass);\n \t\t\t\t}\n \t\t\t\t// Initialize new file system object\n \t\t\t\tfs.initialize(uri);\n \n \t\t\t\t// Add new file system object to cache\n \t\t\t\tCACHE.put(key, fs);\n \t\t\t}\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1c8d866a83065e3d1bc9707dab81117f24c9f678": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-1968] [runtime] Clean up and improve the distributed cache.\n\n - Gives a proper exception when a non-cached file is accessed\n - Forwards I/O exceptions that happen during file transfer, rather than only returning null when transfer failed\n - Consistently keeps reference counts and copies only when needed\n - Properly removes all files when shutdown\n - Uses a shutdown hook to remove files when process is killed\n",
			"commitDate": "2015-05-11, 1:07 PM",
			"commitName": "1c8d866a83065e3d1bc9707dab81117f24c9f678",
			"commitAuthor": "Stephan Ewen",
			"commitDateOld": "2015-03-31, 11:54 AM",
			"commitNameOld": "d8c74d20970e6cf379165ffafe8550a5b98d7c4d",
			"commitAuthorOld": "hongsibao",
			"daysBetweenCommits": 41.05,
			"commitsBetweenForRepo": 215,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,74 @@\n \tpublic static FileSystem get(URI uri) throws IOException {\n-\t\tFileSystem fs = null;\n+\t\tFileSystem fs;\n \n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() == null) {\n \t\t\t\ttry {\n \t\t\t\t\turi = new URI(\"file\", null, uri.getPath(), null);\n \t\t\t\t}\n \t\t\t\tcatch (URISyntaxException e) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\turi = new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n \t\t\t\t\t} catch (URISyntaxException ex) {\n \t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n \t\t\t\t\t\tthrow new IOException(\"The file URI '\" + uri.toString() + \"' is not valid.\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\t\n \t\t\tif (uri.getScheme().equals(\"file\") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri = \"file:///\" + uri.getAuthority() + uri.getPath();\n \t\t\t\t\n \t\t\t\tthrow new IOException(\"Found local file path with authority '\" + uri.getAuthority() + \"' in path '\"\n \t\t\t\t\t\t+ uri.toString() + \"'. Hint: Did you forget a slash? (correct path would be '\" + supposedUri + \"')\");\n \t\t\t}\n \n \t\t\tfinal FSKey key = new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n \t\t\t\t// no build in support for this file system. Falling back to Hadoop's FileSystem impl.\n \t\t\t\tClass<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n \t\t\t\tif (wrapperClass != null) {\n \t\t\t\t\t// hadoop has support for the FileSystem\n \t\t\t\t\tFSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n \t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n \t\t\t\t\t\treturn CACHE.get(wrappedKey);\n \t\t\t\t\t}\n \t\t\t\t\t// cache didn't contain the file system. instantiate it:\n \n \t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n \t\t\t\t\tfs = instantiateHadoopFileSystemWrapper(wrapperClass);\n \t\t\t\t\tfs.initialize(uri);\n \t\t\t\t\tCACHE.put(wrappedKey, fs);\n \n \t\t\t\t} else {\n \t\t\t\t\t// we can not read from this file system.\n \t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n \t\t\t\t\t\t\t+ \", referenced in file URI '\" + uri.toString() + \"'.\");\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// we end up here if we have a file system with build-in flink support.\n \t\t\t\tString fsClass = FSDIRECTORY.get(uri.getScheme());\n \t\t\t\tif (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n \t\t\t\t\tfs = instantiateHadoopFileSystemWrapper(null);\n \t\t\t\t} else {\n \t\t\t\t\tfs = instantiateFileSystem(fsClass);\n \t\t\t\t}\n \t\t\t\t// Initialize new file system object\n \t\t\t\tfs.initialize(uri);\n \n \t\t\t\t// Add new file system object to cache\n \t\t\t\tCACHE.put(key, fs);\n \t\t\t}\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2af658673f877a7e0fd73fdd2907f88824d793a5": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-1295][FLINK-883] Allow to deploy 'job only' YARN cluster. Add tests to YARN\n\n- users can now also deploy Flink on YARN for executing a single job.\n- The flink-yarn project has been moved out of the flink-addons module\n- the MiniYARNCluster is used for testing Flink on YARN\n- There is now a (undocumented) Java interface Flink's YARN client, allowing users to manually control the Yarn session.\n- ALL ports used by Flink when running on YARN are automatically determined. In the past users reported problems with blocked ports (YARN is telling the client the RPC address of the application master)\n- The checks before deployment have been improved to give better error messages if the user is requesting too many resources for a YARN session\n",
			"commitDate": "2015-01-23, 10:39 AM",
			"commitName": "2af658673f877a7e0fd73fdd2907f88824d793a5",
			"commitAuthor": "Robert Metzger",
			"commitDateOld": "2015-01-08, 8:42 AM",
			"commitNameOld": "39fb7c945359465ce5241539559daac416e210b8",
			"commitAuthorOld": "Robert Metzger",
			"daysBetweenCommits": 15.08,
			"commitsBetweenForRepo": 80,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,75 +1,74 @@\n \tpublic static FileSystem get(URI uri) throws IOException {\n \t\tFileSystem fs = null;\n \n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() == null) {\n \t\t\t\ttry {\n \t\t\t\t\turi = new URI(\"file\", null, uri.getPath(), null);\n \t\t\t\t}\n \t\t\t\tcatch (URISyntaxException e) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\turi = new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n \t\t\t\t\t} catch (URISyntaxException ex) {\n \t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n \t\t\t\t\t\tthrow new IOException(\"The file URI '\" + uri.toString() + \"' is not valid.\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\t\n \t\t\tif (uri.getScheme().equals(\"file\") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri = \"file:///\" + uri.getAuthority() + uri.getPath();\n \t\t\t\t\n \t\t\t\tthrow new IOException(\"Found local file path with authority '\" + uri.getAuthority() + \"' in path '\"\n \t\t\t\t\t\t+ uri.toString() + \"'. Hint: Did you forget a slash? (correct path would be '\" + supposedUri + \"')\");\n \t\t\t}\n \n \t\t\tfinal FSKey key = new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n \t\t\t\t// no build in support for this file system. Falling back to Hadoop's FileSystem impl.\n \t\t\t\tClass<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n \t\t\t\tif(wrapperClass != null) {\n \t\t\t\t\t// hadoop has support for the FileSystem\n \t\t\t\t\tFSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n \t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n \t\t\t\t\t\treturn CACHE.get(wrappedKey);\n \t\t\t\t\t}\n \t\t\t\t\t// cache didn't contain the file system. instantiate it:\n \n \t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n \t\t\t\t\tfs = instantiateHadoopFileSystemWrapper(wrapperClass);\n \t\t\t\t\tfs.initialize(uri);\n-\t\t\t\t\tSystem.out.println(\"Initializing new instance of wrapper for \"+wrapperClass);\n \t\t\t\t\tCACHE.put(wrappedKey, fs);\n \n \t\t\t\t} else {\n \t\t\t\t\t// we can not read from this file system.\n \t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n \t\t\t\t\t\t\t+ \", referenced in file URI '\" + uri.toString() + \"'.\");\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// we end up here if we have a file system with build-in flink support.\n \t\t\t\tString fsClass = FSDIRECTORY.get(uri.getScheme());\n \t\t\t\tif(fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n \t\t\t\t\tfs = instantiateHadoopFileSystemWrapper(null);\n \t\t\t\t} else {\n \t\t\t\t\tfs = instantiateFileSystem(fsClass);\n \t\t\t\t}\n \t\t\t\t// Initialize new file system object\n \t\t\t\tfs.initialize(uri);\n \n \t\t\t\t// Add new file system object to cache\n \t\t\t\tCACHE.put(key, fs);\n \t\t\t}\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"39fb7c945359465ce5241539559daac416e210b8": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-1266] More dependency exclusions & fixed image in web client\n\nThis closes #268\n",
			"commitDate": "2015-01-08, 8:42 AM",
			"commitName": "39fb7c945359465ce5241539559daac416e210b8",
			"commitAuthor": "Robert Metzger",
			"commitDateOld": "2015-01-08, 8:35 AM",
			"commitNameOld": "0af4d3abf3afdeff89fee479a37413bc303d0ed0",
			"commitAuthorOld": "Robert Metzger",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,76 +1,75 @@\n \tpublic static FileSystem get(URI uri) throws IOException {\n \t\tFileSystem fs = null;\n \n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() == null) {\n \t\t\t\ttry {\n \t\t\t\t\turi = new URI(\"file\", null, uri.getPath(), null);\n \t\t\t\t}\n \t\t\t\tcatch (URISyntaxException e) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\turi = new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n \t\t\t\t\t} catch (URISyntaxException ex) {\n \t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n \t\t\t\t\t\tthrow new IOException(\"The file URI '\" + uri.toString() + \"' is not valid.\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\t\n \t\t\tif (uri.getScheme().equals(\"file\") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri = \"file:///\" + uri.getAuthority() + uri.getPath();\n \t\t\t\t\n \t\t\t\tthrow new IOException(\"Found local file path with authority '\" + uri.getAuthority() + \"' in path '\"\n \t\t\t\t\t\t+ uri.toString() + \"'. Hint: Did you forget a slash? (correct path would be '\" + supposedUri + \"')\");\n \t\t\t}\n \n \t\t\tfinal FSKey key = new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n \t\t\t\t// no build in support for this file system. Falling back to Hadoop's FileSystem impl.\n \t\t\t\tClass<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n \t\t\t\tif(wrapperClass != null) {\n \t\t\t\t\t// hadoop has support for the FileSystem\n \t\t\t\t\tFSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n \t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n \t\t\t\t\t\treturn CACHE.get(wrappedKey);\n \t\t\t\t\t}\n \t\t\t\t\t// cache didn't contain the file system. instantiate it:\n \n \t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n \t\t\t\t\tfs = instantiateHadoopFileSystemWrapper(wrapperClass);\n \t\t\t\t\tfs.initialize(uri);\n \t\t\t\t\tSystem.out.println(\"Initializing new instance of wrapper for \"+wrapperClass);\n \t\t\t\t\tCACHE.put(wrappedKey, fs);\n \n \t\t\t\t} else {\n \t\t\t\t\t// we can not read from this file system.\n \t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n \t\t\t\t\t\t\t+ \", referenced in file URI '\" + uri.toString() + \"'.\");\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// we end up here if we have a file system with build-in flink support.\n \t\t\t\tString fsClass = FSDIRECTORY.get(uri.getScheme());\n \t\t\t\tif(fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n \t\t\t\t\tfs = instantiateHadoopFileSystemWrapper(null);\n \t\t\t\t} else {\n \t\t\t\t\tfs = instantiateFileSystem(fsClass);\n \t\t\t\t}\n-\t\t\t\tSystem.out.println(\"Initializing new instance of native class for \"+fsClass);\n \t\t\t\t// Initialize new file system object\n \t\t\t\tfs.initialize(uri);\n \n \t\t\t\t// Add new file system object to cache\n \t\t\t\tCACHE.put(key, fs);\n \t\t\t}\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f2909293cbb37cc4b4516e3bef4db66376159e52": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-1266] Generalize DistributedFileSystem implementation\nto HadoopFileSystem wrapper, which supports all subclasses of org.apache.hadoop.fs.FileSystem.\nThis allows us to let users use all file systems with support for HDFS.\nThe change has been tested with Tachyon, Google Cloud Storage Hadoop Adapter and HDFS.\n\nThe change also cleans up the Hadoop dependency exclusions.\n",
			"commitDate": "2015-01-08, 8:35 AM",
			"commitName": "f2909293cbb37cc4b4516e3bef4db66376159e52",
			"commitAuthor": "Robert Metzger",
			"commitDateOld": "2014-11-27, 10:18 AM",
			"commitNameOld": "bbe54ac09154dd3e60870b0d26085e2e2ee564af",
			"commitAuthorOld": "zentol",
			"daysBetweenCommits": 41.93,
			"commitsBetweenForRepo": 210,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,66 +1,76 @@\n \tpublic static FileSystem get(URI uri) throws IOException {\n-\n \t\tFileSystem fs = null;\n \n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() == null) {\n \t\t\t\ttry {\n \t\t\t\t\turi = new URI(\"file\", null, uri.getPath(), null);\n \t\t\t\t}\n \t\t\t\tcatch (URISyntaxException e) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\turi = new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n \t\t\t\t\t} catch (URISyntaxException ex) {\n \t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n \t\t\t\t\t\tthrow new IOException(\"The file URI '\" + uri.toString() + \"' is not valid.\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\t\n \t\t\tif (uri.getScheme().equals(\"file\") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri = \"file:///\" + uri.getAuthority() + uri.getPath();\n \t\t\t\t\n \t\t\t\tthrow new IOException(\"Found local file path with authority '\" + uri.getAuthority() + \"' in path '\"\n \t\t\t\t\t\t+ uri.toString() + \"'. Hint: Did you forget a slash? (correct path would be '\" + supposedUri + \"')\");\n \t\t\t}\n \n \t\t\tfinal FSKey key = new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n+\n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n-\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n-\t\t\t\t\t\t+ \", referenced in file URI '\" + uri.toString() + \"'.\");\n-\t\t\t}\n+\t\t\t\t// no build in support for this file system. Falling back to Hadoop's FileSystem impl.\n+\t\t\t\tClass<?> wrapperClass = getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n+\t\t\t\tif(wrapperClass != null) {\n+\t\t\t\t\t// hadoop has support for the FileSystem\n+\t\t\t\t\tFSKey wrappedKey = new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n+\t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n+\t\t\t\t\t\treturn CACHE.get(wrappedKey);\n+\t\t\t\t\t}\n+\t\t\t\t\t// cache didn't contain the file system. instantiate it:\n \n-\t\t\tClass<? extends FileSystem> fsClass;\n-\t\t\ttry {\n-\t\t\t\tfsClass = ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n-\t\t\t} catch (ClassNotFoundException e1) {\n-\t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n-\t\t\t}\n+\t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n+\t\t\t\t\tfs = instantiateHadoopFileSystemWrapper(wrapperClass);\n+\t\t\t\t\tfs.initialize(uri);\n+\t\t\t\t\tSystem.out.println(\"Initializing new instance of wrapper for \"+wrapperClass);\n+\t\t\t\t\tCACHE.put(wrappedKey, fs);\n \n-\t\t\ttry {\n-\t\t\t\tfs = fsClass.newInstance();\n-\t\t\t}\n-\t\t\tcatch (InstantiationException e) {\n-\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n-\t\t\t}\n-\t\t\tcatch (IllegalAccessException e) {\n-\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n-\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\t// we can not read from this file system.\n+\t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n+\t\t\t\t\t\t\t+ \", referenced in file URI '\" + uri.toString() + \"'.\");\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t// we end up here if we have a file system with build-in flink support.\n+\t\t\t\tString fsClass = FSDIRECTORY.get(uri.getScheme());\n+\t\t\t\tif(fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n+\t\t\t\t\tfs = instantiateHadoopFileSystemWrapper(null);\n+\t\t\t\t} else {\n+\t\t\t\t\tfs = instantiateFileSystem(fsClass);\n+\t\t\t\t}\n+\t\t\t\tSystem.out.println(\"Initializing new instance of native class for \"+fsClass);\n+\t\t\t\t// Initialize new file system object\n+\t\t\t\tfs.initialize(uri);\n \n-\t\t\t// Initialize new file system object\n-\t\t\tfs.initialize(uri);\n-\n-\t\t\t// Add new file system object to cache\n-\t\t\tCACHE.put(key, fs);\n+\t\t\t\t// Add new file system object to cache\n+\t\t\t\tCACHE.put(key, fs);\n+\t\t\t}\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"bbe54ac09154dd3e60870b0d26085e2e2ee564af": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-1270] [APIs] FS.get() supports relative paths\n\nThis closes #224\n",
			"commitDate": "2014-11-27, 10:18 AM",
			"commitName": "bbe54ac09154dd3e60870b0d26085e2e2ee564af",
			"commitAuthor": "zentol",
			"commitDateOld": "2014-11-20, 4:17 AM",
			"commitNameOld": "4203bf99ddd009b72681ba0dc554cabd47e1c85c",
			"commitAuthorOld": "Suneel Marthi",
			"daysBetweenCommits": 7.25,
			"commitsBetweenForRepo": 38,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,63 +1,66 @@\n \tpublic static FileSystem get(URI uri) throws IOException {\n \n \t\tFileSystem fs = null;\n \n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() == null) {\n \t\t\t\ttry {\n \t\t\t\t\turi = new URI(\"file\", null, uri.getPath(), null);\n \t\t\t\t}\n \t\t\t\tcatch (URISyntaxException e) {\n-\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n-\t\t\t\t\tthrow new IOException(\"The file URI '\" + uri.toString() + \"' is not valid. \"\n-\t\t\t\t\t\t\t+ \" File URIs need to specify aboslute file paths.\");\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\turi = new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n+\t\t\t\t\t} catch (URISyntaxException ex) {\n+\t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n+\t\t\t\t\t\tthrow new IOException(\"The file URI '\" + uri.toString() + \"' is not valid.\");\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\t\n \t\t\tif (uri.getScheme().equals(\"file\") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri = \"file:///\" + uri.getAuthority() + uri.getPath();\n \t\t\t\t\n \t\t\t\tthrow new IOException(\"Found local file path with authority '\" + uri.getAuthority() + \"' in path '\"\n \t\t\t\t\t\t+ uri.toString() + \"'. Hint: Did you forget a slash? (correct path would be '\" + supposedUri + \"')\");\n \t\t\t}\n \n \t\t\tfinal FSKey key = new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n \t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n \t\t\t\t\t\t+ \", referenced in file URI '\" + uri.toString() + \"'.\");\n \t\t\t}\n \n \t\t\tClass<? extends FileSystem> fsClass;\n \t\t\ttry {\n \t\t\t\tfsClass = ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n \t\t\t} catch (ClassNotFoundException e1) {\n \t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n \t\t\t}\n \n \t\t\ttry {\n \t\t\t\tfs = fsClass.newInstance();\n \t\t\t}\n \t\t\tcatch (InstantiationException e) {\n \t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException e) {\n \t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n \t\t\t}\n \n \t\t\t// Initialize new file system object\n \t\t\tfs.initialize(uri);\n \n \t\t\t// Add new file system object to cache\n \t\t\tCACHE.put(key, fs);\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4203bf99ddd009b72681ba0dc554cabd47e1c85c": {
			"type": "Ybodychange",
			"commitMessage": "Minor code clean up\n\nThis closes #221.\n",
			"commitDate": "2014-11-20, 4:17 AM",
			"commitName": "4203bf99ddd009b72681ba0dc554cabd47e1c85c",
			"commitAuthor": "Suneel Marthi",
			"commitDateOld": "2014-11-10, 3:59 AM",
			"commitNameOld": "81c5b2adee778532634e52b7915ec682bb939a15",
			"commitAuthorOld": "Stephan Ewen",
			"daysBetweenCommits": 10.01,
			"commitsBetweenForRepo": 48,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,63 +1,63 @@\n \tpublic static FileSystem get(URI uri) throws IOException {\n \n \t\tFileSystem fs = null;\n \n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() == null) {\n \t\t\t\ttry {\n \t\t\t\t\turi = new URI(\"file\", null, uri.getPath(), null);\n \t\t\t\t}\n \t\t\t\tcatch (URISyntaxException e) {\n \t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n \t\t\t\t\tthrow new IOException(\"The file URI '\" + uri.toString() + \"' is not valid. \"\n \t\t\t\t\t\t\t+ \" File URIs need to specify aboslute file paths.\");\n \t\t\t\t}\n \t\t\t}\n \t\t\t\n \t\t\tif (uri.getScheme().equals(\"file\") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri = \"file:///\" + uri.getAuthority() + uri.getPath();\n \t\t\t\t\n \t\t\t\tthrow new IOException(\"Found local file path with authority '\" + uri.getAuthority() + \"' in path '\"\n \t\t\t\t\t\t+ uri.toString() + \"'. Hint: Did you forget a slash? (correct path would be '\" + supposedUri + \"')\");\n \t\t\t}\n \n \t\t\tfinal FSKey key = new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n \t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n \t\t\t\t\t\t+ \", referenced in file URI '\" + uri.toString() + \"'.\");\n \t\t\t}\n \n-\t\t\tClass<? extends FileSystem> fsClass = null;\n+\t\t\tClass<? extends FileSystem> fsClass;\n \t\t\ttry {\n \t\t\t\tfsClass = ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n \t\t\t} catch (ClassNotFoundException e1) {\n \t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n \t\t\t}\n \n \t\t\ttry {\n \t\t\t\tfs = fsClass.newInstance();\n \t\t\t}\n \t\t\tcatch (InstantiationException e) {\n \t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException e) {\n \t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n \t\t\t}\n \n \t\t\t// Initialize new file system object\n \t\t\tfs.initialize(uri);\n \n \t\t\t// Add new file system object to cache\n \t\t\tCACHE.put(key, fs);\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8b39ba9e45145a30c2b95c47d7b03bc3ed2a8a3a": {
			"type": "Ybodychange",
			"commitMessage": "Improve error messages in case of invalid file paths or URIs\n\nThis closes #170\n",
			"commitDate": "2014-11-03, 9:10 AM",
			"commitName": "8b39ba9e45145a30c2b95c47d7b03bc3ed2a8a3a",
			"commitAuthor": "Stephan Ewen",
			"commitDateOld": "2014-09-23, 5:59 AM",
			"commitNameOld": "b904b0041cf97b2c6181b1985afc457ed01cf626",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 41.17,
			"commitsBetweenForRepo": 178,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,56 +1,63 @@\n \tpublic static FileSystem get(URI uri) throws IOException {\n \n \t\tFileSystem fs = null;\n \n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() == null) {\n \t\t\t\ttry {\n \t\t\t\t\turi = new URI(\"file\", null, uri.getPath(), null);\n \t\t\t\t}\n \t\t\t\tcatch (URISyntaxException e) {\n \t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n-\t\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are example schemes. \"\n-\t\t\t\t\t\t\t+ \"Failed for \" + uri.toString() + \".\");\n+\t\t\t\t\tthrow new IOException(\"The file URI '\" + uri.toString() + \"' is not valid. \"\n+\t\t\t\t\t\t\t+ \" File URIs need to specify aboslute file paths.\");\n \t\t\t\t}\n \t\t\t}\n+\t\t\t\n+\t\t\tif (uri.getScheme().equals(\"file\") && uri.getAuthority() != null && !uri.getAuthority().isEmpty()) {\n+\t\t\t\tString supposedUri = \"file:///\" + uri.getAuthority() + uri.getPath();\n+\t\t\t\t\n+\t\t\t\tthrow new IOException(\"Found local file path with authority '\" + uri.getAuthority() + \"' in path '\"\n+\t\t\t\t\t\t+ uri.toString() + \"'. Hint: Did you forget a slash? (correct path would be '\" + supposedUri + \"')\");\n+\t\t\t}\n \n \t\t\tfinal FSKey key = new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n \t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n-\t\t\t\t+ \". Failed for \" + uri.toString() + \".\");\n+\t\t\t\t\t\t+ \", referenced in file URI '\" + uri.toString() + \"'.\");\n \t\t\t}\n \n \t\t\tClass<? extends FileSystem> fsClass = null;\n \t\t\ttry {\n \t\t\t\tfsClass = ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n \t\t\t} catch (ClassNotFoundException e1) {\n \t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n \t\t\t}\n \n \t\t\ttry {\n \t\t\t\tfs = fsClass.newInstance();\n \t\t\t}\n \t\t\tcatch (InstantiationException e) {\n \t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException e) {\n \t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n \t\t\t}\n \n \t\t\t// Initialize new file system object\n \t\t\tfs.initialize(uri);\n \n \t\t\t// Add new file system object to cache\n \t\t\tCACHE.put(key, fs);\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8563d511da8ab8ac0e1362775f11aef7b67375be": {
			"type": "Yfilerename",
			"commitMessage": "Rename POMs, scripts, quickstarts and other minor renames\n",
			"commitDate": "2014-07-10, 2:35 PM",
			"commitName": "8563d511da8ab8ac0e1362775f11aef7b67375be",
			"commitAuthor": "Robert Metzger",
			"commitDateOld": "2014-07-10, 8:46 AM",
			"commitNameOld": "5f011547378ad03c033770503c6dcfd6b64e9647",
			"commitAuthorOld": "Stephan Ewen",
			"daysBetweenCommits": 0.24,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "stratosphere-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
				"newPath": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java"
			}
		}
	},
	"sha": "9e936a5f8198b0059e9b5fba33163c2bbe3efbdd"
}