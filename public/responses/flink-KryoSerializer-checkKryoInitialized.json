{
	"repo": "https://github.com/apache/flink.git",
	"file": "flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java",
	"method": {
		"longName": "KryoSerializer::checkKryoInitialized()",
		"startLine": 426,
		"methodName": "checkKryoInitialized",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "private"
	},
	"history": {
		"8aa5e05733655e7b3d1f11ed15f61672d61e5cb5": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-6178] [core] Allow serializer upgrades for managed state\n\nThis commit adds the functionality of allowing serializer upgrades for\nFlink's managed state. It consists of 2 major changes: 1) new\nuser-facing API in `TypeSerializer`, and 2) activate serializer upgrades\nin state backends.\n\nFor 1) new user-facing API for `TypeSerializer`, the following is added:\n- new class: TypeSerializerConfigSnapshot\n- new class: CompatibilityResult\n- new method: TypeSerializer#snapshotConfiguration()\n- new method:\n  TypeSerializer#ensureCompatibility(TypeSerializerConfigSnapshot)\n\nGenerally speaking, configuration snapshots contains a point-in-time\nview of a serializer's state / configuration, and is persisted along\nwith checkpoints. On restore, the configuration is confronted with the\nnew serializer of the state to check for compatibility, which may\nintroduce reconfiguration of the new serializer to be compatible.\n\nThis compatibility check is integrated in the state backends' restore\nflow in 2). Currently, if the check results in the need to perform state\nmigration, the restore simply fails as the state migration feature isn't\nyet available.\n",
			"commitDate": "2017-05-07, 12:04 PM",
			"commitName": "8aa5e05733655e7b3d1f11ed15f61672d61e5cb5",
			"commitAuthor": "Tzu-Li (Gordon) Tai",
			"commitDateOld": "2017-03-23, 10:34 PM",
			"commitNameOld": "09164cf2388888bc2f92f0ca63bb1f15283e895c",
			"commitAuthorOld": "Aljoscha Krettek",
			"daysBetweenCommits": 44.56,
			"commitsBetweenForRepo": 296,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,52 +1,28 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo == null) {\n \t\t\tthis.kryo = getKryoInstance();\n \n \t\t\t// Enable reference tracking. \n \t\t\tkryo.setReferences(true);\n \t\t\t\n \t\t\t// Throwable and all subclasses should be serialized via java serialization\n \t\t\t// Note: the registered JavaSerializer is Flink's own implementation, and not Kryo's.\n \t\t\t//       This is due to a know issue with Kryo's JavaSerializer. See FLINK-6025 for details.\n \t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \n-\t\t\t// Add default serializers first, so that they type registrations without a serializer\n+\t\t\t// Add default serializers first, so that the type registrations without a serializer\n \t\t\t// are registered with a default serializer\n \t\t\tfor (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> entry: defaultSerializers.entrySet()) {\n \t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n \t\t\t}\n \n \t\t\tfor (Map.Entry<Class<?>, Class<? extends Serializer<?>>> entry: defaultSerializerClasses.entrySet()) {\n \t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n \t\t\t}\n \n-\t\t\t// register the type of our class\n-\t\t\tkryo.register(type);\n-\n-\t\t\t// register given types. we do this first so that any registration of a\n-\t\t\t// more specific serializer overrides this\n-\t\t\tfor (Class<?> type : registeredTypes) {\n-\t\t\t\tkryo.register(type);\n-\t\t\t}\n-\n-\t\t\t// register given serializer classes\n-\t\t\tfor (Map.Entry<Class<?>, Class<? extends Serializer<?>>> e : registeredTypesWithSerializerClasses.entrySet()) {\n-\t\t\t\tClass<?> typeClass = e.getKey();\n-\t\t\t\tClass<? extends Serializer<?>> serializerClass = e.getValue();\n-\n-\t\t\t\tSerializer<?> serializer =\n-\t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n-\t\t\t\tkryo.register(typeClass, serializer);\n-\t\t\t}\n-\n-\t\t\t// register given serializers\n-\t\t\tfor (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> e : registeredTypesWithSerializers.entrySet()) {\n-\t\t\t\tkryo.register(e.getKey(), e.getValue().getSerializer());\n-\t\t\t}\n-\t\t\t// this is needed for Avro but can not be added on demand.\n-\t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n+\t\t\tKryoUtils.applyRegistrations(this.kryo, kryoRegistrations.values());\n \n \t\t\tkryo.setRegistrationRequired(false);\n \t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f2143172feca2925832c8b26c3c9fbbb92ecd48f": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-6025] [core] Add Flink's own JavaSerializer for Kryo serialization\n\nThis commit adds a reimplemented JavaSerializer to be registered with\nKryo. This is due to a know issue with Kryo's JavaSerializer that may\nuse the wrong classloader for deserialzation.\n\nInstead of registering Kryo's JavaSerializer for Throwables, it is now\nchanged to register the reimplemented JavaSerializer. Users who bump\ninto ClassNotFoundExceptions if they are using Kryo's JavaSerializer for\ntheir own types are also recommended to change to Flink's JavaSerializer.\n\nThis closes #3517.\n",
			"commitDate": "2017-03-13, 9:31 AM",
			"commitName": "f2143172feca2925832c8b26c3c9fbbb92ecd48f",
			"commitAuthor": "Tzu-Li (Gordon) Tai",
			"commitDateOld": "2016-04-15, 11:38 AM",
			"commitNameOld": "dc78a7470a5da086a08140b200a20d840460ef79",
			"commitAuthorOld": "Andrew Palumbo",
			"daysBetweenCommits": 331.91,
			"commitsBetweenForRepo": 1897,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,50 +1,52 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo == null) {\n \t\t\tthis.kryo = getKryoInstance();\n \n \t\t\t// Enable reference tracking. \n \t\t\tkryo.setReferences(true);\n \t\t\t\n \t\t\t// Throwable and all subclasses should be serialized via java serialization\n+\t\t\t// Note: the registered JavaSerializer is Flink's own implementation, and not Kryo's.\n+\t\t\t//       This is due to a know issue with Kryo's JavaSerializer. See FLINK-6025 for details.\n \t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \n \t\t\t// Add default serializers first, so that they type registrations without a serializer\n \t\t\t// are registered with a default serializer\n \t\t\tfor (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> entry: defaultSerializers.entrySet()) {\n \t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n \t\t\t}\n \n \t\t\tfor (Map.Entry<Class<?>, Class<? extends Serializer<?>>> entry: defaultSerializerClasses.entrySet()) {\n \t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n \t\t\t}\n \n \t\t\t// register the type of our class\n \t\t\tkryo.register(type);\n \n \t\t\t// register given types. we do this first so that any registration of a\n \t\t\t// more specific serializer overrides this\n \t\t\tfor (Class<?> type : registeredTypes) {\n \t\t\t\tkryo.register(type);\n \t\t\t}\n \n \t\t\t// register given serializer classes\n \t\t\tfor (Map.Entry<Class<?>, Class<? extends Serializer<?>>> e : registeredTypesWithSerializerClasses.entrySet()) {\n \t\t\t\tClass<?> typeClass = e.getKey();\n \t\t\t\tClass<? extends Serializer<?>> serializerClass = e.getValue();\n \n \t\t\t\tSerializer<?> serializer =\n \t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n \t\t\t\tkryo.register(typeClass, serializer);\n \t\t\t}\n \n \t\t\t// register given serializers\n \t\t\tfor (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> e : registeredTypesWithSerializers.entrySet()) {\n \t\t\t\tkryo.register(e.getKey(), e.getValue().getSerializer());\n \t\t\t}\n \t\t\t// this is needed for Avro but can not be added on demand.\n \t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n \n \t\t\tkryo.setRegistrationRequired(false);\n \t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dc78a7470a5da086a08140b200a20d840460ef79": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-3762] [core] Enable Kryo reference tracking\n\nThis closes #1891\n",
			"commitDate": "2016-04-15, 11:38 AM",
			"commitName": "dc78a7470a5da086a08140b200a20d840460ef79",
			"commitAuthor": "Andrew Palumbo",
			"commitDateOld": "2016-04-15, 11:38 AM",
			"commitNameOld": "760a0d9e7fd9fa88e9f7408b137d78df384d764f",
			"commitAuthorOld": "Stephan Ewen",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,51 +1,50 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo == null) {\n \t\t\tthis.kryo = getKryoInstance();\n \n-\t\t\t// disable reference tracking. reference tracking is costly, usually unnecessary, and\n-\t\t\t// inconsistent with Flink's own serialization (which does not do reference tracking)\n-\t\t\tkryo.setReferences(false);\n+\t\t\t// Enable reference tracking. \n+\t\t\tkryo.setReferences(true);\n \t\t\t\n \t\t\t// Throwable and all subclasses should be serialized via java serialization\n \t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \n \t\t\t// Add default serializers first, so that they type registrations without a serializer\n \t\t\t// are registered with a default serializer\n \t\t\tfor (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> entry: defaultSerializers.entrySet()) {\n \t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n \t\t\t}\n \n \t\t\tfor (Map.Entry<Class<?>, Class<? extends Serializer<?>>> entry: defaultSerializerClasses.entrySet()) {\n \t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n \t\t\t}\n \n \t\t\t// register the type of our class\n \t\t\tkryo.register(type);\n \n \t\t\t// register given types. we do this first so that any registration of a\n \t\t\t// more specific serializer overrides this\n \t\t\tfor (Class<?> type : registeredTypes) {\n \t\t\t\tkryo.register(type);\n \t\t\t}\n \n \t\t\t// register given serializer classes\n \t\t\tfor (Map.Entry<Class<?>, Class<? extends Serializer<?>>> e : registeredTypesWithSerializerClasses.entrySet()) {\n \t\t\t\tClass<?> typeClass = e.getKey();\n \t\t\t\tClass<? extends Serializer<?>> serializerClass = e.getValue();\n \n \t\t\t\tSerializer<?> serializer =\n \t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n \t\t\t\tkryo.register(typeClass, serializer);\n \t\t\t}\n \n \t\t\t// register given serializers\n \t\t\tfor (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> e : registeredTypesWithSerializers.entrySet()) {\n \t\t\t\tkryo.register(e.getKey(), e.getValue().getSerializer());\n \t\t\t}\n \t\t\t// this is needed for Avro but can not be added on demand.\n \t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n \n \t\t\tkryo.setRegistrationRequired(false);\n \t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"21a715867d655bb61df9a9f7eef37e42b99e206a": {
			"type": "Yfilerename",
			"commitMessage": "[FLINK-3303] [core] Move all type utilities to flink-core\n",
			"commitDate": "2016-02-02, 8:55 AM",
			"commitName": "21a715867d655bb61df9a9f7eef37e42b99e206a",
			"commitAuthor": "Stephan Ewen",
			"commitDateOld": "2016-02-02, 8:55 AM",
			"commitNameOld": "7081836e0d640ee640687606bd73b6673d3f2a07",
			"commitAuthorOld": "Stephan Ewen",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java",
				"newPath": "flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java"
			}
		},
		"ed3810b1282dfba80d63b1f43a0c202925a3b11c": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-3267] Disable reference tracking in Kryo fallback serializer\n\nBefore this commit, Kryo runs extra logic to track and resolve repeated references to\nthe same object (similar as JavaSerialization)\n\nThis disables reference tracking because\n  - reference tracking is costly\n  - it is virtually always unnecessary in the datatypes used in Flink\n  - it is inconsistent with Flink's own serialization (which does not do reference tracking)\n  - it may have problems if elements are read in a different order than they are written.\n\nThis closes #1528\n",
			"commitDate": "2016-01-25, 7:07 AM",
			"commitName": "ed3810b1282dfba80d63b1f43a0c202925a3b11c",
			"commitAuthor": "Stephan Ewen",
			"commitDateOld": "2016-01-21, 8:22 AM",
			"commitNameOld": "85ad491af66ad7c19401296af66edff2d2e3d6a1",
			"commitAuthorOld": "Maximilian Michels",
			"daysBetweenCommits": 3.95,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,47 +1,51 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo == null) {\n \t\t\tthis.kryo = getKryoInstance();\n \n+\t\t\t// disable reference tracking. reference tracking is costly, usually unnecessary, and\n+\t\t\t// inconsistent with Flink's own serialization (which does not do reference tracking)\n+\t\t\tkryo.setReferences(false);\n+\t\t\t\n \t\t\t// Throwable and all subclasses should be serialized via java serialization\n \t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \n \t\t\t// Add default serializers first, so that they type registrations without a serializer\n \t\t\t// are registered with a default serializer\n \t\t\tfor (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> entry: defaultSerializers.entrySet()) {\n \t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n \t\t\t}\n \n \t\t\tfor (Map.Entry<Class<?>, Class<? extends Serializer<?>>> entry: defaultSerializerClasses.entrySet()) {\n \t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n \t\t\t}\n \n \t\t\t// register the type of our class\n \t\t\tkryo.register(type);\n \n \t\t\t// register given types. we do this first so that any registration of a\n \t\t\t// more specific serializer overrides this\n \t\t\tfor (Class<?> type : registeredTypes) {\n \t\t\t\tkryo.register(type);\n \t\t\t}\n \n \t\t\t// register given serializer classes\n \t\t\tfor (Map.Entry<Class<?>, Class<? extends Serializer<?>>> e : registeredTypesWithSerializerClasses.entrySet()) {\n \t\t\t\tClass<?> typeClass = e.getKey();\n \t\t\t\tClass<? extends Serializer<?>> serializerClass = e.getValue();\n \n \t\t\t\tSerializer<?> serializer =\n \t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n \t\t\t\tkryo.register(typeClass, serializer);\n \t\t\t}\n \n \t\t\t// register given serializers\n \t\t\tfor (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> e : registeredTypesWithSerializers.entrySet()) {\n \t\t\t\tkryo.register(e.getKey(), e.getValue().getSerializer());\n \t\t\t}\n \t\t\t// this is needed for Avro but can not be added on demand.\n \t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n \n \t\t\tkryo.setRegistrationRequired(false);\n \t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cd899f3be39c5f052a2a3e90771111d1a7df1d47": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-2972] [JavaAPI] Remove Chill dependency from flink-java.\n\nThis closes #1331\n",
			"commitDate": "2015-11-30, 12:31 PM",
			"commitName": "cd899f3be39c5f052a2a3e90771111d1a7df1d47",
			"commitAuthor": "Fabian Hueske",
			"commitDateOld": "2015-10-29, 3:18 AM",
			"commitNameOld": "b654e989b60c6607f5f5bf757130c86bd0facd8c",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 32.43,
			"commitsBetweenForRepo": 175,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,47 +1,47 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo == null) {\n-\t\t\tthis.kryo = new ScalaKryoInstantiator().newKryo();\n+\t\t\tthis.kryo = getKryoInstance();\n \n \t\t\t// Throwable and all subclasses should be serialized via java serialization\n \t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \n \t\t\t// Add default serializers first, so that they type registrations without a serializer\n \t\t\t// are registered with a default serializer\n \t\t\tfor (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> entry: defaultSerializers.entrySet()) {\n \t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n \t\t\t}\n \n \t\t\tfor (Map.Entry<Class<?>, Class<? extends Serializer<?>>> entry: defaultSerializerClasses.entrySet()) {\n \t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n \t\t\t}\n \n \t\t\t// register the type of our class\n \t\t\tkryo.register(type);\n \n \t\t\t// register given types. we do this first so that any registration of a\n \t\t\t// more specific serializer overrides this\n \t\t\tfor (Class<?> type : registeredTypes) {\n \t\t\t\tkryo.register(type);\n \t\t\t}\n \n \t\t\t// register given serializer classes\n \t\t\tfor (Map.Entry<Class<?>, Class<? extends Serializer<?>>> e : registeredTypesWithSerializerClasses.entrySet()) {\n \t\t\t\tClass<?> typeClass = e.getKey();\n \t\t\t\tClass<? extends Serializer<?>> serializerClass = e.getValue();\n \n \t\t\t\tSerializer<?> serializer =\n \t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n \t\t\t\tkryo.register(typeClass, serializer);\n \t\t\t}\n \n \t\t\t// register given serializers\n \t\t\tfor (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> e : registeredTypesWithSerializers.entrySet()) {\n \t\t\t\tkryo.register(e.getKey(), e.getValue().getSerializer());\n \t\t\t}\n \t\t\t// this is needed for Avro but can not be added on demand.\n \t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n \n \t\t\tkryo.setRegistrationRequired(false);\n \t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2cc5d98c690c1b1b1ff1f48628ca58b1b4f0c932": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-2665] [api] [runtime] Makes ExecutionConfig serializable by forcing Kryo serializers to be Serializable\n\nThis closes #1128\n\n-----\nClosing PR:\nThis closes #867\n",
			"commitDate": "2015-09-15, 4:33 AM",
			"commitName": "2cc5d98c690c1b1b1ff1f48628ca58b1b4f0c932",
			"commitAuthor": "Till Rohrmann",
			"commitDateOld": "2015-05-26, 3:44 AM",
			"commitNameOld": "ae446388b91ecc0f08887da19400395b96b32f6c",
			"commitAuthorOld": "Till Rohrmann",
			"daysBetweenCommits": 112.03,
			"commitsBetweenForRepo": 594,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,46 +1,47 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo == null) {\n \t\t\tthis.kryo = new ScalaKryoInstantiator().newKryo();\n \n \t\t\t// Throwable and all subclasses should be serialized via java serialization\n \t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \n \t\t\t// Add default serializers first, so that they type registrations without a serializer\n \t\t\t// are registered with a default serializer\n-\t\t\tfor(ExecutionConfig.Entry<Class<?>, Serializer<?>> serializer : defaultSerializers) {\n-\t\t\t\tkryo.addDefaultSerializer(serializer.getKey(), serializer.getValue());\n+\t\t\tfor (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> entry: defaultSerializers.entrySet()) {\n+\t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\n \t\t\t}\n-\t\t\tfor(ExecutionConfig.Entry<Class<?>, Class<? extends Serializer<?>>> serializer : defaultSerializerClasses) {\n-\t\t\t\tkryo.addDefaultSerializer(serializer.getKey(), serializer.getValue());\n+\n+\t\t\tfor (Map.Entry<Class<?>, Class<? extends Serializer<?>>> entry: defaultSerializerClasses.entrySet()) {\n+\t\t\t\tkryo.addDefaultSerializer(entry.getKey(), entry.getValue());\n \t\t\t}\n \n \t\t\t// register the type of our class\n \t\t\tkryo.register(type);\n \n \t\t\t// register given types. we do this first so that any registration of a\n \t\t\t// more specific serializer overrides this\n \t\t\tfor (Class<?> type : registeredTypes) {\n \t\t\t\tkryo.register(type);\n \t\t\t}\n \n \t\t\t// register given serializer classes\n-\t\t\tfor (ExecutionConfig.Entry<Class<?>, Class<? extends Serializer<?>>> e : registeredTypesWithSerializerClasses) {\n+\t\t\tfor (Map.Entry<Class<?>, Class<? extends Serializer<?>>> e : registeredTypesWithSerializerClasses.entrySet()) {\n \t\t\t\tClass<?> typeClass = e.getKey();\n \t\t\t\tClass<? extends Serializer<?>> serializerClass = e.getValue();\n \n \t\t\t\tSerializer<?> serializer =\n \t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n \t\t\t\tkryo.register(typeClass, serializer);\n \t\t\t}\n \n \t\t\t// register given serializers\n-\t\t\tfor (ExecutionConfig.Entry<Class<?>, Serializer<?>> e : registeredTypesWithSerializers) {\n-\t\t\t\tkryo.register(e.getKey(), e.getValue());\n+\t\t\tfor (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> e : registeredTypesWithSerializers.entrySet()) {\n+\t\t\t\tkryo.register(e.getKey(), e.getValue().getSerializer());\n \t\t\t}\n \t\t\t// this is needed for Avro but can not be added on demand.\n \t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n \n \t\t\tkryo.setRegistrationRequired(false);\n \t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"354efec0f9da0fa03ea9b337b02a1a2a03a9ac16": {
			"type": "Ymultichange(Yfilerename,Ybodychange)",
			"commitMessage": "[FLINK-1417] Automatically register types with Kryo\n",
			"commitDate": "2015-02-18, 7:52 AM",
			"commitName": "354efec0f9da0fa03ea9b337b02a1a2a03a9ac16",
			"commitAuthor": "Robert Metzger",
			"subchanges": [
				{
					"type": "Yfilerename",
					"commitMessage": "[FLINK-1417] Automatically register types with Kryo\n",
					"commitDate": "2015-02-18, 7:52 AM",
					"commitName": "354efec0f9da0fa03ea9b337b02a1a2a03a9ac16",
					"commitAuthor": "Robert Metzger",
					"commitDateOld": "2015-02-18, 7:52 AM",
					"commitNameOld": "5015ab490f89d384ac93752c22caf201ceb43776",
					"commitAuthorOld": "Aljoscha Krettek",
					"daysBetweenCommits": 0,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,35 +1,46 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo == null) {\n \t\t\tthis.kryo = new ScalaKryoInstantiator().newKryo();\n \n \t\t\t// Throwable and all subclasses should be serialized via java serialization\n \t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \n+\t\t\t// Add default serializers first, so that they type registrations without a serializer\n+\t\t\t// are registered with a default serializer\n+\t\t\tfor(ExecutionConfig.Entry<Class<?>, Serializer<?>> serializer : defaultSerializers) {\n+\t\t\t\tkryo.addDefaultSerializer(serializer.getKey(), serializer.getValue());\n+\t\t\t}\n+\t\t\tfor(ExecutionConfig.Entry<Class<?>, Class<? extends Serializer<?>>> serializer : defaultSerializerClasses) {\n+\t\t\t\tkryo.addDefaultSerializer(serializer.getKey(), serializer.getValue());\n+\t\t\t}\n+\n \t\t\t// register the type of our class\n \t\t\tkryo.register(type);\n-\t\t\t\n+\n \t\t\t// register given types. we do this first so that any registration of a\n \t\t\t// more specific serializer overrides this\n \t\t\tfor (Class<?> type : registeredTypes) {\n \t\t\t\tkryo.register(type);\n \t\t\t}\n-\t\t\t\n+\n \t\t\t// register given serializer classes\n-\t\t\tfor (Map.Entry<Class<?>, Class<? extends Serializer<?>>> e : registeredSerializersClasses.entrySet()) {\n+\t\t\tfor (ExecutionConfig.Entry<Class<?>, Class<? extends Serializer<?>>> e : registeredTypesWithSerializerClasses) {\n \t\t\t\tClass<?> typeClass = e.getKey();\n \t\t\t\tClass<? extends Serializer<?>> serializerClass = e.getValue();\n-\t\t\t\t\n-\t\t\t\tSerializer<?> serializer = \n+\n+\t\t\t\tSerializer<?> serializer =\n \t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n \t\t\t\tkryo.register(typeClass, serializer);\n \t\t\t}\n \n \t\t\t// register given serializers\n-\t\t\tfor (Map.Entry<Class<?>, Serializer<?>> e : registeredSerializers.entrySet()) {\n+\t\t\tfor (ExecutionConfig.Entry<Class<?>, Serializer<?>> e : registeredTypesWithSerializers) {\n \t\t\t\tkryo.register(e.getKey(), e.getValue());\n \t\t\t}\n-\t\t\t\n+\t\t\t// this is needed for Avro but can not be added on demand.\n+\t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n+\n \t\t\tkryo.setRegistrationRequired(false);\n \t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldPath": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/KryoSerializer.java",
						"newPath": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "[FLINK-1417] Automatically register types with Kryo\n",
					"commitDate": "2015-02-18, 7:52 AM",
					"commitName": "354efec0f9da0fa03ea9b337b02a1a2a03a9ac16",
					"commitAuthor": "Robert Metzger",
					"commitDateOld": "2015-02-18, 7:52 AM",
					"commitNameOld": "5015ab490f89d384ac93752c22caf201ceb43776",
					"commitAuthorOld": "Aljoscha Krettek",
					"daysBetweenCommits": 0,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,35 +1,46 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo == null) {\n \t\t\tthis.kryo = new ScalaKryoInstantiator().newKryo();\n \n \t\t\t// Throwable and all subclasses should be serialized via java serialization\n \t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \n+\t\t\t// Add default serializers first, so that they type registrations without a serializer\n+\t\t\t// are registered with a default serializer\n+\t\t\tfor(ExecutionConfig.Entry<Class<?>, Serializer<?>> serializer : defaultSerializers) {\n+\t\t\t\tkryo.addDefaultSerializer(serializer.getKey(), serializer.getValue());\n+\t\t\t}\n+\t\t\tfor(ExecutionConfig.Entry<Class<?>, Class<? extends Serializer<?>>> serializer : defaultSerializerClasses) {\n+\t\t\t\tkryo.addDefaultSerializer(serializer.getKey(), serializer.getValue());\n+\t\t\t}\n+\n \t\t\t// register the type of our class\n \t\t\tkryo.register(type);\n-\t\t\t\n+\n \t\t\t// register given types. we do this first so that any registration of a\n \t\t\t// more specific serializer overrides this\n \t\t\tfor (Class<?> type : registeredTypes) {\n \t\t\t\tkryo.register(type);\n \t\t\t}\n-\t\t\t\n+\n \t\t\t// register given serializer classes\n-\t\t\tfor (Map.Entry<Class<?>, Class<? extends Serializer<?>>> e : registeredSerializersClasses.entrySet()) {\n+\t\t\tfor (ExecutionConfig.Entry<Class<?>, Class<? extends Serializer<?>>> e : registeredTypesWithSerializerClasses) {\n \t\t\t\tClass<?> typeClass = e.getKey();\n \t\t\t\tClass<? extends Serializer<?>> serializerClass = e.getValue();\n-\t\t\t\t\n-\t\t\t\tSerializer<?> serializer = \n+\n+\t\t\t\tSerializer<?> serializer =\n \t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n \t\t\t\tkryo.register(typeClass, serializer);\n \t\t\t}\n \n \t\t\t// register given serializers\n-\t\t\tfor (Map.Entry<Class<?>, Serializer<?>> e : registeredSerializers.entrySet()) {\n+\t\t\tfor (ExecutionConfig.Entry<Class<?>, Serializer<?>> e : registeredTypesWithSerializers) {\n \t\t\t\tkryo.register(e.getKey(), e.getValue());\n \t\t\t}\n-\t\t\t\n+\t\t\t// this is needed for Avro but can not be added on demand.\n+\t\t\tkryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\n+\n \t\t\tkryo.setRegistrationRequired(false);\n \t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"a0b6af20beed6d12d0f33f6f58f323b20cc12961": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-1399] Fix kryo registration of types and make sure that tags are assigned for registered types.\n",
			"commitDate": "2015-01-18, 2:59 PM",
			"commitName": "a0b6af20beed6d12d0f33f6f58f323b20cc12961",
			"commitAuthor": "Stephan Ewen",
			"commitDateOld": "2015-01-18, 2:26 PM",
			"commitNameOld": "2d4ed15e8d2aa1a1fcd7001fccea2ee70cc8a8b0",
			"commitAuthorOld": "Aljoscha Krettek",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,19 +1,35 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo == null) {\n \t\t\tthis.kryo = new ScalaKryoInstantiator().newKryo();\n-\t\t\tthis.kryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \n-\t\t\tfor (Map.Entry<Class<?>, Serializer<?>> e: registeredSerializers.entrySet()) {\n-\t\t\t\tthis.kryo.addDefaultSerializer(e.getKey(), e.getValue());\n+\t\t\t// Throwable and all subclasses should be serialized via java serialization\n+\t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n+\n+\t\t\t// register the type of our class\n+\t\t\tkryo.register(type);\n+\t\t\t\n+\t\t\t// register given types. we do this first so that any registration of a\n+\t\t\t// more specific serializer overrides this\n+\t\t\tfor (Class<?> type : registeredTypes) {\n+\t\t\t\tkryo.register(type);\n+\t\t\t}\n+\t\t\t\n+\t\t\t// register given serializer classes\n+\t\t\tfor (Map.Entry<Class<?>, Class<? extends Serializer<?>>> e : registeredSerializersClasses.entrySet()) {\n+\t\t\t\tClass<?> typeClass = e.getKey();\n+\t\t\t\tClass<? extends Serializer<?>> serializerClass = e.getValue();\n+\t\t\t\t\n+\t\t\t\tSerializer<?> serializer = \n+\t\t\t\t\t\tReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\n+\t\t\t\tkryo.register(typeClass, serializer);\n \t\t\t}\n \n-\t\t\tfor (Map.Entry<Class<?>, Class<? extends Serializer<?>>> e: registeredSerializersClasses.entrySet()) {\n-\t\t\t\tthis.kryo.addDefaultSerializer(e.getKey(), e.getValue());\n+\t\t\t// register given serializers\n+\t\t\tfor (Map.Entry<Class<?>, Serializer<?>> e : registeredSerializers.entrySet()) {\n+\t\t\t\tkryo.register(e.getKey(), e.getValue());\n \t\t\t}\n-\n-\t\t\tthis.kryo.setRegistrationRequired(false);\n-\t\t\tthis.kryo.register(type);\n-\n-\t\t\tthis.kryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n+\t\t\t\n+\t\t\tkryo.setRegistrationRequired(false);\n+\t\t\tkryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2d4ed15e8d2aa1a1fcd7001fccea2ee70cc8a8b0": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-1399] Add support for registering Serializers with Kryo\n\nThis closes #305\n",
			"commitDate": "2015-01-18, 2:26 PM",
			"commitName": "2d4ed15e8d2aa1a1fcd7001fccea2ee70cc8a8b0",
			"commitAuthor": "Aljoscha Krettek",
			"commitDateOld": "2015-01-11, 1:09 PM",
			"commitNameOld": "8af6ef49fd84c309aeba0a3c8963ac83e0243c59",
			"commitAuthorOld": "Aljoscha Krettek",
			"daysBetweenCommits": 7.05,
			"commitsBetweenForRepo": 30,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,9 +1,19 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo == null) {\n \t\t\tthis.kryo = new ScalaKryoInstantiator().newKryo();\n \t\t\tthis.kryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n+\n+\t\t\tfor (Map.Entry<Class<?>, Serializer<?>> e: registeredSerializers.entrySet()) {\n+\t\t\t\tthis.kryo.addDefaultSerializer(e.getKey(), e.getValue());\n+\t\t\t}\n+\n+\t\t\tfor (Map.Entry<Class<?>, Class<? extends Serializer<?>>> e: registeredSerializersClasses.entrySet()) {\n+\t\t\t\tthis.kryo.addDefaultSerializer(e.getKey(), e.getValue());\n+\t\t\t}\n+\n \t\t\tthis.kryo.setRegistrationRequired(false);\n \t\t\tthis.kryo.register(type);\n+\n \t\t\tthis.kryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8af6ef49fd84c309aeba0a3c8963ac83e0243c59": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-1378] Add support for Throwables in KryoSerializer\n",
			"commitDate": "2015-01-11, 1:09 PM",
			"commitName": "8af6ef49fd84c309aeba0a3c8963ac83e0243c59",
			"commitAuthor": "Aljoscha Krettek",
			"commitDateOld": "2015-01-08, 4:38 AM",
			"commitNameOld": "19066b520435528e104a69ccf372f56811123ee3",
			"commitAuthorOld": "Stephan Ewen",
			"daysBetweenCommits": 3.35,
			"commitsBetweenForRepo": 17,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,8 +1,9 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo == null) {\n \t\t\tthis.kryo = new ScalaKryoInstantiator().newKryo();\n+\t\t\tthis.kryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \t\t\tthis.kryo.setRegistrationRequired(false);\n \t\t\tthis.kryo.register(type);\n \t\t\tthis.kryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a70aa67a0881afc5d66329d46fe536d7a0b89fa8": {
			"type": "Ybodychange",
			"commitMessage": "[FLINK-610] Replace Avro by Kryo as the GenericType serializer\n\nThe performance of data-intensive jobs using Kryo is probably going to be slow.\n\nSet correct classloader\n\ntry to use Kryo.copy() with fallback to serialization copy\n",
			"commitDate": "2014-12-17, 12:44 PM",
			"commitName": "a70aa67a0881afc5d66329d46fe536d7a0b89fa8",
			"commitAuthor": "Robert Metzger",
			"commitDateOld": "2014-10-31, 2:15 PM",
			"commitNameOld": "f5898a01e7877afa3df06223713db211708eaf9a",
			"commitAuthorOld": "Henry Saputra",
			"daysBetweenCommits": 46.98,
			"commitsBetweenForRepo": 219,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,7 +1,8 @@\n \tprivate void checkKryoInitialized() {\n \t\tif (this.kryo == null) {\n-\t\t\tthis.kryo = new Kryo();\n-\t\t\tthis.kryo.setAsmEnabled(true);\n+\t\t\tthis.kryo = new ScalaKryoInstantiator().newKryo();\n+\t\t\tthis.kryo.setRegistrationRequired(false);\n \t\t\tthis.kryo.register(type);\n+\t\t\tthis.kryo.setClassLoader(Thread.currentThread().getContextClassLoader());\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f5898a01e7877afa3df06223713db211708eaf9a": {
			"type": "Ymodifierchange",
			"commitMessage": "Another round to remove final modifier to private methods because it is not needed\n\nRemove final modifier to private methods because it is not needed.\nThose methods are final by default.\n\nAuthor: Henry Saputra <henry.saputra@gmail.com>\n\nCloses #168 from hsaputra/remove_final_privatemethods_1 and squashes the following commits:\n\n860b512 [Henry Saputra] Remove final modifier to private methods because it is not needed. It is final by default.\n",
			"commitDate": "2014-10-31, 2:15 PM",
			"commitName": "f5898a01e7877afa3df06223713db211708eaf9a",
			"commitAuthor": "Henry Saputra",
			"commitDateOld": "2014-09-30, 7:10 AM",
			"commitNameOld": "76d4a75e823c31a899f2143fb6be185b90e55532",
			"commitAuthorOld": "Stephan Ewen",
			"daysBetweenCommits": 31.3,
			"commitsBetweenForRepo": 123,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,7 +1,7 @@\n-\tprivate final void checkKryoInitialized() {\n+\tprivate void checkKryoInitialized() {\n \t\tif (this.kryo == null) {\n \t\t\tthis.kryo = new Kryo();\n \t\t\tthis.kryo.setAsmEnabled(true);\n \t\t\tthis.kryo.register(type);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[private, final]",
				"newValue": "[private]"
			}
		},
		"22203e75f8a0d193ce0187396d0b267e05e9b58e": {
			"type": "Yintroduced",
			"commitMessage": "[FLINK-610] Added KryoSerializer\n\nThis closes #74\n",
			"commitDate": "2014-09-02, 8:35 AM",
			"commitName": "22203e75f8a0d193ce0187396d0b267e05e9b58e",
			"commitAuthor": "Till Rohrmann"
		}
	},
	"sha": "9e936a5f8198b0059e9b5fba33163c2bbe3efbdd"
}