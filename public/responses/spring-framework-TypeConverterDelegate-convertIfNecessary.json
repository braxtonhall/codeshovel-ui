{
	"repo": "https://github.com/spring-projects/spring-framework.git",
	"file": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
	"method": {
		"longName": "public T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class<T> requiredType, TypeDescriptor typeDescriptor);",
		"startLine": 152,
		"methodName": "convertIfNecessary",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"f813712f5b413b354560cd7cc006352e9defa9a3": {
			"type": "Ymultichange(Ybodychange,Yparametermetachange)",
			"commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
			"commitDate": "2017-06-07, 5:19 AM",
			"commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
			"commitAuthor": "Juergen Hoeller",
			"subchanges": [
				{
					"type": "Ybodychange",
					"commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
					"commitDate": "2017-06-07, 5:19 AM",
					"commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
					"commitAuthor": "Juergen Hoeller",
					"commitDateOld": "2017-05-31, 12:42 PM",
					"commitNameOld": "1f28825f9da63a13aaf8940aadedcf81358dc506",
					"commitAuthorOld": "Sebastien Deleuze",
					"daysBetweenCommits": 6.69,
					"commitsBetweenForRepo": 26,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,162 +1,162 @@\n-\tpublic <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, Object newValue,\n-\t\t\t@Nullable Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n+\tpublic <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,\n+\t\t\t@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException conversionAttemptEx = null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tconversionAttemptEx = ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) &&\n \t\t\t\t\tconvertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementTypeDesc != null) {\n \t\t\t\t\tClass<?> elementType = elementTypeDesc.getType();\n \t\t\t\t\tif (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion = false;\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (Object.class == requiredType) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor<T> strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {\n \t\t\t\t\tconvertedValue = NumberUtils.convertNumberToTargetClass(\n \t\t\t\t\t\t\t(Number) convertedValue, (Class<Number>) requiredType);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// convertedValue == null\n \t\t\t\tif (requiredType == Optional.class) {\n \t\t\t\t\tconvertedValue = Optional.empty();\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (conversionAttemptEx != null) {\n \t\t\t\t\t// Original exception from former ConversionService call above...\n \t\t\t\t\tthrow conversionAttemptEx;\n \t\t\t\t}\n-\t\t\t\telse if (conversionService != null) {\n+\t\t\t\telse if (conversionService != null && typeDescriptor != null) {\n \t\t\t\t\t// ConversionService not tried before, probably custom editor found\n \t\t\t\t\t// but editor couldn't produce the required type...\n \t\t\t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type '\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"' to required type '\").append(ClassUtils.getQualifiedName(requiredType)).append(\"'\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type '\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"'\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (conversionAttemptEx != null) {\n \t\t\tif (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {\n \t\t\t\tthrow conversionAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				},
				{
					"type": "Yparametermetachange",
					"commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
					"commitDate": "2017-06-07, 5:19 AM",
					"commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
					"commitAuthor": "Juergen Hoeller",
					"commitDateOld": "2017-05-31, 12:42 PM",
					"commitNameOld": "1f28825f9da63a13aaf8940aadedcf81358dc506",
					"commitAuthorOld": "Sebastien Deleuze",
					"daysBetweenCommits": 6.69,
					"commitsBetweenForRepo": 26,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,162 +1,162 @@\n-\tpublic <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, Object newValue,\n-\t\t\t@Nullable Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n+\tpublic <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,\n+\t\t\t@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException conversionAttemptEx = null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tconversionAttemptEx = ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) &&\n \t\t\t\t\tconvertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementTypeDesc != null) {\n \t\t\t\t\tClass<?> elementType = elementTypeDesc.getType();\n \t\t\t\t\tif (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion = false;\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (Object.class == requiredType) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor<T> strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {\n \t\t\t\t\tconvertedValue = NumberUtils.convertNumberToTargetClass(\n \t\t\t\t\t\t\t(Number) convertedValue, (Class<Number>) requiredType);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// convertedValue == null\n \t\t\t\tif (requiredType == Optional.class) {\n \t\t\t\t\tconvertedValue = Optional.empty();\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (conversionAttemptEx != null) {\n \t\t\t\t\t// Original exception from former ConversionService call above...\n \t\t\t\t\tthrow conversionAttemptEx;\n \t\t\t\t}\n-\t\t\t\telse if (conversionService != null) {\n+\t\t\t\telse if (conversionService != null && typeDescriptor != null) {\n \t\t\t\t\t// ConversionService not tried before, probably custom editor found\n \t\t\t\t\t// but editor couldn't produce the required type...\n \t\t\t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type '\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"' to required type '\").append(ClassUtils.getQualifiedName(requiredType)).append(\"'\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type '\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"'\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (conversionAttemptEx != null) {\n \t\t\tif (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {\n \t\t\t\tthrow conversionAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[propertyName-String(annotations-@Nullable), oldValue-Object(annotations-@Nullable), newValue-Object, requiredType-Class<T>(annotations-@Nullable), typeDescriptor-TypeDescriptor]",
						"newValue": "[propertyName-String(annotations-@Nullable), oldValue-Object(annotations-@Nullable), newValue-Object(annotations-@Nullable), requiredType-Class<T>(annotations-@Nullable), typeDescriptor-TypeDescriptor(annotations-@Nullable)]"
					}
				}
			]
		},
		"1f28825f9da63a13aaf8940aadedcf81358dc506": {
			"type": "Yparametermetachange",
			"commitMessage": "Add more @Nullable parameters based on null usage\n\nIssue: SPR-15540\n",
			"commitDate": "2017-05-31, 12:42 PM",
			"commitName": "1f28825f9da63a13aaf8940aadedcf81358dc506",
			"commitAuthor": "Sebastien Deleuze",
			"commitDateOld": "2017-05-26, 11:57 PM",
			"commitNameOld": "87598f48e41d483745aba56cbf4e998c6f6d680c",
			"commitAuthorOld": "Sebastien Deleuze",
			"daysBetweenCommits": 4.53,
			"commitsBetweenForRepo": 16,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,162 +1,162 @@\n-\tpublic <T> T convertIfNecessary(String propertyName, @Nullable Object oldValue, Object newValue,\n+\tpublic <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, Object newValue,\n \t\t\t@Nullable Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException conversionAttemptEx = null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tconversionAttemptEx = ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) &&\n \t\t\t\t\tconvertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementTypeDesc != null) {\n \t\t\t\t\tClass<?> elementType = elementTypeDesc.getType();\n \t\t\t\t\tif (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion = false;\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (Object.class == requiredType) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor<T> strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {\n \t\t\t\t\tconvertedValue = NumberUtils.convertNumberToTargetClass(\n \t\t\t\t\t\t\t(Number) convertedValue, (Class<Number>) requiredType);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// convertedValue == null\n \t\t\t\tif (requiredType == Optional.class) {\n \t\t\t\t\tconvertedValue = Optional.empty();\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (conversionAttemptEx != null) {\n \t\t\t\t\t// Original exception from former ConversionService call above...\n \t\t\t\t\tthrow conversionAttemptEx;\n \t\t\t\t}\n \t\t\t\telse if (conversionService != null) {\n \t\t\t\t\t// ConversionService not tried before, probably custom editor found\n \t\t\t\t\t// but editor couldn't produce the required type...\n \t\t\t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type '\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"' to required type '\").append(ClassUtils.getQualifiedName(requiredType)).append(\"'\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type '\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"'\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (conversionAttemptEx != null) {\n \t\t\tif (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {\n \t\t\t\tthrow conversionAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[propertyName-String, oldValue-Object(annotations-@Nullable), newValue-Object, requiredType-Class<T>(annotations-@Nullable), typeDescriptor-TypeDescriptor]",
				"newValue": "[propertyName-String(annotations-@Nullable), oldValue-Object(annotations-@Nullable), newValue-Object, requiredType-Class<T>(annotations-@Nullable), typeDescriptor-TypeDescriptor]"
			}
		},
		"87598f48e41d483745aba56cbf4e998c6f6d680c": {
			"type": "Yparametermetachange",
			"commitMessage": "Introduce null-safety of Spring Framework API\n\nThis commit introduces 2 new @Nullable and @NonNullApi\nannotations that leverage JSR 305 (dormant but available via\nFindbugs jsr305 dependency and already used by libraries\nlike OkHttp) meta-annotations to specify explicitly\nnull-safety of Spring Framework parameters and return values.\n\nIn order to avoid adding too much annotations, the\ndefault is set at package level with @NonNullApi and\n@Nullable annotations are added when needed at parameter or\nreturn value level. These annotations are intended to be used\non Spring Framework itself but also by other Spring projects.\n\n@Nullable annotations have been introduced based on Javadoc\nand search of patterns like \"return null;\". It is expected that\nnullability of Spring Framework API will be polished with\ncomplementary commits.\n\nIn practice, this will make the whole Spring Framework API\nnull-safe for Kotlin projects (when KT-10942 will be fixed)\nsince Kotlin will be able to leverage these annotations to\nknow if a parameter or a return value is nullable or not. But\nthis is also useful for Java developers as well since IntelliJ\nIDEA, for example, also understands these annotations to\ngenerate warnings when unsafe nullable usages are detected.\n\nIssue: SPR-15540\n",
			"commitDate": "2017-05-26, 11:57 PM",
			"commitName": "87598f48e41d483745aba56cbf4e998c6f6d680c",
			"commitAuthor": "Sebastien Deleuze",
			"commitDateOld": "2016-10-28, 2:39 PM",
			"commitNameOld": "dc080cb1be4c35398d1d995c3bb8025ccfde6dea",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 210.39,
			"commitsBetweenForRepo": 1205,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,162 +1,162 @@\n-\tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n-\t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n+\tpublic <T> T convertIfNecessary(String propertyName, @Nullable Object oldValue, Object newValue,\n+\t\t\t@Nullable Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException conversionAttemptEx = null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tconversionAttemptEx = ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) &&\n \t\t\t\t\tconvertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementTypeDesc != null) {\n \t\t\t\t\tClass<?> elementType = elementTypeDesc.getType();\n \t\t\t\t\tif (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion = false;\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (Object.class == requiredType) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor<T> strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {\n \t\t\t\t\tconvertedValue = NumberUtils.convertNumberToTargetClass(\n \t\t\t\t\t\t\t(Number) convertedValue, (Class<Number>) requiredType);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// convertedValue == null\n \t\t\t\tif (requiredType == Optional.class) {\n \t\t\t\t\tconvertedValue = Optional.empty();\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (conversionAttemptEx != null) {\n \t\t\t\t\t// Original exception from former ConversionService call above...\n \t\t\t\t\tthrow conversionAttemptEx;\n \t\t\t\t}\n \t\t\t\telse if (conversionService != null) {\n \t\t\t\t\t// ConversionService not tried before, probably custom editor found\n \t\t\t\t\t// but editor couldn't produce the required type...\n \t\t\t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type '\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"' to required type '\").append(ClassUtils.getQualifiedName(requiredType)).append(\"'\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type '\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"'\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (conversionAttemptEx != null) {\n \t\t\tif (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {\n \t\t\t\tthrow conversionAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[propertyName-String, oldValue-Object, newValue-Object, requiredType-Class<T>, typeDescriptor-TypeDescriptor]",
				"newValue": "[propertyName-String, oldValue-Object(annotations-@Nullable), newValue-Object, requiredType-Class<T>(annotations-@Nullable), typeDescriptor-TypeDescriptor]"
			}
		},
		"dc080cb1be4c35398d1d995c3bb8025ccfde6dea": {
			"type": "Ybodychange",
			"commitMessage": "Revised NoSuchBeanDefinitionException message and ResolvableType handling\n\nIncludes consistent quoting of qualified type names in related classes.\n\nIssue: SPR-14831\n",
			"commitDate": "2016-10-28, 2:39 PM",
			"commitName": "dc080cb1be4c35398d1d995c3bb8025ccfde6dea",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2016-07-19, 10:21 AM",
			"commitNameOld": "aaac199e8bc1e037883f9fa8063828a82142d608",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 101.18,
			"commitsBetweenForRepo": 522,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,162 +1,162 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException conversionAttemptEx = null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tconversionAttemptEx = ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) &&\n \t\t\t\t\tconvertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementTypeDesc != null) {\n \t\t\t\t\tClass<?> elementType = elementTypeDesc.getType();\n \t\t\t\t\tif (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion = false;\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (Object.class == requiredType) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor<T> strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {\n \t\t\t\t\tconvertedValue = NumberUtils.convertNumberToTargetClass(\n \t\t\t\t\t\t\t(Number) convertedValue, (Class<Number>) requiredType);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// convertedValue == null\n \t\t\t\tif (requiredType == Optional.class) {\n \t\t\t\t\tconvertedValue = Optional.empty();\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (conversionAttemptEx != null) {\n \t\t\t\t\t// Original exception from former ConversionService call above...\n \t\t\t\t\tthrow conversionAttemptEx;\n \t\t\t\t}\n \t\t\t\telse if (conversionService != null) {\n \t\t\t\t\t// ConversionService not tried before, probably custom editor found\n \t\t\t\t\t// but editor couldn't produce the required type...\n \t\t\t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n-\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n-\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n+\t\t\t\tmsg.append(\"Cannot convert value of type '\").append(ClassUtils.getDescriptiveType(newValue));\n+\t\t\t\tmsg.append(\"' to required type '\").append(ClassUtils.getQualifiedName(requiredType)).append(\"'\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n-\t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n-\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n+\t\t\t\t\t\t\t\"] returned inappropriate value of type '\").append(\n+\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"'\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (conversionAttemptEx != null) {\n \t\t\tif (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {\n \t\t\t\tthrow conversionAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"51252ebbcaa9e65aee83311aec25ca3c7c6d7d37": {
			"type": "Ybodychange",
			"commitMessage": "Avoid defensive checks against Java 8 API (java.util.Optional etc)\n\nThis commit also fixes broken javadoc links and code references.\n\nIssue: SPR-13188\n",
			"commitDate": "2016-07-04, 5:09 PM",
			"commitName": "51252ebbcaa9e65aee83311aec25ca3c7c6d7d37",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2016-06-30, 5:02 AM",
			"commitNameOld": "c4c941c43fc23f58503c7b687fd1469d4a27c777",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 4.5,
			"commitsBetweenForRepo": 50,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,162 +1,162 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException conversionAttemptEx = null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tconversionAttemptEx = ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) &&\n \t\t\t\t\tconvertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementTypeDesc != null) {\n \t\t\t\t\tClass<?> elementType = elementTypeDesc.getType();\n \t\t\t\t\tif (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion = false;\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (Object.class == requiredType) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor<T> strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {\n \t\t\t\t\tconvertedValue = NumberUtils.convertNumberToTargetClass(\n \t\t\t\t\t\t\t(Number) convertedValue, (Class<Number>) requiredType);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// convertedValue == null\n-\t\t\t\tif (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n-\t\t\t\t\tconvertedValue = javaUtilOptionalEmpty;\n+\t\t\t\tif (requiredType == Optional.class) {\n+\t\t\t\t\tconvertedValue = Optional.empty();\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (conversionAttemptEx != null) {\n \t\t\t\t\t// Original exception from former ConversionService call above...\n \t\t\t\t\tthrow conversionAttemptEx;\n \t\t\t\t}\n \t\t\t\telse if (conversionService != null) {\n \t\t\t\t\t// ConversionService not tried before, probably custom editor found\n \t\t\t\t\t// but editor couldn't produce the required type...\n \t\t\t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (conversionAttemptEx != null) {\n \t\t\tif (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {\n \t\t\t\tthrow conversionAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c4c941c43fc23f58503c7b687fd1469d4a27c777": {
			"type": "Ybodychange",
			"commitMessage": "Convert comma-separated string into list of classes analogous to existing support for class array\n\nIssue: SPR-14415\n",
			"commitDate": "2016-06-30, 5:02 AM",
			"commitName": "c4c941c43fc23f58503c7b687fd1469d4a27c777",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2015-08-31, 8:20 AM",
			"commitNameOld": "d4a23b81e9e49a6e9cc871d8bb1accc70c6444df",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 303.86,
			"commitsBetweenForRepo": 1195,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,158 +1,162 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException conversionAttemptEx = null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tconversionAttemptEx = ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n-\t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n-\t\t\t\tTypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n-\t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n-\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n+\t\t\tif (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) &&\n+\t\t\t\t\tconvertedValue instanceof String) {\n+\t\t\t\tTypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor();\n+\t\t\t\tif (elementTypeDesc != null) {\n+\t\t\t\t\tClass<?> elementType = elementTypeDesc.getType();\n+\t\t\t\t\tif (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {\n+\t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion = false;\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (Object.class == requiredType) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor<T> strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {\n \t\t\t\t\tconvertedValue = NumberUtils.convertNumberToTargetClass(\n \t\t\t\t\t\t\t(Number) convertedValue, (Class<Number>) requiredType);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// convertedValue == null\n \t\t\t\tif (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n \t\t\t\t\tconvertedValue = javaUtilOptionalEmpty;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (conversionAttemptEx != null) {\n \t\t\t\t\t// Original exception from former ConversionService call above...\n \t\t\t\t\tthrow conversionAttemptEx;\n \t\t\t\t}\n \t\t\t\telse if (conversionService != null) {\n \t\t\t\t\t// ConversionService not tried before, probably custom editor found\n \t\t\t\t\t// but editor couldn't produce the required type...\n \t\t\t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (conversionAttemptEx != null) {\n \t\t\tif (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {\n \t\t\t\tthrow conversionAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c": {
			"type": "Ybodychange",
			"commitMessage": "Class identity comparisons wherever possible\n\nIssue: SPR-12926\n",
			"commitDate": "2015-05-20, 5:34 AM",
			"commitName": "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2015-05-18, 2:53 PM",
			"commitNameOld": "6418b54f81a9e56242fb78fda4bf95e7b3d4c572",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 1.61,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,158 +1,158 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException conversionAttemptEx = null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tconversionAttemptEx = ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion = false;\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n-\t\t\t\tif (Object.class.equals(requiredType)) {\n+\t\t\t\tif (Object.class == requiredType) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n-\t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n+\t\t\t\tif (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor<T> strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {\n \t\t\t\t\tconvertedValue = NumberUtils.convertNumberToTargetClass(\n \t\t\t\t\t\t\t(Number) convertedValue, (Class<Number>) requiredType);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// convertedValue == null\n \t\t\t\tif (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n \t\t\t\t\tconvertedValue = javaUtilOptionalEmpty;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (conversionAttemptEx != null) {\n \t\t\t\t\t// Original exception from former ConversionService call above...\n \t\t\t\t\tthrow conversionAttemptEx;\n \t\t\t\t}\n \t\t\t\telse if (conversionService != null) {\n \t\t\t\t\t// ConversionService not tried before, probably custom editor found\n \t\t\t\t\t// but editor couldn't produce the required type...\n \t\t\t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (conversionAttemptEx != null) {\n-\t\t\tif (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {\n+\t\t\tif (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {\n \t\t\t\tthrow conversionAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6418b54f81a9e56242fb78fda4bf95e7b3d4c572": {
			"type": "Ybodychange",
			"commitMessage": "DataBinder tries ConversionService if PropertyEditor could not produce required type\n\nIssue: SPR-13042\n",
			"commitDate": "2015-05-18, 2:53 PM",
			"commitName": "6418b54f81a9e56242fb78fda4bf95e7b3d4c572",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2015-05-12, 1:33 PM",
			"commitNameOld": "02da2e85ee0e58202b90d11c126e6050abe184b4",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 6.06,
			"commitsBetweenForRepo": 39,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,149 +1,158 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n-\t\tObject convertedValue = newValue;\n-\n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n-\t\tConversionFailedException firstAttemptEx = null;\n+\t\tConversionFailedException conversionAttemptEx = null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n-\t\tif (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n+\t\tif (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n-\t\t\tTypeDescriptor targetTypeDesc = typeDescriptor;\n-\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n+\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\ttry {\n-\t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n+\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n-\t\t\t\t\tfirstAttemptEx = ex;\n+\t\t\t\t\tconversionAttemptEx = ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n+\t\tObject convertedValue = newValue;\n+\n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion = false;\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (Object.class.equals(requiredType)) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n-\t\t\t\t\tif (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n+\t\t\t\t\tif (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor<T> strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {\n \t\t\t\t\tconvertedValue = NumberUtils.convertNumberToTargetClass(\n \t\t\t\t\t\t\t(Number) convertedValue, (Class<Number>) requiredType);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// convertedValue == null\n \t\t\t\tif (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n \t\t\t\t\tconvertedValue = javaUtilOptionalEmpty;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n-\t\t\t\tif (firstAttemptEx != null) {\n-\t\t\t\t\tthrow firstAttemptEx;\n+\t\t\t\tif (conversionAttemptEx != null) {\n+\t\t\t\t\t// Original exception from former ConversionService call above...\n+\t\t\t\t\tthrow conversionAttemptEx;\n \t\t\t\t}\n+\t\t\t\telse if (conversionService != null) {\n+\t\t\t\t\t// ConversionService not tried before, probably custom editor found\n+\t\t\t\t\t// but editor couldn't produce the required type...\n+\t\t\t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n+\t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n+\t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\tif (firstAttemptEx != null) {\n+\t\tif (conversionAttemptEx != null) {\n \t\t\tif (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {\n-\t\t\t\tthrow firstAttemptEx;\n+\t\t\t\tthrow conversionAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n-\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n+\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"02da2e85ee0e58202b90d11c126e6050abe184b4": {
			"type": "Ybodychange",
			"commitMessage": "DataBinder allows for adding custom Formatters as alternative to PropertyEditors (including per-field formatters)\n\nIncludes a generic FormatterPropertyEditorAdapter plus Number conversion support in TypeConverterDelegate.\n\nIssue: SPR-7773\nIssue: SPR-6069\n",
			"commitDate": "2015-05-12, 1:33 PM",
			"commitName": "02da2e85ee0e58202b90d11c126e6050abe184b4",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2014-07-18, 8:21 AM",
			"commitNameOld": "9d6c38bd54fe8931ee73fbb7a076625deb934e28",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 298.22,
			"commitsBetweenForRepo": 1341,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,144 +1,149 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException firstAttemptEx = null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc = typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tfirstAttemptEx = ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion = false;\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (Object.class.equals(requiredType)) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n-\t\t\t\tif (requiredType.isArray()) {\n+\t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor<T> strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n+\t\t\t\telse if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {\n+\t\t\t\t\tconvertedValue = NumberUtils.convertNumberToTargetClass(\n+\t\t\t\t\t\t\t(Number) convertedValue, (Class<Number>) requiredType);\n+\t\t\t\t\tstandardConversion = true;\n+\t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// convertedValue == null\n \t\t\t\tif (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n \t\t\t\t\tconvertedValue = javaUtilOptionalEmpty;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (firstAttemptEx != null) {\n \t\t\t\t\tthrow firstAttemptEx;\n \t\t\t\t}\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (firstAttemptEx != null) {\n \t\t\tif (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {\n \t\t\t\tthrow firstAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"bc1f19ce18e9ad35d8127048737d6e6e9c276eb3": {
			"type": "Ybodychange",
			"commitMessage": "Defensively check javaUtilOptionalEmpty\n\nIssue: SPR-11888\n",
			"commitDate": "2014-06-19, 12:14 PM",
			"commitName": "bc1f19ce18e9ad35d8127048737d6e6e9c276eb3",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2014-06-16, 11:16 AM",
			"commitNameOld": "0dc6082b01606c3c996b728541467ba5104b747f",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 3.04,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,141 +1,144 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException firstAttemptEx = null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc = typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tfirstAttemptEx = ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion = false;\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (Object.class.equals(requiredType)) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor<T> strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t}\n-\t\t\telse if (requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n-\t\t\t\tconvertedValue = javaUtilOptionalEmpty;\n+\t\t\telse {\n+\t\t\t\t// convertedValue == null\n+\t\t\t\tif (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n+\t\t\t\t\tconvertedValue = javaUtilOptionalEmpty;\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (firstAttemptEx != null) {\n \t\t\t\t\tthrow firstAttemptEx;\n \t\t\t\t}\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (firstAttemptEx != null) {\n \t\t\tif (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {\n \t\t\t\tthrow firstAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0dc6082b01606c3c996b728541467ba5104b747f": {
			"type": "Ybodychange",
			"commitMessage": "Support java.util.Optional for @MVC named value args\n\nAfter this change, java.util.Optional is supported with @RequestParam,\n@RequestHeader, and @MatrixVariable arguments in Java 8. When Optional\nis used the required flag is effectively ignored.\n\nIssue: SPR-11829\n",
			"commitDate": "2014-06-16, 11:16 AM",
			"commitName": "0dc6082b01606c3c996b728541467ba5104b747f",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2014-04-27, 3:47 PM",
			"commitNameOld": "6cb45f714e8d4b6b38501ed6356ced59362d8df2",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 49.81,
			"commitsBetweenForRepo": 199,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,138 +1,141 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException firstAttemptEx = null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc = typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tfirstAttemptEx = ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion = false;\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (Object.class.equals(requiredType)) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor<T> strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t}\n+\t\t\telse if (requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n+\t\t\t\tconvertedValue = javaUtilOptionalEmpty;\n+\t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (firstAttemptEx != null) {\n \t\t\t\t\tthrow firstAttemptEx;\n \t\t\t\t}\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (firstAttemptEx != null) {\n \t\t\tif (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {\n \t\t\t\tthrow firstAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"59002f245623d758765b72d598cd78c326c6f5fa": {
			"type": "Ybodychange",
			"commitMessage": "Fix remaining compiler warnings\n\nFix remaining Java compiler warnings, mainly around missing\ngenerics or deprecated code.\n\nAlso add the `-Werror` compiler option to ensure that any future\nwarnings will fail the build.\n\nIssue: SPR-11064\n",
			"commitDate": "2013-11-25, 12:52 PM",
			"commitName": "59002f245623d758765b72d598cd78c326c6f5fa",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2013-10-18, 5:19 PM",
			"commitNameOld": "c9aace4da215330c1aa552fa1dcdd79748249774",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 37.86,
			"commitsBetweenForRepo": 188,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,138 +1,138 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException firstAttemptEx = null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc = typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tfirstAttemptEx = ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion = false;\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (Object.class.equals(requiredType)) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n-\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n+\t\t\t\t\t\t\t(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n-\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n+\t\t\t\t\t\t\t(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n-\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n+\t\t\t\t\t\t\tConstructor<T> strCtor = requiredType.getConstructor(String.class);\n+\t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (firstAttemptEx != null) {\n \t\t\t\t\tthrow firstAttemptEx;\n \t\t\t\t}\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (firstAttemptEx != null) {\n \t\t\tif (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {\n \t\t\t\tthrow firstAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c9aace4da215330c1aa552fa1dcdd79748249774": {
			"type": "Ybodychange",
			"commitMessage": "Skip convert to Object from TypeConverterDelegate\n\nUpdate TypeConverterDelegate to bypass conversion when the target type\nis Object.class. Prior to this commit converting a single element array\nto an Object would result in the element being returned, rather than\nthe array itself.\n\nIssue: SPR-10996\n",
			"commitDate": "2013-10-18, 5:19 PM",
			"commitName": "c9aace4da215330c1aa552fa1dcdd79748249774",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2013-05-03, 2:49 AM",
			"commitNameOld": "61c3f3d9fdf617097f121d26053f0d24ae621f08",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 168.6,
			"commitsBetweenForRepo": 608,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,135 +1,138 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException firstAttemptEx = null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc = typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tfirstAttemptEx = ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion = false;\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n+\t\t\t\tif (Object.class.equals(requiredType)) {\n+\t\t\t\t\treturn (T) convertedValue;\n+\t\t\t\t}\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (firstAttemptEx != null) {\n \t\t\t\t\tthrow firstAttemptEx;\n \t\t\t\t}\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (firstAttemptEx != null) {\n \t\t\tif (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {\n \t\t\t\tthrow firstAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ff7dcec5f7d2b54324476bd617af74de9cbd56ec": {
			"type": "Ybodychange",
			"commitMessage": "BeanWrapper does not fall back to String constructor if ConversionService attempt failed before\n\nIssue: SPR-9865\n",
			"commitDate": "2012-10-12, 2:34 PM",
			"commitName": "ff7dcec5f7d2b54324476bd617af74de9cbd56ec",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2012-09-04, 3:59 PM",
			"commitNameOld": "6bce09831060430b00e6ed93785c7d40ac8529a8",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 37.94,
			"commitsBetweenForRepo": 115,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,136 +1,135 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException firstAttemptEx = null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc = typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tfirstAttemptEx = ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion = false;\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n-\t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n+\t\t\t\t\tif (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n-\t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (firstAttemptEx != null) {\n \t\t\t\t\tthrow firstAttemptEx;\n \t\t\t\t}\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (firstAttemptEx != null) {\n \t\t\tif (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {\n \t\t\t\tthrow firstAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6bce09831060430b00e6ed93785c7d40ac8529a8": {
			"type": "Ybodychange",
			"commitMessage": "refined TypeConverterDelegate's ConversionService exception handling\n\nIssue: SPR-9498\n",
			"commitDate": "2012-09-04, 3:59 PM",
			"commitName": "6bce09831060430b00e6ed93785c7d40ac8529a8",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2012-09-04, 1:36 PM",
			"commitNameOld": "e904589bd1f910b095acdd1fb760a76ab84e8e54",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 0.1,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,131 +1,136 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException firstAttemptEx = null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc = typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tfirstAttemptEx = ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n-\t\t\t\teditor = findDefaultEditor(requiredType, typeDescriptor);\n+\t\t\t\teditor = findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n+\t\tboolean standardConversion = false;\n+\n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n+\t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n+\t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n+\t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n+\t\t\t\t\tstandardConversion = true;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (firstAttemptEx != null) {\n \t\t\t\t\tthrow firstAttemptEx;\n \t\t\t\t}\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (firstAttemptEx != null) {\n-\t\t\tif (editor == null && convertedValue == newValue && requiredType != null &&\n-\t\t\t\t\t!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n+\t\t\tif (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {\n \t\t\t\tthrow firstAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8e754e9065b5703f93909f480933488a2b180429": {
			"type": "Ybodychange",
			"commitMessage": "SPR-9498: don't make assumptions about equality if ConversionService has failed\n\nThe failure of the conversion service is not fatal, but the check that\nwas in there (line 248) was inadequate to detect the cases that could\nalready be handled by the default property editors.  This code path\nwas also not tested anywhere in spring-beans tests until now.\n",
			"commitDate": "2012-06-14, 3:40 AM",
			"commitName": "8e754e9065b5703f93909f480933488a2b180429",
			"commitAuthor": "Dave Syer",
			"commitDateOld": "2012-01-31, 5:37 AM",
			"commitNameOld": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 134.88,
			"commitsBetweenForRepo": 260,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,130 +1,130 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException firstAttemptEx = null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc = typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tfirstAttemptEx = ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (firstAttemptEx != null) {\n \t\t\t\t\tthrow firstAttemptEx;\n \t\t\t\t}\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (firstAttemptEx != null) {\n-\t\t\tif (editor == null && convertedValue == newValue) {\n+\t\t\tif (editor == null && convertedValue == newValue && requiredType!=null && !ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tthrow firstAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"02a4473c62d8240837bec297f0a1f3cb67ef8a7b": {
			"type": "Yfilerename",
			"commitMessage": "Rename modules {org.springframework.*=>spring-*}\n\nThis renaming more intuitively expresses the relationship between\nsubprojects and the JAR artifacts they produce.\n\nTracking history across these renames is possible, but it requires\nuse of the --follow flag to `git log`, for example\n\n    $ git log spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history up until the renaming event, where\n\n    $ git log --follow spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history for all changes to the file, before and after the\nrenaming.\n\nSee http://chrisbeams.com/git-diff-across-renamed-directories\n",
			"commitDate": "2012-01-31, 5:37 AM",
			"commitName": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2012-01-31, 5:37 AM",
			"commitNameOld": "b6cb514d383dcef52ba6c609a863f19e1a4c1faf",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
				"newPath": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java"
			}
		},
		"d331c5d1c99a2cb6d6932c98b96433e6f9c62c79": {
			"type": "Ybodychange",
			"commitMessage": "correctly handle ParseException from Formatter for String->String case (SPR-8944)\n",
			"commitDate": "2011-12-22, 7:30 AM",
			"commitName": "d331c5d1c99a2cb6d6932c98b96433e6f9c62c79",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2011-12-22, 6:54 AM",
			"commitNameOld": "86bef9030fa4e026107db74cd9eef288beb1beca",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,130 +1,130 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException firstAttemptEx = null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc = typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tfirstAttemptEx = ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (firstAttemptEx != null) {\n \t\t\t\t\tthrow firstAttemptEx;\n \t\t\t\t}\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (firstAttemptEx != null) {\n-\t\t\tif (editor == null) {\n+\t\t\tif (editor == null && convertedValue == newValue) {\n \t\t\t\tthrow firstAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"86bef9030fa4e026107db74cd9eef288beb1beca": {
			"type": "Ybodychange",
			"commitMessage": "correctly handle ParseException from Formatter for String->String case (SPR-8944)\n",
			"commitDate": "2011-12-22, 6:54 AM",
			"commitName": "86bef9030fa4e026107db74cd9eef288beb1beca",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2011-12-03, 7:57 AM",
			"commitNameOld": "84be348cb0ac99896674170dc9f99021b43ba9ee",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 18.96,
			"commitsBetweenForRepo": 97,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,127 +1,130 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException firstAttemptEx = null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc = typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tfirstAttemptEx = ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (firstAttemptEx != null) {\n \t\t\t\t\tthrow firstAttemptEx;\n \t\t\t\t}\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (firstAttemptEx != null) {\n+\t\t\tif (editor == null) {\n+\t\t\t\tthrow firstAttemptEx;\n+\t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"84be348cb0ac99896674170dc9f99021b43ba9ee": {
			"type": "Ybodychange",
			"commitMessage": "log or rethrow original ConversionFailedException as appropriate\n",
			"commitDate": "2011-12-03, 7:57 AM",
			"commitName": "84be348cb0ac99896674170dc9f99021b43ba9ee",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2011-07-04, 2:43 AM",
			"commitNameOld": "57998293c811067cf87e6933f7abb4d4edb677c1",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 152.26,
			"commitsBetweenForRepo": 515,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,115 +1,127 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n+\t\tConversionFailedException firstAttemptEx = null;\n+\n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc = typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n-\t\t\t\t} catch (ConversionFailedException e) {\n+\t\t\t\t}\n+\t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n+\t\t\t\t\tfirstAttemptEx = ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n+\t\t\t\tif (firstAttemptEx != null) {\n+\t\t\t\t\tthrow firstAttemptEx;\n+\t\t\t\t}\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n+\t\tif (firstAttemptEx != null) {\n+\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n+\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n+\t\t}\n+\n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f288060ad8f0d007f1541213130d006729b9ec40": {
			"type": "Ybodychange",
			"commitMessage": "restored support for String-to-ContextResource conversion (SPR-8383)\n",
			"commitDate": "2011-06-15, 8:40 AM",
			"commitName": "f288060ad8f0d007f1541213130d006729b9ec40",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2011-06-06, 7:51 PM",
			"commitNameOld": "5e3a5202fbd17cd30607ca7bb5360c9db8197e75",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 8.53,
			"commitsBetweenForRepo": 61,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,114 +1,115 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc = typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t} catch (ConversionFailedException e) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n-\t\t\t\t\t\t\t\"] returned inappropriate value\");\n+\t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n+\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5e3a5202fbd17cd30607ca7bb5360c9db8197e75": {
			"type": "Ybodychange",
			"commitMessage": "restored TypeDescriptor getElementType, getMapKeyType, and getMapValueType compatibility; StringToCollection and Array Converters are now conditional and check targetElementType if present; TypeDesciptor#isAssignable no longer bothers with element type and map key/value types in checking assignability for consistency elsewhere; improved javadoc\n",
			"commitDate": "2011-06-06, 7:51 PM",
			"commitName": "5e3a5202fbd17cd30607ca7bb5360c9db8197e75",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2011-06-05, 10:52 AM",
			"commitNameOld": "8c6890605a7080e2744be3f3994757cc72e394b0",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 1.37,
			"commitsBetweenForRepo": 19,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,114 +1,114 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc = typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t} catch (ConversionFailedException e) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n-\t\t\t\tTypeDescriptor elementType = typeDescriptor.getElementType();\n+\t\t\t\tTypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8c6890605a7080e2744be3f3994757cc72e394b0": {
			"type": "Ybodychange",
			"commitMessage": "null type descriptor handling\n",
			"commitDate": "2011-06-05, 10:52 AM",
			"commitName": "8c6890605a7080e2744be3f3994757cc72e394b0",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2011-06-04, 11:04 PM",
			"commitNameOld": "2127b160512911e5f65a4e304f0b57826710a91d",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 0.49,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,114 +1,114 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n-\t\tif (editor == null && conversionService != null && convertedValue != null) {\n+\t\tif (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc = typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t} catch (ConversionFailedException e) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType = typeDescriptor.getElementType();\n \t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2127b160512911e5f65a4e304f0b57826710a91d": {
			"type": "Ybodychange",
			"commitMessage": "catch ConversionFailedException and fallback to default container conversion logic rather than propogate exception\n",
			"commitDate": "2011-06-04, 11:04 PM",
			"commitName": "2127b160512911e5f65a4e304f0b57826710a91d",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2011-06-04, 10:46 PM",
			"commitNameOld": "c306afed63e439ee133872a49380d76064bd2638",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,110 +1,114 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc = typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n-\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n+\t\t\t\ttry {\n+\t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n+\t\t\t\t} catch (ConversionFailedException e) {\n+\t\t\t\t\t// fallback to default conversion logic below\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType = typeDescriptor.getElementType();\n \t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c306afed63e439ee133872a49380d76064bd2638": {
			"type": "Ybodychange",
			"commitMessage": "polishing\n",
			"commitDate": "2011-06-04, 10:46 PM",
			"commitName": "c306afed63e439ee133872a49380d76064bd2638",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2011-06-04, 9:43 PM",
			"commitNameOld": "c84cccf06dad4e3f11cd529ab16a5655bf723820",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,110 +1,110 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null) {\n-\t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(convertedValue);\n+\t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc = typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType = typeDescriptor.getElementType();\n \t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c84cccf06dad4e3f11cd529ab16a5655bf723820": {
			"type": "Ybodychange",
			"commitMessage": "revised TypeDescriptor NULL and element/mapKey/mapValue type semantics\n",
			"commitDate": "2011-06-04, 9:43 PM",
			"commitName": "c84cccf06dad4e3f11cd529ab16a5655bf723820",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2011-06-02, 4:37 PM",
			"commitNameOld": "6f146737f475828b6d765784017773378c2c4922",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 2.21,
			"commitsBetweenForRepo": 26,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,110 +1,110 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(convertedValue);\n \t\t\tTypeDescriptor targetTypeDesc = typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n-\t\t\t\tClass elemType = typeDescriptor.getElementType();\n-\t\t\t\tif (elemType != null && Enum.class.isAssignableFrom(elemType)) {\n+\t\t\t\tTypeDescriptor elementType = typeDescriptor.getElementType();\n+\t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6f146737f475828b6d765784017773378c2c4922": {
			"type": "Ybodychange",
			"commitMessage": "simplified TypeDescriptor usage and updated use of the API across BeanWrapper and SpEL; collapsed PropertyTypeDescriptor into TypeDescriptor for simplicity and ease of use; improved docs\n",
			"commitDate": "2011-06-02, 4:37 PM",
			"commitName": "6f146737f475828b6d765784017773378c2c4922",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2011-01-04, 9:49 PM",
			"commitNameOld": "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 148.74,
			"commitsBetweenForRepo": 438,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,111 +1,110 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(convertedValue);\n \t\t\tTypeDescriptor targetTypeDesc = typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n-\t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) &&\n-\t\t\t\t\tconvertedValue instanceof String && typeDescriptor.getMethodParameter() != null) {\n-\t\t\t\tClass elemType = GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n+\t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {\n+\t\t\t\tClass elemType = typeDescriptor.getElementType();\n \t\t\t\tif (elemType != null && Enum.class.isAssignableFrom(elemType)) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6": {
			"type": "Ybodychange",
			"commitMessage": "TypeDescriptor cleanup and general polishing; fixed a number of bugs related to TypeDescriptor usage in client code across beans and spel packages\n",
			"commitDate": "2011-01-04, 9:49 PM",
			"commitName": "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2010-06-23, 1:05 PM",
			"commitNameOld": "942c656970df903705417b0b9631b2dd66e3bff0",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 195.41,
			"commitsBetweenForRepo": 382,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,111 +1,111 @@\n \tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(convertedValue);\n-\t\t\tTypeDescriptor targetTypeDesc = typeDescriptor.forElementType(requiredType);\n+\t\t\tTypeDescriptor targetTypeDesc = typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) &&\n \t\t\t\t\tconvertedValue instanceof String && typeDescriptor.getMethodParameter() != null) {\n \t\t\t\tClass elemType = GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n \t\t\t\tif (elemType != null && Enum.class.isAssignableFrom(elemType)) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2ad2022058d4a2e3d29ea793ede2cb8c09f9102e": {
			"type": "Ymodifierchange",
			"commitMessage": "revised BeanWrapper's exception wrapping to consistently handle ConversionExceptions (SPR-7177)\n",
			"commitDate": "2010-05-17, 2:59 PM",
			"commitName": "2ad2022058d4a2e3d29ea793ede2cb8c09f9102e",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2010-04-02, 1:00 AM",
			"commitNameOld": "580dc8e72ae823ab4cf988de94fd8ae922bd2fc4",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 45.58,
			"commitsBetweenForRepo": 115,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,111 +1,111 @@\n-\tprivate <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n+\tpublic <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(convertedValue);\n \t\t\tTypeDescriptor targetTypeDesc = typeDescriptor.forElementType(requiredType);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) &&\n \t\t\t\t\tconvertedValue instanceof String && typeDescriptor.getMethodParameter() != null) {\n \t\t\t\tClass elemType = GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n \t\t\t\tif (elemType != null && Enum.class.isAssignableFrom(elemType)) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[private]",
				"newValue": "[public]"
			}
		},
		"cbed1c1b4b5fd74c9cd201890f619a7079804d3f": {
			"type": "Ybodychange",
			"commitMessage": "fixed collection element conversion using ConversionService (SPR-6950)\n",
			"commitDate": "2010-03-25, 8:02 AM",
			"commitName": "cbed1c1b4b5fd74c9cd201890f619a7079804d3f",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2010-03-25, 4:53 AM",
			"commitNameOld": "d50881d82b8f2ed8e0947cdffe0e4f74fd3a53dd",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 0.13,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,110 +1,111 @@\n \tprivate <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(convertedValue);\n-\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n-\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n+\t\t\tTypeDescriptor targetTypeDesc = typeDescriptor.forElementType(requiredType);\n+\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n+\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) &&\n \t\t\t\t\tconvertedValue instanceof String && typeDescriptor.getMethodParameter() != null) {\n-\t\t\t\tClass elementType = GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n-\t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType)) {\n+\t\t\t\tClass elemType = GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n+\t\t\t\tif (elemType != null && Enum.class.isAssignableFrom(elemType)) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dc99df297274d8c1291cdaed5d9dd508910584d3": {
			"type": "Ybodychange",
			"commitMessage": "use TypeDescriptor.forObject instead of constructor; enforce use of TypeDescriptor.valueOf through making the constructor private\n",
			"commitDate": "2009-12-15, 12:18 PM",
			"commitName": "dc99df297274d8c1291cdaed5d9dd508910584d3",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-12-15, 4:36 AM",
			"commitNameOld": "2153b2fbd5aa4bff9b233fddb6c1c50cc879dcde",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 0.32,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,110 +1,110 @@\n \tprivate <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null) {\n-\t\t\tTypeDescriptor sourceTypeDesc = new TypeDescriptor(convertedValue);\n+\t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(convertedValue);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) &&\n \t\t\t\t\tconvertedValue instanceof String && typeDescriptor.getMethodParameter() != null) {\n \t\t\t\tClass elementType = GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n \t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType)) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2153b2fbd5aa4bff9b233fddb6c1c50cc879dcde": {
			"type": "Ybodychange",
			"commitMessage": "introspect element type in case of incoming Collection/Map in order to not accidentally say canConvert=true (SPR-6564)\n",
			"commitDate": "2009-12-15, 4:36 AM",
			"commitName": "2153b2fbd5aa4bff9b233fddb6c1c50cc879dcde",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-12-13, 5:21 AM",
			"commitNameOld": "5f9b4443194d3aa3948d76956897c0a1d918d546",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 1.97,
			"commitsBetweenForRepo": 36,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,110 +1,110 @@\n \tprivate <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null) {\n-\t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.valueOf(convertedValue.getClass());\n+\t\t\tTypeDescriptor sourceTypeDesc = new TypeDescriptor(convertedValue);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) &&\n \t\t\t\t\tconvertedValue instanceof String && typeDescriptor.getMethodParameter() != null) {\n \t\t\t\tClass elementType = GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n \t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType)) {\n \t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5f9b4443194d3aa3948d76956897c0a1d918d546": {
			"type": "Ybodychange",
			"commitMessage": "bean properties of type enum array/collection can be populated with comma-separated String (SPR-6547)\n",
			"commitDate": "2009-12-13, 5:21 AM",
			"commitName": "5f9b4443194d3aa3948d76956897c0a1d918d546",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-11-26, 5:43 PM",
			"commitNameOld": "ac490114aee005a66eeb0fba6c3c853552fc6a94",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 16.48,
			"commitsBetweenForRepo": 112,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,100 +1,110 @@\n \tprivate <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.valueOf(convertedValue.getClass());\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n+\t\t\tif (requiredType != null && Collection.class.isAssignableFrom(requiredType) &&\n+\t\t\t\t\tconvertedValue instanceof String && typeDescriptor.getMethodParameter() != null) {\n+\t\t\t\tClass elementType = GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n+\t\t\t\tif (elementType != null && Enum.class.isAssignableFrom(elementType)) {\n+\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n+\t\t\t\t\tif (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n+\t\t\t\t\t\tconvertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n+\t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ac490114aee005a66eeb0fba6c3c853552fc6a94": {
			"type": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
			"commitMessage": "propagate full TypeDescriptor for field-level conversion as well\n",
			"commitDate": "2009-11-26, 5:43 PM",
			"commitName": "ac490114aee005a66eeb0fba6c3c853552fc6a94",
			"commitAuthor": "Juergen Hoeller",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "propagate full TypeDescriptor for field-level conversion as well\n",
					"commitDate": "2009-11-26, 5:43 PM",
					"commitName": "ac490114aee005a66eeb0fba6c3c853552fc6a94",
					"commitAuthor": "Juergen Hoeller",
					"commitDateOld": "2009-10-14, 1:45 PM",
					"commitNameOld": "dc076ee6fe285af7d5deb138f2eb289487d5621f",
					"commitAuthorOld": "Keith Donald",
					"daysBetweenCommits": 43.21,
					"commitsBetweenForRepo": 404,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,110 +1,100 @@\n-\tprotected <T> T convertIfNecessary(\n-\t\t\tString propertyName, Object oldValue, Object newValue, Class<T> requiredType,\n-\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n-\t\t\tthrows IllegalArgumentException {\n+\tprivate <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n+\t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.valueOf(convertedValue.getClass());\n-\t\t\tTypeDescriptor targetTypeDesc;\n-\t\t\tif (methodParam != null) {\n-\t\t\t\ttargetTypeDesc = (descriptor != null ?\n-\t\t\t\t\t\tnew BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\ttargetTypeDesc = TypeDescriptor.valueOf(requiredType);\n-\t\t\t}\n-\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n-\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n+\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n+\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor == null) {\n-\t\t\t\teditor = findDefaultEditor(requiredType, descriptor);\n+\t\t\t\teditor = findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n-\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n+\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n-\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n+\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[propertyName-String, oldValue-Object, newValue-Object, requiredType-Class<T>, descriptor-PropertyDescriptor, methodParam-MethodParameter]",
						"newValue": "[propertyName-String, oldValue-Object, newValue-Object, requiredType-Class<T>, typeDescriptor-TypeDescriptor]"
					}
				},
				{
					"type": "Ymodifierchange",
					"commitMessage": "propagate full TypeDescriptor for field-level conversion as well\n",
					"commitDate": "2009-11-26, 5:43 PM",
					"commitName": "ac490114aee005a66eeb0fba6c3c853552fc6a94",
					"commitAuthor": "Juergen Hoeller",
					"commitDateOld": "2009-10-14, 1:45 PM",
					"commitNameOld": "dc076ee6fe285af7d5deb138f2eb289487d5621f",
					"commitAuthorOld": "Keith Donald",
					"daysBetweenCommits": 43.21,
					"commitsBetweenForRepo": 404,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,110 +1,100 @@\n-\tprotected <T> T convertIfNecessary(\n-\t\t\tString propertyName, Object oldValue, Object newValue, Class<T> requiredType,\n-\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n-\t\t\tthrows IllegalArgumentException {\n+\tprivate <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n+\t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.valueOf(convertedValue.getClass());\n-\t\t\tTypeDescriptor targetTypeDesc;\n-\t\t\tif (methodParam != null) {\n-\t\t\t\ttargetTypeDesc = (descriptor != null ?\n-\t\t\t\t\t\tnew BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\ttargetTypeDesc = TypeDescriptor.valueOf(requiredType);\n-\t\t\t}\n-\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n-\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n+\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n+\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor == null) {\n-\t\t\t\teditor = findDefaultEditor(requiredType, descriptor);\n+\t\t\t\teditor = findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n-\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n+\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n-\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n+\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[protected]",
						"newValue": "[private]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "propagate full TypeDescriptor for field-level conversion as well\n",
					"commitDate": "2009-11-26, 5:43 PM",
					"commitName": "ac490114aee005a66eeb0fba6c3c853552fc6a94",
					"commitAuthor": "Juergen Hoeller",
					"commitDateOld": "2009-10-14, 1:45 PM",
					"commitNameOld": "dc076ee6fe285af7d5deb138f2eb289487d5621f",
					"commitAuthorOld": "Keith Donald",
					"daysBetweenCommits": 43.21,
					"commitsBetweenForRepo": 404,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,110 +1,100 @@\n-\tprotected <T> T convertIfNecessary(\n-\t\t\tString propertyName, Object oldValue, Object newValue, Class<T> requiredType,\n-\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n-\t\t\tthrows IllegalArgumentException {\n+\tprivate <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n+\t\t\tClass<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.valueOf(convertedValue.getClass());\n-\t\t\tTypeDescriptor targetTypeDesc;\n-\t\t\tif (methodParam != null) {\n-\t\t\t\ttargetTypeDesc = (descriptor != null ?\n-\t\t\t\t\t\tnew BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\ttargetTypeDesc = TypeDescriptor.valueOf(requiredType);\n-\t\t\t}\n-\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n-\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n+\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n+\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor == null) {\n-\t\t\t\teditor = findDefaultEditor(requiredType, descriptor);\n+\t\t\t\teditor = findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n-\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n+\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n-\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n+\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n \t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"84447cdf9493a5f6ead3450627d8938af1b7ac5f": {
			"type": "Ybodychange",
			"commitMessage": "DataBinder activates autoGrowNestedPaths by default; fixed enum binding with WebRequestDataBinder\n",
			"commitDate": "2009-10-13, 1:55 PM",
			"commitName": "84447cdf9493a5f6ead3450627d8938af1b7ac5f",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-09-18, 1:32 PM",
			"commitNameOld": "45c542e51e9b01526a97a1644aebfe1e94a2342f",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 25.02,
			"commitsBetweenForRepo": 161,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,107 +1,110 @@\n \tprotected <T> T convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class<T> requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null) {\n \t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.valueOf(convertedValue.getClass());\n \t\t\tTypeDescriptor targetTypeDesc;\n \t\t\tif (methodParam != null) {\n \t\t\t\ttargetTypeDesc = (descriptor != null ?\n \t\t\t\t\t\tnew BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n \t\t\t}\n \t\t\telse {\n \t\t\t\ttargetTypeDesc = TypeDescriptor.valueOf(requiredType);\n \t\t\t}\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n-\t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n-\t\t\t\t\t// We can stringify any primitive value...\n-\t\t\t\t\treturn (T) convertedValue.toString();\n-\t\t\t\t}\n-\t\t\t\telse if (requiredType.isArray()) {\n+\t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n+\t\t\t\tif (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {\n+\t\t\t\t\tconvertedValue = Array.get(convertedValue, 0);\n+\t\t\t\t}\n+\t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n+\t\t\t\t\t// We can stringify any primitive value...\n+\t\t\t\t\treturn (T) convertedValue.toString();\n+\t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"45c542e51e9b01526a97a1644aebfe1e94a2342f": {
			"type": "Ybodychange",
			"commitMessage": "updated for change in conversion service api; source type desc now required\n",
			"commitDate": "2009-09-18, 1:32 PM",
			"commitName": "45c542e51e9b01526a97a1644aebfe1e94a2342f",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2009-09-18, 12:57 PM",
			"commitNameOld": "d3b43ebccb923c6d5825b10d4f4f305b54ee549d",
			"commitAuthorOld": "Keith Donald",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,106 +1,107 @@\n \tprotected <T> T convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class<T> requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null) {\n-\t\t\tTypeDescriptor typeDesc;\n+\t\t\tTypeDescriptor sourceTypeDesc = TypeDescriptor.valueOf(convertedValue.getClass());\n+\t\t\tTypeDescriptor targetTypeDesc;\n \t\t\tif (methodParam != null) {\n-\t\t\t\ttypeDesc = (descriptor != null ?\n+\t\t\t\ttargetTypeDesc = (descriptor != null ?\n \t\t\t\t\t\tnew BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n \t\t\t}\n \t\t\telse {\n-\t\t\t\ttypeDesc = TypeDescriptor.valueOf(requiredType);\n+\t\t\t\ttargetTypeDesc = TypeDescriptor.valueOf(requiredType);\n \t\t\t}\n-\t\t\tif (conversionService.matches(convertedValue.getClass(), typeDesc)) {\n-\t\t\t\treturn (T) conversionService.convert(convertedValue, typeDesc);\n+\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n+\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d3b43ebccb923c6d5825b10d4f4f305b54ee549d": {
			"type": "Ybodychange",
			"commitMessage": "refined generic converter concept\n",
			"commitDate": "2009-09-18, 12:57 PM",
			"commitName": "d3b43ebccb923c6d5825b10d4f4f305b54ee549d",
			"commitAuthor": "Keith Donald",
			"commitDateOld": "2009-09-11, 11:31 AM",
			"commitNameOld": "1480202aa37d7edaf7f070a2bf45cd3a1016eea7",
			"commitAuthorOld": "Rob Harrop",
			"daysBetweenCommits": 7.06,
			"commitsBetweenForRepo": 62,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,106 +1,106 @@\n \tprotected <T> T convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class<T> requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null) {\n \t\t\tTypeDescriptor typeDesc;\n \t\t\tif (methodParam != null) {\n \t\t\t\ttypeDesc = (descriptor != null ?\n \t\t\t\t\t\tnew BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n \t\t\t}\n \t\t\telse {\n \t\t\t\ttypeDesc = TypeDescriptor.valueOf(requiredType);\n \t\t\t}\n-\t\t\tif (conversionService.canConvert(convertedValue.getClass(), typeDesc)) {\n+\t\t\tif (conversionService.matches(convertedValue.getClass(), typeDesc)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, typeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1480202aa37d7edaf7f070a2bf45cd3a1016eea7": {
			"type": "Ybodychange",
			"commitMessage": "[SPR-5644] Support for Enum<?> and Enum<T> values as FQN.FIELD_NAME in type conversion\n",
			"commitDate": "2009-09-11, 11:31 AM",
			"commitName": "1480202aa37d7edaf7f070a2bf45cd3a1016eea7",
			"commitAuthor": "Rob Harrop",
			"commitDateOld": "2009-09-07, 4:58 PM",
			"commitNameOld": "a86a698e5b3394c9b6721a784c8fe251611ff16b",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 3.77,
			"commitsBetweenForRepo": 33,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,116 +1,106 @@\n \tprotected <T> T convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class<T> requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null) {\n \t\t\tTypeDescriptor typeDesc;\n \t\t\tif (methodParam != null) {\n \t\t\t\ttypeDesc = (descriptor != null ?\n \t\t\t\t\t\tnew BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n \t\t\t}\n \t\t\telse {\n \t\t\t\ttypeDesc = TypeDescriptor.valueOf(requiredType);\n \t\t\t}\n \t\t\tif (conversionService.canConvert(convertedValue.getClass(), typeDesc)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, typeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n-\t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n-\t\t\t\t\t// with values defined as static fields. Resulting value still needs\n-\t\t\t\t\t// to be checked, hence we don't return it right away.\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tField enumField = requiredType.getField(trimmedValue);\n-\t\t\t\t\t\tconvertedValue = enumField.get(null);\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (Throwable ex) {\n-\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n-\t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n+\t\t\t\t\t\n+\t\t\t\t\tconvertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a86a698e5b3394c9b6721a784c8fe251611ff16b": {
			"type": "Ybodychange",
			"commitMessage": "initial JSR-303 Bean Validation support; revised ConversionService and FormatterRegistry\n",
			"commitDate": "2009-09-07, 4:58 PM",
			"commitName": "a86a698e5b3394c9b6721a784c8fe251611ff16b",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-08-25, 6:49 AM",
			"commitNameOld": "04cd95ff50f78f4b8ff738f6ca183abe06b366ee",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 13.42,
			"commitsBetweenForRepo": 75,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,112 +1,116 @@\n \tprotected <T> T convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class<T> requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n-\t\tif (editor == null && conversionService != null && convertedValue != null &&\n-\t\t\t\tconversionService.canConvert(convertedValue.getClass(), requiredType)) {\n+\t\tif (editor == null && conversionService != null && convertedValue != null) {\n+\t\t\tTypeDescriptor typeDesc;\n \t\t\tif (methodParam != null) {\n-\t\t\t\treturn (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n+\t\t\t\ttypeDesc = (descriptor != null ?\n+\t\t\t\t\t\tnew BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n \t\t\t}\n \t\t\telse {\n-\t\t\t\treturn conversionService.convert(convertedValue, requiredType);\n+\t\t\t\ttypeDesc = TypeDescriptor.valueOf(requiredType);\n+\t\t\t}\n+\t\t\tif (conversionService.canConvert(convertedValue.getClass(), typeDesc)) {\n+\t\t\t\treturn (T) conversionService.convert(convertedValue, typeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don't return it right away.\n \t\t\t\t\ttry {\n \t\t\t\t\t\tField enumField = requiredType.getField(trimmedValue);\n \t\t\t\t\t\tconvertedValue = enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9a48f3f3a896cad821e5847a93d91c997905e325": {
			"type": "Ybodychange",
			"commitMessage": "try to create unknown collection implementation types via default constructor\n",
			"commitDate": "2009-08-25, 6:29 AM",
			"commitName": "9a48f3f3a896cad821e5847a93d91c997905e325",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-08-24, 6:48 AM",
			"commitNameOld": "04b619ebfbc1e08a9e9bdc54263b3ece21f4aa7f",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 0.99,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,108 +1,112 @@\n \tprotected <T> T convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class<T> requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null &&\n \t\t\t\tconversionService.canConvert(convertedValue.getClass(), requiredType)) {\n \t\t\tif (methodParam != null) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n \t\t\t}\n \t\t\telse {\n \t\t\t\treturn conversionService.convert(convertedValue, requiredType);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n-\t\t\t\telse if (convertedValue instanceof Collection && CollectionFactory.isApproximableCollectionType(requiredType)) {\n+\t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n-\t\t\t\t\tconvertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n+\t\t\t\t\tconvertedValue = convertToTypedCollection(\n+\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n-\t\t\t\telse if (convertedValue instanceof Map && CollectionFactory.isApproximableMapType(requiredType)) {\n+\t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n-\t\t\t\t\tconvertedValue = convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n+\t\t\t\t\tconvertedValue = convertToTypedMap(\n+\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n-\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (NoSuchMethodException ex) {\n-\t\t\t\t\t\t// proceed with field lookup\n-\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n-\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n+\t\t\t\t\tif (!requiredType.isInterface() && !requiredType.isEnum()) {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n+\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (Exception ex) {\n-\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n-\t\t\t\t\t\t\tlogger.trace(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n+\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n+\t\t\t\t\t\t\t// proceed with field lookup\n+\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n+\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don't return it right away.\n \t\t\t\t\ttry {\n \t\t\t\t\t\tField enumField = requiredType.getField(trimmedValue);\n \t\t\t\t\t\tconvertedValue = enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"04b619ebfbc1e08a9e9bdc54263b3ece21f4aa7f": {
			"type": "Ybodychange",
			"commitMessage": "fixed accidental test failures\n",
			"commitDate": "2009-08-24, 6:48 AM",
			"commitName": "04b619ebfbc1e08a9e9bdc54263b3ece21f4aa7f",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-08-24, 6:30 AM",
			"commitNameOld": "fee838a65e87f5da4b65b04ea5101681d6308104",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,103 +1,108 @@\n \tprotected <T> T convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class<T> requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null &&\n \t\t\t\tconversionService.canConvert(convertedValue.getClass(), requiredType)) {\n \t\t\tif (methodParam != null) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n \t\t\t}\n \t\t\telse {\n \t\t\t\treturn conversionService.convert(convertedValue, requiredType);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection && CollectionFactory.isApproximableCollectionType(requiredType)) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map && CollectionFactory.isApproximableMapType(requiredType)) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n \t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n+\t\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n+\t\t\t\t\t\t\tlogger.trace(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don't return it right away.\n \t\t\t\t\ttry {\n \t\t\t\t\t\tField enumField = requiredType.getField(trimmedValue);\n \t\t\t\t\t\tconvertedValue = enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fee838a65e87f5da4b65b04ea5101681d6308104": {
			"type": "Ybodychange",
			"commitMessage": "support for default \"conversionService\" bean in an ApplicationContext; revised formatting package, now integrated with DataBinder and AnnotationMethodHandlerAdapter; revised AccessControlContext access from BeanFactory\n",
			"commitDate": "2009-08-24, 6:30 AM",
			"commitName": "fee838a65e87f5da4b65b04ea5101681d6308104",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-08-08, 5:46 PM",
			"commitNameOld": "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 15.53,
			"commitsBetweenForRepo": 26,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,93 +1,103 @@\n \tprotected <T> T convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class<T> requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n \t\tif (editor == null && conversionService != null && convertedValue != null &&\n \t\t\t\tconversionService.canConvert(convertedValue.getClass(), requiredType)) {\n \t\t\tif (methodParam != null) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n \t\t\t}\n \t\t\telse {\n \t\t\t\treturn conversionService.convert(convertedValue, requiredType);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection && CollectionFactory.isApproximableCollectionType(requiredType)) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map && CollectionFactory.isApproximableMapType(requiredType)) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n-\t\t\t\t\tString strValue = ((String) convertedValue).trim();\n-\t\t\t\t\tif (requiredType.isEnum() && \"\".equals(strValue)) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tConstructor strCtor = requiredType.getConstructor(String.class);\n+\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (NoSuchMethodException ex) {\n+\t\t\t\t\t\t// proceed with field lookup\n+\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n+\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tString trimmedValue = ((String) convertedValue).trim();\n+\t\t\t\t\tif (requiredType.isEnum() && \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don't return it right away.\n \t\t\t\t\ttry {\n-\t\t\t\t\t\tField enumField = requiredType.getField(strValue);\n+\t\t\t\t\t\tField enumField = requiredType.getField(trimmedValue);\n \t\t\t\t\t\tconvertedValue = enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"45a0cadf8e7fc5cc082c11ef03f77dc017af64c4": {
			"type": "Ybodychange",
			"commitMessage": "revised core conversion package for BeanWrapper/BeanFactory integration\n",
			"commitDate": "2009-08-08, 5:46 PM",
			"commitName": "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-05-11, 3:44 PM",
			"commitNameOld": "0297116542a3ce33d19a6a81b8240097081376c5",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 89.08,
			"commitsBetweenForRepo": 569,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,81 +1,93 @@\n \tprotected <T> T convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class<T> requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n+\t\t// No custom editor but custom ConversionService specified?\n+\t\tConversionService conversionService = this.propertyEditorRegistry.getConversionService();\n+\t\tif (editor == null && conversionService != null && convertedValue != null &&\n+\t\t\t\tconversionService.canConvert(convertedValue.getClass(), requiredType)) {\n+\t\t\tif (methodParam != null) {\n+\t\t\t\treturn (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\treturn conversionService.convert(convertedValue, requiredType);\n+\t\t\t}\n+\t\t}\n+\n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection && CollectionFactory.isApproximableCollectionType(requiredType)) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map && CollectionFactory.isApproximableMapType(requiredType)) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tString strValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(strValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don't return it right away.\n \t\t\t\t\ttry {\n \t\t\t\t\t\tField enumField = requiredType.getField(strValue);\n \t\t\t\t\t\tconvertedValue = enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0297116542a3ce33d19a6a81b8240097081376c5": {
			"type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
			"commitMessage": "generified TypeConverter interface\n",
			"commitDate": "2009-05-11, 3:44 PM",
			"commitName": "0297116542a3ce33d19a6a81b8240097081376c5",
			"commitAuthor": "Juergen Hoeller",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "generified TypeConverter interface\n",
					"commitDate": "2009-05-11, 3:44 PM",
					"commitName": "0297116542a3ce33d19a6a81b8240097081376c5",
					"commitAuthor": "Juergen Hoeller",
					"commitDateOld": "2009-05-11, 7:52 AM",
					"commitNameOld": "bf7a947559d8f9918cc738780bf04caf8ea46962",
					"commitAuthorOld": "Arjen Poutsma",
					"daysBetweenCommits": 0.33,
					"commitsBetweenForRepo": 6,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,81 +1,81 @@\n-\tprotected Object convertIfNecessary(\n-\t\t\tString propertyName, Object oldValue, Object newValue, Class requiredType,\n+\tprotected <T> T convertIfNecessary(\n+\t\t\tString propertyName, Object oldValue, Object newValue, Class<T> requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n-\t\t\t\t\treturn convertedValue.toString();\n+\t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n-\t\t\t\t\treturn convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n+\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection && CollectionFactory.isApproximableCollectionType(requiredType)) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map && CollectionFactory.isApproximableMapType(requiredType)) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tString strValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(strValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don't return it right away.\n \t\t\t\t\ttry {\n \t\t\t\t\t\tField enumField = requiredType.getField(strValue);\n \t\t\t\t\t\tconvertedValue = enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\treturn convertedValue;\n+\t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[propertyName-String, oldValue-Object, newValue-Object, requiredType-Class, descriptor-PropertyDescriptor, methodParam-MethodParameter]",
						"newValue": "[propertyName-String, oldValue-Object, newValue-Object, requiredType-Class<T>, descriptor-PropertyDescriptor, methodParam-MethodParameter]"
					}
				},
				{
					"type": "Yreturntypechange",
					"commitMessage": "generified TypeConverter interface\n",
					"commitDate": "2009-05-11, 3:44 PM",
					"commitName": "0297116542a3ce33d19a6a81b8240097081376c5",
					"commitAuthor": "Juergen Hoeller",
					"commitDateOld": "2009-05-11, 7:52 AM",
					"commitNameOld": "bf7a947559d8f9918cc738780bf04caf8ea46962",
					"commitAuthorOld": "Arjen Poutsma",
					"daysBetweenCommits": 0.33,
					"commitsBetweenForRepo": 6,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,81 +1,81 @@\n-\tprotected Object convertIfNecessary(\n-\t\t\tString propertyName, Object oldValue, Object newValue, Class requiredType,\n+\tprotected <T> T convertIfNecessary(\n+\t\t\tString propertyName, Object oldValue, Object newValue, Class<T> requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n-\t\t\t\t\treturn convertedValue.toString();\n+\t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n-\t\t\t\t\treturn convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n+\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection && CollectionFactory.isApproximableCollectionType(requiredType)) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map && CollectionFactory.isApproximableMapType(requiredType)) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tString strValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(strValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don't return it right away.\n \t\t\t\t\ttry {\n \t\t\t\t\t\tField enumField = requiredType.getField(strValue);\n \t\t\t\t\t\tconvertedValue = enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\treturn convertedValue;\n+\t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "Object",
						"newValue": "T"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "generified TypeConverter interface\n",
					"commitDate": "2009-05-11, 3:44 PM",
					"commitName": "0297116542a3ce33d19a6a81b8240097081376c5",
					"commitAuthor": "Juergen Hoeller",
					"commitDateOld": "2009-05-11, 7:52 AM",
					"commitNameOld": "bf7a947559d8f9918cc738780bf04caf8ea46962",
					"commitAuthorOld": "Arjen Poutsma",
					"daysBetweenCommits": 0.33,
					"commitsBetweenForRepo": 6,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,81 +1,81 @@\n-\tprotected Object convertIfNecessary(\n-\t\t\tString propertyName, Object oldValue, Object newValue, Class requiredType,\n+\tprotected <T> T convertIfNecessary(\n+\t\t\tString propertyName, Object oldValue, Object newValue, Class<T> requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n-\t\t\t\t\treturn convertedValue.toString();\n+\t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n-\t\t\t\t\treturn convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n+\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection && CollectionFactory.isApproximableCollectionType(requiredType)) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map && CollectionFactory.isApproximableMapType(requiredType)) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tString strValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(strValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don't return it right away.\n \t\t\t\t\ttry {\n \t\t\t\t\t\tField enumField = requiredType.getField(strValue);\n \t\t\t\t\t\tconvertedValue = enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\treturn convertedValue;\n+\t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"bf7a947559d8f9918cc738780bf04caf8ea46962": {
			"type": "Ybodychange",
			"commitMessage": "SPR-5732 - When no type conversion strategy is found on a @Controller handler method bind target, a 500 error code should be returned not a 400.\n\n",
			"commitDate": "2009-05-11, 7:52 AM",
			"commitName": "bf7a947559d8f9918cc738780bf04caf8ea46962",
			"commitAuthor": "Arjen Poutsma",
			"commitDateOld": "2008-11-24, 5:29 PM",
			"commitNameOld": "29657105da133995b0b2277b82c75d1df2931b64",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 167.56,
			"commitsBetweenForRepo": 808,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,80 +1,81 @@\n \tprotected Object convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\treturn convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection && CollectionFactory.isApproximableCollectionType(requiredType)) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map && CollectionFactory.isApproximableMapType(requiredType)) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tString strValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(strValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don't return it right away.\n \t\t\t\t\ttry {\n \t\t\t\t\t\tField enumField = requiredType.getField(strValue);\n \t\t\t\t\t\tconvertedValue = enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n-\t\t\t\t// Definitely doesn't match: throw IllegalArgumentException.\n+\t\t\t\t// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n+\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n+\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n-\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t}\n \t\t}\n \n \t\treturn convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"29657105da133995b0b2277b82c75d1df2931b64": {
			"type": "Ybodychange",
			"commitMessage": "Java 5 code style\n",
			"commitDate": "2008-11-24, 5:29 PM",
			"commitName": "29657105da133995b0b2277b82c75d1df2931b64",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2008-11-19, 6:10 PM",
			"commitNameOld": "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 4.97,
			"commitsBetweenForRepo": 26,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,79 +1,80 @@\n \tprotected Object convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\treturn convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection && CollectionFactory.isApproximableCollectionType(requiredType)) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map && CollectionFactory.isApproximableMapType(requiredType)) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tString strValue = ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() && \"\".equals(strValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don't return it right away.\n \t\t\t\t\ttry {\n \t\t\t\t\t\tField enumField = requiredType.getField(strValue);\n \t\t\t\t\t\tconvertedValue = enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException.\n \t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n-\t\t\t\t\tmsg.append(\" for property '\" + propertyName + \"'\");\n+\t\t\t\t\tmsg.append(\" for property '\").append(propertyName).append(\"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n-\t\t\t\t\tmsg.append(\": PropertyEditor [\" + editor.getClass().getName() + \"] returned inappropriate value\");\n+\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n+\t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t}\n \t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t}\n \t\t}\n \n \t\treturn convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"347f34c68a7a5bab46cf869e762fb3cee9a1fedc": {
			"type": "Ybodychange",
			"commitMessage": "EL container integration; support for contextual objects; removal of deprecated Spring 2.0 functionality; Java 5 code style\n",
			"commitDate": "2008-11-19, 6:10 PM",
			"commitName": "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2008-10-22, 9:13 AM",
			"commitNameOld": "f11d3436ed21d3908b9e0b569f2d783df161c0a3",
			"commitAuthorOld": "Arjen Poutsma",
			"daysBetweenCommits": 28.41,
			"commitsBetweenForRepo": 194,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,79 +1,79 @@\n \tprotected Object convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue = newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// Value not of required type?\n \t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor == null) {\n \t\t\t\teditor = findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType != null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue != null) {\n \t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n \t\t\t\t\treturn convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection && CollectionFactory.isApproximableCollectionType(requiredType)) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map && CollectionFactory.isApproximableMapType(requiredType)) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue = convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tString strValue = ((String) convertedValue).trim();\n-\t\t\t\t\tif (JdkVersion.isAtLeastJava15() && requiredType.isEnum() && \"\".equals(strValue)) {\n+\t\t\t\t\tif (requiredType.isEnum() && \"\".equals(strValue)) {\n \t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don't return it right away.\n \t\t\t\t\ttry {\n \t\t\t\t\t\tField enumField = requiredType.getField(strValue);\n \t\t\t\t\t\tconvertedValue = enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn't match: throw IllegalArgumentException.\n-\t\t\t\tStringBuffer msg = new StringBuffer();\n+\t\t\t\tStringBuilder msg = new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName != null) {\n \t\t\t\t\tmsg.append(\" for property '\" + propertyName + \"'\");\n \t\t\t\t}\n \t\t\t\tif (editor != null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\" + editor.getClass().getName() + \"] returned inappropriate value\");\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t}\n \t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t}\n \t\t}\n \n \t\treturn convertedValue;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f11d3436ed21d3908b9e0b569f2d783df161c0a3": {
			"type": "Yintroduced",
			"commitMessage": "Moved over initial version of beans bundle\n",
			"commitDate": "2008-10-22, 9:13 AM",
			"commitName": "f11d3436ed21d3908b9e0b569f2d783df161c0a3",
			"commitAuthor": "Arjen Poutsma",
			"diff": "@@ -0,0 +1,79 @@\n+\tprotected Object convertIfNecessary(\n+\t\t\tString propertyName, Object oldValue, Object newValue, Class requiredType,\n+\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n+\t\t\tthrows IllegalArgumentException {\n+\n+\t\tObject convertedValue = newValue;\n+\n+\t\t// Custom editor for this type?\n+\t\tPropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n+\n+\t\t// Value not of required type?\n+\t\tif (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n+\t\t\tif (editor == null) {\n+\t\t\t\teditor = findDefaultEditor(requiredType, descriptor);\n+\t\t\t}\n+\t\t\tconvertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);\n+\t\t}\n+\n+\t\tif (requiredType != null) {\n+\t\t\t// Try to apply some standard type conversion rules if appropriate.\n+\n+\t\t\tif (convertedValue != null) {\n+\t\t\t\tif (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n+\t\t\t\t\t// We can stringify any primitive value...\n+\t\t\t\t\treturn convertedValue.toString();\n+\t\t\t\t}\n+\t\t\t\telse if (requiredType.isArray()) {\n+\t\t\t\t\t// Array required -> apply appropriate conversion of elements.\n+\t\t\t\t\treturn convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n+\t\t\t\t}\n+\t\t\t\telse if (convertedValue instanceof Collection && CollectionFactory.isApproximableCollectionType(requiredType)) {\n+\t\t\t\t\t// Convert elements to target type, if determined.\n+\t\t\t\t\tconvertedValue = convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n+\t\t\t\t}\n+\t\t\t\telse if (convertedValue instanceof Map && CollectionFactory.isApproximableMapType(requiredType)) {\n+\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n+\t\t\t\t\tconvertedValue = convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n+\t\t\t\t}\n+\t\t\t\telse if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {\n+\t\t\t\t\tString strValue = ((String) convertedValue).trim();\n+\t\t\t\t\tif (JdkVersion.isAtLeastJava15() && requiredType.isEnum() && \"\".equals(strValue)) {\n+\t\t\t\t\t\t// It's an empty enum identifier: reset the enum value to null.\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\t}\n+\t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n+\t\t\t\t\t// with values defined as static fields. Resulting value still needs\n+\t\t\t\t\t// to be checked, hence we don't return it right away.\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tField enumField = requiredType.getField(strValue);\n+\t\t\t\t\t\tconvertedValue = enumField.get(null);\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (Throwable ex) {\n+\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n+\t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn't an enum value\", ex);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n+\t\t\t\t// Definitely doesn't match: throw IllegalArgumentException.\n+\t\t\t\tStringBuffer msg = new StringBuffer();\n+\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n+\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n+\t\t\t\tif (propertyName != null) {\n+\t\t\t\t\tmsg.append(\" for property '\" + propertyName + \"'\");\n+\t\t\t\t}\n+\t\t\t\tif (editor != null) {\n+\t\t\t\t\tmsg.append(\": PropertyEditor [\" + editor.getClass().getName() + \"] returned inappropriate value\");\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n+\t\t\t\t}\n+\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn convertedValue;\n+\t}\n\\ No newline at end of file\n"
		}
	},
	"sha": "b325c74216fd9564a36602158fa1269e2e832874"
}