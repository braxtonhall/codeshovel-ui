{
	"repo": "https://github.com/spring-projects/spring-framework.git",
	"file": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
	"method": {
		"longName": "ConfigurationClassParser::doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)",
		"startLine": 261,
		"methodName": "doProcessConfigurationClass",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "protected"
	},
	"history": {
		"9a43d2ec208d2e8cd0866431acf26af3529f8677": {
			"type": "Ybodychange",
			"commitMessage": "Revised log levels: less WARN and INFO, fine-tuned DEBUG vs TRACE\n\nIssue: SPR-16946\n",
			"commitDate": "2018-07-20, 7:05 AM",
			"commitName": "9a43d2ec208d2e8cd0866431acf26af3529f8677",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2018-06-28, 6:51 AM",
			"commitNameOld": "40efcc933ca2cb5733655d114f36be035dc9fd54",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 22.01,
			"commitsBetweenForRepo": 158,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,79 +1,79 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)\n \t\t\tthrows IOException {\n \n \t\t// Recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// Process any @PropertySource annotations\n \t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), PropertySources.class,\n \t\t\t\torg.springframework.context.annotation.PropertySource.class)) {\n \t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n \t\t\t\tprocessPropertySource(propertySource);\n \t\t\t}\n \t\t\telse {\n-\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n+\t\t\t\tlogger.info(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n \t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t}\n \n \t\t// Process any @ComponentScan annotations\n \t\tSet<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n \t\tif (!componentScans.isEmpty() &&\n \t\t\t\t!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tfor (AnnotationAttributes componentScan : componentScans) {\n \t\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if needed\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tBeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();\n \t\t\t\t\tif (bdCand == null) {\n \t\t\t\t\t\tbdCand = holder.getBeanDefinition();\n \t\t\t\t\t}\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n \t\t\t\t\t\tparse(bdCand.getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Process any @Import annotations\n \t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true);\n \n \t\t// Process any @ImportResource annotations\n \t\tAnnotationAttributes importResource =\n \t\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\tif (importResource != null) {\n \t\t\tString[] resources = importResource.getStringArray(\"locations\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// Process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// Process default methods on interfaces\n \t\tprocessInterfaces(configClass, sourceClass);\n \n \t\t// Process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (superclass != null && !superclass.startsWith(\"java\") &&\n \t\t\t\t\t!this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// Superclass found, return its annotation metadata and recurse\n \t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t}\n \t\t}\n \n \t\t// No superclass -> processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c8b6233bd03d43c8a91ec197e9cf1ea15bba478c": {
			"type": "Ybodychange",
			"commitMessage": "Introspect originating bean definition as configuration class candidate\n\nIssue: SPR-16756\n",
			"commitDate": "2018-05-02, 7:20 AM",
			"commitName": "c8b6233bd03d43c8a91ec197e9cf1ea15bba478c",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2018-03-29, 3:50 PM",
			"commitNameOld": "d553ddc5b3a657adebad04d9f3c7d466fbdd7b05",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 33.65,
			"commitsBetweenForRepo": 149,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,76 +1,79 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)\n \t\t\tthrows IOException {\n \n \t\t// Recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// Process any @PropertySource annotations\n \t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), PropertySources.class,\n \t\t\t\torg.springframework.context.annotation.PropertySource.class)) {\n \t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n \t\t\t\tprocessPropertySource(propertySource);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n \t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t}\n \n \t\t// Process any @ComponentScan annotations\n \t\tSet<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n \t\tif (!componentScans.isEmpty() &&\n \t\t\t\t!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tfor (AnnotationAttributes componentScan : componentScans) {\n \t\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if needed\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n-\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(\n-\t\t\t\t\t\t\tholder.getBeanDefinition(), this.metadataReaderFactory)) {\n-\t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+\t\t\t\t\tBeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();\n+\t\t\t\t\tif (bdCand == null) {\n+\t\t\t\t\t\tbdCand = holder.getBeanDefinition();\n+\t\t\t\t\t}\n+\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n+\t\t\t\t\t\tparse(bdCand.getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Process any @Import annotations\n \t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true);\n \n \t\t// Process any @ImportResource annotations\n \t\tAnnotationAttributes importResource =\n \t\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\tif (importResource != null) {\n \t\t\tString[] resources = importResource.getStringArray(\"locations\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// Process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// Process default methods on interfaces\n \t\tprocessInterfaces(configClass, sourceClass);\n \n \t\t// Process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (superclass != null && !superclass.startsWith(\"java\") &&\n \t\t\t\t\t!this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// Superclass found, return its annotation metadata and recurse\n \t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t}\n \t\t}\n \n \t\t// No superclass -> processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f813712f5b413b354560cd7cc006352e9defa9a3": {
			"type": "Ybodychange",
			"commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
			"commitDate": "2017-06-07, 6:19 AM",
			"commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2017-05-31, 2:51 PM",
			"commitNameOld": "b494c53b40a76a3ce01a54b1bd384b6809f1a147",
			"commitAuthorOld": "Sebastien Deleuze",
			"daysBetweenCommits": 6.64,
			"commitsBetweenForRepo": 25,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,75 +1,76 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)\n \t\t\tthrows IOException {\n \n \t\t// Recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// Process any @PropertySource annotations\n \t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), PropertySources.class,\n \t\t\t\torg.springframework.context.annotation.PropertySource.class)) {\n \t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n \t\t\t\tprocessPropertySource(propertySource);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n \t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t}\n \n \t\t// Process any @ComponentScan annotations\n \t\tSet<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n \t\tif (!componentScans.isEmpty() &&\n \t\t\t\t!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tfor (AnnotationAttributes componentScan : componentScans) {\n \t\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if needed\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(\n \t\t\t\t\t\t\tholder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Process any @Import annotations\n \t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true);\n \n \t\t// Process any @ImportResource annotations\n-\t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n-\t\t\tAnnotationAttributes importResource =\n-\t\t\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n+\t\tAnnotationAttributes importResource =\n+\t\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n+\t\tif (importResource != null) {\n \t\t\tString[] resources = importResource.getStringArray(\"locations\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// Process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// Process default methods on interfaces\n \t\tprocessInterfaces(configClass, sourceClass);\n \n \t\t// Process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n-\t\t\tif (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n+\t\t\tif (superclass != null && !superclass.startsWith(\"java\") &&\n+\t\t\t\t\t!this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// Superclass found, return its annotation metadata and recurse\n \t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t}\n \t\t}\n \n \t\t// No superclass -> processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"91df0653fe5e22477ec2ed6dbe7e44b835c99038": {
			"type": "Ybodychange",
			"commitMessage": "Polishing\n",
			"commitDate": "2017-04-17, 7:05 AM",
			"commitName": "91df0653fe5e22477ec2ed6dbe7e44b835c99038",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2017-04-11, 3:45 AM",
			"commitNameOld": "c4e0d6c2a235fe4896276844d20a60f8510acf09",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 6.14,
			"commitsBetweenForRepo": 48,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,70 +1,75 @@\n-\tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n+\tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)\n+\t\t\tthrows IOException {\n+\n \t\t// Recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// Process any @PropertySource annotations\n \t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n-\t\t\t\tsourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n+\t\t\t\tsourceClass.getMetadata(), PropertySources.class,\n+\t\t\t\torg.springframework.context.annotation.PropertySource.class)) {\n \t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n \t\t\t\tprocessPropertySource(propertySource);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n \t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t}\n \n \t\t// Process any @ComponentScan annotations\n \t\tSet<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n-\t\tif (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n+\t\tif (!componentScans.isEmpty() &&\n+\t\t\t\t!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tfor (AnnotationAttributes componentScan : componentScans) {\n \t\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n-\t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if necessary\n+\t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if needed\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n-\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n+\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(\n+\t\t\t\t\t\t\tholder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Process any @Import annotations\n \t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true);\n \n \t\t// Process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource =\n \t\t\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"locations\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// Process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// Process default methods on interfaces\n \t\tprocessInterfaces(configClass, sourceClass);\n \n \t\t// Process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// Superclass found, return its annotation metadata and recurse\n \t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t}\n \t\t}\n \n \t\t// No superclass -> processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3295a4e6ef43c3e3053f41404ccf7da6ab53f310": {
			"type": "Ybodychange",
			"commitMessage": "ConfigurationClassParser enforces @Bean declaration order through ASM metadata\n\nIssue: SPR-14505\n",
			"commitDate": "2016-12-23, 12:29 PM",
			"commitName": "3295a4e6ef43c3e3053f41404ccf7da6ab53f310",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2016-12-09, 7:01 AM",
			"commitNameOld": "a7ec6dc0afb5ad83371ed073a26a31cb9e1dd4f1",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 14.23,
			"commitsBetweenForRepo": 145,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,70 +1,70 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \t\t// Recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// Process any @PropertySource annotations\n \t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n \t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n \t\t\t\tprocessPropertySource(propertySource);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n \t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t}\n \n \t\t// Process any @ComponentScan annotations\n \t\tSet<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n \t\tif (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tfor (AnnotationAttributes componentScan : componentScans) {\n \t\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Process any @Import annotations\n \t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true);\n \n \t\t// Process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource =\n \t\t\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"locations\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// Process individual @Bean methods\n-\t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n+\t\tSet<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// Process default methods on interfaces\n \t\tprocessInterfaces(configClass, sourceClass);\n \n \t\t// Process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// Superclass found, return its annotation metadata and recurse\n \t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t}\n \t\t}\n \n \t\t// No superclass -> processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d96a66ae8fc01cb480132e909b320a6c6addbfde": {
			"type": "Ybodychange",
			"commitMessage": "ConfigurationClassParser uses unified ImportStack with chained import analysis\n\nIssue: SPR-14517\n",
			"commitDate": "2016-07-27, 4:06 PM",
			"commitName": "d96a66ae8fc01cb480132e909b320a6c6addbfde",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2016-07-27, 8:21 AM",
			"commitNameOld": "316244d2bdcb288ef4e6ff58daef6da0511fe765",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 0.32,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,79 +1,70 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \t\t// Recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// Process any @PropertySource annotations\n \t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n \t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n \t\t\t\tprocessPropertySource(propertySource);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n \t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t}\n \n \t\t// Process any @ComponentScan annotations\n \t\tSet<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n \t\tif (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tfor (AnnotationAttributes componentScan : componentScans) {\n \t\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n-\t\t\t\t\t\t// Provide isolated circular import detection for scanned classes,\n-\t\t\t\t\t\t// since the initial registration did not come explicitly.\n-\t\t\t\t\t\tImportStack previousStack = this.importStack;\n-\t\t\t\t\t\tthis.importStack = new ImportStack();\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tfinally {\n-\t\t\t\t\t\t\tthis.importStack = previousStack;\n-\t\t\t\t\t\t}\n+\t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Process any @Import annotations\n \t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true);\n \n \t\t// Process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource =\n \t\t\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"locations\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// Process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// Process default methods on interfaces\n \t\tprocessInterfaces(configClass, sourceClass);\n \n \t\t// Process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// Superclass found, return its annotation metadata and recurse\n \t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t}\n \t\t}\n \n \t\t// No superclass -> processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"316244d2bdcb288ef4e6ff58daef6da0511fe765": {
			"type": "Ybodychange",
			"commitMessage": "Isolated circular import detection for scanned configuration classes\n\nIssue: SPR-14517\n",
			"commitDate": "2016-07-27, 8:21 AM",
			"commitName": "316244d2bdcb288ef4e6ff58daef6da0511fe765",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2016-07-19, 11:21 AM",
			"commitNameOld": "aaac199e8bc1e037883f9fa8063828a82142d608",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 7.88,
			"commitsBetweenForRepo": 73,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,70 +1,79 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \t\t// Recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// Process any @PropertySource annotations\n \t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n \t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n \t\t\t\tprocessPropertySource(propertySource);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n \t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t}\n \n \t\t// Process any @ComponentScan annotations\n \t\tSet<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n \t\tif (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tfor (AnnotationAttributes componentScan : componentScans) {\n \t\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n-\t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+\t\t\t\t\t\t// Provide isolated circular import detection for scanned classes,\n+\t\t\t\t\t\t// since the initial registration did not come explicitly.\n+\t\t\t\t\t\tImportStack previousStack = this.importStack;\n+\t\t\t\t\t\tthis.importStack = new ImportStack();\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tfinally {\n+\t\t\t\t\t\t\tthis.importStack = previousStack;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Process any @Import annotations\n \t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true);\n \n \t\t// Process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource =\n \t\t\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"locations\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// Process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// Process default methods on interfaces\n \t\tprocessInterfaces(configClass, sourceClass);\n \n \t\t// Process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// Superclass found, return its annotation metadata and recurse\n \t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t}\n \t\t}\n \n \t\t// No superclass -> processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3d3407c78992bbb504ae96a8f3eb17dbca07bcc7": {
			"type": "Ybodychange",
			"commitMessage": "Consistent alias processing behind AnnotatedTypeMetadata abstraction (also for ASM)\n\nIssue: SPR-14427\n",
			"commitDate": "2016-07-15, 5:59 AM",
			"commitName": "3d3407c78992bbb504ae96a8f3eb17dbca07bcc7",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2016-07-05, 9:00 AM",
			"commitNameOld": "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
			"commitAuthorOld": "Stephane Nicoll",
			"daysBetweenCommits": 9.87,
			"commitsBetweenForRepo": 122,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,69 +1,70 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \t\t// Recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// Process any @PropertySource annotations\n \t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n \t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n \t\t\t\tprocessPropertySource(propertySource);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n \t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t}\n \n \t\t// Process any @ComponentScan annotations\n \t\tSet<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n \t\tif (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tfor (AnnotationAttributes componentScan : componentScans) {\n \t\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Process any @Import annotations\n \t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true);\n \n \t\t// Process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n-\t\t\tAnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n-\t\t\tString[] resources = importResource.getAliasedStringArray(\"locations\", ImportResource.class, sourceClass);\n+\t\t\tAnnotationAttributes importResource =\n+\t\t\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n+\t\t\tString[] resources = importResource.getStringArray(\"locations\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// Process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// Process default methods on interfaces\n \t\tprocessInterfaces(configClass, sourceClass);\n \n \t\t// Process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// Superclass found, return its annotation metadata and recurse\n \t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t}\n \t\t}\n \n \t\t// No superclass -> processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"03affa02dbb3d629d12228b1622a1d2c8cd37931": {
			"type": "Ybodychange",
			"commitMessage": "ConfigurationClassParser detects @Bean methods in interface hierarchies as well\n\nIssue: SPR-14288\n",
			"commitDate": "2016-05-27, 2:34 PM",
			"commitName": "03affa02dbb3d629d12228b1622a1d2c8cd37931",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2016-02-22, 3:25 PM",
			"commitNameOld": "a3789120c9d5d77a7f3946c9d5d809195de6d243",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 94.92,
			"commitsBetweenForRepo": 408,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,77 +1,69 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \t\t// Recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// Process any @PropertySource annotations\n \t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n \t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n \t\t\t\tprocessPropertySource(propertySource);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n \t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t}\n \n \t\t// Process any @ComponentScan annotations\n \t\tSet<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n \t\tif (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tfor (AnnotationAttributes componentScan : componentScans) {\n \t\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Process any @Import annotations\n \t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true);\n \n \t\t// Process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getAliasedStringArray(\"locations\", ImportResource.class, sourceClass);\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// Process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// Process default methods on interfaces\n-\t\tfor (SourceClass ifc : sourceClass.getInterfaces()) {\n-\t\t\tbeanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName());\n-\t\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n-\t\t\t\tif (!methodMetadata.isAbstract()) {\n-\t\t\t\t\t// A default method or other concrete method on a Java 8+ interface...\n-\t\t\t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n+\t\tprocessInterfaces(configClass, sourceClass);\n \n \t\t// Process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// Superclass found, return its annotation metadata and recurse\n \t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t}\n \t\t}\n \n \t\t// No superclass -> processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"388bd87ef03b3c080f1c351855d01af1df033a94": {
			"type": "Ybodychange",
			"commitMessage": "ComponentScan annotation is repeatable now\n\nIssue: SPR-13151\n",
			"commitDate": "2015-12-29, 1:40 PM",
			"commitName": "388bd87ef03b3c080f1c351855d01af1df033a94",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2015-06-15, 7:46 AM",
			"commitNameOld": "1c01f575c2d3407e5c3c18a58d19ee00f5420249",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 197.29,
			"commitsBetweenForRepo": 933,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,77 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \t\t// Recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// Process any @PropertySource annotations\n \t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n \t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n \t\t\t\tprocessPropertySource(propertySource);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n \t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t}\n \n \t\t// Process any @ComponentScan annotations\n-\t\tAnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n-\t\tif (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n-\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n-\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n-\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n-\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if necessary\n-\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n-\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n-\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+\t\tSet<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n+\t\t\t\tsourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n+\t\tif (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n+\t\t\tfor (AnnotationAttributes componentScan : componentScans) {\n+\t\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n+\t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n+\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n+\t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if necessary\n+\t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n+\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n+\t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Process any @Import annotations\n \t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true);\n \n \t\t// Process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getAliasedStringArray(\"locations\", ImportResource.class, sourceClass);\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// Process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// Process default methods on interfaces\n \t\tfor (SourceClass ifc : sourceClass.getInterfaces()) {\n \t\t\tbeanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\t\tif (!methodMetadata.isAbstract()) {\n \t\t\t\t\t// A default method or other concrete method on a Java 8+ interface...\n \t\t\t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// Superclass found, return its annotation metadata and recurse\n \t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t}\n \t\t}\n \n \t\t// No superclass -> processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d3b5aeb768b89d960302b471bd4b3e913dd2df27": {
			"type": "Ybodychange",
			"commitMessage": "Introduce alias for 'value' attribute in @ImportResource\n\nIssue: SPR-11393\n",
			"commitDate": "2015-06-03, 7:26 PM",
			"commitName": "d3b5aeb768b89d960302b471bd4b3e913dd2df27",
			"commitAuthor": "Sam Brannen",
			"commitDateOld": "2015-03-23, 12:58 PM",
			"commitNameOld": "1a8c6fa5ee9e70ed880cd2e9afefc4fe38283f1e",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 72.27,
			"commitsBetweenForRepo": 427,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,74 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \t\t// Recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// Process any @PropertySource annotations\n \t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n \t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n \t\t\t\tprocessPropertySource(propertySource);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n \t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t}\n \n \t\t// Process any @ComponentScan annotations\n \t\tAnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n \t\tif (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Process any @Import annotations\n \t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true);\n \n \t\t// Process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n-\t\t\tString[] resources = importResource.getStringArray(\"value\");\n+\t\t\tString[] resources = importResource.getAliasedStringArray(\"locations\", ImportResource.class, sourceClass);\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// Process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// Process default methods on interfaces\n \t\tfor (SourceClass ifc : sourceClass.getInterfaces()) {\n \t\t\tbeanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\t\tif (!methodMetadata.isAbstract()) {\n \t\t\t\t\t// A default method or other concrete method on a Java 8+ interface...\n \t\t\t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// Superclass found, return its annotation metadata and recurse\n \t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t}\n \t\t}\n \n \t\t// No superclass -> processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1a8c6fa5ee9e70ed880cd2e9afefc4fe38283f1e": {
			"type": "Ybodychange",
			"commitMessage": "Deferred import processing reliably detects late registration attempts\n\nIssue: SPR-12838\n",
			"commitDate": "2015-03-23, 12:58 PM",
			"commitName": "1a8c6fa5ee9e70ed880cd2e9afefc4fe38283f1e",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2015-03-19, 9:50 AM",
			"commitNameOld": "192462902ef3d97c0b6684d467c7d2023ecd5be1",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 4.13,
			"commitsBetweenForRepo": 32,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,74 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \t\t// Recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// Process any @PropertySource annotations\n \t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n \t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n \t\t\t\tprocessPropertySource(propertySource);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n \t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t}\n \n \t\t// Process any @ComponentScan annotations\n \t\tAnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n \t\tif (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Process any @Import annotations\n-\t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true, false);\n+\t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true);\n \n \t\t// Process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// Process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// Process default methods on interfaces\n \t\tfor (SourceClass ifc : sourceClass.getInterfaces()) {\n \t\t\tbeanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\t\tif (!methodMetadata.isAbstract()) {\n \t\t\t\t\t// A default method or other concrete method on a Java 8+ interface...\n \t\t\t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// Superclass found, return its annotation metadata and recurse\n \t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t}\n \t\t}\n \n \t\t// No superclass -> processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"192462902ef3d97c0b6684d467c7d2023ecd5be1": {
			"type": "Ybodychange",
			"commitMessage": "Consistent support for Java 8 default methods (in interfaces implemented by user classes)\n\nCovers ReflectionUtils.doWithMethods as well as affected annotation post-processors.\nIncludes an extension of MethodMetadata for the detection of @Bean default methods.\n\nIssue: SPR-12822\nIssue: SPR-10919\n",
			"commitDate": "2015-03-19, 9:50 AM",
			"commitName": "192462902ef3d97c0b6684d467c7d2023ecd5be1",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2014-10-29, 3:08 PM",
			"commitNameOld": "c7a93a80d4866dacafa9bb522062fbf9ef75ddb2",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 140.78,
			"commitsBetweenForRepo": 469,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,63 +1,74 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \t\t// Recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// Process any @PropertySource annotations\n \t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n \t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n \t\t\t\tprocessPropertySource(propertySource);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n \t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t}\n \n \t\t// Process any @ComponentScan annotations\n \t\tAnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n \t\tif (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Process any @Import annotations\n \t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true, false);\n \n \t\t// Process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// Process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n+\t\t// Process default methods on interfaces\n+\t\tfor (SourceClass ifc : sourceClass.getInterfaces()) {\n+\t\t\tbeanMethods = ifc.getMetadata().getAnnotatedMethods(Bean.class.getName());\n+\t\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n+\t\t\t\tif (!methodMetadata.isAbstract()) {\n+\t\t\t\t\t// A default method or other concrete method on a Java 8+ interface...\n+\t\t\t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n \t\t// Process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// Superclass found, return its annotation metadata and recurse\n \t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t}\n \t\t}\n \n \t\t// No superclass -> processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"078f23d6e65c7c377b7e20681214e2c7fcf5f2b4": {
			"type": "Ybodychange",
			"commitMessage": "Polishing\n",
			"commitDate": "2014-08-22, 5:07 PM",
			"commitName": "078f23d6e65c7c377b7e20681214e2c7fcf5f2b4",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2014-08-22, 5:54 AM",
			"commitNameOld": "9dfbc5326b17ab48a0335efa4d82e15e6df0dfae",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 0.47,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,66 +1,63 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \t\t// Recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// Process any @PropertySource annotations\n \t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n \t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n \t\t\t\tprocessPropertySource(propertySource);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n \t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t}\n \n \t\t// Process any @ComponentScan annotations\n \t\tAnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n-\t\tif (componentScan != null) {\n-\t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n-\t\t\tif (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n-\t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n-\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n-\n-\t\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n-\t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n-\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n-\t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n-\t\t\t\t\t}\n+\t\tif (componentScan != null && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n+\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n+\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n+\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n+\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if necessary\n+\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n+\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n+\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Process any @Import annotations\n \t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true, false);\n \n \t\t// Process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// Process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// Process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// Superclass found, return its annotation metadata and recurse\n \t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t}\n \t\t}\n \n-\t\t// No superclass, processing is complete\n+\t\t// No superclass -> processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9dfbc5326b17ab48a0335efa4d82e15e6df0dfae": {
			"type": "Ybodychange",
			"commitMessage": "Revised ResourcePropertySource in order to avoid ConfigurationClassProcessor's AnnotationPropertySource subclass\n\nIssue: SPR-12115\n",
			"commitDate": "2014-08-22, 5:54 AM",
			"commitName": "9dfbc5326b17ab48a0335efa4d82e15e6df0dfae",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2014-08-21, 10:21 PM",
			"commitNameOld": "84564a0c7b6c34cec4beede6ee75078a6073abb9",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 0.31,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,66 +1,66 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \t\t// Recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// Process any @PropertySource annotations\n \t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n-\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n-\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotation on \"\n-\t\t\t\t\t\t+ sourceClass.getMetadata().getClassName()\n-\t\t\t\t\t\t+ \"Reason: Environment must implement ConfigurableEnvironment\");\n-\t\t\t} else {\n+\t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n \t\t\t\tprocessPropertySource(propertySource);\n \t\t\t}\n+\t\t\telse {\n+\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n+\t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n+\t\t\t}\n \t\t}\n \n \t\t// Process any @ComponentScan annotations\n \t\tAnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tif (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \n \t\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Process any @Import annotations\n \t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true, false);\n \n \t\t// Process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// Process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// Process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// Superclass found, return its annotation metadata and recurse\n \t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t}\n \t\t}\n \n \t\t// No superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"84564a0c7b6c34cec4beede6ee75078a6073abb9": {
			"type": "Ybodychange",
			"commitMessage": "Rework @PropertySource early parsing logic\n\nRework the @PropertySource parsing logic recently changed in commit\n7c608886 to deal with the same source appearing on a @Configuration\nclass and an @Import class.\n\nProcessing now occurs in a single sweep, with any previously added\nsources being converted to a CompositePropertySource.\n\nIssue: SPR-12115\n",
			"commitDate": "2014-08-21, 10:21 PM",
			"commitName": "84564a0c7b6c34cec4beede6ee75078a6073abb9",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2014-08-21, 2:43 PM",
			"commitNameOld": "7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 0.32,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,63 +1,66 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \t\t// Recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// Process any @PropertySource annotations\n \t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n-\t\t\tprocessPropertySource(propertySource);\n+\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n+\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotation on \"\n+\t\t\t\t\t\t+ sourceClass.getMetadata().getClassName()\n+\t\t\t\t\t\t+ \"Reason: Environment must implement ConfigurableEnvironment\");\n+\t\t\t} else {\n+\t\t\t\tprocessPropertySource(propertySource);\n+\t\t\t}\n \t\t}\n \n-\t\t// Register PropertySources with Environment\n-\t\tregisterPropertySources();\n-\n \t\t// Process any @ComponentScan annotations\n \t\tAnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tif (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \n \t\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Process any @Import annotations\n \t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true, false);\n \n \t\t// Process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// Process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// Process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// Superclass found, return its annotation metadata and recurse\n \t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t}\n \t\t}\n \n \t\t// No superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6": {
			"type": "Ybodychange",
			"commitMessage": "@PropertySource gets parsed as early as possible\n\nOther PropertySources and in particular @ComponentScan can benefit from previously declared property sources on the same configuration class.\n\nIssue: SPR-12110\nIssue: SPR-12111\n",
			"commitDate": "2014-08-21, 2:43 PM",
			"commitName": "7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2014-08-12, 9:23 AM",
			"commitNameOld": "71c6eb2bb594f29803b6ec4a50de875def98be86",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 9.22,
			"commitsBetweenForRepo": 63,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,60 +1,63 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n-\t\t// recursively process any member (nested) classes first\n+\t\t// Recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n-\t\t// process any @PropertySource annotations\n+\t\t// Process any @PropertySource annotations\n \t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n \t\t\tprocessPropertySource(propertySource);\n \t\t}\n \n-\t\t// process any @ComponentScan annotations\n+\t\t// Register PropertySources with Environment\n+\t\tregisterPropertySources();\n+\n+\t\t// Process any @ComponentScan annotations\n \t\tAnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tif (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \n \t\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\t// process any @Import annotations\n+\t\t// Process any @Import annotations\n \t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true, false);\n \n-\t\t// process any @ImportResource annotations\n+\t\t// Process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n-\t\t// process individual @Bean methods\n+\t\t// Process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n-\t\t// process superclass, if any\n+\t\t// Process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n-\t\t\t\t// superclass found, return its annotation metadata and recurse\n+\t\t\t\t// Superclass found, return its annotation metadata and recurse\n \t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t}\n \t\t}\n \n-\t\t// no superclass, processing is complete\n+\t\t// No superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"bbf58008314bd42dd20c92602c1133287423dc7f": {
			"type": "Ybodychange",
			"commitMessage": "ConfigurationClassParser processes late-arriving DeferredImportSelectors as regular import selectors\n\nAlso contains refined exception handling, treating regular class loading and ASM-based loading consistently in terms of exception wrapping, and always mentioning the current configuration class in all exception messages.\n\nIssue: SPR-11997\n",
			"commitDate": "2014-07-15, 2:04 PM",
			"commitName": "bbf58008314bd42dd20c92602c1133287423dc7f",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2014-06-06, 6:01 AM",
			"commitNameOld": "6aa9c40552c8b446ffcbd71bf2edc17b5ca38c77",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 39.34,
			"commitsBetweenForRepo": 230,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,65 +1,60 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \t\t// recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// process any @PropertySource annotations\n \t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n \t\t\tprocessPropertySource(propertySource);\n \t\t}\n \n \t\t// process any @ComponentScan annotations\n \t\tAnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tif (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \n \t\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n-\t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true);\n+\t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true, false);\n \n \t\t// process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n-\t\t\t\ttry {\n-\t\t\t\t\treturn sourceClass.getSuperClass();\n-\t\t\t\t}\n-\t\t\t\tcatch (ClassNotFoundException ex) {\n-\t\t\t\t\tthrow new IllegalStateException(ex);\n-\t\t\t\t}\n+\t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ce1954da1edd64f1280ead0435c7b3923e33f6da": {
			"type": "Ybodychange",
			"commitMessage": "Configuration class processing explicitly skips java.* classes since we'll never find @Bean annotations there anyway\n\nIssue: SPR-11718\n(cherry picked from commit c8ea80d)\n",
			"commitDate": "2014-04-27, 4:33 PM",
			"commitName": "ce1954da1edd64f1280ead0435c7b3923e33f6da",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2014-04-09, 9:43 AM",
			"commitNameOld": "0041e245a1f80affba828c79fd8db13b0319fb85",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 18.28,
			"commitsBetweenForRepo": 92,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,65 +1,65 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \t\t// recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// process any @PropertySource annotations\n \t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n \t\t\t\tsourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n \t\t\tprocessPropertySource(propertySource);\n \t\t}\n \n \t\t// process any @ComponentScan annotations\n \t\tAnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tif (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \n \t\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n \t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true);\n \n \t\t// process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n-\t\t\tif (!this.knownSuperclasses.containsKey(superclass)) {\n+\t\t\tif (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n \t\t\t\ttry {\n \t\t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t\t}\n \t\t\t\tcatch (ClassNotFoundException ex) {\n \t\t\t\t\tthrow new IllegalStateException(ex);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e8dead247c7d421074caf171456e0653d63780f7": {
			"type": "Ybodychange",
			"commitMessage": "@EnableTransactionManagement and co get detected on superclasses as well\n\nIssue: SPR-10864\n",
			"commitDate": "2013-12-02, 2:59 AM",
			"commitName": "e8dead247c7d421074caf171456e0653d63780f7",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2013-11-25, 1:52 PM",
			"commitNameOld": "59002f245623d758765b72d598cd78c326c6f5fa",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 6.55,
			"commitsBetweenForRepo": 18,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,66 +1,65 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \t\t// recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// process any @PropertySource annotations\n \t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n-\t\t\t\tsourceClass.getMetadata(), PropertySources.class,\n-\t\t\t\torg.springframework.context.annotation.PropertySource.class)) {\n+\t\t\t\tsourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n \t\t\tprocessPropertySource(propertySource);\n \t\t}\n \n \t\t// process any @ComponentScan annotations\n \t\tAnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tif (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \n \t\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n-\t\tprocessImports(configClass, getImports(sourceClass), true);\n+\t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true);\n \n \t\t// process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n \t\t\t\ttry {\n \t\t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t\t}\n \t\t\t\tcatch (ClassNotFoundException ex) {\n \t\t\t\t\tthrow new IllegalStateException(ex);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e95bd9e25086bf1dad37f8d08293c948621faf6b": {
			"type": "Ybodychange",
			"commitMessage": "Add @PropertySources and ignoreResourceNotFound\n\nSupport repeatable @PropertySource annotations in Java 8 and add\n@PropertySources container annotation for Java 6/7. Also add an\nignoreResourceNotFound attribute to @PropertySource allowing missing\nproperty resources to be silently ignored.\n\nThis commit also introduces some generally useful methods to\nAnnotationUtils for working with @Repeatable annotations.\n\nIssue: SPR-8371\n",
			"commitDate": "2013-10-22, 12:15 PM",
			"commitName": "e95bd9e25086bf1dad37f8d08293c948621faf6b",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2013-10-21, 2:11 PM",
			"commitNameOld": "e3d3d8cd9569ceb5db3dd00d8104a979c7dfe82d",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 0.92,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,66 +1,66 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \t\t// recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// process any @PropertySource annotations\n-\t\tAnnotationAttributes propertySource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(),\n-\t\t\t\torg.springframework.context.annotation.PropertySource.class);\n-\t\tif (propertySource != null) {\n+\t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n+\t\t\t\tsourceClass.getMetadata(), PropertySources.class,\n+\t\t\t\torg.springframework.context.annotation.PropertySource.class)) {\n \t\t\tprocessPropertySource(propertySource);\n \t\t}\n \n \t\t// process any @ComponentScan annotations\n \t\tAnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tif (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \n \t\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n \t\tprocessImports(configClass, getImports(sourceClass), true);\n \n \t\t// process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n \t\t\t\ttry {\n \t\t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t\t}\n \t\t\t\tcatch (ClassNotFoundException ex) {\n \t\t\t\t\tthrow new IllegalStateException(ex);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d87838fc6d0923659465ca5b75d8e0ba628afb77": {
			"type": "Ybodychange",
			"commitMessage": "Polishing\n",
			"commitDate": "2013-10-15, 5:51 PM",
			"commitName": "d87838fc6d0923659465ca5b75d8e0ba628afb77",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2013-08-27, 4:00 PM",
			"commitNameOld": "5efe894ee4969a7c3780a2fd4d2ceab695777c50",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 49.08,
			"commitsBetweenForRepo": 171,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,65 +1,66 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \t\t// recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// process any @PropertySource annotations\n-\t\tAnnotationAttributes propertySource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n+\t\tAnnotationAttributes propertySource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(),\n+\t\t\t\torg.springframework.context.annotation.PropertySource.class);\n \t\tif (propertySource != null) {\n \t\t\tprocessPropertySource(propertySource);\n \t\t}\n \n \t\t// process any @ComponentScan annotations\n \t\tAnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n-\t\t\tif (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n+\t\t\tif (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \n \t\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n \t\tprocessImports(configClass, getImports(sourceClass), true);\n \n \t\t// process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n \t\t\t\ttry {\n \t\t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t\t}\n \t\t\t\tcatch (ClassNotFoundException ex) {\n \t\t\t\t\tthrow new IllegalStateException(ex);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ced5ea2f93a474646e9554354ca09c0c12e967e8": {
			"type": "Ybodychange",
			"commitMessage": "Revert \"Ensure @Conditions consider super classes\"\n\nThis reverts commit 620c16f5c7bb543b18f71b2848f90461f8646237.\n",
			"commitDate": "2013-08-27, 11:39 AM",
			"commitName": "ced5ea2f93a474646e9554354ca09c0c12e967e8",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2013-08-26, 6:12 PM",
			"commitNameOld": "620c16f5c7bb543b18f71b2848f90461f8646237",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 0.73,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,60 +1,65 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \t\t// recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// process any @PropertySource annotations\n \t\tAnnotationAttributes propertySource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n \t\tif (propertySource != null) {\n \t\t\tprocessPropertySource(propertySource);\n \t\t}\n \n \t\t// process any @ComponentScan annotations\n \t\tAnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n-\t\t\tif (!shouldSkip(sourceClass, ConfigurationPhase.REGISTER_BEAN)) {\n+\t\t\tif (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \n \t\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n \t\tprocessImports(configClass, getImports(sourceClass), true);\n \n \t\t// process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n-\t\t\t\treturn sourceClass.getSuperClass();\n+\t\t\t\ttry {\n+\t\t\t\t\treturn sourceClass.getSuperClass();\n+\t\t\t\t}\n+\t\t\t\tcatch (ClassNotFoundException ex) {\n+\t\t\t\t\tthrow new IllegalStateException(ex);\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"620c16f5c7bb543b18f71b2848f90461f8646237": {
			"type": "Ybodychange",
			"commitMessage": "Ensure @Conditions consider super classes\n\nFix @Condition evaluation to also consider super classes for both\n@Configuration classes and regular @Components. This change allows\n@Conditional annotations to be inherited and restores the previous\nbehavior of @Profile.\n\nIssue: SPR-10840\n",
			"commitDate": "2013-08-26, 6:12 PM",
			"commitName": "620c16f5c7bb543b18f71b2848f90461f8646237",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2013-08-23, 8:49 AM",
			"commitNameOld": "c9771012e98afe1679cd1c3ebf5ab6c1a018fd65",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 3.39,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,65 +1,60 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \t\t// recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// process any @PropertySource annotations\n \t\tAnnotationAttributes propertySource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n \t\tif (propertySource != null) {\n \t\t\tprocessPropertySource(propertySource);\n \t\t}\n \n \t\t// process any @ComponentScan annotations\n \t\tAnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n-\t\t\tif (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n+\t\t\tif (!shouldSkip(sourceClass, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \n \t\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n \t\tprocessImports(configClass, getImports(sourceClass), true);\n \n \t\t// process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n-\t\t\t\ttry {\n-\t\t\t\t\treturn sourceClass.getSuperClass();\n-\t\t\t\t}\n-\t\t\t\tcatch (ClassNotFoundException ex) {\n-\t\t\t\t\tthrow new IllegalStateException(ex);\n-\t\t\t\t}\n+\t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c9771012e98afe1679cd1c3ebf5ab6c1a018fd65": {
			"type": "Ybodychange",
			"commitMessage": "Introduced @Description annotation for populating BeanDefinition.getDescription()\n\nIssue: SPR-10583\n",
			"commitDate": "2013-08-23, 8:49 AM",
			"commitName": "c9771012e98afe1679cd1c3ebf5ab6c1a018fd65",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2013-07-30, 2:36 PM",
			"commitNameOld": "481aeeec984433f11781a1999328f9c85848d1b3",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 23.76,
			"commitsBetweenForRepo": 90,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,65 +1,65 @@\n \tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \t\t// recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// process any @PropertySource annotations\n-\t\tAnnotationAttributes propertySource = attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n+\t\tAnnotationAttributes propertySource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n \t\tif (propertySource != null) {\n \t\t\tprocessPropertySource(propertySource);\n \t\t}\n \n \t\t// process any @ComponentScan annotations\n-\t\tAnnotationAttributes componentScan = attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n+\t\tAnnotationAttributes componentScan = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tif (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \n \t\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n \t\tprocessImports(configClass, getImports(sourceClass), true);\n \n \t\t// process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n-\t\t\tAnnotationAttributes importResource = attributesFor(sourceClass.getMetadata(), ImportResource.class);\n+\t\t\tAnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n \t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n \t\t\t\ttry {\n \t\t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t\t}\n \t\t\t\tcatch (ClassNotFoundException ex) {\n \t\t\t\t\tthrow new IllegalStateException(ex);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1a8f0d6a9e37d12b31a2fe7bc1fbc2c91700a08e": {
			"type": "Ybodychange",
			"commitMessage": "Resolve ${} placeholders in @ImportResource\n\nUpdate ConfigurationClassParser to resolve any ${} placeholders from\n@ImportResource values.\n\nIssue: SPR-10686\n",
			"commitDate": "2013-07-19, 2:10 PM",
			"commitName": "1a8f0d6a9e37d12b31a2fe7bc1fbc2c91700a08e",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2013-06-12, 12:45 PM",
			"commitNameOld": "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 37.06,
			"commitsBetweenForRepo": 119,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,66 +1,67 @@\n \tprotected final SourceClass doProcessConfigurationClass(\n \t\t\tConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// process any @PropertySource annotations\n \t\tAnnotationAttributes propertySource = attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n \t\tif (propertySource != null) {\n \t\t\tprocessPropertySource(propertySource);\n \t\t}\n \n \t\t// process any @ComponentScan annotations\n \t\tAnnotationAttributes componentScan = attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tif (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \n \t\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n \t\tprocessImports(configClass, getImports(sourceClass), true);\n \n \t\t// process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n-\t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n+\t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n+\t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n \t\t\t\ttry {\n \t\t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t\t}\n \t\t\t\tcatch (ClassNotFoundException ex) {\n \t\t\t\t\tthrow new IllegalStateException(ex);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6": {
			"type": "Ybodychange",
			"commitMessage": "Improve support for @Conditional on @Configuration\n\nIntroduce new ConfigurationCondition interface allowing more\nfine-grained control for @Conditional when used with @Configuration\nbeans.\n\nPrimarily added so that the evaluation of conditions that inspect bean\ndefinitions can be deferred until all @Configuration classes have been\nparsed.\n\nIssue: SPR-10534\n",
			"commitDate": "2013-06-12, 12:45 PM",
			"commitName": "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2013-06-10, 10:25 AM",
			"commitNameOld": "e10e16cd6b2a2342a6b7d169878117046b6c5e16",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 2.1,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,67 +1,66 @@\n \tprotected final SourceClass doProcessConfigurationClass(\n \t\t\tConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// process any @PropertySource annotations\n \t\tAnnotationAttributes propertySource = attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n \t\tif (propertySource != null) {\n \t\t\tprocessPropertySource(propertySource);\n \t\t}\n \n \t\t// process any @ComponentScan annotations\n \t\tAnnotationAttributes componentScan = attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n-\t\t\tif (!ConditionEvaluator.get(configClass.getMetadata(), false).shouldSkip(\n-\t\t\t\t\tthis.registry, this.environment)) {\n+\t\t\tif (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \n \t\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n-\t\t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+\t\t\t\t\t\tparse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n \t\tprocessImports(configClass, getImports(sourceClass), true);\n \n \t\t// process any @ImportResource annotations\n \t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n \t\tif (sourceClass.getMetadata().hasSuperClass()) {\n \t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n \t\t\t\ttry {\n \t\t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t\t}\n \t\t\t\tcatch (ClassNotFoundException ex) {\n \t\t\t\t\tthrow new IllegalStateException(ex);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e10e16cd6b2a2342a6b7d169878117046b6c5e16": {
			"type": "Ymultichange(Yparameterchange,Yreturntypechange,Ymodifierchange,Ybodychange)",
			"commitMessage": "Support fall-back to ASM parsing @Configuration\n\nUpdate ConfigurationClassParser to fall-back to ASM parsing if standard\nannotation processing fails. This change allows @Conditional annotations\nthat refer to missing classes to work.\n\nThis commit also introduces a new inner SourceClass object that\nencapsulates the conditional logic required when reading the source\nclasses.\n\nIssue: SPR-10646\n",
			"commitDate": "2013-06-10, 10:25 AM",
			"commitName": "e10e16cd6b2a2342a6b7d169878117046b6c5e16",
			"commitAuthor": "Phillip Webb",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Support fall-back to ASM parsing @Configuration\n\nUpdate ConfigurationClassParser to fall-back to ASM parsing if standard\nannotation processing fails. This change allows @Conditional annotations\nthat refer to missing classes to work.\n\nThis commit also introduces a new inner SourceClass object that\nencapsulates the conditional logic required when reading the source\nclasses.\n\nIssue: SPR-10646\n",
					"commitDate": "2013-06-10, 10:25 AM",
					"commitName": "e10e16cd6b2a2342a6b7d169878117046b6c5e16",
					"commitAuthor": "Phillip Webb",
					"commitDateOld": "2013-06-04, 11:27 AM",
					"commitNameOld": "239ce1466ce118294f5c7b8e842a80815fd813de",
					"commitAuthorOld": "Phillip Webb",
					"daysBetweenCommits": 5.96,
					"commitsBetweenForRepo": 11,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,84 +1,67 @@\n-\tprotected AnnotationMetadata doProcessConfigurationClass(\n-\t\t\tConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n+\tprotected final SourceClass doProcessConfigurationClass(\n+\t\t\tConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n-\t\tprocessMemberClasses(configClass, metadata);\n+\t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// process any @PropertySource annotations\n-\t\tAnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n+\t\tAnnotationAttributes propertySource = attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n \t\tif (propertySource != null) {\n \t\t\tprocessPropertySource(propertySource);\n \t\t}\n \n \t\t// process any @ComponentScan annotations\n-\t\tAnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n+\t\tAnnotationAttributes componentScan = attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tif (!ConditionEvaluator.get(configClass.getMetadata(), false).shouldSkip(\n \t\t\t\t\tthis.registry, this.environment)) {\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n-\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, metadata.getClassName());\n+\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \n \t\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n-\t\tSet<Object> imports = new LinkedHashSet<Object>();\n-\t\tSet<Object> visited = new LinkedHashSet<Object>();\n-\t\tcollectImports(metadata, imports, visited);\n-\t\tif (!imports.isEmpty()) {\n-\t\t\tprocessImport(configClass, imports, true);\n-\t\t}\n+\t\tprocessImports(configClass, getImports(sourceClass), true);\n \n \t\t// process any @ImportResource annotations\n-\t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n-\t\t\tAnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n+\t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n+\t\t\tAnnotationAttributes importResource = attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n-\t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n+\t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n-\t\tif (metadata.hasSuperClass()) {\n-\t\t\tString superclass = metadata.getSuperClassName();\n+\t\tif (sourceClass.getMetadata().hasSuperClass()) {\n+\t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n-\t\t\t\tif (metadata instanceof StandardAnnotationMetadata) {\n-\t\t\t\t\tClass<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n-\t\t\t\t\treturn new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n+\t\t\t\ttry {\n+\t\t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t\t}\n-\t\t\t\telse if (superclass.startsWith(\"java\")) {\n-\t\t\t\t\t// never load core JDK classes via ASM, in particular not java.lang.Object!\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\treturn new StandardAnnotationMetadata(\n-\t\t\t\t\t\t\t\tthis.resourceLoader.getClassLoader().loadClass(superclass), true);\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (ClassNotFoundException ex) {\n-\t\t\t\t\t\tthrow new IllegalStateException(ex);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n-\t\t\t\t\treturn reader.getAnnotationMetadata();\n+\t\t\t\tcatch (ClassNotFoundException ex) {\n+\t\t\t\t\tthrow new IllegalStateException(ex);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[configClass-ConfigurationClass, metadata-AnnotationMetadata]",
						"newValue": "[configClass-ConfigurationClass, sourceClass-SourceClass]"
					}
				},
				{
					"type": "Yreturntypechange",
					"commitMessage": "Support fall-back to ASM parsing @Configuration\n\nUpdate ConfigurationClassParser to fall-back to ASM parsing if standard\nannotation processing fails. This change allows @Conditional annotations\nthat refer to missing classes to work.\n\nThis commit also introduces a new inner SourceClass object that\nencapsulates the conditional logic required when reading the source\nclasses.\n\nIssue: SPR-10646\n",
					"commitDate": "2013-06-10, 10:25 AM",
					"commitName": "e10e16cd6b2a2342a6b7d169878117046b6c5e16",
					"commitAuthor": "Phillip Webb",
					"commitDateOld": "2013-06-04, 11:27 AM",
					"commitNameOld": "239ce1466ce118294f5c7b8e842a80815fd813de",
					"commitAuthorOld": "Phillip Webb",
					"daysBetweenCommits": 5.96,
					"commitsBetweenForRepo": 11,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,84 +1,67 @@\n-\tprotected AnnotationMetadata doProcessConfigurationClass(\n-\t\t\tConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n+\tprotected final SourceClass doProcessConfigurationClass(\n+\t\t\tConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n-\t\tprocessMemberClasses(configClass, metadata);\n+\t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// process any @PropertySource annotations\n-\t\tAnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n+\t\tAnnotationAttributes propertySource = attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n \t\tif (propertySource != null) {\n \t\t\tprocessPropertySource(propertySource);\n \t\t}\n \n \t\t// process any @ComponentScan annotations\n-\t\tAnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n+\t\tAnnotationAttributes componentScan = attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tif (!ConditionEvaluator.get(configClass.getMetadata(), false).shouldSkip(\n \t\t\t\t\tthis.registry, this.environment)) {\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n-\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, metadata.getClassName());\n+\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \n \t\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n-\t\tSet<Object> imports = new LinkedHashSet<Object>();\n-\t\tSet<Object> visited = new LinkedHashSet<Object>();\n-\t\tcollectImports(metadata, imports, visited);\n-\t\tif (!imports.isEmpty()) {\n-\t\t\tprocessImport(configClass, imports, true);\n-\t\t}\n+\t\tprocessImports(configClass, getImports(sourceClass), true);\n \n \t\t// process any @ImportResource annotations\n-\t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n-\t\t\tAnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n+\t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n+\t\t\tAnnotationAttributes importResource = attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n-\t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n+\t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n-\t\tif (metadata.hasSuperClass()) {\n-\t\t\tString superclass = metadata.getSuperClassName();\n+\t\tif (sourceClass.getMetadata().hasSuperClass()) {\n+\t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n-\t\t\t\tif (metadata instanceof StandardAnnotationMetadata) {\n-\t\t\t\t\tClass<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n-\t\t\t\t\treturn new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n+\t\t\t\ttry {\n+\t\t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t\t}\n-\t\t\t\telse if (superclass.startsWith(\"java\")) {\n-\t\t\t\t\t// never load core JDK classes via ASM, in particular not java.lang.Object!\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\treturn new StandardAnnotationMetadata(\n-\t\t\t\t\t\t\t\tthis.resourceLoader.getClassLoader().loadClass(superclass), true);\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (ClassNotFoundException ex) {\n-\t\t\t\t\t\tthrow new IllegalStateException(ex);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n-\t\t\t\t\treturn reader.getAnnotationMetadata();\n+\t\t\t\tcatch (ClassNotFoundException ex) {\n+\t\t\t\t\tthrow new IllegalStateException(ex);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "AnnotationMetadata",
						"newValue": "SourceClass"
					}
				},
				{
					"type": "Ymodifierchange",
					"commitMessage": "Support fall-back to ASM parsing @Configuration\n\nUpdate ConfigurationClassParser to fall-back to ASM parsing if standard\nannotation processing fails. This change allows @Conditional annotations\nthat refer to missing classes to work.\n\nThis commit also introduces a new inner SourceClass object that\nencapsulates the conditional logic required when reading the source\nclasses.\n\nIssue: SPR-10646\n",
					"commitDate": "2013-06-10, 10:25 AM",
					"commitName": "e10e16cd6b2a2342a6b7d169878117046b6c5e16",
					"commitAuthor": "Phillip Webb",
					"commitDateOld": "2013-06-04, 11:27 AM",
					"commitNameOld": "239ce1466ce118294f5c7b8e842a80815fd813de",
					"commitAuthorOld": "Phillip Webb",
					"daysBetweenCommits": 5.96,
					"commitsBetweenForRepo": 11,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,84 +1,67 @@\n-\tprotected AnnotationMetadata doProcessConfigurationClass(\n-\t\t\tConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n+\tprotected final SourceClass doProcessConfigurationClass(\n+\t\t\tConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n-\t\tprocessMemberClasses(configClass, metadata);\n+\t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// process any @PropertySource annotations\n-\t\tAnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n+\t\tAnnotationAttributes propertySource = attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n \t\tif (propertySource != null) {\n \t\t\tprocessPropertySource(propertySource);\n \t\t}\n \n \t\t// process any @ComponentScan annotations\n-\t\tAnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n+\t\tAnnotationAttributes componentScan = attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tif (!ConditionEvaluator.get(configClass.getMetadata(), false).shouldSkip(\n \t\t\t\t\tthis.registry, this.environment)) {\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n-\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, metadata.getClassName());\n+\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \n \t\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n-\t\tSet<Object> imports = new LinkedHashSet<Object>();\n-\t\tSet<Object> visited = new LinkedHashSet<Object>();\n-\t\tcollectImports(metadata, imports, visited);\n-\t\tif (!imports.isEmpty()) {\n-\t\t\tprocessImport(configClass, imports, true);\n-\t\t}\n+\t\tprocessImports(configClass, getImports(sourceClass), true);\n \n \t\t// process any @ImportResource annotations\n-\t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n-\t\t\tAnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n+\t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n+\t\t\tAnnotationAttributes importResource = attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n-\t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n+\t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n-\t\tif (metadata.hasSuperClass()) {\n-\t\t\tString superclass = metadata.getSuperClassName();\n+\t\tif (sourceClass.getMetadata().hasSuperClass()) {\n+\t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n-\t\t\t\tif (metadata instanceof StandardAnnotationMetadata) {\n-\t\t\t\t\tClass<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n-\t\t\t\t\treturn new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n+\t\t\t\ttry {\n+\t\t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t\t}\n-\t\t\t\telse if (superclass.startsWith(\"java\")) {\n-\t\t\t\t\t// never load core JDK classes via ASM, in particular not java.lang.Object!\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\treturn new StandardAnnotationMetadata(\n-\t\t\t\t\t\t\t\tthis.resourceLoader.getClassLoader().loadClass(superclass), true);\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (ClassNotFoundException ex) {\n-\t\t\t\t\t\tthrow new IllegalStateException(ex);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n-\t\t\t\t\treturn reader.getAnnotationMetadata();\n+\t\t\t\tcatch (ClassNotFoundException ex) {\n+\t\t\t\t\tthrow new IllegalStateException(ex);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[protected]",
						"newValue": "[protected, final]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Support fall-back to ASM parsing @Configuration\n\nUpdate ConfigurationClassParser to fall-back to ASM parsing if standard\nannotation processing fails. This change allows @Conditional annotations\nthat refer to missing classes to work.\n\nThis commit also introduces a new inner SourceClass object that\nencapsulates the conditional logic required when reading the source\nclasses.\n\nIssue: SPR-10646\n",
					"commitDate": "2013-06-10, 10:25 AM",
					"commitName": "e10e16cd6b2a2342a6b7d169878117046b6c5e16",
					"commitAuthor": "Phillip Webb",
					"commitDateOld": "2013-06-04, 11:27 AM",
					"commitNameOld": "239ce1466ce118294f5c7b8e842a80815fd813de",
					"commitAuthorOld": "Phillip Webb",
					"daysBetweenCommits": 5.96,
					"commitsBetweenForRepo": 11,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,84 +1,67 @@\n-\tprotected AnnotationMetadata doProcessConfigurationClass(\n-\t\t\tConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n+\tprotected final SourceClass doProcessConfigurationClass(\n+\t\t\tConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n-\t\tprocessMemberClasses(configClass, metadata);\n+\t\tprocessMemberClasses(configClass, sourceClass);\n \n \t\t// process any @PropertySource annotations\n-\t\tAnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n+\t\tAnnotationAttributes propertySource = attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n \t\tif (propertySource != null) {\n \t\t\tprocessPropertySource(propertySource);\n \t\t}\n \n \t\t// process any @ComponentScan annotations\n-\t\tAnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n+\t\tAnnotationAttributes componentScan = attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tif (!ConditionEvaluator.get(configClass.getMetadata(), false).shouldSkip(\n \t\t\t\t\tthis.registry, this.environment)) {\n \t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n-\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, metadata.getClassName());\n+\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n \n \t\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n-\t\tSet<Object> imports = new LinkedHashSet<Object>();\n-\t\tSet<Object> visited = new LinkedHashSet<Object>();\n-\t\tcollectImports(metadata, imports, visited);\n-\t\tif (!imports.isEmpty()) {\n-\t\t\tprocessImport(configClass, imports, true);\n-\t\t}\n+\t\tprocessImports(configClass, getImports(sourceClass), true);\n \n \t\t// process any @ImportResource annotations\n-\t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n-\t\t\tAnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n+\t\tif (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n+\t\t\tAnnotationAttributes importResource = attributesFor(sourceClass.getMetadata(), ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n-\t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n+\t\tSet<MethodMetadata> beanMethods = sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n-\t\tif (metadata.hasSuperClass()) {\n-\t\t\tString superclass = metadata.getSuperClassName();\n+\t\tif (sourceClass.getMetadata().hasSuperClass()) {\n+\t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n \t\t\tif (!this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n-\t\t\t\tif (metadata instanceof StandardAnnotationMetadata) {\n-\t\t\t\t\tClass<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n-\t\t\t\t\treturn new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n+\t\t\t\ttry {\n+\t\t\t\t\treturn sourceClass.getSuperClass();\n \t\t\t\t}\n-\t\t\t\telse if (superclass.startsWith(\"java\")) {\n-\t\t\t\t\t// never load core JDK classes via ASM, in particular not java.lang.Object!\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\treturn new StandardAnnotationMetadata(\n-\t\t\t\t\t\t\t\tthis.resourceLoader.getClassLoader().loadClass(superclass), true);\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (ClassNotFoundException ex) {\n-\t\t\t\t\t\tthrow new IllegalStateException(ex);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n-\t\t\t\t\treturn reader.getAnnotationMetadata();\n+\t\t\t\tcatch (ClassNotFoundException ex) {\n+\t\t\t\t\tthrow new IllegalStateException(ex);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"239ce1466ce118294f5c7b8e842a80815fd813de": {
			"type": "Ybodychange",
			"commitMessage": "Update @Conditional processing logic\n\nDefer @Conditional processing on @Configuration classes until the bean\ndefinitions are loaded, rather than when the @Configuration class is\nparsed. This provides better support for @Conditional implementations\nthat inspect bean definitions.\n\nThis commit also fixes some minor problems with original implementation\nand replaces the ConditionalAnnotationHelper class with\nConditionEvaluator.\n\nIssue: SPR-10534\n",
			"commitDate": "2013-06-04, 11:27 AM",
			"commitName": "239ce1466ce118294f5c7b8e842a80815fd813de",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2013-06-03, 1:19 PM",
			"commitNameOld": "4d3383242e5655631e44dee48ca7060add84f957",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 0.92,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,81 +1,84 @@\n \tprotected AnnotationMetadata doProcessConfigurationClass(\n \t\t\tConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, metadata);\n \n \t\t// process any @PropertySource annotations\n \t\tAnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n \t\tif (propertySource != null) {\n \t\t\tprocessPropertySource(propertySource);\n \t\t}\n \n \t\t// process any @ComponentScan annotations\n \t\tAnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n-\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n-\t\t\t\t\tthis.componentScanParser.parse(componentScan, metadata.getClassName());\n+\t\t\tif (!ConditionEvaluator.get(configClass.getMetadata(), false).shouldSkip(\n+\t\t\t\t\tthis.registry, this.environment)) {\n+\t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n+\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, metadata.getClassName());\n \n-\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n-\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n-\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n-\t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+\t\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n+\t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n+\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n+\t\t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n \t\tSet<Object> imports = new LinkedHashSet<Object>();\n \t\tSet<Object> visited = new LinkedHashSet<Object>();\n \t\tcollectImports(metadata, imports, visited);\n \t\tif (!imports.isEmpty()) {\n \t\t\tprocessImport(configClass, imports, true);\n \t\t}\n \n \t\t// process any @ImportResource annotations\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n \t\tif (metadata.hasSuperClass()) {\n \t\t\tString superclass = metadata.getSuperClassName();\n \t\t\tif (!this.knownSuperclasses.containsKey(superclass)) {\n \t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n \t\t\t\tif (metadata instanceof StandardAnnotationMetadata) {\n \t\t\t\t\tClass<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n \t\t\t\t\treturn new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n \t\t\t\t}\n \t\t\t\telse if (superclass.startsWith(\"java\")) {\n \t\t\t\t\t// never load core JDK classes via ASM, in particular not java.lang.Object!\n \t\t\t\t\ttry {\n \t\t\t\t\t\treturn new StandardAnnotationMetadata(\n \t\t\t\t\t\t\t\tthis.resourceLoader.getClassLoader().loadClass(superclass), true);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (ClassNotFoundException ex) {\n \t\t\t\t\t\tthrow new IllegalStateException(ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n \t\t\t\t\treturn reader.getAnnotationMetadata();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3f7007f73a3b8d660e9ff0224f1d87483650d2c2": {
			"type": "Ybodychange",
			"commitMessage": "Properly handle knownSuperclasses in case of an overridden ConfigurationClass\n\nIssue: SPR-10546\n(cherry picked from commit 6e4317e)\n",
			"commitDate": "2013-05-15, 6:30 AM",
			"commitName": "3f7007f73a3b8d660e9ff0224f1d87483650d2c2",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2013-05-13, 4:04 PM",
			"commitNameOld": "94685481162a93666fc2f39b66223833a6bcb418",
			"commitAuthorOld": "Rob Winch",
			"daysBetweenCommits": 1.6,
			"commitsBetweenForRepo": 16,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,81 +1,81 @@\n \tprotected AnnotationMetadata doProcessConfigurationClass(\n \t\t\tConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n \t\tprocessMemberClasses(configClass, metadata);\n \n \t\t// process any @PropertySource annotations\n \t\tAnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n \t\tif (propertySource != null) {\n \t\t\tprocessPropertySource(propertySource);\n \t\t}\n \n-\t\t// process any @ComponentScan annotions\n+\t\t// process any @ComponentScan annotations\n \t\tAnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\tthis.componentScanParser.parse(componentScan, metadata.getClassName());\n \n \t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n-\n \t\tSet<Object> imports = new LinkedHashSet<Object>();\n \t\tSet<Object> visited = new LinkedHashSet<Object>();\n \t\tcollectImports(metadata, imports, visited);\n \t\tif (!imports.isEmpty()) {\n \t\t\tprocessImport(configClass, imports, true);\n \t\t}\n \n \t\t// process any @ImportResource annotations\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n \t\tif (metadata.hasSuperClass()) {\n \t\t\tString superclass = metadata.getSuperClassName();\n-\t\t\tif (this.knownSuperclasses.add(superclass)) {\n+\t\t\tif (!this.knownSuperclasses.containsKey(superclass)) {\n+\t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n \t\t\t\tif (metadata instanceof StandardAnnotationMetadata) {\n \t\t\t\t\tClass<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n \t\t\t\t\treturn new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n \t\t\t\t}\n \t\t\t\telse if (superclass.startsWith(\"java\")) {\n \t\t\t\t\t// never load core JDK classes via ASM, in particular not java.lang.Object!\n \t\t\t\t\ttry {\n \t\t\t\t\t\treturn new StandardAnnotationMetadata(\n \t\t\t\t\t\t\t\tthis.resourceLoader.getClassLoader().loadClass(superclass), true);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (ClassNotFoundException ex) {\n \t\t\t\t\t\tthrow new IllegalStateException(ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n \t\t\t\t\treturn reader.getAnnotationMetadata();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b257253a2b6890ef532f27a662c441fc4fd21f3b": {
			"type": "Ybodychange",
			"commitMessage": "Support for @Conditional configuration\n\nIntroduce new @Conditional annotation that can be used to filter\nwhich @Configuration classes or methods are loaded. @Conditional\ncan be used directly or as a meta-annotation. Condition implementations\nare provided via the 'Condition' interface and are free to filter based\non any criteria available at the time that they run. The\nConditionalContext provides access to the BeanDefinitionRegistry,\nEnvironment and ConfigurableListableBeanFactory along with a\nResourceLoader and ClassLoader.\n\nThe existing @Profile annotation has been refactored as a @Conditional\nwith the added benefit that it can now be used as a method level\nannotation.\n",
			"commitDate": "2013-05-08, 8:41 PM",
			"commitName": "b257253a2b6890ef532f27a662c441fc4fd21f3b",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2013-05-06, 4:43 PM",
			"commitNameOld": "db0d780d4339953276447e034a6143abc3d83db9",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 2.16,
			"commitsBetweenForRepo": 22,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,81 +1,81 @@\n \tprotected AnnotationMetadata doProcessConfigurationClass(\n \t\t\tConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n-\t\tprocessMemberClasses(metadata);\n+\t\tprocessMemberClasses(configClass, metadata);\n \n \t\t// process any @PropertySource annotations\n \t\tAnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n \t\tif (propertySource != null) {\n \t\t\tprocessPropertySource(propertySource);\n \t\t}\n \n \t\t// process any @ComponentScan annotions\n \t\tAnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\tthis.componentScanParser.parse(componentScan, metadata.getClassName());\n \n \t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n \n \t\tSet<Object> imports = new LinkedHashSet<Object>();\n \t\tSet<Object> visited = new LinkedHashSet<Object>();\n \t\tcollectImports(metadata, imports, visited);\n \t\tif (!imports.isEmpty()) {\n \t\t\tprocessImport(configClass, imports, true);\n \t\t}\n \n \t\t// process any @ImportResource annotations\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n \t\tif (metadata.hasSuperClass()) {\n \t\t\tString superclass = metadata.getSuperClassName();\n \t\t\tif (this.knownSuperclasses.add(superclass)) {\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n \t\t\t\tif (metadata instanceof StandardAnnotationMetadata) {\n \t\t\t\t\tClass<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n \t\t\t\t\treturn new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n \t\t\t\t}\n \t\t\t\telse if (superclass.startsWith(\"java\")) {\n \t\t\t\t\t// never load core JDK classes via ASM, in particular not java.lang.Object!\n \t\t\t\t\ttry {\n \t\t\t\t\t\treturn new StandardAnnotationMetadata(\n \t\t\t\t\t\t\t\tthis.resourceLoader.getClassLoader().loadClass(superclass), true);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (ClassNotFoundException ex) {\n \t\t\t\t\t\tthrow new IllegalStateException(ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n \t\t\t\t\treturn reader.getAnnotationMetadata();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d3a406876834b91a4cf3b1e840855caeb0446d28": {
			"type": "Ybodychange",
			"commitMessage": "Minimized ASM usage\n\nIn particular, avoid accidental usage of ASM for core JDK types - which will fail in case of a new bytecode version in the JDK, even if the application itself has been compiled with an earlier bytecode target.\n\nIssue: SPR-10292\n",
			"commitDate": "2013-04-23, 5:49 AM",
			"commitName": "d3a406876834b91a4cf3b1e840855caeb0446d28",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2013-01-31, 8:51 AM",
			"commitNameOld": "6d77f1cf3b3f060ead70d49079bc87d75e0b105c",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 81.83,
			"commitsBetweenForRepo": 241,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,111 +1,81 @@\n \tprotected AnnotationMetadata doProcessConfigurationClass(\n \t\t\tConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n-\t\tfor (String memberClassName : metadata.getMemberClassNames()) {\n-\t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n-\t\t\tAnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n-\t\t\tif (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n-\t\t\t\tprocessConfigurationClass(new ConfigurationClass(reader, true));\n-\t\t\t}\n-\t\t}\n+\t\tprocessMemberClasses(metadata);\n \n \t\t// process any @PropertySource annotations\n-\t\tAnnotationAttributes propertySource =\n-\t\t\t\tattributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n+\t\tAnnotationAttributes propertySource = attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n \t\tif (propertySource != null) {\n-\t\t\tString name = propertySource.getString(\"name\");\n-\t\t\tString[] locations = propertySource.getStringArray(\"value\");\n-\t\t\tint nLocations = locations.length;\n-\t\t\tif (nLocations == 0) {\n-\t\t\t\tthrow new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n-\t\t\t}\n-\t\t\tfor (int i = 0; i < nLocations; i++) {\n-\t\t\t\tlocations[i] = this.environment.resolveRequiredPlaceholders(locations[i]);\n-\t\t\t}\n-\t\t\tClassLoader classLoader = this.resourceLoader.getClassLoader();\n-\t\t\tif (!StringUtils.hasText(name)) {\n-\t\t\t\tfor (String location : locations) {\n-\t\t\t\t\tthis.propertySources.push(new ResourcePropertySource(location, classLoader));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tif (nLocations == 1) {\n-\t\t\t\t\tthis.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tCompositePropertySource ps = new CompositePropertySource(name);\n-\t\t\t\t\tfor (String location : locations) {\n-\t\t\t\t\t\tps.addPropertySource(new ResourcePropertySource(location, classLoader));\n-\t\t\t\t\t}\n-\t\t\t\t\tthis.propertySources.push(ps);\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\tprocessPropertySource(propertySource);\n \t\t}\n \n \t\t// process any @ComponentScan annotions\n \t\tAnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\tthis.componentScanParser.parse(componentScan, metadata.getClassName());\n \n \t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n-\t\tSet<String> imports = getImports(metadata.getClassName(), null, new HashSet<String>());\n-\t\tif (!CollectionUtils.isEmpty(imports)) {\n-\t\t\tprocessImport(configClass, imports.toArray(new String[imports.size()]), true);\n+\n+\t\tSet<Object> imports = new LinkedHashSet<Object>();\n+\t\tSet<Object> visited = new LinkedHashSet<Object>();\n+\t\tcollectImports(metadata, imports, visited);\n+\t\tif (!imports.isEmpty()) {\n+\t\t\tprocessImport(configClass, imports, true);\n \t\t}\n \n \t\t// process any @ImportResource annotations\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n \t\tif (metadata.hasSuperClass()) {\n \t\t\tString superclass = metadata.getSuperClassName();\n \t\t\tif (this.knownSuperclasses.add(superclass)) {\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n \t\t\t\tif (metadata instanceof StandardAnnotationMetadata) {\n \t\t\t\t\tClass<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n \t\t\t\t\treturn new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n \t\t\t\t}\n \t\t\t\telse if (superclass.startsWith(\"java\")) {\n \t\t\t\t\t// never load core JDK classes via ASM, in particular not java.lang.Object!\n \t\t\t\t\ttry {\n \t\t\t\t\t\treturn new StandardAnnotationMetadata(\n \t\t\t\t\t\t\t\tthis.resourceLoader.getClassLoader().loadClass(superclass), true);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (ClassNotFoundException ex) {\n \t\t\t\t\t\tthrow new IllegalStateException(ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n \t\t\t\t\treturn reader.getAnnotationMetadata();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6d77f1cf3b3f060ead70d49079bc87d75e0b105c": {
			"type": "Ybodychange",
			"commitMessage": "ConfigurationClassPostProcessor consistently uses ClassLoader, not loading core JDK annotations via ASM\n\nIssue: SPR-10249\n",
			"commitDate": "2013-01-31, 8:51 AM",
			"commitName": "6d77f1cf3b3f060ead70d49079bc87d75e0b105c",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2012-12-05, 11:12 AM",
			"commitNameOld": "a92f7dd474406a02844ec635fde6c22eb8ef8456",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 56.9,
			"commitsBetweenForRepo": 297,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,111 +1,111 @@\n \tprotected AnnotationMetadata doProcessConfigurationClass(\n \t\t\tConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n \t\tfor (String memberClassName : metadata.getMemberClassNames()) {\n \t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n \t\t\tAnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n \t\t\tif (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n \t\t\t\tprocessConfigurationClass(new ConfigurationClass(reader, true));\n \t\t\t}\n \t\t}\n \n \t\t// process any @PropertySource annotations\n \t\tAnnotationAttributes propertySource =\n \t\t\t\tattributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n \t\tif (propertySource != null) {\n \t\t\tString name = propertySource.getString(\"name\");\n \t\t\tString[] locations = propertySource.getStringArray(\"value\");\n \t\t\tint nLocations = locations.length;\n \t\t\tif (nLocations == 0) {\n \t\t\t\tthrow new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n \t\t\t}\n \t\t\tfor (int i = 0; i < nLocations; i++) {\n \t\t\t\tlocations[i] = this.environment.resolveRequiredPlaceholders(locations[i]);\n \t\t\t}\n \t\t\tClassLoader classLoader = this.resourceLoader.getClassLoader();\n \t\t\tif (!StringUtils.hasText(name)) {\n \t\t\t\tfor (String location : locations) {\n \t\t\t\t\tthis.propertySources.push(new ResourcePropertySource(location, classLoader));\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif (nLocations == 1) {\n \t\t\t\t\tthis.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tCompositePropertySource ps = new CompositePropertySource(name);\n \t\t\t\t\tfor (String location : locations) {\n \t\t\t\t\t\tps.addPropertySource(new ResourcePropertySource(location, classLoader));\n \t\t\t\t\t}\n \t\t\t\t\tthis.propertySources.push(ps);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @ComponentScan annotions\n \t\tAnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\tthis.componentScanParser.parse(componentScan, metadata.getClassName());\n \n \t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n \t\tSet<String> imports = getImports(metadata.getClassName(), null, new HashSet<String>());\n-\t\tif (imports != null && !imports.isEmpty()) {\n+\t\tif (!CollectionUtils.isEmpty(imports)) {\n \t\t\tprocessImport(configClass, imports.toArray(new String[imports.size()]), true);\n \t\t}\n \n \t\t// process any @ImportResource annotations\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n \t\tif (metadata.hasSuperClass()) {\n \t\t\tString superclass = metadata.getSuperClassName();\n \t\t\tif (this.knownSuperclasses.add(superclass)) {\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n \t\t\t\tif (metadata instanceof StandardAnnotationMetadata) {\n \t\t\t\t\tClass<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n \t\t\t\t\treturn new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n \t\t\t\t}\n \t\t\t\telse if (superclass.startsWith(\"java\")) {\n \t\t\t\t\t// never load core JDK classes via ASM, in particular not java.lang.Object!\n \t\t\t\t\ttry {\n \t\t\t\t\t\treturn new StandardAnnotationMetadata(\n \t\t\t\t\t\t\t\tthis.resourceLoader.getClassLoader().loadClass(superclass), true);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (ClassNotFoundException ex) {\n \t\t\t\t\t\tthrow new IllegalStateException(ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n \t\t\t\t\treturn reader.getAnnotationMetadata();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a92f7dd474406a02844ec635fde6c22eb8ef8456": {
			"type": "Ybodychange",
			"commitMessage": "ConfigurationClassPostProcessor consistently uses ClassLoader, not loading core JDK classes via ASM\n\nIssue: SPR-10058\n",
			"commitDate": "2012-12-05, 11:12 AM",
			"commitName": "a92f7dd474406a02844ec635fde6c22eb8ef8456",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2012-11-12, 10:26 AM",
			"commitNameOld": "146a66fe0b7a0bb25b67ce5e2d1ca8a33039ec59",
			"commitAuthorOld": "Oliver Gierke",
			"daysBetweenCommits": 23.03,
			"commitsBetweenForRepo": 122,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,101 +1,111 @@\n \tprotected AnnotationMetadata doProcessConfigurationClass(\n \t\t\tConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n \t\tfor (String memberClassName : metadata.getMemberClassNames()) {\n \t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n \t\t\tAnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n \t\t\tif (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n \t\t\t\tprocessConfigurationClass(new ConfigurationClass(reader, true));\n \t\t\t}\n \t\t}\n \n \t\t// process any @PropertySource annotations\n \t\tAnnotationAttributes propertySource =\n \t\t\t\tattributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n \t\tif (propertySource != null) {\n \t\t\tString name = propertySource.getString(\"name\");\n \t\t\tString[] locations = propertySource.getStringArray(\"value\");\n \t\t\tint nLocations = locations.length;\n \t\t\tif (nLocations == 0) {\n \t\t\t\tthrow new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n \t\t\t}\n \t\t\tfor (int i = 0; i < nLocations; i++) {\n \t\t\t\tlocations[i] = this.environment.resolveRequiredPlaceholders(locations[i]);\n \t\t\t}\n \t\t\tClassLoader classLoader = this.resourceLoader.getClassLoader();\n \t\t\tif (!StringUtils.hasText(name)) {\n \t\t\t\tfor (String location : locations) {\n \t\t\t\t\tthis.propertySources.push(new ResourcePropertySource(location, classLoader));\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif (nLocations == 1) {\n \t\t\t\t\tthis.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tCompositePropertySource ps = new CompositePropertySource(name);\n \t\t\t\t\tfor (String location : locations) {\n \t\t\t\t\t\tps.addPropertySource(new ResourcePropertySource(location, classLoader));\n \t\t\t\t\t}\n \t\t\t\t\tthis.propertySources.push(ps);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @ComponentScan annotions\n \t\tAnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\tthis.componentScanParser.parse(componentScan, metadata.getClassName());\n \n \t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n \t\tSet<String> imports = getImports(metadata.getClassName(), null, new HashSet<String>());\n \t\tif (imports != null && !imports.isEmpty()) {\n \t\t\tprocessImport(configClass, imports.toArray(new String[imports.size()]), true);\n \t\t}\n \n \t\t// process any @ImportResource annotations\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n \t\tif (metadata.hasSuperClass()) {\n \t\t\tString superclass = metadata.getSuperClassName();\n \t\t\tif (this.knownSuperclasses.add(superclass)) {\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n \t\t\t\tif (metadata instanceof StandardAnnotationMetadata) {\n \t\t\t\t\tClass<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n \t\t\t\t\treturn new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n \t\t\t\t}\n+\t\t\t\telse if (superclass.startsWith(\"java\")) {\n+\t\t\t\t\t// never load core JDK classes via ASM, in particular not java.lang.Object!\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\treturn new StandardAnnotationMetadata(\n+\t\t\t\t\t\t\t\tthis.resourceLoader.getClassLoader().loadClass(superclass), true);\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (ClassNotFoundException ex) {\n+\t\t\t\t\t\tthrow new IllegalStateException(ex);\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n \t\t\t\t\treturn reader.getAnnotationMetadata();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4cdf46f83c775c5101bc664c819fd5c0bb0682f7": {
			"type": "Ybodychange",
			"commitMessage": "Polish @Imports search code\n\nIssue: SPR-9925\n",
			"commitDate": "2012-10-31, 10:30 AM",
			"commitName": "4cdf46f83c775c5101bc664c819fd5c0bb0682f7",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2012-10-31, 6:40 AM",
			"commitNameOld": "3416e058a01d80d22c52c8c6fb720454be4c4290",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 0.16,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,98 +1,101 @@\n \tprotected AnnotationMetadata doProcessConfigurationClass(\n \t\t\tConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n \t\tfor (String memberClassName : metadata.getMemberClassNames()) {\n \t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n \t\t\tAnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n \t\t\tif (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n \t\t\t\tprocessConfigurationClass(new ConfigurationClass(reader, true));\n \t\t\t}\n \t\t}\n \n \t\t// process any @PropertySource annotations\n \t\tAnnotationAttributes propertySource =\n \t\t\t\tattributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n \t\tif (propertySource != null) {\n \t\t\tString name = propertySource.getString(\"name\");\n \t\t\tString[] locations = propertySource.getStringArray(\"value\");\n \t\t\tint nLocations = locations.length;\n \t\t\tif (nLocations == 0) {\n \t\t\t\tthrow new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n \t\t\t}\n \t\t\tfor (int i = 0; i < nLocations; i++) {\n \t\t\t\tlocations[i] = this.environment.resolveRequiredPlaceholders(locations[i]);\n \t\t\t}\n \t\t\tClassLoader classLoader = this.resourceLoader.getClassLoader();\n \t\t\tif (!StringUtils.hasText(name)) {\n \t\t\t\tfor (String location : locations) {\n \t\t\t\t\tthis.propertySources.push(new ResourcePropertySource(location, classLoader));\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif (nLocations == 1) {\n \t\t\t\t\tthis.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tCompositePropertySource ps = new CompositePropertySource(name);\n \t\t\t\t\tfor (String location : locations) {\n \t\t\t\t\t\tps.addPropertySource(new ResourcePropertySource(location, classLoader));\n \t\t\t\t\t}\n \t\t\t\t\tthis.propertySources.push(ps);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @ComponentScan annotions\n \t\tAnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\tthis.componentScanParser.parse(componentScan, metadata.getClassName());\n \n \t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n-\t\tprocessImport(configClass, getImports(metadata.getClassName()), true);\n+\t\tSet<String> imports = getImports(metadata.getClassName(), null, new HashSet<String>());\n+\t\tif (imports != null && !imports.isEmpty()) {\n+\t\t\tprocessImport(configClass, imports.toArray(new String[imports.size()]), true);\n+\t\t}\n \n \t\t// process any @ImportResource annotations\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n \t\tif (metadata.hasSuperClass()) {\n \t\t\tString superclass = metadata.getSuperClassName();\n \t\t\tif (this.knownSuperclasses.add(superclass)) {\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n \t\t\t\tif (metadata instanceof StandardAnnotationMetadata) {\n \t\t\t\t\tClass<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n \t\t\t\t\treturn new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n \t\t\t\t\treturn reader.getAnnotationMetadata();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3416e058a01d80d22c52c8c6fb720454be4c4290": {
			"type": "Ybodychange",
			"commitMessage": "Ensure @Imports are processed in correct order\n\nIssue: SPR-9925\n",
			"commitDate": "2012-10-31, 6:40 AM",
			"commitName": "3416e058a01d80d22c52c8c6fb720454be4c4290",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2012-10-31, 2:42 AM",
			"commitNameOld": "6d8b37d8bbce8c6e6cb4890291469c80742132f7",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 0.17,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,101 +1,98 @@\n \tprotected AnnotationMetadata doProcessConfigurationClass(\n \t\t\tConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n \t\tfor (String memberClassName : metadata.getMemberClassNames()) {\n \t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n \t\t\tAnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n \t\t\tif (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n \t\t\t\tprocessConfigurationClass(new ConfigurationClass(reader, true));\n \t\t\t}\n \t\t}\n \n \t\t// process any @PropertySource annotations\n \t\tAnnotationAttributes propertySource =\n \t\t\t\tattributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n \t\tif (propertySource != null) {\n \t\t\tString name = propertySource.getString(\"name\");\n \t\t\tString[] locations = propertySource.getStringArray(\"value\");\n \t\t\tint nLocations = locations.length;\n \t\t\tif (nLocations == 0) {\n \t\t\t\tthrow new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n \t\t\t}\n \t\t\tfor (int i = 0; i < nLocations; i++) {\n \t\t\t\tlocations[i] = this.environment.resolveRequiredPlaceholders(locations[i]);\n \t\t\t}\n \t\t\tClassLoader classLoader = this.resourceLoader.getClassLoader();\n \t\t\tif (!StringUtils.hasText(name)) {\n \t\t\t\tfor (String location : locations) {\n \t\t\t\t\tthis.propertySources.push(new ResourcePropertySource(location, classLoader));\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif (nLocations == 1) {\n \t\t\t\t\tthis.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tCompositePropertySource ps = new CompositePropertySource(name);\n \t\t\t\t\tfor (String location : locations) {\n \t\t\t\t\t\tps.addPropertySource(new ResourcePropertySource(location, classLoader));\n \t\t\t\t\t}\n \t\t\t\t\tthis.propertySources.push(ps);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @ComponentScan annotions\n \t\tAnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\tthis.componentScanParser.parse(componentScan, metadata.getClassName());\n \n \t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n-\t\tSet<String> imports = getImports(metadata.getClassName(), null, new HashSet<String>());\n-\t\tif (imports != null && !imports.isEmpty()) {\n-\t\t\tprocessImport(configClass, imports.toArray(new String[imports.size()]), true);\n-\t\t}\n+\t\tprocessImport(configClass, getImports(metadata.getClassName()), true);\n \n \t\t// process any @ImportResource annotations\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n \t\tif (metadata.hasSuperClass()) {\n \t\t\tString superclass = metadata.getSuperClassName();\n \t\t\tif (this.knownSuperclasses.add(superclass)) {\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n \t\t\t\tif (metadata instanceof StandardAnnotationMetadata) {\n \t\t\t\t\tClass<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n \t\t\t\t\treturn new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n \t\t\t\t\treturn reader.getAnnotationMetadata();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6d8b37d8bbce8c6e6cb4890291469c80742132f7": {
			"type": "Ybodychange",
			"commitMessage": "Prevent duplicate @Import processing\n\nRefactor ConfigurationClassParser to recursively find values from\nall @Import annotations, combining them into a single unique set.\n\nThis change prevents ImportBeanDefinitionRegistrars from being\ninvoked twice.\n\nIssue: SPR-9925\n",
			"commitDate": "2012-10-31, 2:42 AM",
			"commitName": "6d8b37d8bbce8c6e6cb4890291469c80742132f7",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2012-09-11, 8:50 AM",
			"commitNameOld": "73832f8c6e51eb305b88dfc11815801d18b4d567",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 49.74,
			"commitsBetweenForRepo": 182,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,102 +1,101 @@\n \tprotected AnnotationMetadata doProcessConfigurationClass(\n \t\t\tConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n \t\tfor (String memberClassName : metadata.getMemberClassNames()) {\n \t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n \t\t\tAnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n \t\t\tif (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n \t\t\t\tprocessConfigurationClass(new ConfigurationClass(reader, true));\n \t\t\t}\n \t\t}\n \n \t\t// process any @PropertySource annotations\n \t\tAnnotationAttributes propertySource =\n \t\t\t\tattributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n \t\tif (propertySource != null) {\n \t\t\tString name = propertySource.getString(\"name\");\n \t\t\tString[] locations = propertySource.getStringArray(\"value\");\n \t\t\tint nLocations = locations.length;\n \t\t\tif (nLocations == 0) {\n \t\t\t\tthrow new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n \t\t\t}\n \t\t\tfor (int i = 0; i < nLocations; i++) {\n \t\t\t\tlocations[i] = this.environment.resolveRequiredPlaceholders(locations[i]);\n \t\t\t}\n \t\t\tClassLoader classLoader = this.resourceLoader.getClassLoader();\n \t\t\tif (!StringUtils.hasText(name)) {\n \t\t\t\tfor (String location : locations) {\n \t\t\t\t\tthis.propertySources.push(new ResourcePropertySource(location, classLoader));\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif (nLocations == 1) {\n \t\t\t\t\tthis.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tCompositePropertySource ps = new CompositePropertySource(name);\n \t\t\t\t\tfor (String location : locations) {\n \t\t\t\t\t\tps.addPropertySource(new ResourcePropertySource(location, classLoader));\n \t\t\t\t\t}\n \t\t\t\t\tthis.propertySources.push(ps);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @ComponentScan annotions\n \t\tAnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n \t\t\t\t\tthis.componentScanParser.parse(componentScan, metadata.getClassName());\n \n \t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n-\t\tList<AnnotationAttributes> imports =\n-\t\t\tfindAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n-\t\tfor (AnnotationAttributes importAnno : imports) {\n-\t\t\tprocessImport(configClass, importAnno.getStringArray(\"value\"), true);\n+\t\tSet<String> imports = getImports(metadata.getClassName(), null, new HashSet<String>());\n+\t\tif (imports != null && !imports.isEmpty()) {\n+\t\t\tprocessImport(configClass, imports.toArray(new String[imports.size()]), true);\n \t\t}\n \n \t\t// process any @ImportResource annotations\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n \t\tif (metadata.hasSuperClass()) {\n \t\t\tString superclass = metadata.getSuperClassName();\n \t\t\tif (this.knownSuperclasses.add(superclass)) {\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n \t\t\t\tif (metadata instanceof StandardAnnotationMetadata) {\n \t\t\t\t\tClass<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n \t\t\t\t\treturn new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n \t\t\t\t\treturn reader.getAnnotationMetadata();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"73832f8c6e51eb305b88dfc11815801d18b4d567": {
			"type": "Ybodychange",
			"commitMessage": "Support inferred base package for @ComponentScan\n\nPrior to this change, @ComponentScan required the declaration of\nexactly one of the #value, #basePackage or #basePackageClasses\nattributes in order to determine which package(s) to scan.\n\nThis commit introduces support for base package inference, relaxing the\nabove requirement and falling back to scanning the package in which the\n@ComponentScan-annotated class is declared.\n\nIssue: SPR-9586\n",
			"commitDate": "2012-09-11, 8:50 AM",
			"commitName": "73832f8c6e51eb305b88dfc11815801d18b4d567",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2012-09-10, 3:16 PM",
			"commitNameOld": "0a42c80c1151380f7f492ec75de5648cfe62d250",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 0.73,
			"commitsBetweenForRepo": 10,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,101 +1,102 @@\n \tprotected AnnotationMetadata doProcessConfigurationClass(\n \t\t\tConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n \t\tfor (String memberClassName : metadata.getMemberClassNames()) {\n \t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n \t\t\tAnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n \t\t\tif (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n \t\t\t\tprocessConfigurationClass(new ConfigurationClass(reader, true));\n \t\t\t}\n \t\t}\n \n \t\t// process any @PropertySource annotations\n \t\tAnnotationAttributes propertySource =\n \t\t\t\tattributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n \t\tif (propertySource != null) {\n \t\t\tString name = propertySource.getString(\"name\");\n \t\t\tString[] locations = propertySource.getStringArray(\"value\");\n \t\t\tint nLocations = locations.length;\n \t\t\tif (nLocations == 0) {\n \t\t\t\tthrow new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n \t\t\t}\n \t\t\tfor (int i = 0; i < nLocations; i++) {\n \t\t\t\tlocations[i] = this.environment.resolveRequiredPlaceholders(locations[i]);\n \t\t\t}\n \t\t\tClassLoader classLoader = this.resourceLoader.getClassLoader();\n \t\t\tif (!StringUtils.hasText(name)) {\n \t\t\t\tfor (String location : locations) {\n \t\t\t\t\tthis.propertySources.push(new ResourcePropertySource(location, classLoader));\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif (nLocations == 1) {\n \t\t\t\t\tthis.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tCompositePropertySource ps = new CompositePropertySource(name);\n \t\t\t\t\tfor (String location : locations) {\n \t\t\t\t\t\tps.addPropertySource(new ResourcePropertySource(location, classLoader));\n \t\t\t\t\t}\n \t\t\t\t\tthis.propertySources.push(ps);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @ComponentScan annotions\n \t\tAnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n-\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan);\n+\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n+\t\t\t\t\tthis.componentScanParser.parse(componentScan, metadata.getClassName());\n \n \t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n \t\tList<AnnotationAttributes> imports =\n \t\t\tfindAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n \t\tfor (AnnotationAttributes importAnno : imports) {\n \t\t\tprocessImport(configClass, importAnno.getStringArray(\"value\"), true);\n \t\t}\n \n \t\t// process any @ImportResource annotations\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n \t\tif (metadata.hasSuperClass()) {\n \t\t\tString superclass = metadata.getSuperClassName();\n \t\t\tif (this.knownSuperclasses.add(superclass)) {\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n \t\t\t\tif (metadata instanceof StandardAnnotationMetadata) {\n \t\t\t\t\tClass<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n \t\t\t\t\treturn new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n \t\t\t\t\treturn reader.getAnnotationMetadata();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4df2a14b13ac41d71f8034fa68e1b7e54e3f7a48": {
			"type": "Ybodychange",
			"commitMessage": "Fix regression in @PropertySource placeholder resolution\n\nChanges in commit 41ade68b50b39485b3cf02b9c6fb8eb74962146b introduced\na regression causing all but the first location in the\n@PropertySource#value array to be ignored during ${...} placeholder\nresolution. This change ensures that all locations are processed and\nreplaced as expected.\n\nIssue: SPR-9133, SPR-9127\n",
			"commitDate": "2012-02-20, 6:21 AM",
			"commitName": "4df2a14b13ac41d71f8034fa68e1b7e54e3f7a48",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2012-02-20, 6:19 AM",
			"commitNameOld": "37d547c506f9fab4f478c1e4bc0f1b8e553bd950",
			"commitAuthorOld": "",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,101 +1,101 @@\n \tprotected AnnotationMetadata doProcessConfigurationClass(\n \t\t\tConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n \t\tfor (String memberClassName : metadata.getMemberClassNames()) {\n \t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n \t\t\tAnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n \t\t\tif (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n \t\t\t\tprocessConfigurationClass(new ConfigurationClass(reader, true));\n \t\t\t}\n \t\t}\n \n \t\t// process any @PropertySource annotations\n \t\tAnnotationAttributes propertySource =\n \t\t\t\tattributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n \t\tif (propertySource != null) {\n \t\t\tString name = propertySource.getString(\"name\");\n \t\t\tString[] locations = propertySource.getStringArray(\"value\");\n \t\t\tint nLocations = locations.length;\n \t\t\tif (nLocations == 0) {\n \t\t\t\tthrow new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n \t\t\t}\n \t\t\tfor (int i = 0; i < nLocations; i++) {\n-\t\t\t\tlocations[0] = this.environment.resolveRequiredPlaceholders(locations[0]);\n+\t\t\t\tlocations[i] = this.environment.resolveRequiredPlaceholders(locations[i]);\n \t\t\t}\n \t\t\tClassLoader classLoader = this.resourceLoader.getClassLoader();\n \t\t\tif (!StringUtils.hasText(name)) {\n \t\t\t\tfor (String location : locations) {\n \t\t\t\t\tthis.propertySources.push(new ResourcePropertySource(location, classLoader));\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif (nLocations == 1) {\n \t\t\t\t\tthis.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tCompositePropertySource ps = new CompositePropertySource(name);\n \t\t\t\t\tfor (String location : locations) {\n \t\t\t\t\t\tps.addPropertySource(new ResourcePropertySource(location, classLoader));\n \t\t\t\t\t}\n \t\t\t\t\tthis.propertySources.push(ps);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @ComponentScan annotions\n \t\tAnnotationAttributes componentScan = attributesFor(metadata, ComponentScan.class);\n \t\tif (componentScan != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan);\n \n \t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n \t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n \t\tList<AnnotationAttributes> imports =\n \t\t\tfindAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n \t\tfor (AnnotationAttributes importAnno : imports) {\n \t\t\tprocessImport(configClass, importAnno.getStringArray(\"value\"), true);\n \t\t}\n \n \t\t// process any @ImportResource annotations\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tAnnotationAttributes importResource = attributesFor(metadata, ImportResource.class);\n \t\t\tString[] resources = importResource.getStringArray(\"value\");\n \t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \n \t\t// process superclass, if any\n \t\tif (metadata.hasSuperClass()) {\n \t\t\tString superclass = metadata.getSuperClassName();\n \t\t\tif (this.knownSuperclasses.add(superclass)) {\n \t\t\t\t// superclass found, return its annotation metadata and recurse\n \t\t\t\tif (metadata instanceof StandardAnnotationMetadata) {\n \t\t\t\t\tClass<?> clazz = ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n \t\t\t\t\treturn new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(superclass);\n \t\t\t\t\treturn reader.getAnnotationMetadata();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// no superclass, processing is complete\n \t\treturn null;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"02a4473c62d8240837bec297f0a1f3cb67ef8a7b": {
			"type": "Yfilerename",
			"commitMessage": "Rename modules {org.springframework.*=>spring-*}\n\nThis renaming more intuitively expresses the relationship between\nsubprojects and the JAR artifacts they produce.\n\nTracking history across these renames is possible, but it requires\nuse of the --follow flag to `git log`, for example\n\n    $ git log spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history up until the renaming event, where\n\n    $ git log --follow spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history for all changes to the file, before and after the\nrenaming.\n\nSee http://chrisbeams.com/git-diff-across-renamed-directories\n",
			"commitDate": "2012-01-31, 6:37 AM",
			"commitName": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2012-01-31, 6:37 AM",
			"commitNameOld": "b6cb514d383dcef52ba6c609a863f19e1a4c1faf",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
				"newPath": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java"
			}
		},
		"d6d169ac5614ca10aa7d5bade5a695f599823d8a": {
			"type": "Ybodychange",
			"commitMessage": "resolved package dependency tangles\n",
			"commitDate": "2011-11-28, 6:16 PM",
			"commitName": "d6d169ac5614ca10aa7d5bade5a695f599823d8a",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2011-11-28, 2:35 PM",
			"commitNameOld": "6991cd9cdf610f94ace3cd8072634106830b439f",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0.15,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,67 +1,67 @@\n \tprotected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n \t\tfor (String memberClassName : metadata.getMemberClassNames()) {\n \t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n \t\t\tAnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n-\t\t\tif (isConfigurationCandidate(memberClassMetadata)) {\n+\t\t\tif (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n \t\t\t\tprocessConfigurationClass(new ConfigurationClass(reader, null));\n \t\t\t}\n \t\t}\n \n \t\t// process any @PropertySource annotations\n \t\tMap<String, Object> propertySourceAttributes =\n \t\t\tmetadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n \t\tif (propertySourceAttributes != null) {\n \t\t\tString name = (String) propertySourceAttributes.get(\"name\");\n \t\t\tString[] locations = (String[]) propertySourceAttributes.get(\"value\");\n \t\t\tClassLoader classLoader = this.resourceLoader.getClassLoader();\n \t\t\tfor (String location : locations) {\n \t\t\t\tlocation = this.environment.resolveRequiredPlaceholders(location);\n \t\t\t\tResourcePropertySource ps = StringUtils.hasText(name) ?\n \t\t\t\t\t\tnew ResourcePropertySource(name, location, classLoader) :\n \t\t\t\t\t\tnew ResourcePropertySource(location, classLoader);\n \t\t\t\tthis.propertySources.push(ps);\n \t\t\t}\n \t\t}\n \n \t\t// process any @ComponentScan annotions\n \t\tMap<String, Object> componentScanAttributes = metadata.getAnnotationAttributes(ComponentScan.class.getName());\n \t\tif (componentScanAttributes != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScanAttributes);\n \n \t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n \t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n \t\tList<Map<String, Object>> allImportAttribs =\n-\t\t\tAnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true, metadataReaderFactory);\n+\t\t\tfindAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n \t\tfor (Map<String, Object> importAttribs : allImportAttribs) {\n \t\t\tprocessImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n \t\t}\n \n \t\t// process any @ImportResource annotations\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tString[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n \t\t\tClass<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n \t\t\tif (readerClass == null) {\n \t\t\t\tthrow new IllegalStateException(\"No reader class associated with imported resources: \" +\n \t\t\t\t\t\tStringUtils.arrayToCommaDelimitedString(resources));\n \t\t\t}\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6991cd9cdf610f94ace3cd8072634106830b439f": {
			"type": "Ybodychange",
			"commitMessage": "Allow @Configuration classes to self-@ComponentScan\n\nPrior to this change, a @Configuration classes that @ComponentScan\nthemselves would result in a ConflictingBeanDefinitionException.\n\nFor example:\n\n    package com.foo.config;\n\n    @Configuration\n    @ComponentScan(\"com.foo\");\n    public class AppConfig {\n        // ...\n    }\n\nThis resulted in a ConflictingBeanDefinitionException that users have\ntypically worked around in the following fashion:\n\n    package com.foo.config;\n\n    @Configuration\n    @ComponentScan(basePackages=\"com.foo\",\n        excludeFilters=@Filter(value=ANNOTATION_TYPE, type=Configuration.class);\n    public class AppConfig {\n        // ...\n    }\n\nThis is obviously more verbose and cumbersome than would be desirable,\nand furthermore potentially too constraining as it prohibits the ability\nto include other legitimate @Configuration classes via scanning.\n\nThe exception was being thrown because of a logic problem in\nClassPathBeanDefinitionScanner.  The bean definition for AppConfig gets\nregistered once by the user (e.g. when constructing an\nAnnotationConfigApplicationContext), then again when performing the\ncomponent scan for 'com.foo'. Prior to this change,\nClassPathBeanDefinitionScanner's #isCompatible returned false if the new\nbean definition was anything other than an AnnotatedBeanDefinition.  The\nintention of this check is really to see whether the new bean definition\nis a *scanned* bean definition, i.e. the result of a component-scanning\noperation.  If so, then it becomes safe to assume that the original bean\ndefinition is the one that should be kept, as it is the one explicitly\nregistered by the user.\n\nTherefore, the fix is as simple as narrowing the instanceof check from\nAnnotatedBeanDefinition to its ScannedGenericBeanDefinition subtype.\n\nNote that this commit partially reverts changes introduced in SPR-8307\nthat explicitly caught ConflictingBeanDefinitionExceptions when\nprocessing recursive @ComponentScan definitions, and rethrew as a\n\"CircularComponentScanException.  With the changes in this commit,\nsuch CBDEs will no longer occur, obviating the need for this check and\nfor this custom exception type altogether.\n\nIssue: SPR-8808, SPR-8307\n",
			"commitDate": "2011-11-28, 2:35 PM",
			"commitName": "6991cd9cdf610f94ace3cd8072634106830b439f",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2011-11-15, 9:20 PM",
			"commitNameOld": "40798bd48f63a8f0d9c6529ca6aaa7203b95cbc3",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 12.72,
			"commitsBetweenForRepo": 77,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,73 +1,67 @@\n \tprotected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n \t\tfor (String memberClassName : metadata.getMemberClassNames()) {\n \t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n \t\t\tAnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n \t\t\tif (isConfigurationCandidate(memberClassMetadata)) {\n \t\t\t\tprocessConfigurationClass(new ConfigurationClass(reader, null));\n \t\t\t}\n \t\t}\n \n \t\t// process any @PropertySource annotations\n \t\tMap<String, Object> propertySourceAttributes =\n \t\t\tmetadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n \t\tif (propertySourceAttributes != null) {\n \t\t\tString name = (String) propertySourceAttributes.get(\"name\");\n \t\t\tString[] locations = (String[]) propertySourceAttributes.get(\"value\");\n \t\t\tClassLoader classLoader = this.resourceLoader.getClassLoader();\n \t\t\tfor (String location : locations) {\n \t\t\t\tlocation = this.environment.resolveRequiredPlaceholders(location);\n \t\t\t\tResourcePropertySource ps = StringUtils.hasText(name) ?\n \t\t\t\t\t\tnew ResourcePropertySource(name, location, classLoader) :\n \t\t\t\t\t\tnew ResourcePropertySource(location, classLoader);\n \t\t\t\tthis.propertySources.push(ps);\n \t\t\t}\n \t\t}\n \n \t\t// process any @ComponentScan annotions\n \t\tMap<String, Object> componentScanAttributes = metadata.getAnnotationAttributes(ComponentScan.class.getName());\n \t\tif (componentScanAttributes != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScanAttributes);\n \n \t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n-\t\t\t\t\t} catch (ConflictingBeanDefinitionException ex) {\n-\t\t\t\t\t\tthrow new CircularComponentScanException(\n-\t\t\t\t\t\t\t\t\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" +\n-\t\t\t\t\t\t\t\t\"This usually indicates a circle between scanned packages.\", ex);\n-\t\t\t\t\t}\n+\t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n \t\tList<Map<String, Object>> allImportAttribs =\n \t\t\tAnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true, metadataReaderFactory);\n \t\tfor (Map<String, Object> importAttribs : allImportAttribs) {\n \t\t\tprocessImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n \t\t}\n \n \t\t// process any @ImportResource annotations\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tString[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n \t\t\tClass<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n \t\t\tif (readerClass == null) {\n \t\t\t\tthrow new IllegalStateException(\"No reader class associated with imported resources: \" +\n \t\t\t\t\t\tStringUtils.arrayToCommaDelimitedString(resources));\n \t\t\t}\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6837111bda5e4df9bdfa617c78c1ea32ced7ab5c": {
			"type": "Ybodychange",
			"commitMessage": "Refactor AnnotationUtils#findAllAnnotationAttributes\n\nRemove all convenience variants of #findAllAnnotationAttributes and\nrefactor the remaining method to accept a MetadataReaderFactory\ninstead of creating its own SimpleMetadataReaderFactory internally.\nThis allows clients to use non-default class loaders as well as\ncustomize the particular MetadataReaderFactory to be used (e.g.\n'simple' vs 'caching', etc).\n\nIssue: SPR-8752\n",
			"commitDate": "2011-10-09, 2:32 PM",
			"commitName": "6837111bda5e4df9bdfa617c78c1ea32ced7ab5c",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2011-07-13, 5:28 PM",
			"commitNameOld": "c5463a2e52b432c0347da895d7e711079a4af969",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 87.88,
			"commitsBetweenForRepo": 294,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,73 +1,73 @@\n \tprotected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n \t\tfor (String memberClassName : metadata.getMemberClassNames()) {\n \t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n \t\t\tAnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n \t\t\tif (isConfigurationCandidate(memberClassMetadata)) {\n \t\t\t\tprocessConfigurationClass(new ConfigurationClass(reader, null));\n \t\t\t}\n \t\t}\n \n \t\t// process any @PropertySource annotations\n \t\tMap<String, Object> propertySourceAttributes =\n \t\t\tmetadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n \t\tif (propertySourceAttributes != null) {\n \t\t\tString name = (String) propertySourceAttributes.get(\"name\");\n \t\t\tString[] locations = (String[]) propertySourceAttributes.get(\"value\");\n \t\t\tClassLoader classLoader = this.resourceLoader.getClassLoader();\n \t\t\tfor (String location : locations) {\n \t\t\t\tlocation = this.environment.resolveRequiredPlaceholders(location);\n \t\t\t\tResourcePropertySource ps = StringUtils.hasText(name) ?\n \t\t\t\t\t\tnew ResourcePropertySource(name, location, classLoader) :\n \t\t\t\t\t\tnew ResourcePropertySource(location, classLoader);\n \t\t\t\tthis.propertySources.push(ps);\n \t\t\t}\n \t\t}\n \n \t\t// process any @ComponentScan annotions\n \t\tMap<String, Object> componentScanAttributes = metadata.getAnnotationAttributes(ComponentScan.class.getName());\n \t\tif (componentScanAttributes != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScanAttributes);\n \n \t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t} catch (ConflictingBeanDefinitionException ex) {\n \t\t\t\t\t\tthrow new CircularComponentScanException(\n \t\t\t\t\t\t\t\t\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" +\n \t\t\t\t\t\t\t\t\"This usually indicates a circle between scanned packages.\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n \t\tList<Map<String, Object>> allImportAttribs =\n-\t\t\tAnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n+\t\t\tAnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true, metadataReaderFactory);\n \t\tfor (Map<String, Object> importAttribs : allImportAttribs) {\n \t\t\tprocessImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n \t\t}\n \n \t\t// process any @ImportResource annotations\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tString[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n \t\t\tClass<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n \t\t\tif (readerClass == null) {\n \t\t\t\tthrow new IllegalStateException(\"No reader class associated with imported resources: \" +\n \t\t\t\t\t\tStringUtils.arrayToCommaDelimitedString(resources));\n \t\t\t}\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"234bca64624d0fadd0333e1ec3fc2c680308f081": {
			"type": "Ybodychange",
			"commitMessage": "Resolve ${...} placeholders in @PropertySource\n\nIssue: SPR-8442\n",
			"commitDate": "2011-06-12, 10:23 PM",
			"commitName": "234bca64624d0fadd0333e1ec3fc2c680308f081",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2011-05-25, 4:52 AM",
			"commitNameOld": "2ceeff370aff402bd669f9125d93e99d09e8ce71",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 18.73,
			"commitsBetweenForRepo": 147,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,72 +1,73 @@\n \tprotected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n \t\tfor (String memberClassName : metadata.getMemberClassNames()) {\n \t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n \t\t\tAnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n \t\t\tif (isConfigurationCandidate(memberClassMetadata)) {\n \t\t\t\tprocessConfigurationClass(new ConfigurationClass(reader, null));\n \t\t\t}\n \t\t}\n \n \t\t// process any @PropertySource annotations\n \t\tMap<String, Object> propertySourceAttributes =\n \t\t\tmetadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n \t\tif (propertySourceAttributes != null) {\n \t\t\tString name = (String) propertySourceAttributes.get(\"name\");\n \t\t\tString[] locations = (String[]) propertySourceAttributes.get(\"value\");\n \t\t\tClassLoader classLoader = this.resourceLoader.getClassLoader();\n \t\t\tfor (String location : locations) {\n+\t\t\t\tlocation = this.environment.resolveRequiredPlaceholders(location);\n \t\t\t\tResourcePropertySource ps = StringUtils.hasText(name) ?\n \t\t\t\t\t\tnew ResourcePropertySource(name, location, classLoader) :\n \t\t\t\t\t\tnew ResourcePropertySource(location, classLoader);\n \t\t\t\tthis.propertySources.push(ps);\n \t\t\t}\n \t\t}\n \n \t\t// process any @ComponentScan annotions\n \t\tMap<String, Object> componentScanAttributes = metadata.getAnnotationAttributes(ComponentScan.class.getName());\n \t\tif (componentScanAttributes != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScanAttributes);\n \n \t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t} catch (ConflictingBeanDefinitionException ex) {\n \t\t\t\t\t\tthrow new CircularComponentScanException(\n \t\t\t\t\t\t\t\t\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" +\n \t\t\t\t\t\t\t\t\"This usually indicates a circle between scanned packages.\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n \t\tList<Map<String, Object>> allImportAttribs =\n \t\t\tAnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n \t\tfor (Map<String, Object> importAttribs : allImportAttribs) {\n \t\t\tprocessImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n \t\t}\n \n \t\t// process any @ImportResource annotations\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tString[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n \t\t\tClass<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n \t\t\tif (readerClass == null) {\n \t\t\t\tthrow new IllegalStateException(\"No reader class associated with imported resources: \" +\n \t\t\t\t\t\tStringUtils.arrayToCommaDelimitedString(resources));\n \t\t\t}\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2ceeff370aff402bd669f9125d93e99d09e8ce71": {
			"type": "Ybodychange",
			"commitMessage": "Allow multiple locations via @PropertySource#value\n\nIssue: SPR-8314\n",
			"commitDate": "2011-05-25, 4:52 AM",
			"commitName": "2ceeff370aff402bd669f9125d93e99d09e8ce71",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2011-05-20, 7:20 PM",
			"commitNameOld": "95b1dbadb0014e791b93d73254903a683bd49433",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 4.4,
			"commitsBetweenForRepo": 21,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,70 +1,72 @@\n \tprotected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \n \t\t// recursively process any member (nested) classes first\n \t\tfor (String memberClassName : metadata.getMemberClassNames()) {\n \t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n \t\t\tAnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n \t\t\tif (isConfigurationCandidate(memberClassMetadata)) {\n \t\t\t\tprocessConfigurationClass(new ConfigurationClass(reader, null));\n \t\t\t}\n \t\t}\n \n \t\t// process any @PropertySource annotations\n \t\tMap<String, Object> propertySourceAttributes =\n \t\t\tmetadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n \t\tif (propertySourceAttributes != null) {\n \t\t\tString name = (String) propertySourceAttributes.get(\"name\");\n-\t\t\tString location = (String) propertySourceAttributes.get(\"value\");\n+\t\t\tString[] locations = (String[]) propertySourceAttributes.get(\"value\");\n \t\t\tClassLoader classLoader = this.resourceLoader.getClassLoader();\n-\t\t\tResourcePropertySource ps = StringUtils.hasText(name) ?\n-\t\t\t\t\tnew ResourcePropertySource(name, location, classLoader) :\n-\t\t\t\t\tnew ResourcePropertySource(location, classLoader);\n-\t\t\tthis.propertySources.push(ps);\n+\t\t\tfor (String location : locations) {\n+\t\t\t\tResourcePropertySource ps = StringUtils.hasText(name) ?\n+\t\t\t\t\t\tnew ResourcePropertySource(name, location, classLoader) :\n+\t\t\t\t\t\tnew ResourcePropertySource(location, classLoader);\n+\t\t\t\tthis.propertySources.push(ps);\n+\t\t\t}\n \t\t}\n \n \t\t// process any @ComponentScan annotions\n \t\tMap<String, Object> componentScanAttributes = metadata.getAnnotationAttributes(ComponentScan.class.getName());\n \t\tif (componentScanAttributes != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScanAttributes);\n \n \t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t} catch (ConflictingBeanDefinitionException ex) {\n \t\t\t\t\t\tthrow new CircularComponentScanException(\n \t\t\t\t\t\t\t\t\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" +\n \t\t\t\t\t\t\t\t\"This usually indicates a circle between scanned packages.\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// process any @Import annotations\n \t\tList<Map<String, Object>> allImportAttribs =\n \t\t\tAnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n \t\tfor (Map<String, Object> importAttribs : allImportAttribs) {\n \t\t\tprocessImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n \t\t}\n \n \t\t// process any @ImportResource annotations\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tString[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n \t\t\tClass<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n \t\t\tif (readerClass == null) {\n \t\t\t\tthrow new IllegalStateException(\"No reader class associated with imported resources: \" +\n \t\t\t\t\t\tStringUtils.arrayToCommaDelimitedString(resources));\n \t\t\t}\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \n \t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"95b1dbadb0014e791b93d73254903a683bd49433": {
			"type": "Ybodychange",
			"commitMessage": "Register nested @Configuration classes automatically\n\nThe following is now possible:\n\n@Configuration\npublic class AppConfig {\n    @Inject DataSource dataSource;\n\n    @Bean\n    public MyBean myBean() {\n        return new MyBean(dataSource);\n    }\n\n    @Configuration\n    static class DatabaseConfig {\n        @Bean\n        DataSource dataSource() {\n            return new EmbeddedDatabaseBuilder().build();\n        }\n    }\n}\n\npublic static void main(String... args) {\n    AnnotationConfigApplicationContext ctx =\n        new AnnotationConfigApplicationContext(AppConfig.class);\n    ctx.getBean(MyBean.class);     // works\n    ctx.getBean(DataSource.class); // works\n}\n\nNotice that the @Import annotation was not used and that only AppConfig\nwas registered against the context. By virtue of the fact that\nDatabaseConfig is a member class of AppConfig, it is automatically\nregistered when AppConfig is registered. This avoids an awkward and\nredundant @Import annotation when the relationship is already implicitly\nclear.\n\nSee @Configuration Javadoc for details.\n\nIssue: SPR-8186\n",
			"commitDate": "2011-05-20, 7:20 PM",
			"commitName": "95b1dbadb0014e791b93d73254903a683bd49433",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2011-05-18, 2:53 AM",
			"commitNameOld": "4520ea8690fa8769a2d45658883eac51ea2453ed",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 2.69,
			"commitsBetweenForRepo": 21,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,54 +1,70 @@\n \tprotected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n+\n+\t\t// recursively process any member (nested) classes first\n+\t\tfor (String memberClassName : metadata.getMemberClassNames()) {\n+\t\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(memberClassName);\n+\t\t\tAnnotationMetadata memberClassMetadata = reader.getAnnotationMetadata();\n+\t\t\tif (isConfigurationCandidate(memberClassMetadata)) {\n+\t\t\t\tprocessConfigurationClass(new ConfigurationClass(reader, null));\n+\t\t\t}\n+\t\t}\n+\n+\t\t// process any @PropertySource annotations\n \t\tMap<String, Object> propertySourceAttributes =\n \t\t\tmetadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n \t\tif (propertySourceAttributes != null) {\n \t\t\tString name = (String) propertySourceAttributes.get(\"name\");\n \t\t\tString location = (String) propertySourceAttributes.get(\"value\");\n \t\t\tClassLoader classLoader = this.resourceLoader.getClassLoader();\n \t\t\tResourcePropertySource ps = StringUtils.hasText(name) ?\n \t\t\t\t\tnew ResourcePropertySource(name, location, classLoader) :\n \t\t\t\t\tnew ResourcePropertySource(location, classLoader);\n \t\t\tthis.propertySources.push(ps);\n \t\t}\n \n+\t\t// process any @ComponentScan annotions\n \t\tMap<String, Object> componentScanAttributes = metadata.getAnnotationAttributes(ComponentScan.class.getName());\n \t\tif (componentScanAttributes != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScanAttributes);\n \n \t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t} catch (ConflictingBeanDefinitionException ex) {\n \t\t\t\t\t\tthrow new CircularComponentScanException(\n \t\t\t\t\t\t\t\t\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" +\n \t\t\t\t\t\t\t\t\"This usually indicates a circle between scanned packages.\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n+\t\t// process any @Import annotations\n \t\tList<Map<String, Object>> allImportAttribs =\n \t\t\tAnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n \t\tfor (Map<String, Object> importAttribs : allImportAttribs) {\n \t\t\tprocessImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n \t\t}\n \n+\t\t// process any @ImportResource annotations\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tString[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n \t\t\tClass<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n \t\t\tif (readerClass == null) {\n \t\t\t\tthrow new IllegalStateException(\"No reader class associated with imported resources: \" +\n \t\t\t\t\t\tStringUtils.arrayToCommaDelimitedString(resources));\n \t\t\t}\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n+\n+\t\t// process individual @Bean methods\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c8bc54e0ccad49f0785856f911349283619eb8ba": {
			"type": "Ybodychange",
			"commitMessage": "Introduce @PropertySource\n\nAllows a convenient mechanism for contributing a PropertySource to the\nenclosing Spring Environment. See @PropertySource Javadoc for\ncomplete details and PropertySourceAnnotationTests for examples.\n\nIssue: SPR-8314\n",
			"commitDate": "2011-05-11, 7:28 AM",
			"commitName": "c8bc54e0ccad49f0785856f911349283619eb8ba",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2011-05-08, 7:49 AM",
			"commitNameOld": "d0c31ad84cffd7af718a45d679483a1c51f9e552",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 2.99,
			"commitsBetweenForRepo": 14,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,42 +1,54 @@\n \tprotected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n+\t\tMap<String, Object> propertySourceAttributes =\n+\t\t\tmetadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n+\t\tif (propertySourceAttributes != null) {\n+\t\t\tString name = (String) propertySourceAttributes.get(\"name\");\n+\t\t\tString location = (String) propertySourceAttributes.get(\"value\");\n+\t\t\tClassLoader classLoader = this.resourceLoader.getClassLoader();\n+\t\t\tResourcePropertySource ps = StringUtils.hasText(name) ?\n+\t\t\t\t\tnew ResourcePropertySource(name, location, classLoader) :\n+\t\t\t\t\tnew ResourcePropertySource(location, classLoader);\n+\t\t\tthis.propertySources.push(ps);\n+\t\t}\n+\n \t\tMap<String, Object> componentScanAttributes = metadata.getAnnotationAttributes(ComponentScan.class.getName());\n \t\tif (componentScanAttributes != null) {\n \t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n \t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScanAttributes);\n \n \t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n \t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n \t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n \t\t\t\t\t} catch (ConflictingBeanDefinitionException ex) {\n \t\t\t\t\t\tthrow new CircularComponentScanException(\n \t\t\t\t\t\t\t\t\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" +\n \t\t\t\t\t\t\t\t\"This usually indicates a circle between scanned packages.\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tList<Map<String, Object>> allImportAttribs =\n \t\t\tAnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n \t\tfor (Map<String, Object> importAttribs : allImportAttribs) {\n \t\t\tprocessImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n \t\t}\n \n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tString[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n \t\t\tClass<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n \t\t\tif (readerClass == null) {\n \t\t\t\tthrow new IllegalStateException(\"No reader class associated with imported resources: \" +\n \t\t\t\t\t\tStringUtils.arrayToCommaDelimitedString(resources));\n \t\t\t}\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d0c31ad84cffd7af718a45d679483a1c51f9e552": {
			"type": "Ybodychange",
			"commitMessage": "Allow recursive use of @ComponentScan\n\nPrior to this change, @ComponentScan annotations were only processed at\nthe first level of depth.  Now, the set of bean definitions resulting\nfrom each declaration of @ComponentScan is checked for configuration\nclasses that declare @ComponentScan, and recursion is performed as\nnecessary.\n\nCycles between @ComponentScan declarations are detected as well. See\nCircularComponentScanException.\n\nIssue: SPR-8307\n",
			"commitDate": "2011-05-08, 7:49 AM",
			"commitName": "d0c31ad84cffd7af718a45d679483a1c51f9e552",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2011-05-06, 1:06 PM",
			"commitNameOld": "9a271ce6c92695b9421aa603c9aa56e805c7920c",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 1.78,
			"commitsBetweenForRepo": 15,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,23 +1,42 @@\n \tprotected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n+\t\tMap<String, Object> componentScanAttributes = metadata.getAnnotationAttributes(ComponentScan.class.getName());\n+\t\tif (componentScanAttributes != null) {\n+\t\t\t// the config class is annotated with @ComponentScan -> perform the scan immediately\n+\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScanAttributes);\n+\n+\t\t\t// check the set of scanned definitions for any further config classes and parse recursively if necessary\n+\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n+\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tthis.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+\t\t\t\t\t} catch (ConflictingBeanDefinitionException ex) {\n+\t\t\t\t\t\tthrow new CircularComponentScanException(\n+\t\t\t\t\t\t\t\t\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" +\n+\t\t\t\t\t\t\t\t\"This usually indicates a circle between scanned packages.\", ex);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n \t\tList<Map<String, Object>> allImportAttribs =\n \t\t\tAnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n \t\tfor (Map<String, Object> importAttribs : allImportAttribs) {\n \t\t\tprocessImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n \t\t}\n \n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tString[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n \t\t\tClass<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n \t\t\tif (readerClass == null) {\n \t\t\t\tthrow new IllegalStateException(\"No reader class associated with imported resources: \" +\n \t\t\t\t\t\tStringUtils.arrayToCommaDelimitedString(resources));\n \t\t\t}\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9a271ce6c92695b9421aa603c9aa56e805c7920c": {
			"type": "Ybodychange",
			"commitMessage": "Introduce ImportSelector interface\n\nAllows @Enable* a layer of indirection for deciding which @Configuration\nclass(es) to @Import.\n\nThe @Import annotation may now accept @Configuration class literals\nand/or ImportSelector class literals.\n",
			"commitDate": "2011-05-06, 1:06 PM",
			"commitName": "9a271ce6c92695b9421aa603c9aa56e805c7920c",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2011-05-06, 1:05 PM",
			"commitNameOld": "cdb01cbd3795f273b751d0f0a45caa22d07c62da",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,23 +1,23 @@\n \tprotected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \t\tList<Map<String, Object>> allImportAttribs =\n \t\t\tAnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n \t\tfor (Map<String, Object> importAttribs : allImportAttribs) {\n-\t\t\tprocessImport(configClass, (String[]) importAttribs.get(\"value\"));\n+\t\t\tprocessImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n \t\t}\n \n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tString[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n \t\t\tClass<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n \t\t\tif (readerClass == null) {\n \t\t\t\tthrow new IllegalStateException(\"No reader class associated with imported resources: \" +\n \t\t\t\t\t\tStringUtils.arrayToCommaDelimitedString(resources));\n \t\t\t}\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"89005a5b7034cc1c2f702eac4bd36836b99f3765": {
			"type": "Ybodychange",
			"commitMessage": "Process all meta and local @Import declarations\n\nIncludes the introduction of AnnotationUtils#findAllAnnotationAttributes\nto support iterating through all annotations declared on a given type\nand interrogating each for the presence of a meta-annotation. See tests\nfor details.\n",
			"commitDate": "2011-05-06, 1:05 PM",
			"commitName": "89005a5b7034cc1c2f702eac4bd36836b99f3765",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2011-05-06, 1:01 PM",
			"commitNameOld": "0a790c143feeabf571e98f8ee0700a4586cbb67c",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,20 +1,23 @@\n \tprotected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n-\t\tif (metadata.isAnnotated(Import.class.getName())) {\n-\t\t\tprocessImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName(), true).get(\"value\"));\n+\t\tList<Map<String, Object>> allImportAttribs =\n+\t\t\tAnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n+\t\tfor (Map<String, Object> importAttribs : allImportAttribs) {\n+\t\t\tprocessImport(configClass, (String[]) importAttribs.get(\"value\"));\n \t\t}\n+\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tString[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n \t\t\tClass<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n \t\t\tif (readerClass == null) {\n \t\t\t\tthrow new IllegalStateException(\"No reader class associated with imported resources: \" +\n \t\t\t\t\t\tStringUtils.arrayToCommaDelimitedString(resources));\n \t\t\t}\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0a790c143feeabf571e98f8ee0700a4586cbb67c": {
			"type": "Ybodychange",
			"commitMessage": "Rename ConfigurationClassMethod => BeanMethod\n",
			"commitDate": "2011-05-06, 1:01 PM",
			"commitName": "0a790c143feeabf571e98f8ee0700a4586cbb67c",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2011-03-15, 6:57 AM",
			"commitNameOld": "150838bfc13a136ef0baf943e378a8ebb5f3549f",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 52.25,
			"commitsBetweenForRepo": 118,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,20 +1,20 @@\n \tprotected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \t\tif (metadata.isAnnotated(Import.class.getName())) {\n \t\t\tprocessImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName(), true).get(\"value\"));\n \t\t}\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tString[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n \t\t\tClass<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n \t\t\tif (readerClass == null) {\n \t\t\t\tthrow new IllegalStateException(\"No reader class associated with imported resources: \" +\n \t\t\t\t\t\tStringUtils.arrayToCommaDelimitedString(resources));\n \t\t\t}\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n-\t\tfor (MethodMetadata beanMethod : beanMethods) {\n-\t\t\tconfigClass.addMethod(new ConfigurationClassMethod(beanMethod, configClass));\n+\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n+\t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d78eda8aebda0704e29fdccf619e9931b5446efc": {
			"type": "Ybodychange",
			"commitMessage": "polishing\n",
			"commitDate": "2010-10-10, 12:31 PM",
			"commitName": "d78eda8aebda0704e29fdccf619e9931b5446efc",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2010-01-29, 4:31 PM",
			"commitNameOld": "fbd797e50b2f1c5b0dfef944ee218d826f1a0694",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 253.79,
			"commitsBetweenForRepo": 804,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,20 +1,20 @@\n \tprotected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \t\tif (metadata.isAnnotated(Import.class.getName())) {\n \t\t\tprocessImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName(), true).get(\"value\"));\n \t\t}\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tString[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n \t\t\tClass<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n \t\t\tif (readerClass == null) {\n \t\t\t\tthrow new IllegalStateException(\"No reader class associated with imported resources: \" +\n \t\t\t\t\t\tStringUtils.arrayToCommaDelimitedString(resources));\n \t\t\t}\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n-\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n-\t\t\tconfigClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n+\t\tfor (MethodMetadata beanMethod : beanMethods) {\n+\t\t\tconfigClass.addMethod(new ConfigurationClassMethod(beanMethod, configClass));\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d1b3f57320d5567ff8f6420c9bcf07521ea5e2b9": {
			"type": "Ybodychange",
			"commitMessage": "Resolved SPR-6618. Restrictions were too tight on overloaded bean methods and were preventing it altogether.  Overloading is now allowed, as long as there is no ambiguity at runtime which bean method should be invoked.\n",
			"commitDate": "2009-12-30, 12:42 PM",
			"commitName": "d1b3f57320d5567ff8f6420c9bcf07521ea5e2b9",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-11-12, 12:29 AM",
			"commitNameOld": "9f07b151853f21bc363340fd3056ec14118a1e89",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 48.51,
			"commitsBetweenForRepo": 306,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,20 +1,20 @@\n \tprotected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \t\tif (metadata.isAnnotated(Import.class.getName())) {\n \t\t\tprocessImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName(), true).get(\"value\"));\n \t\t}\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n \t\t\tString[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n-\t\t\tClass readerClass = (Class) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n+\t\t\tClass<?> readerClass = (Class<?>) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n \t\t\tif (readerClass == null) {\n \t\t\t\tthrow new IllegalStateException(\"No reader class associated with imported resources: \" +\n \t\t\t\t\t\tStringUtils.arrayToCommaDelimitedString(resources));\n \t\t\t}\n \t\t\tfor (String resource : resources) {\n \t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n-\t\tSet<MethodMetadata> methods = metadata.getAnnotatedMethods(Bean.class.getName());\n-\t\tfor (MethodMetadata methodMetadata : methods) {\n+\t\tSet<MethodMetadata> beanMethods = metadata.getAnnotatedMethods(Bean.class.getName());\n+\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n \t\t\tconfigClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"bbd7fb3969b7fd93c814380209d8f28e2a9c6714": {
			"type": "Ybodychange",
			"commitMessage": "AnnotationMetadata returns Class values by default (again), allowing for explicit retrieval of String class names where preferred (SPR-5827)\n",
			"commitDate": "2009-11-11, 12:11 PM",
			"commitName": "bbd7fb3969b7fd93c814380209d8f28e2a9c6714",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-11-10, 5:48 PM",
			"commitNameOld": "ee553f7804c9cc2ac89b963bcff58974503c20fe",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0.77,
			"commitsBetweenForRepo": 20,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,15 +1,20 @@\n \tprotected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \t\tif (metadata.isAnnotated(Import.class.getName())) {\n-\t\t\tprocessImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName()).get(\"value\"));\n+\t\t\tprocessImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName(), true).get(\"value\"));\n \t\t}\n \t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n-\t\t\tString readerClassName = (String) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n-\t\t\tfor (String importedResource : (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\")) {\n-\t\t\t\tconfigClass.addImportedResource(importedResource, readerClassName);\n+\t\t\tString[] resources = (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n+\t\t\tClass readerClass = (Class) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n+\t\t\tif (readerClass == null) {\n+\t\t\t\tthrow new IllegalStateException(\"No reader class associated with imported resources: \" +\n+\t\t\t\t\t\tStringUtils.arrayToCommaDelimitedString(resources));\n+\t\t\t}\n+\t\t\tfor (String resource : resources) {\n+\t\t\t\tconfigClass.addImportedResource(resource, readerClass);\n \t\t\t}\n \t\t}\n \t\tSet<MethodMetadata> methods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : methods) {\n \t\t\tconfigClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ee553f7804c9cc2ac89b963bcff58974503c20fe": {
			"type": "Ybodychange",
			"commitMessage": "SPR-6328: Rename @ImportXml -> @ImportResource and allow for usage of non-XML BeanDefinitionReader types\n\n",
			"commitDate": "2009-11-10, 5:48 PM",
			"commitName": "ee553f7804c9cc2ac89b963bcff58974503c20fe",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-11-06, 5:32 PM",
			"commitNameOld": "0a4463fb71e6901a943a5bafc9d1957da2229333",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 4.01,
			"commitsBetweenForRepo": 44,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,14 +1,15 @@\n \tprotected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \t\tif (metadata.isAnnotated(Import.class.getName())) {\n \t\t\tprocessImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName()).get(\"value\"));\n \t\t}\n-\t\tif (metadata.isAnnotated(ImportXml.class.getName())) {\n-\t\t\tfor (String xmlImport : (String[]) metadata.getAnnotationAttributes(ImportXml.class.getName()).get(\"value\")) {\n-\t\t\t\tconfigClass.addXmlImport(xmlImport);\n+\t\tif (metadata.isAnnotated(ImportResource.class.getName())) {\n+\t\t\tString readerClassName = (String) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n+\t\t\tfor (String importedResource : (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\")) {\n+\t\t\t\tconfigClass.addImportedResource(importedResource, readerClassName);\n \t\t\t}\n \t\t}\n \t\tSet<MethodMetadata> methods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : methods) {\n \t\t\tconfigClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0a4463fb71e6901a943a5bafc9d1957da2229333": {
			"type": "Ybodychange",
			"commitMessage": "SPR-6158: Initial implementation and tests for @ImportXml\n\n",
			"commitDate": "2009-11-06, 5:32 PM",
			"commitName": "0a4463fb71e6901a943a5bafc9d1957da2229333",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-07-22, 9:23 AM",
			"commitNameOld": "f519406c37b23eef816704baeb3a496f7430bb89",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 107.38,
			"commitsBetweenForRepo": 678,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,9 +1,14 @@\n \tprotected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n \t\tif (metadata.isAnnotated(Import.class.getName())) {\n \t\t\tprocessImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName()).get(\"value\"));\n \t\t}\n+\t\tif (metadata.isAnnotated(ImportXml.class.getName())) {\n+\t\t\tfor (String xmlImport : (String[]) metadata.getAnnotationAttributes(ImportXml.class.getName()).get(\"value\")) {\n+\t\t\t\tconfigClass.addXmlImport(xmlImport);\n+\t\t\t}\n+\t\t}\n \t\tSet<MethodMetadata> methods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : methods) {\n \t\t\tconfigClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f519406c37b23eef816704baeb3a496f7430bb89": {
			"type": "Ybodychange",
			"commitMessage": "@Primary/@Lazy/@DependsOn supported as meta-annotations; @Bean supported as meta-annotation on factory methods as well\n",
			"commitDate": "2009-07-22, 9:23 AM",
			"commitName": "f519406c37b23eef816704baeb3a496f7430bb89",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-06-06, 1:59 AM",
			"commitNameOld": "8c65ed9e0bf84cdaa4a12843d52e929a8146fb31",
			"commitAuthorOld": "Christian Dupuis",
			"daysBetweenCommits": 46.31,
			"commitsBetweenForRepo": 272,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,9 +1,9 @@\n \tprotected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n-\t\tif (metadata.hasAnnotation(Import.class.getName())) {\n+\t\tif (metadata.isAnnotated(Import.class.getName())) {\n \t\t\tprocessImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName()).get(\"value\"));\n \t\t}\n \t\tSet<MethodMetadata> methods = metadata.getAnnotatedMethods(Bean.class.getName());\n \t\tfor (MethodMetadata methodMetadata : methods) {\n \t\t\tconfigClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b5d21108da24f8344be3bc708c7afdfca9a1d089": {
			"type": "Yintroduced",
			"commitMessage": "@Configuration parsing fully relies on Spring's MetadataReader abstraction now\n",
			"commitDate": "2009-04-24, 5:16 AM",
			"commitName": "b5d21108da24f8344be3bc708c7afdfca9a1d089",
			"commitAuthor": "Juergen Hoeller"
		}
	},
	"sha": "b325c74216fd9564a36602158fa1269e2e832874"
}