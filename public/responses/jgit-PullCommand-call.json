{
	"repo": "https://github.com/eclipse/jgit.git",
	"file": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
	"method": {
		"longName": "PullCommand::call()",
		"startLine": 206,
		"methodName": "call",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"df638e0cfc628469eee9a91df5b2b65634e274d7": {
			"type": "Ybodychange",
			"commitMessage": "Allow to programmatically set FastForwardMode for PullCommand\n\nBug: 517847\nChange-Id: I70d12dbe347a3d7a3528687ee04e52a2052bfb93\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2017-06-16, 3:20 PM",
			"commitName": "df638e0cfc628469eee9a91df5b2b65634e274d7",
			"commitAuthor": "Matthias Sohn",
			"commitDateOld": "2017-06-16, 3:20 PM",
			"commitNameOld": "0d447b16604d934675d2dc8e958fa043e945dfc6",
			"commitAuthorOld": "Mattias Neuling",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,157 +1,155 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tInvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \t\tConfig repoConfig = repo.getConfig();\n \n \t\tString branchName = null;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (fullBranch != null\n \t\t\t\t\t&& fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \t\tif (remoteBranchName == null && branchName != null) {\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.<branch name>.merge\n \t\t\tremoteBranchName = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t}\n \t\tif (remoteBranchName == null) {\n \t\t\tremoteBranchName = branchName;\n \t\t}\n \t\tif (remoteBranchName == null) {\n \t\t\tthrow new NoHeadException(\n \t\t\t\t\tJGitText.get().cannotCheckoutFromUnbornBranch);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tif (remote == null && branchName != null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.<branch name>.remote\n \t\t\tremote = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote == null) {\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \t\t}\n \n \t\t// determines whether rebase should be used after fetching\n \t\tif (pullRebaseMode == null && branchName != null) {\n \t\t\tpullRebaseMode = getRebaseMode(branchName, repoConfig);\n \t\t}\n \n \n \t\tfinal boolean isRemote = !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo).setRemote(remote)\n \t\t\t\t\t.setProgressMonitor(monitor).setTagOpt(tagOption)\n \t\t\t\t\t.setRecurseSubmodules(submoduleRecurseMode);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = JGitText.get().localRepository;\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null) {\n \t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n \t\t\t\t\t\tremoteBranchName));\n \t\t\t} else {\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t\t}\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName = MessageFormat.format(\n \t\t\t\tJGitText.get().upstreamBranchName,\n \t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n \t\tif (pullRebaseMode != BranchRebaseMode.NONE) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.setPreserveMerges(\n \t\t\t\t\t\t\tpullRebaseMode == BranchRebaseMode.PRESERVE)\n \t\t\t\t\t.call();\n \t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n-\t\t\tmerge.include(upstreamName, commitToMerge);\n-\t\t\tmerge.setStrategy(strategy);\n-\t\t\tmerge.setProgressMonitor(monitor);\n-\t\t\tmerge.setFastForward(getFastForwardMode());\n-\t\t\tMergeResult mergeRes = merge.call();\n+\t\t\tMergeResult mergeRes = merge.include(upstreamName, commitToMerge)\n+\t\t\t\t\t.setStrategy(strategy).setProgressMonitor(monitor)\n+\t\t\t\t\t.setFastForward(getFastForwardMode()).call();\n \t\t\tmonitor.update(1);\n \t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0d447b16604d934675d2dc8e958fa043e945dfc6": {
			"type": "Ybodychange",
			"commitMessage": "Add support for config \"pull.ff\n\nWhen the configuration entry 'pull.ff' exists the merge of the pull will\nuse the value as fast forward option.\n\nBug: 474174\nChange-Id: Ic8db2f00095ed81528667b064ff523911e6c122e\nSigned-off-by: Mattias Neuling <neuling@dakosy.de>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2017-06-16, 3:20 PM",
			"commitName": "0d447b16604d934675d2dc8e958fa043e945dfc6",
			"commitAuthor": "Mattias Neuling",
			"commitDateOld": "2017-06-15, 9:52 PM",
			"commitNameOld": "b4a46b5ed0e33f0a958ba809c648f46e5a19abd7",
			"commitAuthorOld": "David Pursehouse",
			"daysBetweenCommits": 0.73,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,156 +1,157 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tInvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \t\tConfig repoConfig = repo.getConfig();\n \n \t\tString branchName = null;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (fullBranch != null\n \t\t\t\t\t&& fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \t\tif (remoteBranchName == null && branchName != null) {\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.<branch name>.merge\n \t\t\tremoteBranchName = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t}\n \t\tif (remoteBranchName == null) {\n \t\t\tremoteBranchName = branchName;\n \t\t}\n \t\tif (remoteBranchName == null) {\n \t\t\tthrow new NoHeadException(\n \t\t\t\t\tJGitText.get().cannotCheckoutFromUnbornBranch);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tif (remote == null && branchName != null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.<branch name>.remote\n \t\t\tremote = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote == null) {\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \t\t}\n \n \t\t// determines whether rebase should be used after fetching\n \t\tif (pullRebaseMode == null && branchName != null) {\n \t\t\tpullRebaseMode = getRebaseMode(branchName, repoConfig);\n \t\t}\n \n \n \t\tfinal boolean isRemote = !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo).setRemote(remote)\n \t\t\t\t\t.setProgressMonitor(monitor).setTagOpt(tagOption)\n \t\t\t\t\t.setRecurseSubmodules(submoduleRecurseMode);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = JGitText.get().localRepository;\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null) {\n \t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n \t\t\t\t\t\tremoteBranchName));\n \t\t\t} else {\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t\t}\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName = MessageFormat.format(\n \t\t\t\tJGitText.get().upstreamBranchName,\n \t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n \t\tif (pullRebaseMode != BranchRebaseMode.NONE) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.setPreserveMerges(\n \t\t\t\t\t\t\tpullRebaseMode == BranchRebaseMode.PRESERVE)\n \t\t\t\t\t.call();\n \t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n \t\t\tmerge.setProgressMonitor(monitor);\n+\t\t\tmerge.setFastForward(getFastForwardMode());\n \t\t\tMergeResult mergeRes = merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5b84e25fa3afe66bbfa7eb953ea0bd332c745ecd": {
			"type": "Ymultichange(Yexceptionschange,Ybodychange)",
			"commitMessage": "Support pull on detached HEAD\n\nBug: 485396\nChange-Id: I82be09385c9b0bcc0054fea5a9cb9d178a41e278\nSigned-off-by: Mickael Istria <mistria@redhat.com>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2017-05-07, 4:38 PM",
			"commitName": "5b84e25fa3afe66bbfa7eb953ea0bd332c745ecd",
			"commitAuthor": "Mickael Istria",
			"subchanges": [
				{
					"type": "Yexceptionschange",
					"commitMessage": "Support pull on detached HEAD\n\nBug: 485396\nChange-Id: I82be09385c9b0bcc0054fea5a9cb9d178a41e278\nSigned-off-by: Mickael Istria <mistria@redhat.com>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
					"commitDate": "2017-05-07, 4:38 PM",
					"commitName": "5b84e25fa3afe66bbfa7eb953ea0bd332c745ecd",
					"commitAuthor": "Mickael Istria",
					"commitDateOld": "2017-03-23, 5:02 PM",
					"commitNameOld": "5f902f07ccae32b82a36c05e1eca23b21a27da99",
					"commitAuthorOld": "David Pursehouse",
					"daysBetweenCommits": 44.98,
					"commitsBetweenForRepo": 56,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,155 +1,156 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n-\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n+\t\t\tInvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n+\t\tConfig repoConfig = repo.getConfig();\n \n-\t\tString branchName;\n+\t\tString branchName = null;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n-\t\t\tif (fullBranch == null)\n-\t\t\t\tthrow new NoHeadException(\n-\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n-\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n-\t\t\t\t// we can not pull if HEAD is detached and branch is not\n-\t\t\t\t// specified explicitly\n-\t\t\t\tthrow new DetachedHeadException();\n+\t\t\tif (fullBranch != null\n+\t\t\t\t\t&& fullBranch.startsWith(Constants.R_HEADS)) {\n+\t\t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t\t}\n-\t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n+\t\tif (remoteBranchName == null && branchName != null) {\n+\t\t\t// get the name of the branch in the remote repository\n+\t\t\t// stored in configuration key branch.<branch name>.merge\n+\t\t\tremoteBranchName = repoConfig.getString(\n+\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n+\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n+\t\t}\n+\t\tif (remoteBranchName == null) {\n+\t\t\tremoteBranchName = branchName;\n+\t\t}\n+\t\tif (remoteBranchName == null) {\n+\t\t\tthrow new NoHeadException(\n+\t\t\t\t\tJGitText.get().cannotCheckoutFromUnbornBranch);\n+\t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n-\t\tConfig repoConfig = repo.getConfig();\n-\t\tif (remote == null) {\n+\t\tif (remote == null && branchName != null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.<branch name>.remote\n \t\t\tremote = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n-\t\tif (remote == null)\n+\t\tif (remote == null) {\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n-\n-\t\tif (remoteBranchName == null)\n-\t\t\t// get the name of the branch in the remote repository\n-\t\t\t// stored in configuration key branch.<branch name>.merge\n-\t\t\tremoteBranchName = repoConfig.getString(\n-\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n-\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n+\t\t}\n \n \t\t// determines whether rebase should be used after fetching\n-\t\tif (pullRebaseMode == null) {\n+\t\tif (pullRebaseMode == null && branchName != null) {\n \t\t\tpullRebaseMode = getRebaseMode(branchName, repoConfig);\n \t\t}\n \n-\t\tif (remoteBranchName == null)\n-\t\t\tremoteBranchName = branchName;\n \n \t\tfinal boolean isRemote = !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo).setRemote(remote)\n \t\t\t\t\t.setProgressMonitor(monitor).setTagOpt(tagOption)\n \t\t\t\t\t.setRecurseSubmodules(submoduleRecurseMode);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = JGitText.get().localRepository;\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null) {\n \t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n \t\t\t\t\t\tremoteBranchName));\n \t\t\t} else {\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t\t}\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName = MessageFormat.format(\n \t\t\t\tJGitText.get().upstreamBranchName,\n \t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n \t\tif (pullRebaseMode != BranchRebaseMode.NONE) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.setPreserveMerges(\n \t\t\t\t\t\t\tpullRebaseMode == BranchRebaseMode.PRESERVE)\n \t\t\t\t\t.call();\n \t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n \t\t\tmerge.setProgressMonitor(monitor);\n \t\t\tMergeResult mergeRes = merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException]",
						"newValue": "[GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Support pull on detached HEAD\n\nBug: 485396\nChange-Id: I82be09385c9b0bcc0054fea5a9cb9d178a41e278\nSigned-off-by: Mickael Istria <mistria@redhat.com>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
					"commitDate": "2017-05-07, 4:38 PM",
					"commitName": "5b84e25fa3afe66bbfa7eb953ea0bd332c745ecd",
					"commitAuthor": "Mickael Istria",
					"commitDateOld": "2017-03-23, 5:02 PM",
					"commitNameOld": "5f902f07ccae32b82a36c05e1eca23b21a27da99",
					"commitAuthorOld": "David Pursehouse",
					"daysBetweenCommits": 44.98,
					"commitsBetweenForRepo": 56,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,155 +1,156 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n-\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n+\t\t\tInvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n+\t\tConfig repoConfig = repo.getConfig();\n \n-\t\tString branchName;\n+\t\tString branchName = null;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n-\t\t\tif (fullBranch == null)\n-\t\t\t\tthrow new NoHeadException(\n-\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n-\t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n-\t\t\t\t// we can not pull if HEAD is detached and branch is not\n-\t\t\t\t// specified explicitly\n-\t\t\t\tthrow new DetachedHeadException();\n+\t\t\tif (fullBranch != null\n+\t\t\t\t\t&& fullBranch.startsWith(Constants.R_HEADS)) {\n+\t\t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t\t}\n-\t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n+\t\tif (remoteBranchName == null && branchName != null) {\n+\t\t\t// get the name of the branch in the remote repository\n+\t\t\t// stored in configuration key branch.<branch name>.merge\n+\t\t\tremoteBranchName = repoConfig.getString(\n+\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n+\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n+\t\t}\n+\t\tif (remoteBranchName == null) {\n+\t\t\tremoteBranchName = branchName;\n+\t\t}\n+\t\tif (remoteBranchName == null) {\n+\t\t\tthrow new NoHeadException(\n+\t\t\t\t\tJGitText.get().cannotCheckoutFromUnbornBranch);\n+\t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n-\t\tConfig repoConfig = repo.getConfig();\n-\t\tif (remote == null) {\n+\t\tif (remote == null && branchName != null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.<branch name>.remote\n \t\t\tremote = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n-\t\tif (remote == null)\n+\t\tif (remote == null) {\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n-\n-\t\tif (remoteBranchName == null)\n-\t\t\t// get the name of the branch in the remote repository\n-\t\t\t// stored in configuration key branch.<branch name>.merge\n-\t\t\tremoteBranchName = repoConfig.getString(\n-\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n-\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n+\t\t}\n \n \t\t// determines whether rebase should be used after fetching\n-\t\tif (pullRebaseMode == null) {\n+\t\tif (pullRebaseMode == null && branchName != null) {\n \t\t\tpullRebaseMode = getRebaseMode(branchName, repoConfig);\n \t\t}\n \n-\t\tif (remoteBranchName == null)\n-\t\t\tremoteBranchName = branchName;\n \n \t\tfinal boolean isRemote = !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo).setRemote(remote)\n \t\t\t\t\t.setProgressMonitor(monitor).setTagOpt(tagOption)\n \t\t\t\t\t.setRecurseSubmodules(submoduleRecurseMode);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = JGitText.get().localRepository;\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null) {\n \t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n \t\t\t\t\t\tremoteBranchName));\n \t\t\t} else {\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t\t}\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName = MessageFormat.format(\n \t\t\t\tJGitText.get().upstreamBranchName,\n \t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n \t\tif (pullRebaseMode != BranchRebaseMode.NONE) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.setPreserveMerges(\n \t\t\t\t\t\t\tpullRebaseMode == BranchRebaseMode.PRESERVE)\n \t\t\t\t\t.call();\n \t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n \t\t\tmerge.setProgressMonitor(monitor);\n \t\t\tMergeResult mergeRes = merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"5f902f07ccae32b82a36c05e1eca23b21a27da99": {
			"type": "Ybodychange",
			"commitMessage": "PullCommand: Add support for recursing into submodules\n\nAdd a new API method to set the recurse mode, and pass the mode into\nthe fetch command.\n\nExtend the existing FetchCommandRecurseSubmodulesTest to also perform\nthe same tests for fetch. Rename the test class accordingly.\n\nChange-Id: I12553af47774b4778f7011e1018bd575a7909bd0\nSigned-off-by: David Pursehouse <david.pursehouse@gmail.com>\n",
			"commitDate": "2017-03-23, 5:02 PM",
			"commitName": "5f902f07ccae32b82a36c05e1eca23b21a27da99",
			"commitAuthor": "David Pursehouse",
			"commitDateOld": "2017-02-19, 5:05 PM",
			"commitNameOld": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
			"commitAuthorOld": "David Pursehouse",
			"daysBetweenCommits": 31.96,
			"commitsBetweenForRepo": 46,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,154 +1,155 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (fullBranch == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tConfig repoConfig = repo.getConfig();\n \t\tif (remote == null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.<branch name>.remote\n \t\t\tremote = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\tif (remoteBranchName == null)\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.<branch name>.merge\n \t\t\tremoteBranchName = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n \t\t// determines whether rebase should be used after fetching\n \t\tif (pullRebaseMode == null) {\n \t\t\tpullRebaseMode = getRebaseMode(branchName, repoConfig);\n \t\t}\n \n \t\tif (remoteBranchName == null)\n \t\t\tremoteBranchName = branchName;\n \n \t\tfinal boolean isRemote = !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo).setRemote(remote)\n-\t\t\t\t\t.setProgressMonitor(monitor).setTagOpt(tagOption);\n+\t\t\t\t\t.setProgressMonitor(monitor).setTagOpt(tagOption)\n+\t\t\t\t\t.setRecurseSubmodules(submoduleRecurseMode);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = JGitText.get().localRepository;\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null) {\n \t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n \t\t\t\t\t\tremoteBranchName));\n \t\t\t} else {\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t\t}\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName = MessageFormat.format(\n \t\t\t\tJGitText.get().upstreamBranchName,\n \t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n \t\tif (pullRebaseMode != BranchRebaseMode.NONE) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.setPreserveMerges(\n \t\t\t\t\t\t\tpullRebaseMode == BranchRebaseMode.PRESERVE)\n \t\t\t\t\t.call();\n \t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n \t\t\tmerge.setProgressMonitor(monitor);\n \t\t\tMergeResult mergeRes = merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1cda4faed425286fe5230a6b2b8454c376ba79f1": {
			"type": "Ybodychange",
			"commitMessage": "PullCommand: Allow to set tag behavior\n\nAdd a new method setTagOpt which sets the annotated tag behavior during\nfetch. Pass the option to the fetch command.\n\nNo explicit tests are added; the fetch with tags functionality is already\ncovered by the tests of the fetch command.\n\nChange-Id: I131e1f68d8fcced178d8fa48abf7ffab17f8e173\nSigned-off-by: David Pursehouse <david.pursehouse@gmail.com>\n",
			"commitDate": "2017-02-18, 7:21 AM",
			"commitName": "1cda4faed425286fe5230a6b2b8454c376ba79f1",
			"commitAuthor": "David Pursehouse",
			"commitDateOld": "2016-09-14, 4:44 PM",
			"commitNameOld": "aadbb158e10ccc3194c4e7f2c1b3885b3c40571c",
			"commitAuthorOld": "Thomas Wolf",
			"daysBetweenCommits": 156.65,
			"commitsBetweenForRepo": 221,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,155 +1,154 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (fullBranch == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tConfig repoConfig = repo.getConfig();\n \t\tif (remote == null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.<branch name>.remote\n \t\t\tremote = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\tif (remoteBranchName == null)\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.<branch name>.merge\n \t\t\tremoteBranchName = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n \t\t// determines whether rebase should be used after fetching\n \t\tif (pullRebaseMode == null) {\n \t\t\tpullRebaseMode = getRebaseMode(branchName, repoConfig);\n \t\t}\n \n \t\tif (remoteBranchName == null)\n \t\t\tremoteBranchName = branchName;\n \n \t\tfinal boolean isRemote = !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n-\t\t\tFetchCommand fetch = new FetchCommand(repo);\n-\t\t\tfetch.setRemote(remote);\n-\t\t\tfetch.setProgressMonitor(monitor);\n+\t\t\tFetchCommand fetch = new FetchCommand(repo).setRemote(remote)\n+\t\t\t\t\t.setProgressMonitor(monitor).setTagOpt(tagOption);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = JGitText.get().localRepository;\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null) {\n \t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n \t\t\t\t\t\tremoteBranchName));\n \t\t\t} else {\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t\t}\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName = MessageFormat.format(\n \t\t\t\tJGitText.get().upstreamBranchName,\n \t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n \t\tif (pullRebaseMode != BranchRebaseMode.NONE) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.setPreserveMerges(\n \t\t\t\t\t\t\tpullRebaseMode == BranchRebaseMode.PRESERVE)\n \t\t\t\t\t.call();\n \t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n \t\t\tmerge.setProgressMonitor(monitor);\n \t\t\tMergeResult mergeRes = merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"aadbb158e10ccc3194c4e7f2c1b3885b3c40571c": {
			"type": "Ybodychange",
			"commitMessage": "Handle all values of branch.[name].rebase\n\nBranchConfig treated this config property as a boolean, but git also\nallows the values \"preserve\" and \"interactive\". Config property\npull.rebase also allows the same values.\n\nReplace private enum PullCommand.PullRebaseMode by new public enum\nBranchConfig.BranchRebaseMode and adapt all uses. Add a new setter to\nPullCommand.\n\nNote: PullCommand will treat \"interactive\" like \"true\", i.e., as a\nnon-interactive rebase. Not sure how \"interactive\" should be handled.\nAt least it won't balk on it.\n\nBug: 499482\nChange-Id: I7309360f5662b2c2efa1bd8ea6f112c63cf064af\nSigned-off-by: Thomas Wolf <thomas.wolf@paranor.ch>",
			"commitDate": "2016-09-14, 4:44 PM",
			"commitName": "aadbb158e10ccc3194c4e7f2c1b3885b3c40571c",
			"commitAuthor": "Thomas Wolf",
			"commitDateOld": "2016-01-21, 3:37 AM",
			"commitNameOld": "1e1fb9fc596603a44b0fff6d19eeba2b005d659d",
			"commitAuthorOld": "Laurent Delaigue",
			"daysBetweenCommits": 237.5,
			"commitsBetweenForRepo": 328,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,154 +1,155 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (fullBranch == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tConfig repoConfig = repo.getConfig();\n \t\tif (remote == null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.<branch name>.remote\n \t\t\tremote = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\tif (remoteBranchName == null)\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.<branch name>.merge\n \t\t\tremoteBranchName = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n \t\t// determines whether rebase should be used after fetching\n \t\tif (pullRebaseMode == null) {\n \t\t\tpullRebaseMode = getRebaseMode(branchName, repoConfig);\n \t\t}\n \n \t\tif (remoteBranchName == null)\n \t\t\tremoteBranchName = branchName;\n \n \t\tfinal boolean isRemote = !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = JGitText.get().localRepository;\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null) {\n \t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n \t\t\t\t\t\tremoteBranchName));\n \t\t\t} else {\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t\t}\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName = MessageFormat.format(\n \t\t\t\tJGitText.get().upstreamBranchName,\n \t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n-\t\tif (pullRebaseMode.rebase) {\n+\t\tif (pullRebaseMode != BranchRebaseMode.NONE) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n-\t\t\t\t\t.setPreserveMerges(pullRebaseMode.preserveMerges)\n+\t\t\t\t\t.setPreserveMerges(\n+\t\t\t\t\t\t\tpullRebaseMode == BranchRebaseMode.PRESERVE)\n \t\t\t\t\t.call();\n \t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n \t\t\tmerge.setProgressMonitor(monitor);\n \t\t\tMergeResult mergeRes = merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1e1fb9fc596603a44b0fff6d19eeba2b005d659d": {
			"type": "Ybodychange",
			"commitMessage": "Add progress monitor to Merger\n\nMonitoring progress of merges can be useful for users for large\nrepositories or complex merge processes that take some time.\n\nThis enables setting a monitor. Existing merge implementations in jgit\ndo not yet report progress if a monitor is set. This will be added in a\nlater change.\n\nChange-Id: I17b978b3fc91750dd88649638b90a46820a0877c\nSigned-off-by: Laurent Delaigue <laurent.delaigue@obeo.fr>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2016-01-21, 3:37 AM",
			"commitName": "1e1fb9fc596603a44b0fff6d19eeba2b005d659d",
			"commitAuthor": "Laurent Delaigue",
			"commitDateOld": "2015-06-11, 11:44 AM",
			"commitNameOld": "bbfd9b0e5fc0160f5a1034ce23958a8040e88748",
			"commitAuthorOld": "Jonathan Nieder",
			"daysBetweenCommits": 223.7,
			"commitsBetweenForRepo": 350,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,153 +1,154 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (fullBranch == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tConfig repoConfig = repo.getConfig();\n \t\tif (remote == null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.<branch name>.remote\n \t\t\tremote = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\tif (remoteBranchName == null)\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.<branch name>.merge\n \t\t\tremoteBranchName = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n \t\t// determines whether rebase should be used after fetching\n \t\tif (pullRebaseMode == null) {\n \t\t\tpullRebaseMode = getRebaseMode(branchName, repoConfig);\n \t\t}\n \n \t\tif (remoteBranchName == null)\n \t\t\tremoteBranchName = branchName;\n \n \t\tfinal boolean isRemote = !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = JGitText.get().localRepository;\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null) {\n \t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n \t\t\t\t\t\tremoteBranchName));\n \t\t\t} else {\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t\t}\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName = MessageFormat.format(\n \t\t\t\tJGitText.get().upstreamBranchName,\n \t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n \t\tif (pullRebaseMode.rebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.setPreserveMerges(pullRebaseMode.preserveMerges)\n \t\t\t\t\t.call();\n \t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n+\t\t\tmerge.setProgressMonitor(monitor);\n \t\t\tMergeResult mergeRes = merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"efacad0fc8e98505be6f007230ab2b1cdc1684f3": {
			"type": "Ymultichange(Yexceptionschange,Ybodychange)",
			"commitMessage": "Improve exception thrown when pull can't find advertised ref\n\n- throw an API exception instead of an internal exception to allow\napplications to handle this problem\n- improve error message to give hints about possible root causes\n\nBug: 464660\nChange-Id: Ib7d18bb2eeeac0fc218daea375b290ea5034bda1\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2015-05-28, 4:15 PM",
			"commitName": "efacad0fc8e98505be6f007230ab2b1cdc1684f3",
			"commitAuthor": "Matthias Sohn",
			"subchanges": [
				{
					"type": "Yexceptionschange",
					"commitMessage": "Improve exception thrown when pull can't find advertised ref\n\n- throw an API exception instead of an internal exception to allow\napplications to handle this problem\n- improve error message to give hints about possible root causes\n\nBug: 464660\nChange-Id: Ib7d18bb2eeeac0fc218daea375b290ea5034bda1\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
					"commitDate": "2015-05-28, 4:15 PM",
					"commitName": "efacad0fc8e98505be6f007230ab2b1cdc1684f3",
					"commitAuthor": "Matthias Sohn",
					"commitDateOld": "2015-05-26, 2:52 AM",
					"commitNameOld": "2390531888af6dc9e4fda6cb026271dc068c40ab",
					"commitAuthorOld": "Matthias Sohn",
					"daysBetweenCommits": 2.56,
					"commitsBetweenForRepo": 23,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,151 +1,153 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n-\t\t\tRefNotFoundException, NoHeadException,\n+\t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (fullBranch == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tConfig repoConfig = repo.getConfig();\n \t\tif (remote == null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.<branch name>.remote\n \t\t\tremote = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\tif (remoteBranchName == null)\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.<branch name>.merge\n \t\t\tremoteBranchName = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n \t\t// determines whether rebase should be used after fetching\n \t\tif (pullRebaseMode == null) {\n \t\t\tpullRebaseMode = getRebaseMode(branchName, repoConfig);\n \t\t}\n \n \t\tif (remoteBranchName == null)\n \t\t\tremoteBranchName = branchName;\n \n \t\tfinal boolean isRemote = !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = JGitText.get().localRepository;\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n-\t\t\tif (r == null)\n-\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n-\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n-\t\t\telse\n+\t\t\tif (r == null) {\n+\t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n+\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n+\t\t\t\t\t\tremoteBranchName));\n+\t\t\t} else {\n \t\t\t\tcommitToMerge = r.getObjectId();\n+\t\t\t}\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName = MessageFormat.format(\n \t\t\t\tJGitText.get().upstreamBranchName,\n \t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n \t\tif (pullRebaseMode.rebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.setPreserveMerges(pullRebaseMode.preserveMerges)\n \t\t\t\t\t.call();\n \t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n \t\t\tMergeResult mergeRes = merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException]",
						"newValue": "[GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Improve exception thrown when pull can't find advertised ref\n\n- throw an API exception instead of an internal exception to allow\napplications to handle this problem\n- improve error message to give hints about possible root causes\n\nBug: 464660\nChange-Id: Ib7d18bb2eeeac0fc218daea375b290ea5034bda1\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
					"commitDate": "2015-05-28, 4:15 PM",
					"commitName": "efacad0fc8e98505be6f007230ab2b1cdc1684f3",
					"commitAuthor": "Matthias Sohn",
					"commitDateOld": "2015-05-26, 2:52 AM",
					"commitNameOld": "2390531888af6dc9e4fda6cb026271dc068c40ab",
					"commitAuthorOld": "Matthias Sohn",
					"daysBetweenCommits": 2.56,
					"commitsBetweenForRepo": 23,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,151 +1,153 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n-\t\t\tRefNotFoundException, NoHeadException,\n+\t\t\tRefNotFoundException, RefNotAdvertisedException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (fullBranch == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tConfig repoConfig = repo.getConfig();\n \t\tif (remote == null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.<branch name>.remote\n \t\t\tremote = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\tif (remoteBranchName == null)\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.<branch name>.merge\n \t\t\tremoteBranchName = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n \t\t// determines whether rebase should be used after fetching\n \t\tif (pullRebaseMode == null) {\n \t\t\tpullRebaseMode = getRebaseMode(branchName, repoConfig);\n \t\t}\n \n \t\tif (remoteBranchName == null)\n \t\t\tremoteBranchName = branchName;\n \n \t\tfinal boolean isRemote = !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = JGitText.get().localRepository;\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n-\t\t\tif (r == null)\n-\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n-\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n-\t\t\telse\n+\t\t\tif (r == null) {\n+\t\t\t\tthrow new RefNotAdvertisedException(MessageFormat.format(\n+\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef, remote,\n+\t\t\t\t\t\tremoteBranchName));\n+\t\t\t} else {\n \t\t\t\tcommitToMerge = r.getObjectId();\n+\t\t\t}\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName = MessageFormat.format(\n \t\t\t\tJGitText.get().upstreamBranchName,\n \t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n \t\tif (pullRebaseMode.rebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.setPreserveMerges(pullRebaseMode.preserveMerges)\n \t\t\t\t\t.call();\n \t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n \t\t\tMergeResult mergeRes = merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"2390531888af6dc9e4fda6cb026271dc068c40ab": {
			"type": "Ybodychange",
			"commitMessage": "Externalize translatable texts in org.eclipse.jgit\n\nChange-Id: Ibf4c299f9d203c78cae79e61f88d4bea60ea2795\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2015-05-26, 2:52 AM",
			"commitName": "2390531888af6dc9e4fda6cb026271dc068c40ab",
			"commitAuthor": "Matthias Sohn",
			"commitDateOld": "2014-07-15, 5:08 PM",
			"commitNameOld": "48544e27ae3808807dc1960083d8e42c05e62af3",
			"commitAuthorOld": "Konrad Kgler",
			"daysBetweenCommits": 314.41,
			"commitsBetweenForRepo": 408,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,151 +1,151 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (fullBranch == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tConfig repoConfig = repo.getConfig();\n \t\tif (remote == null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.<branch name>.remote\n \t\t\tremote = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\tif (remoteBranchName == null)\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.<branch name>.merge\n \t\t\tremoteBranchName = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n \t\t// determines whether rebase should be used after fetching\n \t\tif (pullRebaseMode == null) {\n \t\t\tpullRebaseMode = getRebaseMode(branchName, repoConfig);\n \t\t}\n \n \t\tif (remoteBranchName == null)\n \t\t\tremoteBranchName = branchName;\n \n \t\tfinal boolean isRemote = !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n-\t\t\tremoteUri = \"local repository\";\n+\t\t\tremoteUri = JGitText.get().localRepository;\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n-\t\tString upstreamName = \"branch \\'\"\n-\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\' of \"\n-\t\t\t\t+ remoteUri;\n+\t\tString upstreamName = MessageFormat.format(\n+\t\t\t\tJGitText.get().upstreamBranchName,\n+\t\t\t\tRepository.shortenRefName(remoteBranchName), remoteUri);\n \n \t\tPullResult result;\n \t\tif (pullRebaseMode.rebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.setPreserveMerges(pullRebaseMode.preserveMerges)\n \t\t\t\t\t.call();\n \t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n \t\t\tMergeResult mergeRes = merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"48544e27ae3808807dc1960083d8e42c05e62af3": {
			"type": "Ybodychange",
			"commitMessage": "Preserve merges during pull if configured to do so\n\nSetting branch.<name>.rebase or pull.rebase to 'preserve' will preserve\nmerges during rebase. Also, pull.rebase is now consulted if there is no\nbranch-specific configuration.\n\nBug: 429664\nChange-Id: I345fa295c7e774e0d0a8e6aba30fbfc3552e0084\nSigned-off-by: Konrad Kgler <swamblumat-eclipsebugs@yahoo.de>\n",
			"commitDate": "2014-07-15, 5:08 PM",
			"commitName": "48544e27ae3808807dc1960083d8e42c05e62af3",
			"commitAuthor": "Konrad Kgler",
			"commitDateOld": "2014-05-06, 8:30 AM",
			"commitNameOld": "7424d58255340fa44d9191a7436fbe70d72a457c",
			"commitAuthorOld": "Laurent Goubet",
			"daysBetweenCommits": 70.36,
			"commitsBetweenForRepo": 77,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,163 +1,151 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (fullBranch == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tConfig repoConfig = repo.getConfig();\n \t\tif (remote == null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.<branch name>.remote\n \t\t\tremote = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\tif (remoteBranchName == null)\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.<branch name>.merge\n \t\t\tremoteBranchName = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n-        // determines whether rebase should be used after fetching\n-        boolean doRebase = false;\n-        switch (pullRebaseMode) {\n-            case REBASE:\n-                doRebase = true;\n-                break;\n-            case NO_REBASE:\n-                doRebase = false;\n-                break;\n-            case USE_CONFIG:\n-            default:\n-                // check if the branch is configured for pull-rebase\n-                doRebase = repoConfig.getBoolean(\n-                        ConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n-                        ConfigConstants.CONFIG_KEY_REBASE, false);\n-                break;\n-        }\n+\t\t// determines whether rebase should be used after fetching\n+\t\tif (pullRebaseMode == null) {\n+\t\t\tpullRebaseMode = getRebaseMode(branchName, repoConfig);\n+\t\t}\n \n \t\tif (remoteBranchName == null)\n \t\t\tremoteBranchName = branchName;\n \n \t\tfinal boolean isRemote = !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName = \"branch \\'\"\n \t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\' of \"\n \t\t\t\t+ remoteUri;\n \n \t\tPullResult result;\n-\t\tif (doRebase) {\n+\t\tif (pullRebaseMode.rebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n \t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n+\t\t\t\t\t.setPreserveMerges(pullRebaseMode.preserveMerges)\n \t\t\t\t\t.call();\n \t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tmerge.setStrategy(strategy);\n \t\t\tMergeResult mergeRes = merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7424d58255340fa44d9191a7436fbe70d72a457c": {
			"type": "Ybodychange",
			"commitMessage": "Allow callers to use different merging strategies\n\nSigned-off-by: Laurent Goubet <laurent.goubet@obeo.fr>\nChange-Id: I84e9d7b4b772b4ad7d3e7010aad78291d4d178fe\n",
			"commitDate": "2014-05-06, 8:30 AM",
			"commitName": "7424d58255340fa44d9191a7436fbe70d72a457c",
			"commitAuthor": "Laurent Goubet",
			"commitDateOld": "2014-03-29, 11:34 AM",
			"commitNameOld": "32ff57a2b2b9480f4d374a2592fada7f720b124f",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 37.87,
			"commitsBetweenForRepo": 55,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,162 +1,163 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (fullBranch == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\tConfig repoConfig = repo.getConfig();\n \t\tif (remote == null) {\n \t\t\t// get the configured remote for the currently checked out branch\n \t\t\t// stored in configuration key branch.<branch name>.remote\n \t\t\tremote = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\t}\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\tif (remoteBranchName == null)\n \t\t\t// get the name of the branch in the remote repository\n \t\t\t// stored in configuration key branch.<branch name>.merge\n \t\t\tremoteBranchName = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n         // determines whether rebase should be used after fetching\n         boolean doRebase = false;\n         switch (pullRebaseMode) {\n             case REBASE:\n                 doRebase = true;\n                 break;\n             case NO_REBASE:\n                 doRebase = false;\n                 break;\n             case USE_CONFIG:\n             default:\n                 // check if the branch is configured for pull-rebase\n                 doRebase = repoConfig.getBoolean(\n                         ConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n                         ConfigConstants.CONFIG_KEY_REBASE, false);\n                 break;\n         }\n \n \t\tif (remoteBranchName == null)\n \t\t\tremoteBranchName = branchName;\n \n \t\tfinal boolean isRemote = !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName = \"branch \\'\"\n \t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\' of \"\n \t\t\t\t+ remoteUri;\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n-\t\t\t\t\t.setUpstreamName(upstreamName)\n-\t\t\t\t\t.setProgressMonitor(monitor).setOperation(Operation.BEGIN)\n+\t\t\t\t\t.setUpstreamName(upstreamName).setProgressMonitor(monitor)\n+\t\t\t\t\t.setOperation(Operation.BEGIN).setStrategy(strategy)\n \t\t\t\t\t.call();\n \t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n+\t\t\tmerge.setStrategy(strategy);\n \t\t\tMergeResult mergeRes = merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1eae309723be301a4f2fc12a3e07e7e7c9f30782": {
			"type": "Ybodychange",
			"commitMessage": "Allow programmatic remote configuration for PullCommand\n\nAlso imply remoteBranchName to match current branch name if it wasn't\nconfigured in branch configuration.\n\nBug: 424812\nChange-Id: Id852cedaefb2a537b6aa3c330b9861efad052f11\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2014-02-14, 8:10 AM",
			"commitName": "1eae309723be301a4f2fc12a3e07e7e7c9f30782",
			"commitAuthor": "Matthias Sohn",
			"commitDateOld": "2012-12-27, 8:57 AM",
			"commitNameOld": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 413.97,
			"commitsBetweenForRepo": 508,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,163 +1,162 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (fullBranch == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n-\t\t// get the configured remote for the currently checked out branch\n-\t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n-\t\tString remote = repoConfig.getString(\n-\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n-\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n+\t\tif (remote == null) {\n+\t\t\t// get the configured remote for the currently checked out branch\n+\t\t\t// stored in configuration key branch.<branch name>.remote\n+\t\t\tremote = repoConfig.getString(\n+\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n+\t\t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n+\t\t}\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n-\t\t// get the name of the branch in the remote repository\n-\t\t// stored in configuration key branch.<branch name>.merge\n-\t\tString remoteBranchName = repoConfig.getString(\n-\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n-\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n+\t\tif (remoteBranchName == null)\n+\t\t\t// get the name of the branch in the remote repository\n+\t\t\t// stored in configuration key branch.<branch name>.merge\n+\t\t\tremoteBranchName = repoConfig.getString(\n+\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n+\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n         // determines whether rebase should be used after fetching\n         boolean doRebase = false;\n         switch (pullRebaseMode) {\n             case REBASE:\n                 doRebase = true;\n                 break;\n             case NO_REBASE:\n                 doRebase = false;\n                 break;\n             case USE_CONFIG:\n             default:\n                 // check if the branch is configured for pull-rebase\n                 doRebase = repoConfig.getBoolean(\n                         ConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n                         ConfigConstants.CONFIG_KEY_REBASE, false);\n                 break;\n         }\n \n-\t\tif (remoteBranchName == null) {\n-\t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n-\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n-\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n-\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n-\t\t}\n+\t\tif (remoteBranchName == null)\n+\t\t\tremoteBranchName = branchName;\n \n \t\tfinal boolean isRemote = !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName = \"branch \\'\"\n \t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\' of \"\n \t\t\t\t+ remoteUri;\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName)\n \t\t\t\t\t.setProgressMonitor(monitor).setOperation(Operation.BEGIN)\n \t\t\t\t\t.call();\n \t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tMergeResult mergeRes = merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c310fa0c802f40a774edb58641de3ac5bfad0e2c": {
			"type": "Ybodychange",
			"commitMessage": "Mark non-externalizable strings as such\n\nA few classes such as Constanrs are marked with @SuppressWarnings, as are\ntoString() methods with many liternal, but otherwise $NLS-n$ is used for\nstring containing text that should not be translated. A few literals may\nfall into the gray zone, but mostly I've tried to only tag the obvious\nones.\n\nChange-Id: I22e50a77e2bf9e0b842a66bdf674e8fa1692f590\n",
			"commitDate": "2012-12-27, 8:57 AM",
			"commitName": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
			"commitAuthor": "Robin Rosenberg",
			"commitDateOld": "2012-11-16, 1:51 PM",
			"commitNameOld": "fa5231191d530afb24810080e89990913c8e8054",
			"commitAuthorOld": "Mikael Karlsson",
			"daysBetweenCommits": 40.8,
			"commitsBetweenForRepo": 34,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,163 +1,163 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (fullBranch == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n \t\tString remote = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.<branch name>.merge\n \t\tString remoteBranchName = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \n         // determines whether rebase should be used after fetching\n         boolean doRebase = false;\n         switch (pullRebaseMode) {\n             case REBASE:\n                 doRebase = true;\n                 break;\n             case NO_REBASE:\n                 doRebase = false;\n                 break;\n             case USE_CONFIG:\n             default:\n                 // check if the branch is configured for pull-rebase\n                 doRebase = repoConfig.getBoolean(\n                         ConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n                         ConfigConstants.CONFIG_KEY_REBASE, false);\n                 break;\n         }\n \n \t\tif (remoteBranchName == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n-\t\tfinal boolean isRemote = !remote.equals(\".\");\n+\t\tfinal boolean isRemote = !remote.equals(\".\"); //$NON-NLS-1$\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName = \"branch \\'\"\n \t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\' of \"\n \t\t\t\t+ remoteUri;\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName)\n \t\t\t\t\t.setProgressMonitor(monitor).setOperation(Operation.BEGIN)\n \t\t\t\t\t.call();\n \t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tMergeResult mergeRes = merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fa5231191d530afb24810080e89990913c8e8054": {
			"type": "Ybodychange",
			"commitMessage": "Add support for pull with --rebase and --no-rebase\n\nBug: 394501\nChange-Id: I697e2fc82a46c03762111eb1de93e673a2643b4f\nSigned-off-by: Chris Aniszczyk <zx@twitter.com>\n",
			"commitDate": "2012-11-16, 1:51 PM",
			"commitName": "fa5231191d530afb24810080e89990913c8e8054",
			"commitAuthor": "Mikael Karlsson",
			"commitDateOld": "2012-08-17, 4:11 PM",
			"commitNameOld": "5854ca091a22346e1c710ca9f875165afb3f2cc8",
			"commitAuthorOld": "Robin Stocker",
			"daysBetweenCommits": 90.94,
			"commitsBetweenForRepo": 109,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,149 +1,163 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (fullBranch == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n \t\tString remote = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.<branch name>.merge\n \t\tString remoteBranchName = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n-\t\t// check if the branch is configured for pull-rebase\n-\t\tboolean doRebase = repoConfig.getBoolean(\n-\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n-\t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n+\n+        // determines whether rebase should be used after fetching\n+        boolean doRebase = false;\n+        switch (pullRebaseMode) {\n+            case REBASE:\n+                doRebase = true;\n+                break;\n+            case NO_REBASE:\n+                doRebase = false;\n+                break;\n+            case USE_CONFIG:\n+            default:\n+                // check if the branch is configured for pull-rebase\n+                doRebase = repoConfig.getBoolean(\n+                        ConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n+                        ConfigConstants.CONFIG_KEY_REBASE, false);\n+                break;\n+        }\n \n \t\tif (remoteBranchName == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote = !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tString upstreamName = \"branch \\'\"\n \t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\' of \"\n \t\t\t\t+ remoteUri;\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t.setUpstreamName(upstreamName)\n \t\t\t\t\t.setProgressMonitor(monitor).setOperation(Operation.BEGIN)\n \t\t\t\t\t.call();\n \t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tMergeResult mergeRes = merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5854ca091a22346e1c710ca9f875165afb3f2cc8": {
			"type": "Ybodychange",
			"commitMessage": "Improve ours/theirs conflict markers for rebase, cherry-pick\n\nOn conflicts in rebase or cherry-pick, the conflict markers were like\nthis:\n\n    <<<<<<< OURS\n    a\n    =======\n    b\n    >>>>>>> THEIRS\n\nThis is technically correct, but it could be better.\n\nIt's especially confusing during a rebase, where the meaning of\nOURS/THEIRS is not obvious. The intuition is that \"ours\" is the commits\nthat \"I\" did before the rebase, but it's the other way around because of\nthe way rebase works. See various bug reports and stackoverflow\ndiscussions.\n\nWith this change, in the case of a cherry-pick while on master, the\nmarkers will be like this:\n\n    <<<<<<< master\n    a\n    =======\n    b\n    >>>>>>> bad1dea Message of the commit I'm cherry-picking\n\nIn the case of a \"git rebase master\":\n\n    <<<<<<< Upstream, based on master\n    a\n    =======\n    b\n    >>>>>>> b161dea Message of a commit I'm rebasing\n\nIt's not \"master\" because that would only be correct for the first\ncherry-pick during a rebase, after that, it's master + already\ncherry-picked commits.\n\nAnd in the case of a \"git pull --rebase\":\n\n    <<<<<<< Upstream, based on branch 'master' of git@example.org:repo\n    a\n    =======\n    b\n    >>>>>>> b161dea Message of a commit I'm rebasing\n\nBug: 336819\nChange-Id: I1333a8dd170bb0077f491962013485efb6f2a926\nSigned-off-by: Robin Stocker <robin@nibor.org>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2012-08-17, 4:11 PM",
			"commitName": "5854ca091a22346e1c710ca9f875165afb3f2cc8",
			"commitAuthor": "Robin Stocker",
			"commitDateOld": "2012-06-05, 8:55 AM",
			"commitNameOld": "b61d35e848e637ef85fde4ebe95d60ced171e963",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 73.3,
			"commitsBetweenForRepo": 70,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,147 +1,149 @@\n \tpublic PullResult call() throws GitAPIException,\n \t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n \t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n \t\t\tRefNotFoundException, NoHeadException,\n \t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (fullBranch == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n \t\tString remote = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.<branch name>.merge\n \t\tString remoteBranchName = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase = repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote = !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n+\t\tString upstreamName = \"branch \\'\"\n+\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\' of \"\n+\t\t\t\t+ remoteUri;\n+\n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n+\t\t\t\t\t.setUpstreamName(upstreamName)\n \t\t\t\t\t.setProgressMonitor(monitor).setOperation(Operation.BEGIN)\n \t\t\t\t\t.call();\n \t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n-\t\t\tString name = \"branch \\'\"\n-\t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\' of \"\n-\t\t\t\t\t+ remoteUri;\n-\t\t\tmerge.include(name, commitToMerge);\n+\t\t\tmerge.include(upstreamName, commitToMerge);\n \t\t\tMergeResult mergeRes = merge.call();\n \t\t\tmonitor.update(1);\n \t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b61d35e848e637ef85fde4ebe95d60ced171e963": {
			"type": "Ymultichange(Yexceptionschange,Ybodychange)",
			"commitMessage": "Further cleanup of exceptions in Git API\n\n- Translate internal exceptions to corresponding API exception\n- Do not catch GitAPI exceptions internally to an internal\nexception. Just pass them to caller\n- Mention thrown exceptions in javadoc\n\nChange-Id: I9044cf86d2b0bcc8b63b7cc016e1bf0055a62053\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2012-06-05, 8:55 AM",
			"commitName": "b61d35e848e637ef85fde4ebe95d60ced171e963",
			"commitAuthor": "Robin Rosenberg",
			"subchanges": [
				{
					"type": "Yexceptionschange",
					"commitMessage": "Further cleanup of exceptions in Git API\n\n- Translate internal exceptions to corresponding API exception\n- Do not catch GitAPI exceptions internally to an internal\nexception. Just pass them to caller\n- Mention thrown exceptions in javadoc\n\nChange-Id: I9044cf86d2b0bcc8b63b7cc016e1bf0055a62053\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
					"commitDate": "2012-06-05, 8:55 AM",
					"commitName": "b61d35e848e637ef85fde4ebe95d60ced171e963",
					"commitAuthor": "Robin Rosenberg",
					"commitDateOld": "2012-05-30, 2:08 PM",
					"commitNameOld": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
					"commitAuthorOld": "Robin Rosenberg",
					"daysBetweenCommits": 5.78,
					"commitsBetweenForRepo": 16,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,171 +1,147 @@\n-\tpublic PullResult call() throws GitAPIException, WrongRepositoryStateException,\n-\t\t\tInvalidConfigurationException, DetachedHeadException,\n-\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException,\n-\t\t\tNoHeadException {\n+\tpublic PullResult call() throws GitAPIException,\n+\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n+\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n+\t\t\tRefNotFoundException, NoHeadException,\n+\t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (fullBranch == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n \t\tString remote = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.<branch name>.merge\n \t\tString remoteBranchName = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase = repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote = !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n-\t\t\ttry {\n-\t\t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n-\t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n-\t\t\t\t\t\t\t\tOperation.BEGIN).call();\n-\t\t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n-\t\t\t} catch (NoHeadException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (RefNotFoundException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (JGitInternalException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (GitAPIException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t}\n+\t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n+\t\t\t\t\t.setProgressMonitor(monitor).setOperation(Operation.BEGIN)\n+\t\t\t\t\t.call();\n+\t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tString name = \"branch \\'\"\n \t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\' of \"\n \t\t\t\t\t+ remoteUri;\n \t\t\tmerge.include(name, commitToMerge);\n-\t\t\tMergeResult mergeRes;\n-\t\t\ttry {\n-\t\t\t\tmergeRes = merge.call();\n-\t\t\t\tmonitor.update(1);\n-\t\t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n-\t\t\t} catch (NoHeadException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (ConcurrentRefUpdateException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (CheckoutConflictException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (InvalidMergeHeadsException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (WrongRepositoryStateException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (NoMessageException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t}\n+\t\t\tMergeResult mergeRes = merge.call();\n+\t\t\tmonitor.update(1);\n+\t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException]",
						"newValue": "[GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Further cleanup of exceptions in Git API\n\n- Translate internal exceptions to corresponding API exception\n- Do not catch GitAPI exceptions internally to an internal\nexception. Just pass them to caller\n- Mention thrown exceptions in javadoc\n\nChange-Id: I9044cf86d2b0bcc8b63b7cc016e1bf0055a62053\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
					"commitDate": "2012-06-05, 8:55 AM",
					"commitName": "b61d35e848e637ef85fde4ebe95d60ced171e963",
					"commitAuthor": "Robin Rosenberg",
					"commitDateOld": "2012-05-30, 2:08 PM",
					"commitNameOld": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
					"commitAuthorOld": "Robin Rosenberg",
					"daysBetweenCommits": 5.78,
					"commitsBetweenForRepo": 16,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,171 +1,147 @@\n-\tpublic PullResult call() throws GitAPIException, WrongRepositoryStateException,\n-\t\t\tInvalidConfigurationException, DetachedHeadException,\n-\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException,\n-\t\t\tNoHeadException {\n+\tpublic PullResult call() throws GitAPIException,\n+\t\t\tWrongRepositoryStateException, InvalidConfigurationException,\n+\t\t\tDetachedHeadException, InvalidRemoteException, CanceledException,\n+\t\t\tRefNotFoundException, NoHeadException,\n+\t\t\torg.eclipse.jgit.api.errors.TransportException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (fullBranch == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n \t\tString remote = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.<branch name>.merge\n \t\tString remoteBranchName = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase = repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote = !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n-\t\t\ttry {\n-\t\t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n-\t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n-\t\t\t\t\t\t\t\tOperation.BEGIN).call();\n-\t\t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n-\t\t\t} catch (NoHeadException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (RefNotFoundException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (JGitInternalException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (GitAPIException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t}\n+\t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n+\t\t\t\t\t.setProgressMonitor(monitor).setOperation(Operation.BEGIN)\n+\t\t\t\t\t.call();\n+\t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tString name = \"branch \\'\"\n \t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\' of \"\n \t\t\t\t\t+ remoteUri;\n \t\t\tmerge.include(name, commitToMerge);\n-\t\t\tMergeResult mergeRes;\n-\t\t\ttry {\n-\t\t\t\tmergeRes = merge.call();\n-\t\t\t\tmonitor.update(1);\n-\t\t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n-\t\t\t} catch (NoHeadException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (ConcurrentRefUpdateException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (CheckoutConflictException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (InvalidMergeHeadsException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (WrongRepositoryStateException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t} catch (NoMessageException e) {\n-\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t\t}\n+\t\t\tMergeResult mergeRes = merge.call();\n+\t\t\tmonitor.update(1);\n+\t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"4e1454ded6e2fcf6cb789c004756883c3ea5f77e": {
			"type": "Yexceptionschange",
			"commitMessage": "Git API does not declare GitAPIException call() and related cleanups\n\nAll commands should throw a GitAPIException so new exceptions can be\nadded without breaking the builds of old code, i.e. anyone that calls\na Git API should catch GitAPIException and not just the currently known\nexceptions.\n\nNow the only checked exceptions on Git API calls are GitException and\nsubclasses of it. New checked exceptions that are subclasses of\nGitException may be added without breaking the API.\n\nJavadoc for GitAPIException is declared on GitCommand and\ninherited to subclasses. JGitInternalException is not explicitly\ndocumented anymore.\n\nUnfortunately this change itself breaks the API. The intention is\nthat it shall be possible to add new checked subclasses of\nGitAPIException without breaking the API.\n\nBug: 366914\nEGit-Change-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nChange-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>\n",
			"commitDate": "2012-05-30, 2:08 PM",
			"commitName": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
			"commitAuthor": "Robin Rosenberg",
			"commitDateOld": "2012-03-12, 8:20 AM",
			"commitNameOld": "95d311f8886f42f31a4475f84aa23c6345ab7059",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 79.24,
			"commitsBetweenForRepo": 65,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,171 +1,171 @@\n-\tpublic PullResult call() throws WrongRepositoryStateException,\n+\tpublic PullResult call() throws GitAPIException, WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException, RefNotFoundException,\n \t\t\tNoHeadException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (fullBranch == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n \t\tString remote = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.<branch name>.merge\n \t\tString remoteBranchName = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase = repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote = !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tString name = \"branch \\'\"\n \t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\' of \"\n \t\t\t\t\t+ remoteUri;\n \t\t\tmerge.include(name, commitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes = merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException]",
				"newValue": "[GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException]"
			}
		},
		"c3fe50bb18ed4e4e5e563172be4076fa5901a18a": {
			"type": "Ymultichange(Yexceptionschange,Ybodychange)",
			"commitMessage": "Guard against null branch in PullCommand\n\nThrow a NoHeadException when Repository.getFullBranch\nreturns null\n\nBug: 351543\nChange-Id: I666cd5b67781508a293ae553c6fe5c080c8f4d99\nSigned-off-by: Kevin Sawicki <kevin@github.com>",
			"commitDate": "2011-11-22, 5:29 PM",
			"commitName": "c3fe50bb18ed4e4e5e563172be4076fa5901a18a",
			"commitAuthor": "Kevin Sawicki",
			"subchanges": [
				{
					"type": "Yexceptionschange",
					"commitMessage": "Guard against null branch in PullCommand\n\nThrow a NoHeadException when Repository.getFullBranch\nreturns null\n\nBug: 351543\nChange-Id: I666cd5b67781508a293ae553c6fe5c080c8f4d99\nSigned-off-by: Kevin Sawicki <kevin@github.com>",
					"commitDate": "2011-11-22, 5:29 PM",
					"commitName": "c3fe50bb18ed4e4e5e563172be4076fa5901a18a",
					"commitAuthor": "Kevin Sawicki",
					"commitDateOld": "2011-11-10, 11:57 AM",
					"commitNameOld": "da901c49688ef72858cd2b6904e0f8e478fa0ec3",
					"commitAuthorOld": "Kevin Sawicki",
					"daysBetweenCommits": 12.23,
					"commitsBetweenForRepo": 19,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,167 +1,171 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n-\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n+\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException,\n+\t\t\tNoHeadException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n+\t\t\tif (fullBranch == null)\n+\t\t\t\tthrow new NoHeadException(\n+\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n \t\tString remote = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.<branch name>.merge\n \t\tString remoteBranchName = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase = repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote = !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tString name = \"branch \\'\"\n \t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\' of \"\n \t\t\t\t\t+ remoteUri;\n \t\t\tmerge.include(name, commitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes = merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException]",
						"newValue": "[WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Guard against null branch in PullCommand\n\nThrow a NoHeadException when Repository.getFullBranch\nreturns null\n\nBug: 351543\nChange-Id: I666cd5b67781508a293ae553c6fe5c080c8f4d99\nSigned-off-by: Kevin Sawicki <kevin@github.com>",
					"commitDate": "2011-11-22, 5:29 PM",
					"commitName": "c3fe50bb18ed4e4e5e563172be4076fa5901a18a",
					"commitAuthor": "Kevin Sawicki",
					"commitDateOld": "2011-11-10, 11:57 AM",
					"commitNameOld": "da901c49688ef72858cd2b6904e0f8e478fa0ec3",
					"commitAuthorOld": "Kevin Sawicki",
					"daysBetweenCommits": 12.23,
					"commitsBetweenForRepo": 19,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,167 +1,171 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n-\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n+\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException,\n+\t\t\tNoHeadException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n+\t\t\tif (fullBranch == null)\n+\t\t\t\tthrow new NoHeadException(\n+\t\t\t\t\t\tJGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n \t\tString remote = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.<branch name>.merge\n \t\tString remoteBranchName = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase = repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote = !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tString name = \"branch \\'\"\n \t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\' of \"\n \t\t\t\t\t+ remoteUri;\n \t\t\tmerge.include(name, commitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes = merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"da901c49688ef72858cd2b6904e0f8e478fa0ec3": {
			"type": "Ybodychange",
			"commitMessage": "Support a configured credentials provider in LsRemoteCommand\n\nRefactored the three common transport configuration options:\ncredentials provider, timeout, and transport config callback\ninto a new TransportCommand base class which is now extended\nby all commands that use a Transport object during execution.\n\nBug: 349188\nChange-Id: I90c2c14fb4e3cc4712905158f9047153a0c235c2\nSigned-off-by: Kevin Sawicki <kevin@github.com>\nSigned-off-by: Chris Aniszczyk <zx@twitter.com>\n",
			"commitDate": "2011-11-10, 11:57 AM",
			"commitName": "da901c49688ef72858cd2b6904e0f8e478fa0ec3",
			"commitAuthor": "Kevin Sawicki",
			"commitDateOld": "2011-09-16, 9:04 AM",
			"commitNameOld": "791a9fd691e5ae101650f27f39366ec7b23f3955",
			"commitAuthorOld": "Roberto Tyley",
			"daysBetweenCommits": 55.16,
			"commitsBetweenForRepo": 52,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,169 +1,167 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n \t\tString remote = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.<branch name>.merge\n \t\tString remoteBranchName = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase = repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote = !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n-\t\t\tfetch.setTimeout(this.timeout);\n-\t\t\tfetch.setCredentialsProvider(credentialsProvider);\n-\t\t\tfetch.setTransportConfigCallback(transportConfigCallback);\n+\t\t\tconfigure(fetch);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tString name = \"branch \\'\"\n \t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\' of \"\n \t\t\t\t\t+ remoteUri;\n \t\t\tmerge.include(name, commitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes = merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"791a9fd691e5ae101650f27f39366ec7b23f3955": {
			"type": "Ybodychange",
			"commitMessage": "Enable full Transport configuration for JGit API commands\n\nAdd a TransportConfigCallback parameter to JGit API commands, to allow\nconsumers of the JGit command API to perform custom Transport configuration\nthat would be otherwise difficult to anticipate & expose on the API command\nbuilders.\n\n\nMy specific use-case is configuring additional properties on SshTransport\n- I need to take over the SshSessionFactory used by the transport. Using\nTransportConfigCallback I can simply do this (rather than reimplement the\nAPI command classes):\n\npublic void configure(Transport tn) {\n  if (tn instanceof SshTransport) {\n    ((SshTransport) tn).setSshSessionFactory(factoryProvider.get());\n  }\n}\n\nAdding an explicit setSshSessionFactory() method to the JGit command\nclasses would bloat the API. Also, creating the replacement\nSshSessionFactory is unnecessary if the transport is not SSH, but the type\nof the Transport is only known once the remote has been resolved and the\nURI parsed - consequently it makes sense to perform this step in a\ncallback, where the transport instance can be inspected to determine if\nit's of a relevant type.\n\n\nA note about where this leaves the API - there are now 4 commands:\n\nCloneCommand\nPullCommand\nFetchCommand\nPushCommand\n\n-that share 3 identical transport-related parameters:\n\ntimeout\ncredentialsProvider\ntransportConfigurator\n\nI think there's potential for introducing an interface or val-object to\nidentify/encapsulate this repetition, which I'd be happy to do in a\nsubsequent commit.\n\nChange-Id: I8983c3627cdd7d7b2aeb0b6a3dadee553378b951\nSigned-off-by: Roberto Tyley <roberto.tyley@gmail.com>\n",
			"commitDate": "2011-09-16, 9:04 AM",
			"commitName": "791a9fd691e5ae101650f27f39366ec7b23f3955",
			"commitAuthor": "Roberto Tyley",
			"commitDateOld": "2011-08-02, 8:19 AM",
			"commitNameOld": "6d293c7b06e219086959e80d495b5febe8ae530d",
			"commitAuthorOld": "Tomasz Zarna",
			"daysBetweenCommits": 45.03,
			"commitsBetweenForRepo": 44,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,168 +1,169 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n \t\tString remote = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.<branch name>.merge\n \t\tString remoteBranchName = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase = repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote = !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n \t\t\tfetch.setCredentialsProvider(credentialsProvider);\n+\t\t\tfetch.setTransportConfigCallback(transportConfigCallback);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tString name = \"branch \\'\"\n \t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\' of \"\n \t\t\t\t\t+ remoteUri;\n \t\t\tmerge.include(name, commitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes = merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6d293c7b06e219086959e80d495b5febe8ae530d": {
			"type": "Ybodychange",
			"commitMessage": "Don't hard-code section names, use ConfigConstants instead\n\nChange-Id: Ie2dde43da491fa27b25a2ad8014866d77d484b24\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2011-08-02, 8:19 AM",
			"commitName": "6d293c7b06e219086959e80d495b5febe8ae530d",
			"commitAuthor": "Tomasz Zarna",
			"commitDateOld": "2011-03-22, 12:46 PM",
			"commitNameOld": "770c733687d9f2f71f30822f9691427bf83b7577",
			"commitAuthorOld": "Robin Stocker",
			"daysBetweenCommits": 132.81,
			"commitsBetweenForRepo": 160,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,167 +1,168 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n \t\tString remote = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.<branch name>.merge\n \t\tString remoteBranchName = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase = repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote = !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n-\t\t\tremoteUri = repoConfig.getString(\"remote\", remote,\n+\t\t\tremoteUri = repoConfig.getString(\n+\t\t\t\t\tConfigConstants.CONFIG_REMOTE_SECTION, remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n \t\t\tfetch.setCredentialsProvider(credentialsProvider);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tString name = \"branch \\'\"\n \t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\' of \"\n \t\t\t\t\t+ remoteUri;\n \t\t\tmerge.include(name, commitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes = merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"770c733687d9f2f71f30822f9691427bf83b7577": {
			"type": "Ybodychange",
			"commitMessage": "PullCommand: Use short ref name in merge message\n\nAdd a test case for PullCommand for the successful merge case and test\nthat the short ref name is used.\n\nChange-Id: I16cbbc88595f73e5512f984e67f93f87ee0fe242\nSigned-off-by: Robin Stocker <robin@nibor.org>\n",
			"commitDate": "2011-03-22, 12:46 PM",
			"commitName": "770c733687d9f2f71f30822f9691427bf83b7577",
			"commitAuthor": "Robin Stocker",
			"commitDateOld": "2011-02-16, 7:46 AM",
			"commitNameOld": "68459b646e6c8243dc5650cbe08ce1bcdb8a621d",
			"commitAuthorOld": "Stefan Lay",
			"daysBetweenCommits": 34.17,
			"commitsBetweenForRepo": 108,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,166 +1,167 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n \t\tString remote = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.<branch name>.merge\n \t\tString remoteBranchName = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase = repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote = !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\"remote\", remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n \t\t\tfetch.setCredentialsProvider(credentialsProvider);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\tif (commitToMerge == null)\n \t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n-\t\t\tmerge.include(\n-\t\t\t\t\t\"branch \\'\" + remoteBranchName + \"\\' of \" + remoteUri,\n-\t\t\t\t\tcommitToMerge);\n+\t\t\tString name = \"branch \\'\"\n+\t\t\t\t\t+ Repository.shortenRefName(remoteBranchName) + \"\\' of \"\n+\t\t\t\t\t+ remoteUri;\n+\t\t\tmerge.include(name, commitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes = merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"68459b646e6c8243dc5650cbe08ce1bcdb8a621d": {
			"type": "Ymultichange(Yexceptionschange,Ybodychange)",
			"commitMessage": "Fix NullPointer when pulling from a deleted local branch\n\nA checked Exception is thrown instead. \n\nThe reason for throwing an Exception is that the state of the\nrepository is inconsistent in this case: There is a merge\nconfiguration containing a non-existing local branch. Ideally the\ndeletion of a local branch should also delete the corresponding\nmerge configuration.\n\nBug: 337315\nChange-Id: I71e56ffb90e11e6e3c1bbd964ad63972d67990c0\nSigned-off-by: Stefan Lay <stefan.lay@sap.com>",
			"commitDate": "2011-02-16, 7:46 AM",
			"commitName": "68459b646e6c8243dc5650cbe08ce1bcdb8a621d",
			"commitAuthor": "Stefan Lay",
			"subchanges": [
				{
					"type": "Yexceptionschange",
					"commitMessage": "Fix NullPointer when pulling from a deleted local branch\n\nA checked Exception is thrown instead. \n\nThe reason for throwing an Exception is that the state of the\nrepository is inconsistent in this case: There is a merge\nconfiguration containing a non-existing local branch. Ideally the\ndeletion of a local branch should also delete the corresponding\nmerge configuration.\n\nBug: 337315\nChange-Id: I71e56ffb90e11e6e3c1bbd964ad63972d67990c0\nSigned-off-by: Stefan Lay <stefan.lay@sap.com>",
					"commitDate": "2011-02-16, 7:46 AM",
					"commitName": "68459b646e6c8243dc5650cbe08ce1bcdb8a621d",
					"commitAuthor": "Stefan Lay",
					"commitDateOld": "2011-02-08, 12:56 AM",
					"commitNameOld": "724af77c65c27eb24d41989bed3229910dbe063c",
					"commitAuthorOld": "Mathias Kinzler",
					"daysBetweenCommits": 8.28,
					"commitsBetweenForRepo": 23,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,163 +1,166 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n-\t\t\tInvalidRemoteException, CanceledException {\n+\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n \t\tString remote = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.<branch name>.merge\n \t\tString remoteBranchName = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase = repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote = !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\"remote\", remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n \t\t\tfetch.setCredentialsProvider(credentialsProvider);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n+\t\t\t\tif (commitToMerge == null)\n+\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n+\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tmerge.include(\n \t\t\t\t\t\"branch \\'\" + remoteBranchName + \"\\' of \" + remoteUri,\n \t\t\t\t\tcommitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes = merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException]",
						"newValue": "[WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Fix NullPointer when pulling from a deleted local branch\n\nA checked Exception is thrown instead. \n\nThe reason for throwing an Exception is that the state of the\nrepository is inconsistent in this case: There is a merge\nconfiguration containing a non-existing local branch. Ideally the\ndeletion of a local branch should also delete the corresponding\nmerge configuration.\n\nBug: 337315\nChange-Id: I71e56ffb90e11e6e3c1bbd964ad63972d67990c0\nSigned-off-by: Stefan Lay <stefan.lay@sap.com>",
					"commitDate": "2011-02-16, 7:46 AM",
					"commitName": "68459b646e6c8243dc5650cbe08ce1bcdb8a621d",
					"commitAuthor": "Stefan Lay",
					"commitDateOld": "2011-02-08, 12:56 AM",
					"commitNameOld": "724af77c65c27eb24d41989bed3229910dbe063c",
					"commitAuthorOld": "Mathias Kinzler",
					"daysBetweenCommits": 8.28,
					"commitsBetweenForRepo": 23,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,163 +1,166 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n-\t\t\tInvalidRemoteException, CanceledException {\n+\t\t\tInvalidRemoteException, CanceledException, RefNotFoundException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n \t\tString remote = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote == null)\n \t\t\t// fall back to default remote\n \t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.<branch name>.merge\n \t\tString remoteBranchName = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase = repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote = !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\"remote\", remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n \t\t\tfetch.setCredentialsProvider(credentialsProvider);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n+\t\t\t\tif (commitToMerge == null)\n+\t\t\t\t\tthrow new RefNotFoundException(MessageFormat.format(\n+\t\t\t\t\t\t\tJGitText.get().refNotResolved, remoteBranchName));\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tmerge.include(\n \t\t\t\t\t\"branch \\'\" + remoteBranchName + \"\\' of \" + remoteUri,\n \t\t\t\t\tcommitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes = merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"724af77c65c27eb24d41989bed3229910dbe063c": {
			"type": "Ybodychange",
			"commitMessage": "PullCommand: use default remote instead of throwing Exception\n\nWhen pulling into a local branch that has no upstream configuration,\npull should try to used the default remote (\"origin\") instead of\nthrowing an Exception.\n\nBug: 336504\nChange-Id: Ife75858e89ea79c0d6d88ba73877fe8400448e34\nSigned-off-by: Mathias Kinzler <mathias.kinzler@sap.com>\n",
			"commitDate": "2011-02-08, 12:56 AM",
			"commitName": "724af77c65c27eb24d41989bed3229910dbe063c",
			"commitAuthor": "Mathias Kinzler",
			"commitDateOld": "2011-01-31, 4:12 AM",
			"commitNameOld": "b15b9d5df25b375108ca125b31338df637454865",
			"commitAuthorOld": "Mathias Kinzler",
			"daysBetweenCommits": 7.86,
			"commitsBetweenForRepo": 21,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,166 +1,163 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n-\t\tfinal String remote = repoConfig.getString(\n+\t\tString remote = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n-\t\tif (remote == null) {\n-\t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n-\t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n-\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n-\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n-\t\t}\n+\t\tif (remote == null)\n+\t\t\t// fall back to default remote\n+\t\t\tremote = Constants.DEFAULT_REMOTE_NAME;\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.<branch name>.merge\n \t\tString remoteBranchName = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\t// check if the branch is configured for pull-rebase\n \t\tboolean doRebase = repoConfig.getBoolean(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote = !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\"remote\", remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n \t\t\tfetch.setCredentialsProvider(credentialsProvider);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t// we check the updates to see which of the updated branches\n \t\t// corresponds\n \t\t// to the remote branch name\n \t\tAnyObjectId commitToMerge;\n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tmerge.include(\n \t\t\t\t\t\"branch \\'\" + remoteBranchName + \"\\' of \" + remoteUri,\n \t\t\t\t\tcommitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes = merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b15b9d5df25b375108ca125b31338df637454865": {
			"type": "Ybodychange",
			"commitMessage": "Proper handling of rebase during pull\n\nAfter consulting with Christian Halstrick, it turned out that the\nhandling of rebase during pull was implemented incorrectly.\n\nChange-Id: I40f03409e080cdfeceb21460150f5e02a016e7f4\nSigned-off-by: Mathias Kinzler <mathias.kinzler@sap.com>\n",
			"commitDate": "2011-01-31, 4:12 AM",
			"commitName": "b15b9d5df25b375108ca125b31338df637454865",
			"commitAuthor": "Mathias Kinzler",
			"commitDateOld": "2011-01-28, 1:06 PM",
			"commitNameOld": "9fbda2239202ca9d3a20c84d7326f47c667aa920",
			"commitAuthorOld": "Tomasz Zarna",
			"daysBetweenCommits": 2.63,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,173 +1,166 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n \t\tfinal String remote = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.<branch name>.merge\n \t\tString remoteBranchName = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n-\t\tboolean doRebase = false;\n-\t\tif (remoteBranchName == null) {\n-\t\t\t// check if the branch is configured for pull-rebase\n-\t\t\tremoteBranchName = repoConfig.getString(\n-\t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n-\t\t\t\t\tConfigConstants.CONFIG_KEY_REBASE);\n-\t\t\tif (remoteBranchName != null) {\n-\t\t\t\tdoRebase = true;\n-\t\t\t}\n-\t\t}\n+\t\t// check if the branch is configured for pull-rebase\n+\t\tboolean doRebase = repoConfig.getBoolean(\n+\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n+\t\t\t\tConfigConstants.CONFIG_KEY_REBASE, false);\n \n \t\tif (remoteBranchName == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote = !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\"remote\", remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n \t\t\tfetch.setCredentialsProvider(credentialsProvider);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n+\t\t// we check the updates to see which of the updated branches\n+\t\t// corresponds\n+\t\t// to the remote branch name\n+\t\tAnyObjectId commitToMerge;\n+\t\tif (isRemote) {\n+\t\t\tRef r = null;\n+\t\t\tif (fetchRes != null) {\n+\t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n+\t\t\t\tif (r == null)\n+\t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n+\t\t\t\t\t\t\t+ remoteBranchName);\n+\t\t\t}\n+\t\t\tif (r == null)\n+\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n+\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n+\t\t\telse\n+\t\t\t\tcommitToMerge = r.getObjectId();\n+\t\t} else {\n+\t\t\ttry {\n+\t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new JGitInternalException(\n+\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n+\t\t\t\t\t\te);\n+\t\t\t}\n+\t\t}\n+\n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\ttry {\n-\t\t\t\tRebaseResult rebaseRes = rebase.setUpstream(remoteBranchName)\n+\t\t\t\tRebaseResult rebaseRes = rebase.setUpstream(commitToMerge)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n-\t\t\t// we check the updates to see which of the updated branches\n-\t\t\t// corresponds\n-\t\t\t// to the remote branch name\n-\t\t\tAnyObjectId commitToMerge;\n-\n-\t\t\tif (isRemote) {\n-\t\t\t\tRef r = null;\n-\t\t\t\tif (fetchRes != null) {\n-\t\t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n-\t\t\t\t\tif (r == null)\n-\t\t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n-\t\t\t\t\t\t\t\t+ remoteBranchName);\n-\t\t\t\t}\n-\t\t\t\tif (r == null)\n-\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n-\t\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef,\n-\t\t\t\t\t\t\tremoteBranchName));\n-\t\t\t\telse\n-\t\t\t\t\tcommitToMerge = r.getObjectId();\n-\t\t\t} else {\n-\t\t\t\ttry {\n-\t\t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n-\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\tthrow new JGitInternalException(\n-\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n-\t\t\t\t\t\t\te);\n-\t\t\t\t}\n-\t\t\t}\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tmerge.include(\n \t\t\t\t\t\"branch \\'\" + remoteBranchName + \"\\' of \" + remoteUri,\n \t\t\t\t\tcommitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes = merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9fbda2239202ca9d3a20c84d7326f47c667aa920": {
			"type": "Ybodychange",
			"commitMessage": "Add setCredentialsProvider to PullCommand\n\nBug: 335703\nChange-Id: Id9713a4849c772e030fca23dd64b993264f28366\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
			"commitDate": "2011-01-28, 1:06 PM",
			"commitName": "9fbda2239202ca9d3a20c84d7326f47c667aa920",
			"commitAuthor": "Tomasz Zarna",
			"commitDateOld": "2011-01-28, 7:04 AM",
			"commitNameOld": "14ca80bc90ed85e3484fa28aa665fa0538096d30",
			"commitAuthorOld": "Mathias Kinzler",
			"daysBetweenCommits": 0.25,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,172 +1,173 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n \t\tfinal String remote = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.<branch name>.merge\n \t\tString remoteBranchName = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\tboolean doRebase = false;\n \t\tif (remoteBranchName == null) {\n \t\t\t// check if the branch is configured for pull-rebase\n \t\t\tremoteBranchName = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REBASE);\n \t\t\tif (remoteBranchName != null) {\n \t\t\t\tdoRebase = true;\n \t\t\t}\n \t\t}\n \n \t\tif (remoteBranchName == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote = !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\"remote\", remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n+\t\t\tfetch.setCredentialsProvider(credentialsProvider);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\tPullResult result;\n \t\tif (doRebase) {\n \t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n \t\t\ttry {\n \t\t\t\tRebaseResult rebaseRes = rebase.setUpstream(remoteBranchName)\n \t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n \t\t\t\t\t\t\t\tOperation.BEGIN).call();\n \t\t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (RefNotFoundException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (JGitInternalException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (GitAPIException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t} else {\n \t\t\t// we check the updates to see which of the updated branches\n \t\t\t// corresponds\n \t\t\t// to the remote branch name\n \t\t\tAnyObjectId commitToMerge;\n \n \t\t\tif (isRemote) {\n \t\t\t\tRef r = null;\n \t\t\t\tif (fetchRes != null) {\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\t\tif (r == null)\n \t\t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t\t}\n \t\t\t\tif (r == null)\n \t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef,\n \t\t\t\t\t\t\tremoteBranchName));\n \t\t\t\telse\n \t\t\t\t\tcommitToMerge = r.getObjectId();\n \t\t\t} else {\n \t\t\t\ttry {\n \t\t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t\t} catch (IOException e) {\n \t\t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\t\te);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMergeCommand merge = new MergeCommand(repo);\n \t\t\tmerge.include(\n \t\t\t\t\t\"branch \\'\" + remoteBranchName + \"\\' of \" + remoteUri,\n \t\t\t\t\tcommitToMerge);\n \t\t\tMergeResult mergeRes;\n \t\t\ttry {\n \t\t\t\tmergeRes = merge.call();\n \t\t\t\tmonitor.update(1);\n \t\t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n \t\t\t} catch (NoHeadException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (CheckoutConflictException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (InvalidMergeHeadsException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (WrongRepositoryStateException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t} catch (NoMessageException e) {\n \t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"14ca80bc90ed85e3484fa28aa665fa0538096d30": {
			"type": "Ybodychange",
			"commitMessage": "Make PullCommand work with Rebase\n\nRebase must honor the upstream configuration\n\nbranch.<branchname>.rebase\n\nChange-Id: Ic94f263d3f47b630ad75bd5412cb4741bb1109ca\nSigned-off-by: Mathias Kinzler <mathias.kinzler@sap.com>\n",
			"commitDate": "2011-01-28, 7:04 AM",
			"commitName": "14ca80bc90ed85e3484fa28aa665fa0538096d30",
			"commitAuthor": "Mathias Kinzler",
			"commitDateOld": "2010-12-15, 4:14 PM",
			"commitNameOld": "013cb8de3824c304645a9c5db87c2e80286872d1",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 43.62,
			"commitsBetweenForRepo": 80,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,152 +1,172 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n \t\tfinal String remote = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.<branch name>.merge\n \t\tString remoteBranchName = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n+\t\tboolean doRebase = false;\n \t\tif (remoteBranchName == null) {\n \t\t\t// check if the branch is configured for pull-rebase\n \t\t\tremoteBranchName = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REBASE);\n \t\t\tif (remoteBranchName != null) {\n-\t\t\t\t// TODO implement pull-rebase\n-\t\t\t\tthrow new JGitInternalException(\n-\t\t\t\t\t\t\"Pull with rebase is not yet supported\");\n+\t\t\t\tdoRebase = true;\n \t\t\t}\n \t\t}\n \n \t\tif (remoteBranchName == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote = !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repoConfig.getString(\"remote\", remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n-\t\t// we check the updates to see which of the updated branches corresponds\n-\t\t// to the remote branch name\n-\n-\t\tAnyObjectId commitToMerge;\n-\n-\t\tif (isRemote) {\n-\t\t\tRef r = null;\n-\t\t\tif (fetchRes != null) {\n-\t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n-\t\t\t\tif (r == null)\n-\t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n-\t\t\t\t\t\t\t+ remoteBranchName);\n-\t\t\t}\n-\t\t\tif (r == null)\n-\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n-\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n-\t\t\telse\n-\t\t\t\tcommitToMerge = r.getObjectId();\n-\t\t} else {\n-\t\t\ttry {\n-\t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n-\t\t\t} catch (IOException e) {\n-\t\t\t\tthrow new JGitInternalException(\n-\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n-\t\t\t\t\t\te);\n-\t\t\t}\n-\t\t}\n-\n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n-\t\tMergeCommand merge = new MergeCommand(repo);\n-\t\tmerge.include(\"branch \\'\" + remoteBranchName + \"\\' of \" + remoteUri,\n-\t\t\t\tcommitToMerge);\n-\t\tMergeResult mergeRes;\n-\t\ttry {\n-\t\t\tmergeRes = merge.call();\n-\t\t\tmonitor.update(1);\n-\t\t} catch (NoHeadException e) {\n-\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t} catch (ConcurrentRefUpdateException e) {\n-\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t} catch (CheckoutConflictException e) {\n-\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t} catch (InvalidMergeHeadsException e) {\n-\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t} catch (WrongRepositoryStateException e) {\n-\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n-\t\t} catch (NoMessageException e) {\n-\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\tPullResult result;\n+\t\tif (doRebase) {\n+\t\t\tRebaseCommand rebase = new RebaseCommand(repo);\n+\t\t\ttry {\n+\t\t\t\tRebaseResult rebaseRes = rebase.setUpstream(remoteBranchName)\n+\t\t\t\t\t\t.setProgressMonitor(monitor).setOperation(\n+\t\t\t\t\t\t\t\tOperation.BEGIN).call();\n+\t\t\t\tresult = new PullResult(fetchRes, remote, rebaseRes);\n+\t\t\t} catch (NoHeadException e) {\n+\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t} catch (RefNotFoundException e) {\n+\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t} catch (JGitInternalException e) {\n+\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t} catch (GitAPIException e) {\n+\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// we check the updates to see which of the updated branches\n+\t\t\t// corresponds\n+\t\t\t// to the remote branch name\n+\t\t\tAnyObjectId commitToMerge;\n+\n+\t\t\tif (isRemote) {\n+\t\t\t\tRef r = null;\n+\t\t\t\tif (fetchRes != null) {\n+\t\t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n+\t\t\t\t\tif (r == null)\n+\t\t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n+\t\t\t\t\t\t\t\t+ remoteBranchName);\n+\t\t\t\t}\n+\t\t\t\tif (r == null)\n+\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n+\t\t\t\t\t\t\tJGitText.get().couldNotGetAdvertisedRef,\n+\t\t\t\t\t\t\tremoteBranchName));\n+\t\t\t\telse\n+\t\t\t\t\tcommitToMerge = r.getObjectId();\n+\t\t\t} else {\n+\t\t\t\ttry {\n+\t\t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n+\t\t\t\t} catch (IOException e) {\n+\t\t\t\t\tthrow new JGitInternalException(\n+\t\t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n+\t\t\t\t\t\t\te);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tMergeCommand merge = new MergeCommand(repo);\n+\t\t\tmerge.include(\n+\t\t\t\t\t\"branch \\'\" + remoteBranchName + \"\\' of \" + remoteUri,\n+\t\t\t\t\tcommitToMerge);\n+\t\t\tMergeResult mergeRes;\n+\t\t\ttry {\n+\t\t\t\tmergeRes = merge.call();\n+\t\t\t\tmonitor.update(1);\n+\t\t\t\tresult = new PullResult(fetchRes, remote, mergeRes);\n+\t\t\t} catch (NoHeadException e) {\n+\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t} catch (ConcurrentRefUpdateException e) {\n+\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t} catch (CheckoutConflictException e) {\n+\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t} catch (InvalidMergeHeadsException e) {\n+\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t} catch (WrongRepositoryStateException e) {\n+\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t} catch (NoMessageException e) {\n+\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t}\n \t\t}\n \t\tmonitor.endTask();\n-\t\treturn new PullResult(fetchRes, remote, mergeRes);\n+\t\treturn result;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"013cb8de3824c304645a9c5db87c2e80286872d1": {
			"type": "Ybodychange",
			"commitMessage": "Reduce calls to Repository.getConfig\n\nEach time getConfig() is called on FileRepository, it checks the\nlast modified time of both ~/.gitconfig and $GIT_DIR?config.  If\n$GIT_DIR/config appears to have been modified, it is read back in\nfrom disk and the current config is wiped out.\n\nWhen mutating a configuration file, this may cause in-memory edits\nto disappear.  To avoid that callers need to avoid calling getConfig\nuntil after the configuration has been saved to disk.\n\nUnfortunately the API is still horribly broken.  Configuration should\nbe modified only while a lock is held on the configuration file, very\nsimilar to the way a ref is updated via its locking protocol.  But our\nexisting API is really broken for that so we'll have to defer cleaning\nup the edit path for a future change.\n\nChange-Id: I5888dd97bac20ddf60456c81ffc1eb8df04ef410\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-12-15, 4:14 PM",
			"commitName": "013cb8de3824c304645a9c5db87c2e80286872d1",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-10-29, 7:12 AM",
			"commitNameOld": "d36c80fd048fc55d7ac31ae62eb67fbac9b12e31",
			"commitAuthorOld": "Robin Stocker",
			"daysBetweenCommits": 47.42,
			"commitsBetweenForRepo": 132,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,152 +1,152 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n \t\tfinal String remote = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.<branch name>.merge\n \t\tString remoteBranchName = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\tif (remoteBranchName == null) {\n \t\t\t// check if the branch is configured for pull-rebase\n \t\t\tremoteBranchName = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REBASE);\n \t\t\tif (remoteBranchName != null) {\n \t\t\t\t// TODO implement pull-rebase\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\"Pull with rebase is not yet supported\");\n \t\t\t}\n \t\t}\n \n \t\tif (remoteBranchName == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote = !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n-\t\t\tremoteUri = repo.getConfig().getString(\"remote\", remote,\n+\t\t\tremoteUri = repoConfig.getString(\"remote\", remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n \t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\t// we check the updates to see which of the updated branches corresponds\n \t\t// to the remote branch name\n \n \t\tAnyObjectId commitToMerge;\n \n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\tMergeCommand merge = new MergeCommand(repo);\n \t\tmerge.include(\"branch \\'\" + remoteBranchName + \"\\' of \" + remoteUri,\n \t\t\t\tcommitToMerge);\n \t\tMergeResult mergeRes;\n \t\ttry {\n \t\t\tmergeRes = merge.call();\n \t\t\tmonitor.update(1);\n \t\t} catch (NoHeadException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (CheckoutConflictException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (InvalidMergeHeadsException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (WrongRepositoryStateException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (NoMessageException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn new PullResult(fetchRes, remote, mergeRes);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d36c80fd048fc55d7ac31ae62eb67fbac9b12e31": {
			"type": "Ybodychange",
			"commitMessage": "Remove unnecessary null check\n\nThe field monitor is never null, it's a NullProgressMonitor when not\nexplicitly set.\n\nChange-Id: I8ce703a32c28ce5c3455efeb7ed5f5c9a443cbef\n",
			"commitDate": "2010-10-29, 7:12 AM",
			"commitName": "d36c80fd048fc55d7ac31ae62eb67fbac9b12e31",
			"commitAuthor": "Robin Stocker",
			"commitDateOld": "2010-10-28, 10:18 AM",
			"commitNameOld": "7668a462829b12e4f6a192c43157152ef63ff305",
			"commitAuthorOld": "Mathias Kinzler",
			"daysBetweenCommits": 0.87,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,153 +1,152 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n \t\tfinal String remote = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.<branch name>.merge\n \t\tString remoteBranchName = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\tif (remoteBranchName == null) {\n \t\t\t// check if the branch is configured for pull-rebase\n \t\t\tremoteBranchName = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_REBASE);\n \t\t\tif (remoteBranchName != null) {\n \t\t\t\t// TODO implement pull-rebase\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\"Pull with rebase is not yet supported\");\n \t\t\t}\n \t\t}\n \n \t\tif (remoteBranchName == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n \t\tfinal boolean isRemote = !remote.equals(\".\");\n \t\tString remoteUri;\n \t\tFetchResult fetchRes;\n \t\tif (isRemote) {\n \t\t\tremoteUri = repo.getConfig().getString(\"remote\", remote,\n \t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n \t\t\tif (remoteUri == null) {\n \t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n \t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n \t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t\t}\n \n \t\t\tif (monitor.isCancelled())\n \t\t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\t\tFetchCommand fetch = new FetchCommand(repo);\n \t\t\tfetch.setRemote(remote);\n-\t\t\tif (monitor != null)\n-\t\t\t\tfetch.setProgressMonitor(monitor);\n+\t\t\tfetch.setProgressMonitor(monitor);\n \t\t\tfetch.setTimeout(this.timeout);\n \n \t\t\tfetchRes = fetch.call();\n \t\t} else {\n \t\t\t// we can skip the fetch altogether\n \t\t\tremoteUri = \"local repository\";\n \t\t\tfetchRes = null;\n \t\t}\n \n \t\tmonitor.update(1);\n \n \t\t// we check the updates to see which of the updated branches corresponds\n \t\t// to the remote branch name\n \n \t\tAnyObjectId commitToMerge;\n \n \t\tif (isRemote) {\n \t\t\tRef r = null;\n \t\t\tif (fetchRes != null) {\n \t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n \t\t\t\tif (r == null)\n \t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n \t\t\t\t\t\t\t+ remoteBranchName);\n \t\t\t}\n \t\t\tif (r == null)\n \t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n \t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n \t\t\telse\n \t\t\t\tcommitToMerge = r.getObjectId();\n \t\t} else {\n \t\t\ttry {\n \t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n \t\t}\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\tMergeCommand merge = new MergeCommand(repo);\n \t\tmerge.include(\"branch \\'\" + remoteBranchName + \"\\' of \" + remoteUri,\n \t\t\t\tcommitToMerge);\n \t\tMergeResult mergeRes;\n \t\ttry {\n \t\t\tmergeRes = merge.call();\n \t\t\tmonitor.update(1);\n \t\t} catch (NoHeadException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (CheckoutConflictException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (InvalidMergeHeadsException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (WrongRepositoryStateException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (NoMessageException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn new PullResult(fetchRes, remote, mergeRes);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7668a462829b12e4f6a192c43157152ef63ff305": {
			"type": "Ybodychange",
			"commitMessage": "PullCommand: support upstream configuration for local branches\n\nWhen creating a local branch based on another local branch, the\nupstream configuration contains \".\" as origin and the source branch\nas \"merge\". The PullCommand should support this by skipping the\nfetch step altogether and use the base branch to merge with.\n\nChange-Id: I260a1771aeeffca5b0161d1494fd63c672ecc2a6\nSigned-off-by: Mathias Kinzler <mathias.kinzler@sap.com>\n",
			"commitDate": "2010-10-28, 10:18 AM",
			"commitName": "7668a462829b12e4f6a192c43157152ef63ff305",
			"commitAuthor": "Mathias Kinzler",
			"commitDateOld": "2010-10-08, 7:57 AM",
			"commitNameOld": "db55d13f5f4b641a9390076ced6b1775bcfcd6f6",
			"commitAuthorOld": "Mathias Kinzler",
			"daysBetweenCommits": 20.1,
			"commitsBetweenForRepo": 43,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,139 +1,153 @@\n \tpublic PullResult call() throws WrongRepositoryStateException,\n \t\t\tInvalidConfigurationException, DetachedHeadException,\n \t\t\tInvalidRemoteException, CanceledException {\n \t\tcheckCallable();\n \n \t\tmonitor.beginTask(JGitText.get().pullTaskName, 2);\n \n \t\tString branchName;\n \t\ttry {\n \t\t\tString fullBranch = repo.getFullBranch();\n \t\t\tif (!fullBranch.startsWith(Constants.R_HEADS)) {\n \t\t\t\t// we can not pull if HEAD is detached and branch is not\n \t\t\t\t// specified explicitly\n \t\t\t\tthrow new DetachedHeadException();\n \t\t\t}\n \t\t\tbranchName = fullBranch.substring(Constants.R_HEADS.length());\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\te);\n \t\t}\n \n \t\tif (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotPullOnARepoWithState, repo\n \t\t\t\t\t\t\t.getRepositoryState().name()));\n \n \t\t// get the configured remote for the currently checked out branch\n \t\t// stored in configuration key branch.<branch name>.remote\n \t\tConfig repoConfig = repo.getConfig();\n \t\tfinal String remote = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_REMOTE);\n \t\tif (remote == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n-\t\tfinal String remoteUri = repo.getConfig().getString(\"remote\", remote,\n-\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n-\t\tif (remoteUri == null) {\n-\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n-\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n-\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n-\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n-\t\t}\n \n \t\t// get the name of the branch in the remote repository\n \t\t// stored in configuration key branch.<branch name>.merge\n \t\tString remoteBranchName = repoConfig.getString(\n \t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n \t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n \t\tif (remoteBranchName == null) {\n \t\t\t// check if the branch is configured for pull-rebase\n \t\t\tremoteBranchName = repoConfig.getString(\n \t\t\t\t\tConfigConstants.CONFIG_BRANCH_SECTION, branchName,\n-\t\t\t\t\tConfigConstants.CONFIG_KEY_MERGE);\n+\t\t\t\t\tConfigConstants.CONFIG_KEY_REBASE);\n \t\t\tif (remoteBranchName != null) {\n \t\t\t\t// TODO implement pull-rebase\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\t\"Pull with rebase is not yet supported\");\n \t\t\t}\n \t\t}\n+\n \t\tif (remoteBranchName == null) {\n \t\t\tString missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT\n \t\t\t\t\t+ branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n \t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n \t\t}\n \n-\t\tif (monitor.isCancelled())\n-\t\t\tthrow new CanceledException(MessageFormat.format(\n-\t\t\t\t\tJGitText.get().operationCanceled,\n-\t\t\t\t\tJGitText.get().pullTaskName));\n+\t\tfinal boolean isRemote = !remote.equals(\".\");\n+\t\tString remoteUri;\n+\t\tFetchResult fetchRes;\n+\t\tif (isRemote) {\n+\t\t\tremoteUri = repo.getConfig().getString(\"remote\", remote,\n+\t\t\t\t\tConfigConstants.CONFIG_KEY_URL);\n+\t\t\tif (remoteUri == null) {\n+\t\t\t\tString missingKey = ConfigConstants.CONFIG_REMOTE_SECTION + DOT\n+\t\t\t\t\t\t+ remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n+\t\t\t\tthrow new InvalidConfigurationException(MessageFormat.format(\n+\t\t\t\t\t\tJGitText.get().missingConfigurationForKey, missingKey));\n+\t\t\t}\n \n-\t\tFetchCommand fetch = new FetchCommand(repo);\n-\t\tfetch.setRemote(remote);\n-\t\tif (monitor != null)\n-\t\t\tfetch.setProgressMonitor(monitor);\n-\t\tfetch.setTimeout(this.timeout);\n+\t\t\tif (monitor.isCancelled())\n+\t\t\t\tthrow new CanceledException(MessageFormat.format(\n+\t\t\t\t\t\tJGitText.get().operationCanceled,\n+\t\t\t\t\t\tJGitText.get().pullTaskName));\n \n-\t\tFetchResult fetchRes = fetch.call();\n+\t\t\tFetchCommand fetch = new FetchCommand(repo);\n+\t\t\tfetch.setRemote(remote);\n+\t\t\tif (monitor != null)\n+\t\t\t\tfetch.setProgressMonitor(monitor);\n+\t\t\tfetch.setTimeout(this.timeout);\n+\n+\t\t\tfetchRes = fetch.call();\n+\t\t} else {\n+\t\t\t// we can skip the fetch altogether\n+\t\t\tremoteUri = \"local repository\";\n+\t\t\tfetchRes = null;\n+\t\t}\n \n \t\tmonitor.update(1);\n \n \t\t// we check the updates to see which of the updated branches corresponds\n \t\t// to the remote branch name\n \n-\t\tAnyObjectId commitToMerge = null;\n+\t\tAnyObjectId commitToMerge;\n \n-\t\tRef r = fetchRes.getAdvertisedRef(remoteBranchName);\n-\t\tif (r == null)\n-\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n-\t\tif (r == null) {\n-\t\t\t// TODO: we should be able to get the mapping also if nothing was\n-\t\t\t// updated by the fetch; for the time being, use the naming\n-\t\t\t// convention as fall back\n-\t\t\tString remoteTrackingBranch = Constants.R_REMOTES + remote + '/'\n-\t\t\t\t\t+ branchName;\n+\t\tif (isRemote) {\n+\t\t\tRef r = null;\n+\t\t\tif (fetchRes != null) {\n+\t\t\t\tr = fetchRes.getAdvertisedRef(remoteBranchName);\n+\t\t\t\tif (r == null)\n+\t\t\t\t\tr = fetchRes.getAdvertisedRef(Constants.R_HEADS\n+\t\t\t\t\t\t\t+ remoteBranchName);\n+\t\t\t}\n+\t\t\tif (r == null)\n+\t\t\t\tthrow new JGitInternalException(MessageFormat.format(JGitText\n+\t\t\t\t\t\t.get().couldNotGetAdvertisedRef, remoteBranchName));\n+\t\t\telse\n+\t\t\t\tcommitToMerge = r.getObjectId();\n+\t\t} else {\n \t\t\ttry {\n-\t\t\t\tcommitToMerge = repo.resolve(remoteTrackingBranch);\n+\t\t\t\tcommitToMerge = repo.resolve(remoteBranchName);\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new JGitInternalException(\n \t\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfPullCommand,\n \t\t\t\t\t\te);\n \t\t\t}\n-\n-\t\t} else\n-\t\t\tcommitToMerge = r.getObjectId();\n+\t\t}\n \n \t\tif (monitor.isCancelled())\n \t\t\tthrow new CanceledException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().operationCanceled,\n \t\t\t\t\tJGitText.get().pullTaskName));\n \n \t\tMergeCommand merge = new MergeCommand(repo);\n \t\tmerge.include(\"branch \\'\" + remoteBranchName + \"\\' of \" + remoteUri,\n \t\t\t\tcommitToMerge);\n \t\tMergeResult mergeRes;\n \t\ttry {\n \t\t\tmergeRes = merge.call();\n \t\t\tmonitor.update(1);\n \t\t} catch (NoHeadException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (ConcurrentRefUpdateException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (CheckoutConflictException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (InvalidMergeHeadsException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (WrongRepositoryStateException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t} catch (NoMessageException e) {\n \t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t}\n \t\tmonitor.endTask();\n \t\treturn new PullResult(fetchRes, remote, mergeRes);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"db55d13f5f4b641a9390076ced6b1775bcfcd6f6": {
			"type": "Yintroduced",
			"commitMessage": "Add \"Pull\" command\n\nThis is the minimal implementation of a \"Pull\" command. It does not\nhave any parameters besides the generic progress monitor and timeout.\nIt works on the currently checked-out branch and assumes that the\nconfiguration contains the keys \"branch.<branch name>.remote\" and\n\"branch.<branch name>.merge\" to determine the remote configuration\nfor the fetch and the remote branch name for the merge.\n\nBug: 303404\nChange-Id: I7fe09029996d0cfc09a7d8f097b5d6af1488fa93\nSigned-off-by: Mathias Kinzler <mathias.kinzler@sap.com>\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
			"commitDate": "2010-10-08, 7:57 AM",
			"commitName": "db55d13f5f4b641a9390076ced6b1775bcfcd6f6",
			"commitAuthor": "Mathias Kinzler"
		}
	},
	"sha": "bd1a82502680b5de5bf86f6c4470185fd1602386"
}