{
	"repo": "https://github.com/eclipse/jgit.git",
	"file": "org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java",
	"method": {
		"longName": "public boolean diff(ProgressMonitor monitor, int estWorkTreeSize, int estIndexSize, String title);",
		"startLine": 409,
		"methodName": "diff",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"5639639b06c004d18415f59a271319da2fb7b930": {
			"type": "Ybodychange",
			"commitMessage": "IndexDiff: Refactor to open Repository in try-with-resource\n\nChange-Id: I667d685ccedc730e786f1e52323fdeba4b91af3e\nSigned-off-by: David Pursehouse <david.pursehouse@gmail.com>\n",
			"commitDate": "2018-03-14, 3:57 PM",
			"commitName": "5639639b06c004d18415f59a271319da2fb7b930",
			"commitAuthor": "David Pursehouse",
			"commitDateOld": "2017-12-19, 3:02 PM",
			"commitNameOld": "0c259eaf1db076837768512deb6c251c86e67941",
			"commitAuthorOld": "David Pursehouse",
			"daysBetweenCommits": 85,
			"commitsBetweenForRepo": 242,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,188 +1,185 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\ttry (TreeWalk treeWalk = new TreeWalk(repository)) {\n \t\t\ttreeWalk.setOperationType(OperationType.CHECKIN_OP);\n \t\t\ttreeWalk.setRecursive(true);\n \t\t\t// add the trees (tree, dirchache, workdir)\n \t\t\tif (tree != null)\n \t\t\t\ttreeWalk.addTree(tree);\n \t\t\telse\n \t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\t\tinitialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n \t\t\tCollection<TreeFilter> filters = new ArrayList<>(4);\n \n \t\t\tif (monitor != null) {\n \t\t\t\t// Get the maximum size of the work tree and index\n \t\t\t\t// and add some (quite arbitrary)\n \t\t\t\tif (estIndexSize == 0)\n \t\t\t\t\testIndexSize = dirCache.getEntryCount();\n \t\t\t\tint total = Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\t\tmonitor.beginTask(title, total);\n \t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t\t}\n \n \t\t\tif (filter != null)\n \t\t\t\tfilters.add(filter);\n \t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\t\tindexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n \t\t\tfilters.add(indexDiffFilter);\n \t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\t\tfileModes.clear();\n \t\t\twhile (treeWalk.next()) {\n \t\t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\t\tAbstractTreeIterator.class);\n \t\t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\t\tDirCacheIterator.class);\n \t\t\t\tWorkingTreeIterator workingTreeIterator = treeWalk\n \t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n \n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n \t\t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\t\tif (dirCacheEntry != null) {\n \t\t\t\t\t\tint stage = dirCacheEntry.getStage();\n \t\t\t\t\t\tif (stage > 0) {\n \t\t\t\t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (treeIterator != null) {\n \t\t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| treeIterator\n \t\t\t\t\t\t\t\t\t\t.getEntryRawMode() != dirCacheIterator\n \t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n \t\t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t\t\t\t\t&& ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\tif (path != null) {\n \t\t\t\t\tfor (int i = 0; i < treeWalk.getTreeCount(); i++) {\n \t\t\t\t\t\trecordFileMode(path, treeWalk.getFileMode(i));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode == null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode = smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n \t\t\t\t\tthrow new IOException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().invalidIgnoreParamSubmodule,\n \t\t\t\t\t\t\tsmw.getPath()), e);\n \t\t\t\t}\n-\t\t\t\tRepository subRepo = smw.getRepository();\n-\t\t\t\tif (subRepo != null) {\n-\t\t\t\t\tString subRepoPath = smw.getPath();\n-\t\t\t\t\ttry {\n+\t\t\t\ttry (Repository subRepo = smw.getRepository()) {\n+\t\t\t\t\tif (subRepo != null) {\n+\t\t\t\t\t\tString subRepoPath = smw.getPath();\n \t\t\t\t\t\tObjectId subHead = subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n \t\t\t\t\t\tif (subHead != null\n \t\t\t\t\t\t\t\t&& !subHead.equals(smw.getObjectId())) {\n \t\t\t\t\t\t\tmodified.add(subRepoPath);\n \t\t\t\t\t\t\trecordFileMode(subRepoPath, FileMode.GITLINK);\n \t\t\t\t\t\t} else if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\t\t\tIndexDiff smid = submoduleIndexDiffs.get(smw\n \t\t\t\t\t\t\t\t\t.getPath());\n \t\t\t\t\t\t\tif (smid == null) {\n \t\t\t\t\t\t\t\tsmid = new IndexDiff(subRepo,\n \t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n \t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n \t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(subRepoPath, smid);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\t\t\tif (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t\t\t&& smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tmodified.add(subRepoPath);\n \t\t\t\t\t\t\t\trecordFileMode(subRepoPath, FileMode.GITLINK);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t} finally {\n-\t\t\t\t\t\tsubRepo.close();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor != null)\n \t\t\tmonitor.endTask();\n \n \t\tignored = indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0c259eaf1db076837768512deb6c251c86e67941": {
			"type": "Ybodychange",
			"commitMessage": "Replace explicit calls to initCause where possible\n\nWhere the exception being thrown has a constructor that takes a\nThrowable, use that instead of instantiating the exception and then\nexplicitly calling initCause.\n\nChange-Id: I06a0df407ba751a7af8c1c4a46f9e2714f13dbe3\nSigned-off-by: David Pursehouse <david.pursehouse@gmail.com>\n",
			"commitDate": "2017-12-19, 3:02 PM",
			"commitName": "0c259eaf1db076837768512deb6c251c86e67941",
			"commitAuthor": "David Pursehouse",
			"commitDateOld": "2017-12-19, 4:43 AM",
			"commitNameOld": "8a6af368c4129ef35520ec72cc9f55a3f685bfb8",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 0.43,
			"commitsBetweenForRepo": 11,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,190 +1,188 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\ttry (TreeWalk treeWalk = new TreeWalk(repository)) {\n \t\t\ttreeWalk.setOperationType(OperationType.CHECKIN_OP);\n \t\t\ttreeWalk.setRecursive(true);\n \t\t\t// add the trees (tree, dirchache, workdir)\n \t\t\tif (tree != null)\n \t\t\t\ttreeWalk.addTree(tree);\n \t\t\telse\n \t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\t\tinitialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n \t\t\tCollection<TreeFilter> filters = new ArrayList<>(4);\n \n \t\t\tif (monitor != null) {\n \t\t\t\t// Get the maximum size of the work tree and index\n \t\t\t\t// and add some (quite arbitrary)\n \t\t\t\tif (estIndexSize == 0)\n \t\t\t\t\testIndexSize = dirCache.getEntryCount();\n \t\t\t\tint total = Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\t\tmonitor.beginTask(title, total);\n \t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t\t}\n \n \t\t\tif (filter != null)\n \t\t\t\tfilters.add(filter);\n \t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\t\tindexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n \t\t\tfilters.add(indexDiffFilter);\n \t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\t\tfileModes.clear();\n \t\t\twhile (treeWalk.next()) {\n \t\t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\t\tAbstractTreeIterator.class);\n \t\t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\t\tDirCacheIterator.class);\n \t\t\t\tWorkingTreeIterator workingTreeIterator = treeWalk\n \t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n \n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n \t\t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\t\tif (dirCacheEntry != null) {\n \t\t\t\t\t\tint stage = dirCacheEntry.getStage();\n \t\t\t\t\t\tif (stage > 0) {\n \t\t\t\t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (treeIterator != null) {\n \t\t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| treeIterator\n \t\t\t\t\t\t\t\t\t\t.getEntryRawMode() != dirCacheIterator\n \t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n \t\t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t\t\t\t\t&& ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\tif (path != null) {\n \t\t\t\t\tfor (int i = 0; i < treeWalk.getTreeCount(); i++) {\n \t\t\t\t\t\trecordFileMode(path, treeWalk.getFileMode(i));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode == null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode = smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n-\t\t\t\t\tIOException e1 = new IOException(MessageFormat.format(\n+\t\t\t\t\tthrow new IOException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().invalidIgnoreParamSubmodule,\n-\t\t\t\t\t\t\tsmw.getPath()));\n-\t\t\t\t\te1.initCause(e);\n-\t\t\t\t\tthrow e1;\n+\t\t\t\t\t\t\tsmw.getPath()), e);\n \t\t\t\t}\n \t\t\t\tRepository subRepo = smw.getRepository();\n \t\t\t\tif (subRepo != null) {\n \t\t\t\t\tString subRepoPath = smw.getPath();\n \t\t\t\t\ttry {\n \t\t\t\t\t\tObjectId subHead = subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n \t\t\t\t\t\tif (subHead != null\n \t\t\t\t\t\t\t\t&& !subHead.equals(smw.getObjectId())) {\n \t\t\t\t\t\t\tmodified.add(subRepoPath);\n \t\t\t\t\t\t\trecordFileMode(subRepoPath, FileMode.GITLINK);\n \t\t\t\t\t\t} else if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\t\t\tIndexDiff smid = submoduleIndexDiffs.get(smw\n \t\t\t\t\t\t\t\t\t.getPath());\n \t\t\t\t\t\t\tif (smid == null) {\n \t\t\t\t\t\t\t\tsmid = new IndexDiff(subRepo,\n \t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n \t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n \t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(subRepoPath, smid);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\t\t\tif (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t\t\t&& smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tmodified.add(subRepoPath);\n \t\t\t\t\t\t\t\trecordFileMode(subRepoPath, FileMode.GITLINK);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\tsubRepo.close();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor != null)\n \t\t\tmonitor.endTask();\n \n \t\tignored = indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"df3469f6ad81dccb314bf2d5021a3cec2b184985": {
			"type": "Ybodychange",
			"commitMessage": "Record submodule paths with untracked changes as FileMode.GITLINK\n\nBug: 520702\nChange-Id: I9bb48af9e8f1f2ce7968a82297c7c16f1237f987\nSigned-off-by: Thomas Wolf <thomas.wolf@paranor.ch>\n",
			"commitDate": "2017-08-14, 5:03 AM",
			"commitName": "df3469f6ad81dccb314bf2d5021a3cec2b184985",
			"commitAuthor": "Thomas Wolf",
			"commitDateOld": "2017-02-20, 1:47 PM",
			"commitNameOld": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
			"commitAuthorOld": "David Pursehouse",
			"daysBetweenCommits": 174.59,
			"commitsBetweenForRepo": 208,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,191 +1,190 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\ttry (TreeWalk treeWalk = new TreeWalk(repository)) {\n \t\t\ttreeWalk.setOperationType(OperationType.CHECKIN_OP);\n \t\t\ttreeWalk.setRecursive(true);\n \t\t\t// add the trees (tree, dirchache, workdir)\n \t\t\tif (tree != null)\n \t\t\t\ttreeWalk.addTree(tree);\n \t\t\telse\n \t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\t\tinitialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n \t\t\tCollection<TreeFilter> filters = new ArrayList<>(4);\n \n \t\t\tif (monitor != null) {\n \t\t\t\t// Get the maximum size of the work tree and index\n \t\t\t\t// and add some (quite arbitrary)\n \t\t\t\tif (estIndexSize == 0)\n \t\t\t\t\testIndexSize = dirCache.getEntryCount();\n \t\t\t\tint total = Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\t\tmonitor.beginTask(title, total);\n \t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t\t}\n \n \t\t\tif (filter != null)\n \t\t\t\tfilters.add(filter);\n \t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\t\tindexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n \t\t\tfilters.add(indexDiffFilter);\n \t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\t\tfileModes.clear();\n \t\t\twhile (treeWalk.next()) {\n \t\t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\t\tAbstractTreeIterator.class);\n \t\t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\t\tDirCacheIterator.class);\n \t\t\t\tWorkingTreeIterator workingTreeIterator = treeWalk\n \t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n \n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n \t\t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\t\tif (dirCacheEntry != null) {\n \t\t\t\t\t\tint stage = dirCacheEntry.getStage();\n \t\t\t\t\t\tif (stage > 0) {\n \t\t\t\t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (treeIterator != null) {\n \t\t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| treeIterator\n \t\t\t\t\t\t\t\t\t\t.getEntryRawMode() != dirCacheIterator\n \t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n \t\t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t\t\t\t\t&& ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n-\t\t\t\tfor (int i = 0; i < treeWalk.getTreeCount(); i++) {\n-\t\t\t\t\tSet<String> values = fileModes.get(treeWalk.getFileMode(i));\n-\t\t\t\t\tString path = treeWalk.getPathString();\n-\t\t\t\t\tif (path != null) {\n-\t\t\t\t\t\tif (values == null)\n-\t\t\t\t\t\t\tvalues = new HashSet<>();\n-\t\t\t\t\t\tvalues.add(path);\n-\t\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n+\t\t\t\tString path = treeWalk.getPathString();\n+\t\t\t\tif (path != null) {\n+\t\t\t\t\tfor (int i = 0; i < treeWalk.getTreeCount(); i++) {\n+\t\t\t\t\t\trecordFileMode(path, treeWalk.getFileMode(i));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode == null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode = smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n \t\t\t\t\tIOException e1 = new IOException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().invalidIgnoreParamSubmodule,\n \t\t\t\t\t\t\tsmw.getPath()));\n \t\t\t\t\te1.initCause(e);\n \t\t\t\t\tthrow e1;\n \t\t\t\t}\n \t\t\t\tRepository subRepo = smw.getRepository();\n \t\t\t\tif (subRepo != null) {\n+\t\t\t\t\tString subRepoPath = smw.getPath();\n \t\t\t\t\ttry {\n \t\t\t\t\t\tObjectId subHead = subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n \t\t\t\t\t\tif (subHead != null\n-\t\t\t\t\t\t\t\t&& !subHead.equals(smw.getObjectId()))\n-\t\t\t\t\t\t\tmodified.add(smw.getPath());\n-\t\t\t\t\t\telse if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n+\t\t\t\t\t\t\t\t&& !subHead.equals(smw.getObjectId())) {\n+\t\t\t\t\t\t\tmodified.add(subRepoPath);\n+\t\t\t\t\t\t\trecordFileMode(subRepoPath, FileMode.GITLINK);\n+\t\t\t\t\t\t} else if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\t\t\tIndexDiff smid = submoduleIndexDiffs.get(smw\n \t\t\t\t\t\t\t\t\t.getPath());\n \t\t\t\t\t\t\tif (smid == null) {\n \t\t\t\t\t\t\t\tsmid = new IndexDiff(subRepo,\n \t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n \t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n-\t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n+\t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(subRepoPath, smid);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\t\t\tif (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t\t\t&& smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tmodified.add(smw.getPath());\n+\t\t\t\t\t\t\t\tmodified.add(subRepoPath);\n+\t\t\t\t\t\t\t\trecordFileMode(subRepoPath, FileMode.GITLINK);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\tsubRepo.close();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor != null)\n \t\t\tmonitor.endTask();\n \n \t\tignored = indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": {
			"type": "Ybodychange",
			"commitMessage": "Enable and fix warnings about redundant specification of type arguments\n\nSince the introduction of generic type parameter inference in Java 7,\nit's not necessary to explicitly specify the type of generic parameters.\n\nEnable the warning in Eclipse, and fix all occurrences.\n\nChange-Id: I9158caf1beca5e4980b6240ac401f3868520aad0\nSigned-off-by: David Pursehouse <david.pursehouse@gmail.com>\n",
			"commitDate": "2017-02-20, 1:47 PM",
			"commitName": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
			"commitAuthor": "David Pursehouse",
			"commitDateOld": "2017-02-19, 4:05 PM",
			"commitNameOld": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
			"commitAuthorOld": "David Pursehouse",
			"daysBetweenCommits": 0.9,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,191 +1,191 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\ttry (TreeWalk treeWalk = new TreeWalk(repository)) {\n \t\t\ttreeWalk.setOperationType(OperationType.CHECKIN_OP);\n \t\t\ttreeWalk.setRecursive(true);\n \t\t\t// add the trees (tree, dirchache, workdir)\n \t\t\tif (tree != null)\n \t\t\t\ttreeWalk.addTree(tree);\n \t\t\telse\n \t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\t\tinitialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n-\t\t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n+\t\t\tCollection<TreeFilter> filters = new ArrayList<>(4);\n \n \t\t\tif (monitor != null) {\n \t\t\t\t// Get the maximum size of the work tree and index\n \t\t\t\t// and add some (quite arbitrary)\n \t\t\t\tif (estIndexSize == 0)\n \t\t\t\t\testIndexSize = dirCache.getEntryCount();\n \t\t\t\tint total = Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\t\tmonitor.beginTask(title, total);\n \t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t\t}\n \n \t\t\tif (filter != null)\n \t\t\t\tfilters.add(filter);\n \t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\t\tindexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n \t\t\tfilters.add(indexDiffFilter);\n \t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\t\tfileModes.clear();\n \t\t\twhile (treeWalk.next()) {\n \t\t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\t\tAbstractTreeIterator.class);\n \t\t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\t\tDirCacheIterator.class);\n \t\t\t\tWorkingTreeIterator workingTreeIterator = treeWalk\n \t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n \n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n \t\t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\t\tif (dirCacheEntry != null) {\n \t\t\t\t\t\tint stage = dirCacheEntry.getStage();\n \t\t\t\t\t\tif (stage > 0) {\n \t\t\t\t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (treeIterator != null) {\n \t\t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| treeIterator\n \t\t\t\t\t\t\t\t\t\t.getEntryRawMode() != dirCacheIterator\n \t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n \t\t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t\t\t\t\t&& ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < treeWalk.getTreeCount(); i++) {\n \t\t\t\t\tSet<String> values = fileModes.get(treeWalk.getFileMode(i));\n \t\t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\t\tif (path != null) {\n \t\t\t\t\t\tif (values == null)\n-\t\t\t\t\t\t\tvalues = new HashSet<String>();\n+\t\t\t\t\t\t\tvalues = new HashSet<>();\n \t\t\t\t\t\tvalues.add(path);\n \t\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode == null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode = smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n \t\t\t\t\tIOException e1 = new IOException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().invalidIgnoreParamSubmodule,\n \t\t\t\t\t\t\tsmw.getPath()));\n \t\t\t\t\te1.initCause(e);\n \t\t\t\t\tthrow e1;\n \t\t\t\t}\n \t\t\t\tRepository subRepo = smw.getRepository();\n \t\t\t\tif (subRepo != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tObjectId subHead = subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n \t\t\t\t\t\tif (subHead != null\n \t\t\t\t\t\t\t\t&& !subHead.equals(smw.getObjectId()))\n \t\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t\telse if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\t\t\tIndexDiff smid = submoduleIndexDiffs.get(smw\n \t\t\t\t\t\t\t\t\t.getPath());\n \t\t\t\t\t\t\tif (smid == null) {\n \t\t\t\t\t\t\t\tsmid = new IndexDiff(subRepo,\n \t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n \t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n \t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\t\t\tif (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t\t\t&& smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\tsubRepo.close();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor != null)\n \t\t\tmonitor.endTask();\n \n \t\tignored = indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5d9f595eb87fba31c2253051102116fc7876e6c0": {
			"type": "Ybodychange",
			"commitMessage": "Add support for clean filters\n\nWhen filters are defined for certain paths in gitattributes make\nsure that clean filters are processed when adding new content to the\nobject database.\n\nChange-Id: Iffd72914cec5b434ba4d0de232e285b7492db868\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>\n",
			"commitDate": "2015-11-27, 2:23 PM",
			"commitName": "5d9f595eb87fba31c2253051102116fc7876e6c0",
			"commitAuthor": "Christian Halstrick",
			"commitDateOld": "2015-11-17, 3:28 PM",
			"commitNameOld": "12280c02dbb8e4ac10893fbbd415be757afab4c1",
			"commitAuthorOld": "Arthur Daussy",
			"daysBetweenCommits": 9.95,
			"commitsBetweenForRepo": 21,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,190 +1,191 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\ttry (TreeWalk treeWalk = new TreeWalk(repository)) {\n \t\t\ttreeWalk.setOperationType(OperationType.CHECKIN_OP);\n \t\t\ttreeWalk.setRecursive(true);\n \t\t\t// add the trees (tree, dirchache, workdir)\n \t\t\tif (tree != null)\n \t\t\t\ttreeWalk.addTree(tree);\n \t\t\telse\n \t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n+\t\t\tinitialWorkingTreeIterator.setDirCacheIterator(treeWalk, 1);\n \t\t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \n \t\t\tif (monitor != null) {\n \t\t\t\t// Get the maximum size of the work tree and index\n \t\t\t\t// and add some (quite arbitrary)\n \t\t\t\tif (estIndexSize == 0)\n \t\t\t\t\testIndexSize = dirCache.getEntryCount();\n \t\t\t\tint total = Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\t\tmonitor.beginTask(title, total);\n \t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t\t}\n \n \t\t\tif (filter != null)\n \t\t\t\tfilters.add(filter);\n \t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\t\tindexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n \t\t\tfilters.add(indexDiffFilter);\n \t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\t\tfileModes.clear();\n \t\t\twhile (treeWalk.next()) {\n \t\t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\t\tAbstractTreeIterator.class);\n \t\t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\t\tDirCacheIterator.class);\n \t\t\t\tWorkingTreeIterator workingTreeIterator = treeWalk\n \t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n \n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n \t\t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\t\tif (dirCacheEntry != null) {\n \t\t\t\t\t\tint stage = dirCacheEntry.getStage();\n \t\t\t\t\t\tif (stage > 0) {\n \t\t\t\t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (treeIterator != null) {\n \t\t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| treeIterator\n \t\t\t\t\t\t\t\t\t\t.getEntryRawMode() != dirCacheIterator\n \t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n \t\t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t\t\t\t\t&& ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < treeWalk.getTreeCount(); i++) {\n \t\t\t\t\tSet<String> values = fileModes.get(treeWalk.getFileMode(i));\n \t\t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\t\tif (path != null) {\n \t\t\t\t\t\tif (values == null)\n \t\t\t\t\t\t\tvalues = new HashSet<String>();\n \t\t\t\t\t\tvalues.add(path);\n \t\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode == null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode = smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n \t\t\t\t\tIOException e1 = new IOException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().invalidIgnoreParamSubmodule,\n \t\t\t\t\t\t\tsmw.getPath()));\n \t\t\t\t\te1.initCause(e);\n \t\t\t\t\tthrow e1;\n \t\t\t\t}\n \t\t\t\tRepository subRepo = smw.getRepository();\n \t\t\t\tif (subRepo != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tObjectId subHead = subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n \t\t\t\t\t\tif (subHead != null\n \t\t\t\t\t\t\t\t&& !subHead.equals(smw.getObjectId()))\n \t\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t\telse if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\t\t\tIndexDiff smid = submoduleIndexDiffs.get(smw\n \t\t\t\t\t\t\t\t\t.getPath());\n \t\t\t\t\t\t\tif (smid == null) {\n \t\t\t\t\t\t\t\tsmid = new IndexDiff(subRepo,\n \t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n \t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n \t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\t\t\tif (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t\t\t&& smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\tsubRepo.close();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor != null)\n \t\t\tmonitor.endTask();\n \n \t\tignored = indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"12280c02dbb8e4ac10893fbbd415be757afab4c1": {
			"type": "Ybodychange",
			"commitMessage": "Adds the git attributes computation on the treewalk\n\nAdds the getAttributes feature to the tree walk. The computation of\nattributes needs to be done by the TreeWalk since it needs both a\nWorkingTreeIterator and a DirCacheIterator.\n\nBug: 342372\nCQ: 9120\nChange-Id: I5e33257fd8c9895869a128bad3fd1e720409d361\nSigned-off-by: Arthur Daussy <arthur.daussy@obeo.fr>\nSigned-off-by: Christian Halstrick <christian.halstrick@sap.com>\n",
			"commitDate": "2015-11-17, 3:28 PM",
			"commitName": "12280c02dbb8e4ac10893fbbd415be757afab4c1",
			"commitAuthor": "Arthur Daussy",
			"commitDateOld": "2015-05-26, 1:52 AM",
			"commitNameOld": "2390531888af6dc9e4fda6cb026271dc068c40ab",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 175.61,
			"commitsBetweenForRepo": 270,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,189 +1,190 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\ttry (TreeWalk treeWalk = new TreeWalk(repository)) {\n+\t\t\ttreeWalk.setOperationType(OperationType.CHECKIN_OP);\n \t\t\ttreeWalk.setRecursive(true);\n \t\t\t// add the trees (tree, dirchache, workdir)\n \t\t\tif (tree != null)\n \t\t\t\ttreeWalk.addTree(tree);\n \t\t\telse\n \t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \n \t\t\tif (monitor != null) {\n \t\t\t\t// Get the maximum size of the work tree and index\n \t\t\t\t// and add some (quite arbitrary)\n \t\t\t\tif (estIndexSize == 0)\n \t\t\t\t\testIndexSize = dirCache.getEntryCount();\n \t\t\t\tint total = Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\t\tmonitor.beginTask(title, total);\n \t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t\t}\n \n \t\t\tif (filter != null)\n \t\t\t\tfilters.add(filter);\n \t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\t\tindexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n \t\t\tfilters.add(indexDiffFilter);\n \t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\t\tfileModes.clear();\n \t\t\twhile (treeWalk.next()) {\n \t\t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\t\tAbstractTreeIterator.class);\n \t\t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\t\tDirCacheIterator.class);\n \t\t\t\tWorkingTreeIterator workingTreeIterator = treeWalk\n \t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n \n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n \t\t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\t\tif (dirCacheEntry != null) {\n \t\t\t\t\t\tint stage = dirCacheEntry.getStage();\n \t\t\t\t\t\tif (stage > 0) {\n \t\t\t\t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (treeIterator != null) {\n \t\t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| treeIterator\n \t\t\t\t\t\t\t\t\t\t.getEntryRawMode() != dirCacheIterator\n \t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n \t\t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t\t\t\t\t&& ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < treeWalk.getTreeCount(); i++) {\n \t\t\t\t\tSet<String> values = fileModes.get(treeWalk.getFileMode(i));\n \t\t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\t\tif (path != null) {\n \t\t\t\t\t\tif (values == null)\n \t\t\t\t\t\t\tvalues = new HashSet<String>();\n \t\t\t\t\t\tvalues.add(path);\n \t\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode == null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode = smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n \t\t\t\t\tIOException e1 = new IOException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().invalidIgnoreParamSubmodule,\n \t\t\t\t\t\t\tsmw.getPath()));\n \t\t\t\t\te1.initCause(e);\n \t\t\t\t\tthrow e1;\n \t\t\t\t}\n \t\t\t\tRepository subRepo = smw.getRepository();\n \t\t\t\tif (subRepo != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tObjectId subHead = subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n \t\t\t\t\t\tif (subHead != null\n \t\t\t\t\t\t\t\t&& !subHead.equals(smw.getObjectId()))\n \t\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t\telse if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\t\t\tIndexDiff smid = submoduleIndexDiffs.get(smw\n \t\t\t\t\t\t\t\t\t.getPath());\n \t\t\t\t\t\t\tif (smid == null) {\n \t\t\t\t\t\t\t\tsmid = new IndexDiff(subRepo,\n \t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n \t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n \t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\t\t\tif (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t\t\t&& smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\tsubRepo.close();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor != null)\n \t\t\tmonitor.endTask();\n \n \t\tignored = indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2390531888af6dc9e4fda6cb026271dc068c40ab": {
			"type": "Ybodychange",
			"commitMessage": "Externalize translatable texts in org.eclipse.jgit\n\nChange-Id: Ibf4c299f9d203c78cae79e61f88d4bea60ea2795\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2015-05-26, 1:52 AM",
			"commitName": "2390531888af6dc9e4fda6cb026271dc068c40ab",
			"commitAuthor": "Matthias Sohn",
			"commitDateOld": "2015-05-20, 3:01 PM",
			"commitNameOld": "0e73d395061d1bfee365acaa2f79c392175d13bf",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 5.45,
			"commitsBetweenForRepo": 19,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,189 +1,189 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\ttry (TreeWalk treeWalk = new TreeWalk(repository)) {\n \t\t\ttreeWalk.setRecursive(true);\n \t\t\t// add the trees (tree, dirchache, workdir)\n \t\t\tif (tree != null)\n \t\t\t\ttreeWalk.addTree(tree);\n \t\t\telse\n \t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \n \t\t\tif (monitor != null) {\n \t\t\t\t// Get the maximum size of the work tree and index\n \t\t\t\t// and add some (quite arbitrary)\n \t\t\t\tif (estIndexSize == 0)\n \t\t\t\t\testIndexSize = dirCache.getEntryCount();\n \t\t\t\tint total = Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\t\tmonitor.beginTask(title, total);\n \t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t\t}\n \n \t\t\tif (filter != null)\n \t\t\t\tfilters.add(filter);\n \t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\t\tindexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n \t\t\tfilters.add(indexDiffFilter);\n \t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\t\tfileModes.clear();\n \t\t\twhile (treeWalk.next()) {\n \t\t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\t\tAbstractTreeIterator.class);\n \t\t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\t\tDirCacheIterator.class);\n \t\t\t\tWorkingTreeIterator workingTreeIterator = treeWalk\n \t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n \n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n \t\t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\t\tif (dirCacheEntry != null) {\n \t\t\t\t\t\tint stage = dirCacheEntry.getStage();\n \t\t\t\t\t\tif (stage > 0) {\n \t\t\t\t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (treeIterator != null) {\n \t\t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| treeIterator\n \t\t\t\t\t\t\t\t\t\t.getEntryRawMode() != dirCacheIterator\n \t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n \t\t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t\t\t\t\t&& ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tfor (int i = 0; i < treeWalk.getTreeCount(); i++) {\n \t\t\t\t\tSet<String> values = fileModes.get(treeWalk.getFileMode(i));\n \t\t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\t\tif (path != null) {\n \t\t\t\t\t\tif (values == null)\n \t\t\t\t\t\t\tvalues = new HashSet<String>();\n \t\t\t\t\t\tvalues.add(path);\n \t\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode == null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode = smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n-\t\t\t\t\tIOException e1 = new IOException(\n-\t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n-\t\t\t\t\t\t\t\t\t+ smw.getPath());\n+\t\t\t\t\tIOException e1 = new IOException(MessageFormat.format(\n+\t\t\t\t\t\t\tJGitText.get().invalidIgnoreParamSubmodule,\n+\t\t\t\t\t\t\tsmw.getPath()));\n \t\t\t\t\te1.initCause(e);\n \t\t\t\t\tthrow e1;\n \t\t\t\t}\n \t\t\t\tRepository subRepo = smw.getRepository();\n \t\t\t\tif (subRepo != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tObjectId subHead = subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n \t\t\t\t\t\tif (subHead != null\n \t\t\t\t\t\t\t\t&& !subHead.equals(smw.getObjectId()))\n \t\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t\telse if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\t\t\tIndexDiff smid = submoduleIndexDiffs.get(smw\n \t\t\t\t\t\t\t\t\t.getPath());\n \t\t\t\t\t\t\tif (smid == null) {\n \t\t\t\t\t\t\t\tsmid = new IndexDiff(subRepo,\n \t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n \t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n \t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\t\t\tif (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t\t\t&& smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\tsubRepo.close();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor != null)\n \t\t\tmonitor.endTask();\n \n \t\tignored = indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0e73d395061d1bfee365acaa2f79c392175d13bf": {
			"type": "Ybodychange",
			"commitMessage": "Use AutoClosable to close resources in bundle org.eclipse.jgit\n\n- use try-with-resource where possible\n- replace use of deprecated release() by close()\n\nChange-Id: I0f139c3535679087b7fa09649166bca514750b81\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2015-05-20, 3:01 PM",
			"commitName": "0e73d395061d1bfee365acaa2f79c392175d13bf",
			"commitAuthor": "Matthias Sohn",
			"commitDateOld": "2014-12-12, 5:49 AM",
			"commitNameOld": "da595f093e5547a7da583fa0459400e47a2638c6",
			"commitAuthorOld": "Christian Halstrick",
			"daysBetweenCommits": 159.34,
			"commitsBetweenForRepo": 215,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,185 +1,189 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n-\t\tTreeWalk treeWalk = new TreeWalk(repository);\n-\t\ttreeWalk.setRecursive(true);\n-\t\t// add the trees (tree, dirchache, workdir)\n-\t\tif (tree != null)\n-\t\t\ttreeWalk.addTree(tree);\n-\t\telse\n-\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n-\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n-\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n-\t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n+\t\ttry (TreeWalk treeWalk = new TreeWalk(repository)) {\n+\t\t\ttreeWalk.setRecursive(true);\n+\t\t\t// add the trees (tree, dirchache, workdir)\n+\t\t\tif (tree != null)\n+\t\t\t\ttreeWalk.addTree(tree);\n+\t\t\telse\n+\t\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n+\t\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n+\t\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n+\t\t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \n-\t\tif (monitor != null) {\n-\t\t\t// Get the maximum size of the work tree and index\n-\t\t\t// and add some (quite arbitrary)\n-\t\t\tif (estIndexSize == 0)\n-\t\t\t\testIndexSize = dirCache.getEntryCount();\n-\t\t\tint total = Math.max(estIndexSize * 10 / 9,\n-\t\t\t\t\testWorkTreeSize * 10 / 9);\n-\t\t\tmonitor.beginTask(title, total);\n-\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n-\t\t}\n-\n-\t\tif (filter != null)\n-\t\t\tfilters.add(filter);\n-\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n-\t\tindexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n-\t\tfilters.add(indexDiffFilter);\n-\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n-\t\tfileModes.clear();\n-\t\twhile (treeWalk.next()) {\n-\t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n-\t\t\t\t\tAbstractTreeIterator.class);\n-\t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n-\t\t\t\t\tDirCacheIterator.class);\n-\t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n-\t\t\t\t\tWorkingTreeIterator.class);\n-\n-\t\t\tif (dirCacheIterator != null) {\n-\t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n-\t\t\t\t\t\t.getDirCacheEntry();\n-\t\t\t\tif (dirCacheEntry != null) {\n-\t\t\t\t\tint stage = dirCacheEntry.getStage();\n-\t\t\t\t\tif (stage > 0) {\n-\t\t\t\t\t\tString path = treeWalk.getPathString();\n-\t\t\t\t\t\taddConflict(path, stage);\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\tif (monitor != null) {\n+\t\t\t\t// Get the maximum size of the work tree and index\n+\t\t\t\t// and add some (quite arbitrary)\n+\t\t\t\tif (estIndexSize == 0)\n+\t\t\t\t\testIndexSize = dirCache.getEntryCount();\n+\t\t\t\tint total = Math.max(estIndexSize * 10 / 9,\n+\t\t\t\t\t\testWorkTreeSize * 10 / 9);\n+\t\t\t\tmonitor.beginTask(title, total);\n+\t\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t\t}\n \n-\t\t\tif (treeIterator != null) {\n+\t\t\tif (filter != null)\n+\t\t\t\tfilters.add(filter);\n+\t\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n+\t\t\tindexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n+\t\t\tfilters.add(indexDiffFilter);\n+\t\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n+\t\t\tfileModes.clear();\n+\t\t\twhile (treeWalk.next()) {\n+\t\t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n+\t\t\t\t\t\tAbstractTreeIterator.class);\n+\t\t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n+\t\t\t\t\t\tDirCacheIterator.class);\n+\t\t\t\tWorkingTreeIterator workingTreeIterator = treeWalk\n+\t\t\t\t\t\t.getTree(WORKDIR, WorkingTreeIterator.class);\n+\n \t\t\t\tif (dirCacheIterator != null) {\n-\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n-\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n-\t\t\t\t\t\t\t!= dirCacheIterator.getEntryRawMode()) {\n-\t\t\t\t\t\t// in repo, in index, content diff => changed\n+\t\t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n+\t\t\t\t\t\t\t.getDirCacheEntry();\n+\t\t\t\t\tif (dirCacheEntry != null) {\n+\t\t\t\t\t\tint stage = dirCacheEntry.getStage();\n+\t\t\t\t\t\tif (stage > 0) {\n+\t\t\t\t\t\t\tString path = treeWalk.getPathString();\n+\t\t\t\t\t\t\taddConflict(path, stage);\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (treeIterator != null) {\n+\t\t\t\t\tif (dirCacheIterator != null) {\n+\t\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n+\t\t\t\t\t\t\t\t|| treeIterator\n+\t\t\t\t\t\t\t\t\t\t.getEntryRawMode() != dirCacheIterator\n+\t\t\t\t\t\t\t\t\t\t\t\t.getEntryRawMode()) {\n+\t\t\t\t\t\t\t// in repo, in index, content diff => changed\n+\t\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n+\t\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n+\t\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n+\t\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n-\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n-\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n+\t\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n+\t\t\t\t\t\tif (workingTreeIterator != null)\n+\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\t// in repo, not in index => removed\n-\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n-\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n-\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n-\t\t\t\t\tif (workingTreeIterator != null)\n-\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n+\t\t\t\t\tif (dirCacheIterator != null) {\n+\t\t\t\t\t\t// not in repo, in index => added\n+\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n+\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n+\t\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t// not in repo, not in index => untracked\n+\t\t\t\t\t\tif (workingTreeIterator != null\n+\t\t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n+\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t} else {\n+\n \t\t\t\tif (dirCacheIterator != null) {\n-\t\t\t\t\t// not in repo, in index => added\n-\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n-\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n-\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n-\t\t\t\t} else {\n-\t\t\t\t\t// not in repo, not in index => untracked\n-\t\t\t\t\tif (workingTreeIterator != null\n-\t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n-\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n+\t\t\t\t\tif (workingTreeIterator == null) {\n+\t\t\t\t\t\t// in index, not in workdir => missing\n+\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n+\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n+\t\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (workingTreeIterator.isModified(\n+\t\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n+\t\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n+\t\t\t\t\t\t\t// in index, in workdir, content differs => modified\n+\t\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n+\t\t\t\t\t\t\t\t\t|| !isEntryGitLink(workingTreeIterator)\n+\t\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL\n+\t\t\t\t\t\t\t\t\t\t\t&& ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n+\t\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t}\n \n-\t\t\tif (dirCacheIterator != null) {\n-\t\t\t\tif (workingTreeIterator == null) {\n-\t\t\t\t\t// in index, not in workdir => missing\n-\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n-\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n-\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n-\t\t\t\t} else {\n-\t\t\t\t\tif (workingTreeIterator.isModified(\n-\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n-\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n-\t\t\t\t\t\t// in index, in workdir, content differs => modified\n-\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator)\n-\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n-\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n+\t\t\t\tfor (int i = 0; i < treeWalk.getTreeCount(); i++) {\n+\t\t\t\t\tSet<String> values = fileModes.get(treeWalk.getFileMode(i));\n+\t\t\t\t\tString path = treeWalk.getPathString();\n+\t\t\t\t\tif (path != null) {\n+\t\t\t\t\t\tif (values == null)\n+\t\t\t\t\t\t\tvalues = new HashSet<String>();\n+\t\t\t\t\t\tvalues.add(path);\n+\t\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\n-\t\t\tfor (int i = 0; i < treeWalk.getTreeCount(); i++) {\n-\t\t\t\tSet<String> values = fileModes.get(treeWalk.getFileMode(i));\n-\t\t\t\tString path = treeWalk.getPathString();\n-\t\t\t\tif (path != null) {\n-\t\t\t\t\tif (values == null)\n-\t\t\t\t\t\tvalues = new HashSet<String>();\n-\t\t\t\t\tvalues.add(path);\n-\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n-\t\t\t\t}\n-\t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode == null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode = smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n \t\t\t\t\tIOException e1 = new IOException(\n \t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n \t\t\t\t\t\t\t\t\t+ smw.getPath());\n \t\t\t\t\te1.initCause(e);\n \t\t\t\t\tthrow e1;\n \t\t\t\t}\n \t\t\t\tRepository subRepo = smw.getRepository();\n \t\t\t\tif (subRepo != null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tObjectId subHead = subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n \t\t\t\t\t\tif (subHead != null\n \t\t\t\t\t\t\t\t&& !subHead.equals(smw.getObjectId()))\n \t\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t\telse if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\t\t\tIndexDiff smid = submoduleIndexDiffs.get(smw\n \t\t\t\t\t\t\t\t\t.getPath());\n \t\t\t\t\t\t\tif (smid == null) {\n \t\t\t\t\t\t\t\tsmid = new IndexDiff(subRepo,\n \t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n \t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n \t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\t\t\tif (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t\t\t&& smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t\t\t&& smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\tsubRepo.close();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor != null)\n \t\t\tmonitor.endTask();\n \n \t\tignored = indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"da595f093e5547a7da583fa0459400e47a2638c6": {
			"type": "Ybodychange",
			"commitMessage": "Fix tests on windows by closing repos\n\nWithout explicitly closing repos we can't delete the test repositories\non windows.\n\nChange-Id: Id5fa17bd764cbf28703c2f21639d7e969289c2d6\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2014-12-12, 5:49 AM",
			"commitName": "da595f093e5547a7da583fa0459400e47a2638c6",
			"commitAuthor": "Christian Halstrick",
			"commitDateOld": "2014-11-09, 1:44 PM",
			"commitNameOld": "9597c41ea9db20d769f7b8c54eafa207824e5bd6",
			"commitAuthorOld": "Christian Halstrick",
			"daysBetweenCommits": 32.67,
			"commitsBetweenForRepo": 33,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,178 +1,185 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \n \t\tif (monitor != null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize == 0)\n \t\t\t\testIndexSize = dirCache.getEntryCount();\n \t\t\tint total = Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tindexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n \t\tfilters.add(indexDiffFilter);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\tfileModes.clear();\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n \t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\tif (dirCacheEntry != null) {\n \t\t\t\t\tint stage = dirCacheEntry.getStage();\n \t\t\t\t\tif (stage > 0) {\n \t\t\t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!= dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tfor (int i = 0; i < treeWalk.getTreeCount(); i++) {\n \t\t\t\tSet<String> values = fileModes.get(treeWalk.getFileMode(i));\n \t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\tif (path != null) {\n \t\t\t\t\tif (values == null)\n \t\t\t\t\t\tvalues = new HashSet<String>();\n \t\t\t\t\tvalues.add(path);\n \t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode == null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode = smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n \t\t\t\t\tIOException e1 = new IOException(\n \t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n \t\t\t\t\t\t\t\t\t+ smw.getPath());\n \t\t\t\t\te1.initCause(e);\n \t\t\t\t\tthrow e1;\n \t\t\t\t}\n \t\t\t\tRepository subRepo = smw.getRepository();\n \t\t\t\tif (subRepo != null) {\n-\t\t\t\t\tObjectId subHead = subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n-\t\t\t\t\tif (subHead != null && !subHead.equals(smw.getObjectId()))\n-\t\t\t\t\t\tmodified.add(smw.getPath());\n-\t\t\t\t\telse if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n-\t\t\t\t\t\tIndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n-\t\t\t\t\t\tif (smid == null) {\n-\t\t\t\t\t\t\tsmid = new IndexDiff(subRepo, smw.getObjectId(),\n-\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n-\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (smid.diff()) {\n-\t\t\t\t\t\t\tif (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED\n-\t\t\t\t\t\t\t\t\t&& smid.getAdded().isEmpty()\n-\t\t\t\t\t\t\t\t\t&& smid.getChanged().isEmpty()\n-\t\t\t\t\t\t\t\t\t&& smid.getConflicting().isEmpty()\n-\t\t\t\t\t\t\t\t\t&& smid.getMissing().isEmpty()\n-\t\t\t\t\t\t\t\t\t&& smid.getModified().isEmpty()\n-\t\t\t\t\t\t\t\t\t&& smid.getRemoved().isEmpty()) {\n-\t\t\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tObjectId subHead = subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n+\t\t\t\t\t\tif (subHead != null\n+\t\t\t\t\t\t\t\t&& !subHead.equals(smw.getObjectId()))\n \t\t\t\t\t\t\tmodified.add(smw.getPath());\n+\t\t\t\t\t\telse if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n+\t\t\t\t\t\t\tIndexDiff smid = submoduleIndexDiffs.get(smw\n+\t\t\t\t\t\t\t\t\t.getPath());\n+\t\t\t\t\t\t\tif (smid == null) {\n+\t\t\t\t\t\t\t\tsmid = new IndexDiff(subRepo,\n+\t\t\t\t\t\t\t\t\t\tsmw.getObjectId(),\n+\t\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n+\t\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (smid.diff()) {\n+\t\t\t\t\t\t\t\tif (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED\n+\t\t\t\t\t\t\t\t\t\t&& smid.getAdded().isEmpty()\n+\t\t\t\t\t\t\t\t\t\t&& smid.getChanged().isEmpty()\n+\t\t\t\t\t\t\t\t\t\t&& smid.getConflicting().isEmpty()\n+\t\t\t\t\t\t\t\t\t\t&& smid.getMissing().isEmpty()\n+\t\t\t\t\t\t\t\t\t\t&& smid.getModified().isEmpty()\n+\t\t\t\t\t\t\t\t\t\t&& smid.getRemoved().isEmpty()) {\n+\t\t\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tmodified.add(smw.getPath());\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n+\t\t\t\t\t} finally {\n+\t\t\t\t\t\tsubRepo.close();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor != null)\n \t\t\tmonitor.endTask();\n \n \t\tignored = indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9597c41ea9db20d769f7b8c54eafa207824e5bd6": {
			"type": "Ybodychange",
			"commitMessage": "Fix possible NPE in IndexDiff when not all submodules are cloned\n\nThe latest changes to IndexDiff just assumed that all configured\nsubmodules are allways cloned. If a configured submodule did not exist\nan exception was thrown. This is fixed by this commit.\n\nBug: 450567\nChange-Id: Iabe3b196d998c19483082e5720038ebddaeb1890\n",
			"commitDate": "2014-11-09, 1:44 PM",
			"commitName": "9597c41ea9db20d769f7b8c54eafa207824e5bd6",
			"commitAuthor": "Christian Halstrick",
			"commitDateOld": "2014-11-06, 12:48 AM",
			"commitNameOld": "abb57e6b5674b7251bd94b7238e5d995ad9c30c5",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 3.54,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,176 +1,178 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \n \t\tif (monitor != null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize == 0)\n \t\t\t\testIndexSize = dirCache.getEntryCount();\n \t\t\tint total = Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tindexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n \t\tfilters.add(indexDiffFilter);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\tfileModes.clear();\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n \t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\tif (dirCacheEntry != null) {\n \t\t\t\t\tint stage = dirCacheEntry.getStage();\n \t\t\t\t\tif (stage > 0) {\n \t\t\t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!= dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tfor (int i = 0; i < treeWalk.getTreeCount(); i++) {\n \t\t\t\tSet<String> values = fileModes.get(treeWalk.getFileMode(i));\n \t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\tif (path != null) {\n \t\t\t\t\tif (values == null)\n \t\t\t\t\t\tvalues = new HashSet<String>();\n \t\t\t\t\tvalues.add(path);\n \t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode == null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode = smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n \t\t\t\t\tIOException e1 = new IOException(\n \t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n \t\t\t\t\t\t\t\t\t+ smw.getPath());\n \t\t\t\t\te1.initCause(e);\n \t\t\t\t\tthrow e1;\n \t\t\t\t}\n \t\t\t\tRepository subRepo = smw.getRepository();\n-\t\t\t\tObjectId subHead = subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n-\t\t\t\tif (subHead != null && !subHead.equals(smw.getObjectId()))\n-\t\t\t\t\tmodified.add(smw.getPath());\n-\t\t\t\telse if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n-\t\t\t\t\tIndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n-\t\t\t\t\tif (smid == null) {\n-\t\t\t\t\t\tsmid = new IndexDiff(subRepo, smw.getObjectId(),\n-\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n-\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n-\t\t\t\t\t}\n-\t\t\t\t\tif (smid.diff()) {\n-\t\t\t\t\t\tif (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED\n-\t\t\t\t\t\t\t\t&& smid.getAdded().isEmpty()\n-\t\t\t\t\t\t\t\t&& smid.getChanged().isEmpty()\n-\t\t\t\t\t\t\t\t&& smid.getConflicting().isEmpty()\n-\t\t\t\t\t\t\t\t&& smid.getMissing().isEmpty()\n-\t\t\t\t\t\t\t\t&& smid.getModified().isEmpty()\n-\t\t\t\t\t\t\t\t&& smid.getRemoved().isEmpty()) {\n-\t\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t\t}\n+\t\t\t\tif (subRepo != null) {\n+\t\t\t\t\tObjectId subHead = subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n+\t\t\t\t\tif (subHead != null && !subHead.equals(smw.getObjectId()))\n \t\t\t\t\t\tmodified.add(smw.getPath());\n+\t\t\t\t\telse if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n+\t\t\t\t\t\tIndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n+\t\t\t\t\t\tif (smid == null) {\n+\t\t\t\t\t\t\tsmid = new IndexDiff(subRepo, smw.getObjectId(),\n+\t\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n+\t\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (smid.diff()) {\n+\t\t\t\t\t\t\tif (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED\n+\t\t\t\t\t\t\t\t\t&& smid.getAdded().isEmpty()\n+\t\t\t\t\t\t\t\t\t&& smid.getChanged().isEmpty()\n+\t\t\t\t\t\t\t\t\t&& smid.getConflicting().isEmpty()\n+\t\t\t\t\t\t\t\t\t&& smid.getMissing().isEmpty()\n+\t\t\t\t\t\t\t\t\t&& smid.getModified().isEmpty()\n+\t\t\t\t\t\t\t\t\t&& smid.getRemoved().isEmpty()) {\n+\t\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tmodified.add(smw.getPath());\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor != null)\n \t\t\tmonitor.endTask();\n \n \t\tignored = indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"abb57e6b5674b7251bd94b7238e5d995ad9c30c5": {
			"type": "Ybodychange",
			"commitMessage": "Do not swallow exception if IndexDiff hits invalid ignore param\n\nChange-Id: I8a595e1f01a0731118d3c537be420222f7fec744\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2014-11-06, 12:48 AM",
			"commitName": "abb57e6b5674b7251bd94b7238e5d995ad9c30c5",
			"commitAuthor": "Matthias Sohn",
			"commitDateOld": "2014-11-06, 12:46 AM",
			"commitNameOld": "d8fcc964a85b255aac431c14ac35624f0634620b",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,174 +1,176 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \n \t\tif (monitor != null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize == 0)\n \t\t\t\testIndexSize = dirCache.getEntryCount();\n \t\t\tint total = Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tindexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n \t\tfilters.add(indexDiffFilter);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\tfileModes.clear();\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n \t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\tif (dirCacheEntry != null) {\n \t\t\t\t\tint stage = dirCacheEntry.getStage();\n \t\t\t\t\tif (stage > 0) {\n \t\t\t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!= dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tfor (int i = 0; i < treeWalk.getTreeCount(); i++) {\n \t\t\t\tSet<String> values = fileModes.get(treeWalk.getFileMode(i));\n \t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\tif (path != null) {\n \t\t\t\t\tif (values == null)\n \t\t\t\t\t\tvalues = new HashSet<String>();\n \t\t\t\t\tvalues.add(path);\n \t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode == null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode = smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n-\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\tIOException e1 = new IOException(\n \t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n \t\t\t\t\t\t\t\t\t+ smw.getPath());\n+\t\t\t\t\te1.initCause(e);\n+\t\t\t\t\tthrow e1;\n \t\t\t\t}\n \t\t\t\tRepository subRepo = smw.getRepository();\n \t\t\t\tObjectId subHead = subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n \t\t\t\tif (subHead != null && !subHead.equals(smw.getObjectId()))\n \t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\telse if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\tIndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n \t\t\t\t\tif (smid == null) {\n \t\t\t\t\t\tsmid = new IndexDiff(subRepo, smw.getObjectId(),\n \t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n \t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n \t\t\t\t\t}\n \t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\tif (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t&& smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t&& smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t&& smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t&& smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t&& smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t&& smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor != null)\n \t\t\tmonitor.endTask();\n \n \t\tignored = indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d8fcc964a85b255aac431c14ac35624f0634620b": {
			"type": "Ybodychange",
			"commitMessage": "Fix non-externalized string warnings in IndexDiff\n\nChange-Id: Ia803182114f0e8b418428e03601f9afc6542ed28\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2014-11-06, 12:46 AM",
			"commitName": "d8fcc964a85b255aac431c14ac35624f0634620b",
			"commitAuthor": "Matthias Sohn",
			"commitDateOld": "2014-11-06, 12:40 AM",
			"commitNameOld": "5328c8c9164414a63ce7f1323d8194b84b6f1e49",
			"commitAuthorOld": "Axel Richard",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,174 +1,174 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \n \t\tif (monitor != null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize == 0)\n \t\t\t\testIndexSize = dirCache.getEntryCount();\n \t\t\tint total = Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tindexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n \t\tfilters.add(indexDiffFilter);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\tfileModes.clear();\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n \t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\tif (dirCacheEntry != null) {\n \t\t\t\t\tint stage = dirCacheEntry.getStage();\n \t\t\t\t\tif (stage > 0) {\n \t\t\t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!= dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tfor (int i = 0; i < treeWalk.getTreeCount(); i++) {\n \t\t\t\tSet<String> values = fileModes.get(treeWalk.getFileMode(i));\n \t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\tif (path != null) {\n \t\t\t\t\tif (values == null)\n \t\t\t\t\t\tvalues = new HashSet<String>();\n \t\t\t\t\tvalues.add(path);\n \t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode == null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode = smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n \t\t\t\t\tthrow new IOException(\n \t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n \t\t\t\t\t\t\t\t\t+ smw.getPath());\n \t\t\t\t}\n \t\t\t\tRepository subRepo = smw.getRepository();\n-\t\t\t\tObjectId subHead = subRepo.resolve(\"HEAD\");\n+\t\t\t\tObjectId subHead = subRepo.resolve(\"HEAD\"); //$NON-NLS-1$\n \t\t\t\tif (subHead != null && !subHead.equals(smw.getObjectId()))\n \t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\telse if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\tIndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n \t\t\t\t\tif (smid == null) {\n \t\t\t\t\t\tsmid = new IndexDiff(subRepo, smw.getObjectId(),\n \t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n \t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n \t\t\t\t\t}\n \t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\tif (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t&& smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t&& smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t&& smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t&& smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t&& smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t&& smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor != null)\n \t\t\tmonitor.endTask();\n \n \t\tignored = indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5328c8c9164414a63ce7f1323d8194b84b6f1e49": {
			"type": "Ybodychange",
			"commitMessage": "Add new method IndexDiff#getPathsWithIndexMode\n\nGet the list of paths that have the given file mode.\n\nThis helps EGit to efficiently determine which modified files are\nsymlinks and should be shown with a symlink icon in the staging view.\n\nBug: 429302\nChange-Id: Id15f0c6f265667f5b8b57cc2d9f97de568371919\nSigned-off-by: Axel Richard <axel.richard@obeo.fr>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2014-11-06, 12:40 AM",
			"commitName": "5328c8c9164414a63ce7f1323d8194b84b6f1e49",
			"commitAuthor": "Axel Richard",
			"commitDateOld": "2014-11-03, 8:08 AM",
			"commitNameOld": "c017ac4c85cab7449a49b681843b9bc33e54d2b6",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 2.69,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,161 +1,174 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \n \t\tif (monitor != null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize == 0)\n \t\t\t\testIndexSize = dirCache.getEntryCount();\n \t\t\tint total = Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tindexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n \t\tfilters.add(indexDiffFilter);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n+\t\tfileModes.clear();\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n \t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\tif (dirCacheEntry != null) {\n \t\t\t\t\tint stage = dirCacheEntry.getStage();\n \t\t\t\t\tif (stage > 0) {\n \t\t\t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!= dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tif (!isEntryGitLink(treeIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n \t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n \t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator)\n \t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n \t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\tfor (int i = 0; i < treeWalk.getTreeCount(); i++) {\n+\t\t\t\tSet<String> values = fileModes.get(treeWalk.getFileMode(i));\n+\t\t\t\tString path = treeWalk.getPathString();\n+\t\t\t\tif (path != null) {\n+\t\t\t\t\tif (values == null)\n+\t\t\t\t\t\tvalues = new HashSet<String>();\n+\t\t\t\t\tvalues.add(path);\n+\t\t\t\t\tfileModes.put(treeWalk.getFileMode(i), values);\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \n \t\tif (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n \t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n \t\t\tSubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n \t\t\twhile (smw.next()) {\n \t\t\t\ttry {\n \t\t\t\t\tif (localIgnoreSubmoduleMode == null)\n \t\t\t\t\t\tlocalIgnoreSubmoduleMode = smw.getModulesIgnore();\n \t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n \t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t} catch (ConfigInvalidException e) {\n \t\t\t\t\tthrow new IOException(\n \t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n \t\t\t\t\t\t\t\t\t+ smw.getPath());\n \t\t\t\t}\n \t\t\t\tRepository subRepo = smw.getRepository();\n \t\t\t\tObjectId subHead = subRepo.resolve(\"HEAD\");\n \t\t\t\tif (subHead != null && !subHead.equals(smw.getObjectId()))\n \t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\telse if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n \t\t\t\t\tIndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n \t\t\t\t\tif (smid == null) {\n \t\t\t\t\t\tsmid = new IndexDiff(subRepo, smw.getObjectId(),\n \t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n \t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n \t\t\t\t\t}\n \t\t\t\t\tif (smid.diff()) {\n \t\t\t\t\t\tif (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED\n \t\t\t\t\t\t\t\t&& smid.getAdded().isEmpty()\n \t\t\t\t\t\t\t\t&& smid.getChanged().isEmpty()\n \t\t\t\t\t\t\t\t&& smid.getConflicting().isEmpty()\n \t\t\t\t\t\t\t\t&& smid.getMissing().isEmpty()\n \t\t\t\t\t\t\t\t&& smid.getModified().isEmpty()\n \t\t\t\t\t\t\t\t&& smid.getRemoved().isEmpty()) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor != null)\n \t\t\tmonitor.endTask();\n \n \t\tignored = indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"95172dea173425697814e3ba0b4eb823301bf7d0": {
			"type": "Ybodychange",
			"commitMessage": "Support for Submodule configuration submodule.<name>.ignore\n\nFor each submodule native git allows to configure which modifications to\nsubmodules should be ignored by the status command. It is possible to\nignore \"none\", \"all\", \"dirty\", \"untracked\" [1]. This configuration is\nnow supported by IndexDiff. The StatusCommand offers the possibility to\nspecify this mode.\n\n[1] http://git-scm.com/docs/gitmodules\n\nChange-Id: Ifd81d574a680f9b4152945ba70f8ec4af4f452c9\n",
			"commitDate": "2014-11-03, 1:32 AM",
			"commitName": "95172dea173425697814e3ba0b4eb823301bf7d0",
			"commitAuthor": "Christian Halstrick",
			"commitDateOld": "2014-02-02, 4:16 AM",
			"commitNameOld": "5404e70dc64201786cd6a21efb41310912860122",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 273.89,
			"commitsBetweenForRepo": 346,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,108 +1,161 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \n \t\tif (monitor != null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize == 0)\n \t\t\t\testIndexSize = dirCache.getEntryCount();\n \t\t\tint total = Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tindexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n \t\tfilters.add(indexDiffFilter);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n \t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\tif (dirCacheEntry != null) {\n \t\t\t\t\tint stage = dirCacheEntry.getStage();\n \t\t\t\t\tif (stage > 0) {\n \t\t\t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!= dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n-\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n+\t\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n+\t\t\t\t\t\t\t\t|| !isEntryGitLink(dirCacheIterator)\n+\t\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n+\t\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n-\t\t\t\t\tremoved.add(treeWalk.getPathString());\n+\t\t\t\t\tif (!isEntryGitLink(treeIterator)\n+\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n+\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n-\t\t\t\t\tadded.add(treeWalk.getPathString());\n+\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n+\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n+\t\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n-\t\t\t\t\tmissing.add(treeWalk.getPathString());\n+\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator)\n+\t\t\t\t\t\t\t|| ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL)\n+\t\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n \t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n-\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n+\t\t\t\t\t\tif (!isEntryGitLink(dirCacheIterator) || !isEntryGitLink(workingTreeIterator)\n+\t\t\t\t\t\t\t\t|| (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL && ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY))\n+\t\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (ignoreSubmoduleMode != IgnoreSubmoduleMode.ALL) {\n+\t\t\tIgnoreSubmoduleMode localIgnoreSubmoduleMode = ignoreSubmoduleMode;\n+\t\t\tSubmoduleWalk smw = SubmoduleWalk.forIndex(repository);\n+\t\t\twhile (smw.next()) {\n+\t\t\t\ttry {\n+\t\t\t\t\tif (localIgnoreSubmoduleMode == null)\n+\t\t\t\t\t\tlocalIgnoreSubmoduleMode = smw.getModulesIgnore();\n+\t\t\t\t\tif (IgnoreSubmoduleMode.ALL\n+\t\t\t\t\t\t\t.equals(localIgnoreSubmoduleMode))\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t} catch (ConfigInvalidException e) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\t\"Found invalid ignore param for submodule \"\n+\t\t\t\t\t\t\t\t\t+ smw.getPath());\n+\t\t\t\t}\n+\t\t\t\tRepository subRepo = smw.getRepository();\n+\t\t\t\tObjectId subHead = subRepo.resolve(\"HEAD\");\n+\t\t\t\tif (subHead != null && !subHead.equals(smw.getObjectId()))\n+\t\t\t\t\tmodified.add(smw.getPath());\n+\t\t\t\telse if (ignoreSubmoduleMode != IgnoreSubmoduleMode.DIRTY) {\n+\t\t\t\t\tIndexDiff smid = submoduleIndexDiffs.get(smw.getPath());\n+\t\t\t\t\tif (smid == null) {\n+\t\t\t\t\t\tsmid = new IndexDiff(subRepo, smw.getObjectId(),\n+\t\t\t\t\t\t\t\twTreeIt.getWorkingTreeIterator(subRepo));\n+\t\t\t\t\t\tsubmoduleIndexDiffs.put(smw.getPath(), smid);\n+\t\t\t\t\t}\n+\t\t\t\t\tif (smid.diff()) {\n+\t\t\t\t\t\tif (ignoreSubmoduleMode == IgnoreSubmoduleMode.UNTRACKED\n+\t\t\t\t\t\t\t\t&& smid.getAdded().isEmpty()\n+\t\t\t\t\t\t\t\t&& smid.getChanged().isEmpty()\n+\t\t\t\t\t\t\t\t&& smid.getConflicting().isEmpty()\n+\t\t\t\t\t\t\t\t&& smid.getMissing().isEmpty()\n+\t\t\t\t\t\t\t\t&& smid.getModified().isEmpty()\n+\t\t\t\t\t\t\t\t&& smid.getRemoved().isEmpty()) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tmodified.add(smw.getPath());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor != null)\n \t\t\tmonitor.endTask();\n \n \t\tignored = indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5404e70dc64201786cd6a21efb41310912860122": {
			"type": "Ybodychange",
			"commitMessage": "Fix for core.autocrlf=input resulting in modified file\n\nThis version does not attempt to unsmudge, unlike the first attempt\nin Idafad150553df14827eccfde2e3b95760e16a8b6.\n\nBug: 372834\nChange-Id: I9300e735cb16d6208e1df963abb1ff69f688155d\nAlso-by: Robin Stocker <robin@nibor.org>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>\nSigned-off-by: Robin Stocker <robin@nibor.org>\n",
			"commitDate": "2014-02-02, 4:16 AM",
			"commitName": "5404e70dc64201786cd6a21efb41310912860122",
			"commitAuthor": "Robin Rosenberg",
			"commitDateOld": "2013-04-19, 8:05 AM",
			"commitNameOld": "1080cc5a0d67012c0ef08d9468fbbc9d90b0c238",
			"commitAuthorOld": "Robin Stocker",
			"daysBetweenCommits": 288.88,
			"commitsBetweenForRepo": 282,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,107 +1,108 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \n \t\tif (monitor != null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize == 0)\n \t\t\t\testIndexSize = dirCache.getEntryCount();\n \t\t\tint total = Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tindexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n \t\tfilters.add(indexDiffFilter);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n \t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\tif (dirCacheEntry != null) {\n \t\t\t\t\tint stage = dirCacheEntry.getStage();\n \t\t\t\t\tif (stage > 0) {\n \t\t\t\t\t\tString path = treeWalk.getPathString();\n \t\t\t\t\t\taddConflict(path, stage);\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!= dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n-\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n+\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true,\n+\t\t\t\t\t\t\ttreeWalk.getObjectReader())) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor != null)\n \t\t\tmonitor.endTask();\n \n \t\tignored = indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1080cc5a0d67012c0ef08d9468fbbc9d90b0c238": {
			"type": "Ybodychange",
			"commitMessage": "IndexDiff: Provide stage state for conflicting entries\n\nAdds a new method getConflictingStageStates() which returns a\nMap<String, StageState> (path to stage state). StageState is an enum for\nall possible stage combinations (BOTH_DELETED, ADDED_BY_US, ...).\n\nThis can be used to implement the conflict text for unmerged paths in\noutput of \"git status\" or in EGit for decorations/hints.\n\nBug: 403697\nChange-Id: Ib461640a43111b7df4a0debe92ff69b82171329c\nSigned-off-by: Chris Aniszczyk <zx@twitter.com>\n",
			"commitDate": "2013-04-19, 8:05 AM",
			"commitName": "1080cc5a0d67012c0ef08d9468fbbc9d90b0c238",
			"commitAuthor": "Robin Stocker",
			"commitDateOld": "2012-12-27, 7:57 AM",
			"commitNameOld": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 112.96,
			"commitsBetweenForRepo": 201,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,103 +1,107 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \n \t\tif (monitor != null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize == 0)\n \t\t\t\testIndexSize = dirCache.getEntryCount();\n \t\t\tint total = Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tindexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n \t\tfilters.add(indexDiffFilter);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n \t\t\t\t\t\t.getDirCacheEntry();\n-\t\t\t\tif (dirCacheEntry != null && dirCacheEntry.getStage() > 0) {\n-\t\t\t\t\tconflicts.add(treeWalk.getPathString());\n-\t\t\t\t\tcontinue;\n+\t\t\t\tif (dirCacheEntry != null) {\n+\t\t\t\t\tint stage = dirCacheEntry.getStage();\n+\t\t\t\t\tif (stage > 0) {\n+\t\t\t\t\t\tString path = treeWalk.getPathString();\n+\t\t\t\t\t\taddConflict(path, stage);\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!= dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor != null)\n \t\t\tmonitor.endTask();\n \n \t\tignored = indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"53ef3e51145adb4b060110e262d7c064be0d5fc5": {
			"type": "Ybodychange",
			"commitMessage": "Add detection of untracked folders to IndexDiffFilter\n\nDecorators need to know whether folders in the working tree contain only\nuntracked files. This change enhances IndexDiffFilter to report such\nfolders. This works only together with treewalks which operate in\ndefault traversal mode. For treewalks which process entries in\npostorder mode (files are walked before their parent folder is walked)\nthis detection doesn't work.\n\nBug: 359264\nChange-Id: I9298d1e3ccac0aec8bbd4e8ac867bc06a5c89c9f\nSigned-off-by: Christian Halstrick <christian.halstrick@sap.com>\nSigned-off-by: Jens Baumgart <jens.baumgart@sap.com>\nSigned-off-by: Chris Aniszczyk <zx@twitter.com>\n",
			"commitDate": "2011-11-10, 11:15 AM",
			"commitName": "53ef3e51145adb4b060110e262d7c064be0d5fc5",
			"commitAuthor": "Jens Baumgart",
			"commitDateOld": "2011-10-05, 4:56 AM",
			"commitNameOld": "6befabcb1584118fb02188f602f7ca34b9a7efc5",
			"commitAuthorOld": "Jens Baumgart",
			"daysBetweenCommits": 36.3,
			"commitsBetweenForRepo": 37,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,103 +1,103 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \n \t\tif (monitor != null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize == 0)\n \t\t\t\testIndexSize = dirCache.getEntryCount();\n \t\t\tint total = Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n-\t\tIndexDiffFilter indexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n+\t\tindexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n \t\tfilters.add(indexDiffFilter);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n \t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\tif (dirCacheEntry != null && dirCacheEntry.getStage() > 0) {\n \t\t\t\t\tconflicts.add(treeWalk.getPathString());\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!= dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor != null)\n \t\t\tmonitor.endTask();\n \n \t\tignored = indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6befabcb1584118fb02188f602f7ca34b9a7efc5": {
			"type": "Ybodychange",
			"commitMessage": "Extend IndexDiff to calculate ignored files and folders\n\nIndexDiff was extended to calculate ignored files and folders.\nThe calculation only considers files that are NOT in the index.\nThis functionality is required by the new EGit decorator implementation.\n\nBug: 359264\nChange-Id: I8f09d6a4d61b64aeea80fd22bf3a2963c2bca347\nSigned-off-by: Jens Baumgart <jens.baumgart@sap.com>\n",
			"commitDate": "2011-10-05, 4:56 AM",
			"commitName": "6befabcb1584118fb02188f602f7ca34b9a7efc5",
			"commitAuthor": "Jens Baumgart",
			"commitDateOld": "2011-08-16, 1:22 PM",
			"commitNameOld": "ac909ec89d7a6f59e2d02dcc900a4f80576b12a4",
			"commitAuthorOld": "Kevin Sawicki",
			"daysBetweenCommits": 49.65,
			"commitsBetweenForRepo": 48,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,101 +1,103 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \n \t\tif (monitor != null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize == 0)\n \t\t\t\testIndexSize = dirCache.getEntryCount();\n \t\t\tint total = Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n-\t\tfilters.add(new IndexDiffFilter(INDEX, WORKDIR));\n+\t\tIndexDiffFilter indexDiffFilter = new IndexDiffFilter(INDEX, WORKDIR);\n+\t\tfilters.add(indexDiffFilter);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n \t\t\t\t\t\t.getDirCacheEntry();\n \t\t\t\tif (dirCacheEntry != null && dirCacheEntry.getStage() > 0) {\n \t\t\t\t\tconflicts.add(treeWalk.getPathString());\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!= dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor != null)\n \t\t\tmonitor.endTask();\n \n+\t\tignored = indexDiffFilter.getIgnoredPaths();\n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"298486a7c320629de12f9506e0133686a7382b01": {
			"type": "Ybodychange",
			"commitMessage": "IndexDiff: conflicting files aren't properly shown\n\nBefore this change any files in the conflicting set would\nalso be listed in the the other IndexDiff Sets which is\nconfusing.  With this change a conflicting file will not\nbe included in any of the other sets.\n\nChange-Id: Ife9f2652685220bcfddc1f9820423acdcd5acfdc\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
			"commitDate": "2011-05-05, 11:48 AM",
			"commitName": "298486a7c320629de12f9506e0133686a7382b01",
			"commitAuthor": "Bernard Leach",
			"commitDateOld": "2011-04-19, 3:11 PM",
			"commitNameOld": "1a867d10b974cab4d43d77f5b392f4f07807ebd8",
			"commitAuthorOld": "Bernard Leach",
			"daysBetweenCommits": 15.86,
			"commitsBetweenForRepo": 22,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,98 +1,101 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \n \t\tif (monitor != null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize == 0)\n \t\t\t\testIndexSize = dirCache.getEntryCount();\n \t\t\tint total = Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(new IndexDiffFilter(INDEX, WORKDIR));\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n+\t\t\tif (dirCacheIterator != null) {\n+\t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n+\t\t\t\t\t\t.getDirCacheEntry();\n+\t\t\t\tif (dirCacheEntry != null && dirCacheEntry.getStage() > 0) {\n+\t\t\t\t\tconflicts.add(treeWalk.getPathString());\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!= dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n-\n-\t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n-\t\t\t\t\t\t.getDirCacheEntry();\n-\t\t\t\tif (dirCacheEntry != null && dirCacheEntry.getStage() > 0) {\n-\t\t\t\t\tconflicts.add(treeWalk.getPathString());\n-\t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor != null)\n \t\t\tmonitor.endTask();\n \n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1a867d10b974cab4d43d77f5b392f4f07807ebd8": {
			"type": "Ybodychange",
			"commitMessage": "Added support to IndexDiff to return information on conflicts\n\nChange-Id: I43c13eb72a44f80135c93525fce0c0280b0e64a2\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
			"commitDate": "2011-04-19, 3:11 PM",
			"commitName": "1a867d10b974cab4d43d77f5b392f4f07807ebd8",
			"commitAuthor": "Bernard Leach",
			"commitDateOld": "2011-03-08, 3:05 PM",
			"commitNameOld": "c7e9f013b716b6c25bffd8f4f83b738c1a1f1cd8",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 41.96,
			"commitsBetweenForRepo": 95,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,92 +1,98 @@\n \tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n \t\t\tint estIndexSize, final String title)\n \t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \n \t\tif (monitor != null) {\n \t\t\t// Get the maximum size of the work tree and index\n \t\t\t// and add some (quite arbitrary)\n \t\t\tif (estIndexSize == 0)\n \t\t\t\testIndexSize = dirCache.getEntryCount();\n \t\t\tint total = Math.max(estIndexSize * 10 / 9,\n \t\t\t\t\testWorkTreeSize * 10 / 9);\n \t\t\tmonitor.beginTask(title, total);\n \t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n \t\t}\n \n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(new IndexDiffFilter(INDEX, WORKDIR));\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!= dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n+\n+\t\t\t\tfinal DirCacheEntry dirCacheEntry = dirCacheIterator\n+\t\t\t\t\t\t.getDirCacheEntry();\n+\t\t\t\tif (dirCacheEntry != null && dirCacheEntry.getStage() > 0) {\n+\t\t\t\t\tconflicts.add(treeWalk.getPathString());\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// consume the remaining work\n \t\tif (monitor != null)\n \t\t\tmonitor.endTask();\n \n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5e2e3819a690b739eba773415899d20db88a452e": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Add progress reporting to IndexDiff\n\nChange-Id: I4f05bdb0c58b039bd379341a6093f06a2cdfec6e\nSigned-off-by: Robin Rosenberg <robin.rosenberg@dewire.com>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>\n",
			"commitDate": "2011-01-20, 4:28 PM",
			"commitName": "5e2e3819a690b739eba773415899d20db88a452e",
			"commitAuthor": "Robin Rosenberg",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Add progress reporting to IndexDiff\n\nChange-Id: I4f05bdb0c58b039bd379341a6093f06a2cdfec6e\nSigned-off-by: Robin Rosenberg <robin.rosenberg@dewire.com>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>\n",
					"commitDate": "2011-01-20, 4:28 PM",
					"commitName": "5e2e3819a690b739eba773415899d20db88a452e",
					"commitAuthor": "Robin Rosenberg",
					"commitDateOld": "2010-12-09, 9:51 AM",
					"commitNameOld": "1783749e169c57cef7131e1749a01ee269b89df8",
					"commitAuthorOld": "Christian Halstrick",
					"daysBetweenCommits": 42.28,
					"commitsBetweenForRepo": 65,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,74 +1,92 @@\n-\tpublic boolean diff() throws IOException {\n+\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n+\t\t\tint estIndexSize, final String title)\n+\t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n+\n+\t\tif (monitor != null) {\n+\t\t\t// Get the maximum size of the work tree and index\n+\t\t\t// and add some (quite arbitrary)\n+\t\t\tif (estIndexSize == 0)\n+\t\t\t\testIndexSize = dirCache.getEntryCount();\n+\t\t\tint total = Math.max(estIndexSize * 10 / 9,\n+\t\t\t\t\testWorkTreeSize * 10 / 9);\n+\t\t\tmonitor.beginTask(title, total);\n+\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n+\t\t}\n+\n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(new IndexDiffFilter(INDEX, WORKDIR));\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!= dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n+\t\t// consume the remaining work\n+\t\tif (monitor != null)\n+\t\t\tmonitor.endTask();\n+\n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[]",
						"newValue": "[monitor-ProgressMonitor(modifiers-final), estWorkTreeSize-int, estIndexSize-int, title-String(modifiers-final)]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Add progress reporting to IndexDiff\n\nChange-Id: I4f05bdb0c58b039bd379341a6093f06a2cdfec6e\nSigned-off-by: Robin Rosenberg <robin.rosenberg@dewire.com>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>\n",
					"commitDate": "2011-01-20, 4:28 PM",
					"commitName": "5e2e3819a690b739eba773415899d20db88a452e",
					"commitAuthor": "Robin Rosenberg",
					"commitDateOld": "2010-12-09, 9:51 AM",
					"commitNameOld": "1783749e169c57cef7131e1749a01ee269b89df8",
					"commitAuthorOld": "Christian Halstrick",
					"daysBetweenCommits": 42.28,
					"commitsBetweenForRepo": 65,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,74 +1,92 @@\n-\tpublic boolean diff() throws IOException {\n+\tpublic boolean diff(final ProgressMonitor monitor, int estWorkTreeSize,\n+\t\t\tint estIndexSize, final String title)\n+\t\t\tthrows IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n+\n+\t\tif (monitor != null) {\n+\t\t\t// Get the maximum size of the work tree and index\n+\t\t\t// and add some (quite arbitrary)\n+\t\t\tif (estIndexSize == 0)\n+\t\t\t\testIndexSize = dirCache.getEntryCount();\n+\t\t\tint total = Math.max(estIndexSize * 10 / 9,\n+\t\t\t\t\testWorkTreeSize * 10 / 9);\n+\t\t\tmonitor.beginTask(title, total);\n+\t\t\tfilters.add(new ProgressReportingFilter(monitor, total));\n+\t\t}\n+\n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(new IndexDiffFilter(INDEX, WORKDIR));\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!= dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n+\t\t// consume the remaining work\n+\t\tif (monitor != null)\n+\t\t\tmonitor.endTask();\n+\n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"1783749e169c57cef7131e1749a01ee269b89df8": {
			"type": "Ybodychange",
			"commitMessage": "Add a performance optimized variant of the ANY_DIFF filter\n\nIf a treewalk walks also over index and the workingtree then the\nIndexDiffFilter filter can be used which works much faster then\nthe semantically equivalent ANY_DIFF filter. This is because this\nfilter can better avoid computing SHA-1 ids over the content of\nworking-tree files which is very costly.\n\nThis fix will significantly improve the performance of e.g.\nEGit's commit dialog.\n\nChange-Id: I2a51816f4ed9df2900c6307a54cd09f50004266f\nSigned-off-by: Christian Halstrick <christian.halstrick@sap.com>\nSigned-off-by: Philipp Thun <philipp.thun@sap.com>\n",
			"commitDate": "2010-12-09, 9:51 AM",
			"commitName": "1783749e169c57cef7131e1749a01ee269b89df8",
			"commitAuthor": "Christian Halstrick",
			"commitDateOld": "2010-12-08, 10:03 AM",
			"commitNameOld": "18abb8195a67a0502a71e2420078dd95563e18c6",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0.99,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,75 +1,74 @@\n \tpublic boolean diff() throws IOException {\n \t\tdirCache = repository.readDirCache();\n \n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n-\t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n-\t\tfilters.add(TreeFilter.ANY_DIFF);\n+\t\tfilters.add(new IndexDiffFilter(INDEX, WORKDIR));\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!= dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n \t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n \t\t\t\t&& untracked.isEmpty())\n \t\t\treturn false;\n \t\telse\n \t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"18abb8195a67a0502a71e2420078dd95563e18c6": {
			"type": "Ybodychange",
			"commitMessage": "IndexDiff: Remove unnecessary changesExist flag\n\nInstead of setting a boolean when a difference record is found, return\nfalse from diff() only if all of the collections are empty.  When all\nof them are empty, no difference was found.\n\nChange-Id: I555fef37adb764ce253481751071c53ad12cf416\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-12-08, 10:03 AM",
			"commitName": "18abb8195a67a0502a71e2420078dd95563e18c6",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-12-08, 10:03 AM",
			"commitNameOld": "a66a7d90fd4c3ec3587d2f314e785ab5bba71b6f",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,76 +1,75 @@\n \tpublic boolean diff() throws IOException {\n-\t\tboolean changesExist = false;\n \t\tdirCache = repository.readDirCache();\n \n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(TreeFilter.ANY_DIFF);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!= dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n-\t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n-\t\t\t\t\tchangesExist = true;\n \t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n-\t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n-\t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n-\t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\tif (workingTreeIterator.isModified(\n \t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n-\t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\treturn changesExist;\n+\n+\t\tif (added.isEmpty() && changed.isEmpty() && removed.isEmpty()\n+\t\t\t\t&& missing.isEmpty() && modified.isEmpty()\n+\t\t\t\t&& untracked.isEmpty())\n+\t\t\treturn false;\n+\t\telse\n+\t\t\treturn true;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a66a7d90fd4c3ec3587d2f314e785ab5bba71b6f": {
			"type": "Ybodychange",
			"commitMessage": "IndexDiff: Use isModified() when comparing index-worktree\n\nThe isModified() is more efficient because it can skip over files that\nare stat clean, without needing to scan them.\n\nThis is useful to efficently work on paths that were already staged\nand thus differ between HEAD and the index, but not between the index\nand the working tree.\n\nChange-Id: I4418202e612f0571974e0898050d987c6c280966\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-12-08, 10:03 AM",
			"commitName": "a66a7d90fd4c3ec3587d2f314e785ab5bba71b6f",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-12-08, 10:03 AM",
			"commitNameOld": "d4bbb2e4497335993f4d24f539111dc5d3f8bbcd",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,75 +1,76 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist = false;\n \t\tdirCache = repository.readDirCache();\n \n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(TreeFilter.ANY_DIFF);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n \t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n \t\t\t\t\t\t\t!= dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n-\t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n+\t\t\t\t\tif (workingTreeIterator.isModified(\n+\t\t\t\t\t\t\tdirCacheIterator.getDirCacheEntry(), true)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d4bbb2e4497335993f4d24f539111dc5d3f8bbcd": {
			"type": "Ybodychange",
			"commitMessage": "IndexDiff: Clean up tree-index compare for staged files\n\nWhen comparing the ObjectIds for two tree entries its faster\nto use the raw buffer compares over allocating ObjectIds and\nthen performing equals on their contents.\n\nHowever, this also needs to consider the raw modes.  It is possible\nfor a path to change modes but not ObjectId (e.g. making a file\nexecutable), and in this case its still a staged change to report back\nto the caller.\n\nChange-Id: I1a267254c04b3273a97f63c71d1e6718cd9d2fa8\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-12-08, 10:03 AM",
			"commitName": "d4bbb2e4497335993f4d24f539111dc5d3f8bbcd",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-12-08, 10:03 AM",
			"commitNameOld": "e6c39227640536ac1c2e41d8970aeca84b3c6268",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,75 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist = false;\n \t\tdirCache = repository.readDirCache();\n \n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(TreeFilter.ANY_DIFF);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n-\t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n-\t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n+\t\t\t\t\tif (!treeIterator.idEqual(dirCacheIterator)\n+\t\t\t\t\t\t\t|| treeIterator.getEntryRawMode()\n+\t\t\t\t\t\t\t!= dirCacheIterator.getEntryRawMode()) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e6c39227640536ac1c2e41d8970aeca84b3c6268": {
			"type": "Ybodychange",
			"commitMessage": "IndexDiff: Fix getAssumeUnchanged()\n\nIf the caller really needs the list of files that are flagged as\nassume-unchanged (aka assume-valid in the DirCache), we should give\nthem the complete list and not just those that we wrongly identified\nas being modified during diff().\n\nThis change is necessary because diff() is slightly broken and is\ndiscovering differences on files that it shouldn't have considered.\n\nChange-Id: Ibe464c1a0e51c19dc287a4bc5348b7b07f4d840b\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-12-08, 10:03 AM",
			"commitName": "e6c39227640536ac1c2e41d8970aeca84b3c6268",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-12-08, 10:03 AM",
			"commitNameOld": "72f87adce69da858164c70c40d9e0ae778aa5257",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,78 +1,74 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist = false;\n-\t\tDirCache dirCache = repository.readDirCache();\n+\t\tdirCache = repository.readDirCache();\n+\n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(TreeFilter.ANY_DIFF);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \n-\t\t\tif (dirCacheIterator != null) {\n-\t\t\t\tif (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n-\t\t\t\t\tassumeUnchanged.add(treeWalk.getPathString());\n-\t\t\t}\n-\n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"48e80698cf7b19422cb7a62a34170cc3c7a3f7a2": {
			"type": "Ybodychange",
			"commitMessage": "IndexDiff: Remove always true not-subtree check\n\nThe TreeWalk is configured to be recursive, which means subtrees are\nnever presented to the application.  Therefore the working tree file\nmode can never be a subtree/subdirectory at this point in the code.\n\nChange-Id: Ie842ddc147957d09205c0d2ce87b25c566862fd9\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-12-08, 10:03 AM",
			"commitName": "48e80698cf7b19422cb7a62a34170cc3c7a3f7a2",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-12-08, 10:03 AM",
			"commitNameOld": "ca9baa0ee2d86edf1c1e29ba3c35ba45fcf32b8c",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,81 +1,78 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist = false;\n \t\tDirCache dirCache = repository.readDirCache();\n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(TreeFilter.ANY_DIFF);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n-\t\t\tFileMode fileModeTree = treeWalk.getFileMode(TREE);\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n \t\t\t\t\tassumeUnchanged.add(treeWalk.getPathString());\n \t\t\t}\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n-\t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n-\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n-\t\t\t\t\t\tchangesExist = true;\n-\t\t\t\t\t\tif (workingTreeIterator != null)\n-\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n-\t\t\t\t\t}\n+\t\t\t\t\tremoved.add(treeWalk.getPathString());\n+\t\t\t\t\tchangesExist = true;\n+\t\t\t\t\tif (workingTreeIterator != null)\n+\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ca9baa0ee2d86edf1c1e29ba3c35ba45fcf32b8c": {
			"type": "Ybodychange",
			"commitMessage": "IndexDiff: Always use TreeWalk.getPathString()\n\nInstead of asking the individual iterators for their path string, use\nthe TreeWalk's generic getPathString() method.  Its just as fast\nbecause it uses the path of the current matching iterator.\n\nChange-Id: I9b827fbbafce1c78f09d5527cdc64fbe9022a16e\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-12-08, 10:03 AM",
			"commitName": "ca9baa0ee2d86edf1c1e29ba3c35ba45fcf32b8c",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-12-08, 10:03 AM",
			"commitNameOld": "f4e9c8890cc625ba57b5a3cd078ca14cbcc86f8b",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,82 +1,81 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist = false;\n \t\tDirCache dirCache = repository.readDirCache();\n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(TreeFilter.ANY_DIFF);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \t\t\tFileMode fileModeTree = treeWalk.getFileMode(TREE);\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n-\t\t\t\t\tassumeUnchanged.add(dirCacheIterator.getEntryPathString());\n+\t\t\t\t\tassumeUnchanged.add(treeWalk.getPathString());\n \t\t\t}\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n-\t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n+\t\t\t\t\t\tchanged.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n-\t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n+\t\t\t\t\t\tremoved.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t\tif (workingTreeIterator != null)\n-\t\t\t\t\t\t\tuntracked.add(workingTreeIterator\n-\t\t\t\t\t\t\t\t\t.getEntryPathString());\n+\t\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n-\t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n+\t\t\t\t\tadded.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n-\t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n+\t\t\t\t\t\tuntracked.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n-\t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n+\t\t\t\t\tmissing.add(treeWalk.getPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n-\t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n+\t\t\t\t\t\tmodified.add(treeWalk.getPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f4e9c8890cc625ba57b5a3cd078ca14cbcc86f8b": {
			"type": "Ybodychange",
			"commitMessage": "IndexDiff: Simplify allocation of filter list\n\nWe add either 3 or 4 filters.  If we are adding only 3 filters,\nallocating the array for 4 isn't a huge waste of memory, but it\ndoes simplify our code.\n\nChange-Id: I7df29b414f6d5cfcf533edb1405083e6fcec32cf\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-12-08, 10:03 AM",
			"commitName": "f4e9c8890cc625ba57b5a3cd078ca14cbcc86f8b",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-12-07, 4:49 PM",
			"commitNameOld": "a02be9725c9f83f0a0280a9a1f00e8d484825885",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0.72,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,83 +1,82 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist = false;\n \t\tDirCache dirCache = repository.readDirCache();\n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n-\t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(\n-\t\t\t\tfilter == null ? 3 : 4);\n+\t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(4);\n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(TreeFilter.ANY_DIFF);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \t\t\tFileMode fileModeTree = treeWalk.getFileMode(TREE);\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n \t\t\t\t\tassumeUnchanged.add(dirCacheIterator.getEntryPathString());\n \t\t\t}\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n \t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\t\tuntracked.add(workingTreeIterator\n \t\t\t\t\t\t\t\t\t.getEntryPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a02be9725c9f83f0a0280a9a1f00e8d484825885": {
			"type": "Ybodychange",
			"commitMessage": "Remove empty iterator from TreeWalk\n\nIts confusing that a new TreeWalk() needs to have reset() invoked\non it before addTree().  This is a historical accident caused by\nhow TreeWalk was abused within ObjectWalk.\n\nDrop the initial empty tree from the TreeWalk and thus remove a\nnumber of pointless reset() operations from unit tests and some of\nthe internal JGit code.\n\nExisting application code which is still calling reset() will simply\nbe incurring a few unnecessary field assignments, but they should\nconsider cleaning up their code in the future.\n\nChange-Id: I434e94ffa43491019e7dff52ca420a4d2245f48b\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-12-07, 4:49 PM",
			"commitName": "a02be9725c9f83f0a0280a9a1f00e8d484825885",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-11-30, 10:51 AM",
			"commitNameOld": "b4359cb8294de1e80147f00caabad9ebd6b7bce1",
			"commitAuthorOld": "Stefan Lay",
			"daysBetweenCommits": 7.25,
			"commitsBetweenForRepo": 27,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,84 +1,83 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist = false;\n \t\tDirCache dirCache = repository.readDirCache();\n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n-\t\ttreeWalk.reset();\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(\n \t\t\t\tfilter == null ? 3 : 4);\n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(TreeFilter.ANY_DIFF);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \t\t\tFileMode fileModeTree = treeWalk.getFileMode(TREE);\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n \t\t\t\t\tassumeUnchanged.add(dirCacheIterator.getEntryPathString());\n \t\t\t}\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n \t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\t\tuntracked.add(workingTreeIterator\n \t\t\t\t\t\t\t\t\t.getEntryPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b4359cb8294de1e80147f00caabad9ebd6b7bce1": {
			"type": "Ybodychange",
			"commitMessage": "Include list of assume unchanged files in IndexDiff\n\nThe IndexDiff had not collected the info if the flag\n\"assume-unchanged\" is set. This information is useful for clients\nwhich may want to decide if specific actions are allowed on a file.\n\nBug: 326213\nChange-Id: I14bb7b03247d6c0b429a9d8d3f6b10f21d8ddeb1\nSigned-off-by: Stefan Lay <stefan.lay@sap.com>\n",
			"commitDate": "2010-11-30, 10:51 AM",
			"commitName": "b4359cb8294de1e80147f00caabad9ebd6b7bce1",
			"commitAuthor": "Stefan Lay",
			"commitDateOld": "2010-11-30, 2:05 AM",
			"commitNameOld": "7bf0f5070e977d716fbce9309266bb7c26be0a74",
			"commitAuthorOld": "Stefan Lay",
			"daysBetweenCommits": 0.37,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,79 +1,84 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist = false;\n \t\tDirCache dirCache = repository.readDirCache();\n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.reset();\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(\n \t\t\t\tfilter == null ? 3 : 4);\n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(TreeFilter.ANY_DIFF);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \t\t\tFileMode fileModeTree = treeWalk.getFileMode(TREE);\n \n+\t\t\tif (dirCacheIterator != null) {\n+\t\t\t\tif (dirCacheIterator.getDirCacheEntry().isAssumeValid())\n+\t\t\t\t\tassumeUnchanged.add(dirCacheIterator.getEntryPathString());\n+\t\t\t}\n+\n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n \t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t\tif (workingTreeIterator != null)\n \t\t\t\t\t\t\tuntracked.add(workingTreeIterator\n \t\t\t\t\t\t\t\t\t.getEntryPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2dc2dd8b1b4c98b255b3f2dec655a3f0b197ce07": {
			"type": "Ybodychange",
			"commitMessage": "IndexDiff: support state [removed, untracked]\n\nIndexDiff was extended to detect files which are both removed from the\nindex and untracked.  Before this change these files were only added\nto the removed collection.\n\nChange-Id: I971d8261d2e8932039fce462b59c12e143f79f90\nSigned-off-by: Jens Baumgart <jens.baumgart@sap.com>\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-11-08, 3:32 PM",
			"commitName": "2dc2dd8b1b4c98b255b3f2dec655a3f0b197ce07",
			"commitAuthor": "Jens Baumgart",
			"commitDateOld": "2010-10-25, 4:00 AM",
			"commitNameOld": "6f3b089188ef4937ab4e9970b0987b061000831e",
			"commitAuthorOld": "Jens Baumgart",
			"daysBetweenCommits": 14.52,
			"commitsBetweenForRepo": 33,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,76 +1,79 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist = false;\n \t\tDirCache dirCache = repository.readDirCache();\n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.reset();\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(\n \t\t\t\tfilter == null ? 3 : 4);\n \t\tif (filter != null)\n \t\t\tfilters.add(filter);\n \t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n \t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n \t\tfilters.add(TreeFilter.ANY_DIFF);\n \t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \t\t\tFileMode fileModeTree = treeWalk.getFileMode(TREE);\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n \t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n+\t\t\t\t\t\tif (workingTreeIterator != null)\n+\t\t\t\t\t\t\tuntracked.add(workingTreeIterator\n+\t\t\t\t\t\t\t\t\t.getEntryPathString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6f3b089188ef4937ab4e9970b0987b061000831e": {
			"type": "Ybodychange",
			"commitMessage": "Allow setting a filter in IndexDiff\n\nIndexDiff now allows to set an additional filter. This can be used\ne.g. for restricting the tree walk to a given set of files.\n\nChange-Id: I642de17e74b997fa0c5878c90631f6640ed70bdd\nSigned-off-by: Jens Baumgart <jens.baumgart@sap.com>\n",
			"commitDate": "2010-10-25, 4:00 AM",
			"commitName": "6f3b089188ef4937ab4e9970b0987b061000831e",
			"commitAuthor": "Jens Baumgart",
			"commitDateOld": "2010-09-01, 3:19 PM",
			"commitNameOld": "ea4ff61ad3de3f5742905c7a92e99cf041d19596",
			"commitAuthorOld": "Marc Strapetz",
			"daysBetweenCommits": 53.53,
			"commitsBetweenForRepo": 112,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,72 +1,76 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist = false;\n \t\tDirCache dirCache = repository.readDirCache();\n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.reset();\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n-\t\ttreeWalk.setFilter(TreeFilter.ANY_DIFF);\n-\t\ttreeWalk.setFilter(AndTreeFilter.create(new TreeFilter[] {\n-\t\t\t\tnew NotIgnoredFilter(WORKDIR), new SkipWorkTreeFilter(INDEX),\n-\t\t\t\tTreeFilter.ANY_DIFF }));\n+\t\tCollection<TreeFilter> filters = new ArrayList<TreeFilter>(\n+\t\t\t\tfilter == null ? 3 : 4);\n+\t\tif (filter != null)\n+\t\t\tfilters.add(filter);\n+\t\tfilters.add(new NotIgnoredFilter(WORKDIR));\n+\t\tfilters.add(new SkipWorkTreeFilter(INDEX));\n+\t\tfilters.add(TreeFilter.ANY_DIFF);\n+\t\ttreeWalk.setFilter(AndTreeFilter.create(filters));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \t\t\tFileMode fileModeTree = treeWalk.getFileMode(TREE);\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n \t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ea4ff61ad3de3f5742905c7a92e99cf041d19596": {
			"type": "Ybodychange",
			"commitMessage": "IndexDiff honors Index entries' \"skipWorkTree\" flag.\n\nChange-Id: I428d11412130b64fc46d7052011f5dff3d653802\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-09-01, 3:19 PM",
			"commitName": "ea4ff61ad3de3f5742905c7a92e99cf041d19596",
			"commitAuthor": "Marc Strapetz",
			"commitDateOld": "2010-08-12, 9:43 AM",
			"commitNameOld": "cd1141cd45e8148c2d3fc5553ae19c9fee3fc4a6",
			"commitAuthorOld": "Jens Baumgart",
			"daysBetweenCommits": 20.23,
			"commitsBetweenForRepo": 92,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,71 +1,72 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist = false;\n \t\tDirCache dirCache = repository.readDirCache();\n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.reset();\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\ttreeWalk.setFilter(TreeFilter.ANY_DIFF);\n-\t\ttreeWalk.setFilter(AndTreeFilter.create(TreeFilter.ANY_DIFF,\n-\t\t\t\tnew NotIgnoredFilter(WORKDIR)));\n+\t\ttreeWalk.setFilter(AndTreeFilter.create(new TreeFilter[] {\n+\t\t\t\tnew NotIgnoredFilter(WORKDIR), new SkipWorkTreeFilter(INDEX),\n+\t\t\t\tTreeFilter.ANY_DIFF }));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \t\t\tFileMode fileModeTree = treeWalk.getFileMode(TREE);\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n \t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cd1141cd45e8148c2d3fc5553ae19c9fee3fc4a6": {
			"type": "Ybodychange",
			"commitMessage": "Improve IndexDiff performance\n\nExclude ignored files from IndexDiff tree walk.\nThis makes EGit commit much faster.\n\nChange-Id: I398499510c22c37667b7612db32eac3b31d325f0\nSigned-off-by: Jens Baumgart <jens.baumgart@sap.com>\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
			"commitDate": "2010-08-12, 9:43 AM",
			"commitName": "cd1141cd45e8148c2d3fc5553ae19c9fee3fc4a6",
			"commitAuthor": "Jens Baumgart",
			"commitDateOld": "2010-08-09, 2:14 AM",
			"commitNameOld": "9a6a433576c8b1cedb5f3aff9cfecb8217881ddf",
			"commitAuthorOld": "Jens Baumgart",
			"daysBetweenCommits": 3.31,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,69 +1,71 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist = false;\n \t\tDirCache dirCache = repository.readDirCache();\n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.reset();\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n \t\tif (tree != null)\n \t\t\ttreeWalk.addTree(tree);\n \t\telse\n \t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\ttreeWalk.setFilter(TreeFilter.ANY_DIFF);\n+\t\ttreeWalk.setFilter(AndTreeFilter.create(TreeFilter.ANY_DIFF,\n+\t\t\t\tnew NotIgnoredFilter(WORKDIR)));\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \t\t\tFileMode fileModeTree = treeWalk.getFileMode(TREE);\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n \t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9a6a433576c8b1cedb5f3aff9cfecb8217881ddf": {
			"type": "Ybodychange",
			"commitMessage": "Fix NPE on commit in empty Repository\n\nNPE occured when committing in an empty repository.\n\nBug: 321858\nChange-Id: Ibddb056c32c14c1444785501c43b95fdf64884b1\nSigned-off-by: Jens Baumgart <jens.baumgart@sap.com>\n",
			"commitDate": "2010-08-09, 2:14 AM",
			"commitName": "9a6a433576c8b1cedb5f3aff9cfecb8217881ddf",
			"commitAuthor": "Jens Baumgart",
			"commitDateOld": "2010-08-04, 8:03 AM",
			"commitNameOld": "3ba1c7c0681642da30fce234b4a4f405852adfdd",
			"commitAuthorOld": "Jens Baumgart",
			"daysBetweenCommits": 4.76,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,66 +1,69 @@\n \tpublic boolean diff() throws IOException {\n \t\tboolean changesExist = false;\n \t\tDirCache dirCache = repository.readDirCache();\n \t\tTreeWalk treeWalk = new TreeWalk(repository);\n \t\ttreeWalk.reset();\n \t\ttreeWalk.setRecursive(true);\n \t\t// add the trees (tree, dirchache, workdir)\n-\t\ttreeWalk.addTree(tree);\n+\t\tif (tree != null)\n+\t\t\ttreeWalk.addTree(tree);\n+\t\telse\n+\t\t\ttreeWalk.addTree(new EmptyTreeIterator());\n \t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n \t\ttreeWalk.addTree(initialWorkingTreeIterator);\n \t\ttreeWalk.setFilter(TreeFilter.ANY_DIFF);\n \t\twhile (treeWalk.next()) {\n \t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n \t\t\t\t\tAbstractTreeIterator.class);\n \t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n \t\t\t\t\tDirCacheIterator.class);\n \t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n \t\t\t\t\tWorkingTreeIterator.class);\n \t\t\tFileMode fileModeTree = treeWalk.getFileMode(TREE);\n \n \t\t\tif (treeIterator != null) {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n \t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n \t\t\t\t\t\t// in repo, in index, content diff => changed\n \t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// in repo, not in index => removed\n \t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n \t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (dirCacheIterator != null) {\n \t\t\t\t\t// not in repo, in index => added\n \t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\t// not in repo, not in index => untracked\n \t\t\t\t\tif (workingTreeIterator != null\n \t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n \t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (dirCacheIterator != null) {\n \t\t\t\tif (workingTreeIterator == null) {\n \t\t\t\t\t// in index, not in workdir => missing\n \t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\tchangesExist = true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n \t\t\t\t\t\t// in index, in workdir, content differs => modified\n \t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n \t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3ba1c7c0681642da30fce234b4a4f405852adfdd": {
			"type": "Ybodychange",
			"commitMessage": "Add gitignore support to IndexDiff and use TreeWalk\n\nIndexDiff was re-implemented and now uses TreeWalk instead\nof GitIndex. Additionally, gitignore support and retrieval of\nuntracked files was added.\n\nChange-Id: Ie6a8e04833c61d44c668c906b161202b200bb509\nSigned-off-by: Jens Baumgart <jens.baumgart@sap.com>\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
			"commitDate": "2010-08-04, 8:03 AM",
			"commitName": "3ba1c7c0681642da30fce234b4a4f405852adfdd",
			"commitAuthor": "Jens Baumgart",
			"commitDateOld": "2010-07-22, 2:56 PM",
			"commitNameOld": "fa9b225e06f16ca7fd7ffca5689f4af0942a73e1",
			"commitAuthorOld": "",
			"daysBetweenCommits": 12.71,
			"commitsBetweenForRepo": 17,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,34 +1,66 @@\n \tpublic boolean diff() throws IOException {\n-\t\tfinal File root = index.getRepository().getWorkTree();\n-\t\tnew IndexTreeWalker(index, tree, root, new AbstractIndexTreeVisitor() {\n-\t\t\tpublic void visitEntry(TreeEntry treeEntry, Entry indexEntry, File file) {\n-\t\t\t\tif (treeEntry == null) {\n-\t\t\t\t\tadded.add(indexEntry.getName());\n-\t\t\t\t\tanyChanges = true;\n-\t\t\t\t} else if (indexEntry == null) {\n-\t\t\t\t\tif (!(treeEntry instanceof Tree))\n-\t\t\t\t\t\tremoved.add(treeEntry.getFullName());\n-\t\t\t\t\tanyChanges = true;\n+\t\tboolean changesExist = false;\n+\t\tDirCache dirCache = repository.readDirCache();\n+\t\tTreeWalk treeWalk = new TreeWalk(repository);\n+\t\ttreeWalk.reset();\n+\t\ttreeWalk.setRecursive(true);\n+\t\t// add the trees (tree, dirchache, workdir)\n+\t\ttreeWalk.addTree(tree);\n+\t\ttreeWalk.addTree(new DirCacheIterator(dirCache));\n+\t\ttreeWalk.addTree(initialWorkingTreeIterator);\n+\t\ttreeWalk.setFilter(TreeFilter.ANY_DIFF);\n+\t\twhile (treeWalk.next()) {\n+\t\t\tAbstractTreeIterator treeIterator = treeWalk.getTree(TREE,\n+\t\t\t\t\tAbstractTreeIterator.class);\n+\t\t\tDirCacheIterator dirCacheIterator = treeWalk.getTree(INDEX,\n+\t\t\t\t\tDirCacheIterator.class);\n+\t\t\tWorkingTreeIterator workingTreeIterator = treeWalk.getTree(WORKDIR,\n+\t\t\t\t\tWorkingTreeIterator.class);\n+\t\t\tFileMode fileModeTree = treeWalk.getFileMode(TREE);\n+\n+\t\t\tif (treeIterator != null) {\n+\t\t\t\tif (dirCacheIterator != null) {\n+\t\t\t\t\tif (!treeIterator.getEntryObjectId().equals(\n+\t\t\t\t\t\t\tdirCacheIterator.getEntryObjectId())) {\n+\t\t\t\t\t\t// in repo, in index, content diff => changed\n+\t\t\t\t\t\tchanged.add(dirCacheIterator.getEntryPathString());\n+\t\t\t\t\t\tchangesExist = true;\n+\t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\tif (!treeEntry.getId().equals(indexEntry.getObjectId())) {\n-\t\t\t\t\t\tchanged.add(indexEntry.getName());\n-\t\t\t\t\t\tanyChanges = true;\n+\t\t\t\t\t// in repo, not in index => removed\n+\t\t\t\t\tif (!fileModeTree.equals(FileMode.TYPE_TREE)) {\n+\t\t\t\t\t\tremoved.add(treeIterator.getEntryPathString());\n+\t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n-\n-\t\t\t\tif (indexEntry != null) {\n-\t\t\t\t\tif (!file.exists()) {\n-\t\t\t\t\t\tmissing.add(indexEntry.getName());\n-\t\t\t\t\t\tanyChanges = true;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif (indexEntry.isModified(root, true)) {\n-\t\t\t\t\t\t\tmodified.add(indexEntry.getName());\n-\t\t\t\t\t\t\tanyChanges = true;\n-\t\t\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif (dirCacheIterator != null) {\n+\t\t\t\t\t// not in repo, in index => added\n+\t\t\t\t\tadded.add(dirCacheIterator.getEntryPathString());\n+\t\t\t\t\tchangesExist = true;\n+\t\t\t\t} else {\n+\t\t\t\t\t// not in repo, not in index => untracked\n+\t\t\t\t\tif (workingTreeIterator != null\n+\t\t\t\t\t\t\t&& !workingTreeIterator.isEntryIgnored()) {\n+\t\t\t\t\t\tuntracked.add(workingTreeIterator.getEntryPathString());\n+\t\t\t\t\t\tchangesExist = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t}).walk();\n \n-\t\treturn anyChanges;\n+\t\t\tif (dirCacheIterator != null) {\n+\t\t\t\tif (workingTreeIterator == null) {\n+\t\t\t\t\t// in index, not in workdir => missing\n+\t\t\t\t\tmissing.add(dirCacheIterator.getEntryPathString());\n+\t\t\t\t\tchangesExist = true;\n+\t\t\t\t} else {\n+\t\t\t\t\tif (!dirCacheIterator.idEqual(workingTreeIterator)) {\n+\t\t\t\t\t\t// in index, in workdir, content differs => modified\n+\t\t\t\t\t\tmodified.add(dirCacheIterator.getEntryPathString());\n+\t\t\t\t\t\tchangesExist = true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn changesExist;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"203bd6626767015dfb04d421c572b26a34e9cecf": {
			"type": "Ybodychange",
			"commitMessage": "Rename Repository getWorkDir to getWorkTree\n\nThis better matches with the name used in the environment\n(GIT_WORK_TREE), in the configuration file (core.worktree),\nand in our builder object.\n\nSince we are already breaking a good chunk of other code\nrelated to repository access, and this fairly easy to fix\nin an application's code base, I'm not going to offer the\nwrapper getWorkDir() method.\n\nChange-Id: Ib698ba4bbc213c48114f342378cecfe377e37bb7\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-06-25, 6:03 PM",
			"commitName": "203bd6626767015dfb04d421c572b26a34e9cecf",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2009-10-31, 2:48 PM",
			"commitNameOld": "4d91645e890527efbe04ffaee12b4aa3637733c4",
			"commitAuthorOld": "Alex Blewitt",
			"daysBetweenCommits": 237.14,
			"commitsBetweenForRepo": 269,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,34 +1,34 @@\n \tpublic boolean diff() throws IOException {\n-\t\tfinal File root = index.getRepository().getWorkDir();\n+\t\tfinal File root = index.getRepository().getWorkTree();\n \t\tnew IndexTreeWalker(index, tree, root, new AbstractIndexTreeVisitor() {\n \t\t\tpublic void visitEntry(TreeEntry treeEntry, Entry indexEntry, File file) {\n \t\t\t\tif (treeEntry == null) {\n \t\t\t\t\tadded.add(indexEntry.getName());\n \t\t\t\t\tanyChanges = true;\n \t\t\t\t} else if (indexEntry == null) {\n \t\t\t\t\tif (!(treeEntry instanceof Tree))\n \t\t\t\t\t\tremoved.add(treeEntry.getFullName());\n \t\t\t\t\tanyChanges = true;\n \t\t\t\t} else {\n \t\t\t\t\tif (!treeEntry.getId().equals(indexEntry.getObjectId())) {\n \t\t\t\t\t\tchanged.add(indexEntry.getName());\n \t\t\t\t\t\tanyChanges = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (indexEntry != null) {\n \t\t\t\t\tif (!file.exists()) {\n \t\t\t\t\t\tmissing.add(indexEntry.getName());\n \t\t\t\t\t\tanyChanges = true;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tif (indexEntry.isModified(root, true)) {\n \t\t\t\t\t\t\tmodified.add(indexEntry.getName());\n \t\t\t\t\t\t\tanyChanges = true;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}).walk();\n \n \t\treturn anyChanges;\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1a6964c8274c50f0253db75f010d78ef0e739343": {
			"type": "Yintroduced",
			"commitMessage": "Initial JGit contribution to eclipse.org\n\nPer CQ 3448 this is the initial contribution of the JGit project\nto eclipse.org.  It is derived from the historical JGit repository\nat commit 3a2dd9921c8a08740a9e02c421469e5b1a9e47cb.\n\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2009-09-29, 4:47 PM",
			"commitName": "1a6964c8274c50f0253db75f010d78ef0e739343",
			"commitAuthor": "Git Development Community",
			"diff": "@@ -0,0 +1,34 @@\n+\tpublic boolean diff() throws IOException {\n+\t\tfinal File root = index.getRepository().getWorkDir();\n+\t\tnew IndexTreeWalker(index, tree, root, new AbstractIndexTreeVisitor() {\n+\t\t\tpublic void visitEntry(TreeEntry treeEntry, Entry indexEntry, File file) {\n+\t\t\t\tif (treeEntry == null) {\n+\t\t\t\t\tadded.add(indexEntry.getName());\n+\t\t\t\t\tanyChanges = true;\n+\t\t\t\t} else if (indexEntry == null) {\n+\t\t\t\t\tif (!(treeEntry instanceof Tree))\n+\t\t\t\t\t\tremoved.add(treeEntry.getFullName());\n+\t\t\t\t\tanyChanges = true;\n+\t\t\t\t} else {\n+\t\t\t\t\tif (!treeEntry.getId().equals(indexEntry.getObjectId())) {\n+\t\t\t\t\t\tchanged.add(indexEntry.getName());\n+\t\t\t\t\t\tanyChanges = true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t\tif (indexEntry != null) {\n+\t\t\t\t\tif (!file.exists()) {\n+\t\t\t\t\t\tmissing.add(indexEntry.getName());\n+\t\t\t\t\t\tanyChanges = true;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (indexEntry.isModified(root, true)) {\n+\t\t\t\t\t\t\tmodified.add(indexEntry.getName());\n+\t\t\t\t\t\t\tanyChanges = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}).walk();\n+\t\t\n+\t\treturn anyChanges;\n+\t}\n\\ No newline at end of file\n"
		}
	},
	"sha": "bd1a82502680b5de5bf86f6c4470185fd1602386"
}