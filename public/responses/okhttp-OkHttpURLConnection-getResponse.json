{
	"repo": "https://github.com/square/okhttp.git",
	"file": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java",
	"method": {
		"longName": "OkHttpURLConnection::getResponse(boolean networkResponseOnError)",
		"startLine": 443,
		"methodName": "getResponse",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "private"
	},
	"history": {
		"aac684aeae32ff18e443799a3ccff6de9d68a684": {
			"type": "Ybodychange",
			"commitMessage": "Retain interrupted state when throwing InterruptedIOException\n\nThe drawbacks seem small; the callsite needs to handle interruption anyway\nbecause the thread is prone to interruption.\n\nAnd the upside is that a single interrupt should now be sufficient to break\nout an in-flight OkHttp call.\n\nNote that although we're fixing this, thread interruption is not well tested\nin OkHttp. Most users should prefer Call.cancel(), which is well tested and\ndoesn't rely on the caller to know which threads OkHttp is using to make\nthe actual HTTP request.\n\nCloses: https://github.com/square/okhttp/issues/3945\n",
			"commitDate": "2018-07-05, 8:37 PM",
			"commitName": "aac684aeae32ff18e443799a3ccff6de9d68a684",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2018-02-18, 4:57 AM",
			"commitNameOld": "2db8c41b3b0f0476c0e8735f4d57562d50f32ffa",
			"commitAuthorOld": "Eric Cochran",
			"daysBetweenCommits": 137.61,
			"commitsBetweenForRepo": 65,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,41 +1,42 @@\n   private Response getResponse(boolean networkResponseOnError) throws IOException {\n     synchronized (lock) {\n       if (response != null) return response;\n       if (callFailure != null) {\n         if (networkResponseOnError && networkResponse != null) return networkResponse;\n         throw propagate(callFailure);\n       }\n     }\n \n     Call call = buildCall();\n     networkInterceptor.proceed();\n \n     OutputStreamRequestBody requestBody = (OutputStreamRequestBody) call.request().body();\n     if (requestBody != null) requestBody.outputStream().close();\n \n     if (executed) {\n       synchronized (lock) {\n         try {\n           while (response == null && callFailure == null) {\n             lock.wait(); // Wait until the response is returned or the call fails.\n           }\n         } catch (InterruptedException e) {\n+          Thread.currentThread().interrupt(); // Retain interrupted status.\n           throw new InterruptedIOException();\n         }\n       }\n     } else {\n       executed = true;\n       try {\n         onResponse(call, call.execute());\n       } catch (IOException e) {\n         onFailure(call, e);\n       }\n     }\n \n     synchronized (lock) {\n       if (callFailure != null) throw propagate(callFailure);\n       if (response != null) return response;\n     }\n \n     throw new AssertionError();\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2b8ad31b084af93ad202a1b835e5be63ac58a269": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Fix flakiness in authenticateWithChunkedStreaming().\n\nWe were prefering to return the networkResponse before the request\nhad completely failed. Instead we should return the network response\nonly on failure, and only for APIs that return failed responses.\n",
			"commitDate": "2016-11-21, 7:58 PM",
			"commitName": "2b8ad31b084af93ad202a1b835e5be63ac58a269",
			"commitAuthor": "jwilson",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Fix flakiness in authenticateWithChunkedStreaming().\n\nWe were prefering to return the networkResponse before the request\nhad completely failed. Instead we should return the network response\nonly on failure, and only for APIs that return failed responses.\n",
					"commitDate": "2016-11-21, 7:58 PM",
					"commitName": "2b8ad31b084af93ad202a1b835e5be63ac58a269",
					"commitAuthor": "jwilson",
					"commitDateOld": "2016-07-24, 5:07 PM",
					"commitNameOld": "591d59556153555c9f5b56bf601780a817defc09",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 120.16,
					"commitsBetweenForRepo": 68,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,41 +1,41 @@\n-  private Response getResponse() throws IOException {\n-    if (response != null) {\n-      return response;\n-    } else if (networkResponse != null) {\n-      return networkResponse;\n-    } else if (callFailure != null) {\n-      throw propagate(callFailure);\n+  private Response getResponse(boolean networkResponseOnError) throws IOException {\n+    synchronized (lock) {\n+      if (response != null) return response;\n+      if (callFailure != null) {\n+        if (networkResponseOnError && networkResponse != null) return networkResponse;\n+        throw propagate(callFailure);\n+      }\n     }\n \n     Call call = buildCall();\n     networkInterceptor.proceed();\n \n     OutputStreamRequestBody requestBody = (OutputStreamRequestBody) call.request().body();\n     if (requestBody != null) requestBody.outputStream().close();\n \n     if (executed) {\n       synchronized (lock) {\n         try {\n           while (response == null && callFailure == null) {\n             lock.wait(); // Wait until the response is returned or the call fails.\n           }\n         } catch (InterruptedException e) {\n           throw new InterruptedIOException();\n         }\n       }\n     } else {\n       executed = true;\n       try {\n         onResponse(call, call.execute());\n       } catch (IOException e) {\n         onFailure(call, e);\n       }\n     }\n \n     synchronized (lock) {\n       if (callFailure != null) throw propagate(callFailure);\n       if (response != null) return response;\n     }\n \n     throw new AssertionError();\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[]",
						"newValue": "[networkResponseOnError-boolean]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Fix flakiness in authenticateWithChunkedStreaming().\n\nWe were prefering to return the networkResponse before the request\nhad completely failed. Instead we should return the network response\nonly on failure, and only for APIs that return failed responses.\n",
					"commitDate": "2016-11-21, 7:58 PM",
					"commitName": "2b8ad31b084af93ad202a1b835e5be63ac58a269",
					"commitAuthor": "jwilson",
					"commitDateOld": "2016-07-24, 5:07 PM",
					"commitNameOld": "591d59556153555c9f5b56bf601780a817defc09",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 120.16,
					"commitsBetweenForRepo": 68,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,41 +1,41 @@\n-  private Response getResponse() throws IOException {\n-    if (response != null) {\n-      return response;\n-    } else if (networkResponse != null) {\n-      return networkResponse;\n-    } else if (callFailure != null) {\n-      throw propagate(callFailure);\n+  private Response getResponse(boolean networkResponseOnError) throws IOException {\n+    synchronized (lock) {\n+      if (response != null) return response;\n+      if (callFailure != null) {\n+        if (networkResponseOnError && networkResponse != null) return networkResponse;\n+        throw propagate(callFailure);\n+      }\n     }\n \n     Call call = buildCall();\n     networkInterceptor.proceed();\n \n     OutputStreamRequestBody requestBody = (OutputStreamRequestBody) call.request().body();\n     if (requestBody != null) requestBody.outputStream().close();\n \n     if (executed) {\n       synchronized (lock) {\n         try {\n           while (response == null && callFailure == null) {\n             lock.wait(); // Wait until the response is returned or the call fails.\n           }\n         } catch (InterruptedException e) {\n           throw new InterruptedIOException();\n         }\n       }\n     } else {\n       executed = true;\n       try {\n         onResponse(call, call.execute());\n       } catch (IOException e) {\n         onFailure(call, e);\n       }\n     }\n \n     synchronized (lock) {\n       if (callFailure != null) throw propagate(callFailure);\n       if (response != null) return response;\n     }\n \n     throw new AssertionError();\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"2843933b4b4778451d1d43822db1a148bf2aa7ea": {
			"type": "Ybodychange",
			"commitMessage": "Fix OkHttpURLConnection to not swallow unexpected exceptions.\n\nPreviously we would sometimes delegate to the asynchronous implementation,\nand that would prevent exceptions from reaching their destination.\n",
			"commitDate": "2016-06-25, 4:04 PM",
			"commitName": "2843933b4b4778451d1d43822db1a148bf2aa7ea",
			"commitAuthor": "jwilson",
			"commitDateOld": "2016-06-25, 1:46 PM",
			"commitNameOld": "ec39c462324c0a54e6abf06cbf8079298056b7d5",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 0.1,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,41 +1,41 @@\n   private Response getResponse() throws IOException {\n     if (response != null) {\n       return response;\n     } else if (networkResponse != null) {\n       return networkResponse;\n     } else if (callFailure != null) {\n-      throw callFailure;\n+      throw propagate(callFailure);\n     }\n \n     Call call = buildCall();\n     networkInterceptor.proceed();\n \n     OutputStreamRequestBody requestBody = (OutputStreamRequestBody) call.request().body();\n     if (requestBody != null) requestBody.outputStream().close();\n \n     if (executed) {\n       synchronized (lock) {\n         try {\n           while (response == null && callFailure == null) {\n             lock.wait(); // Wait until the response is returned or the call fails.\n           }\n         } catch (InterruptedException e) {\n           throw new InterruptedIOException();\n         }\n       }\n     } else {\n       executed = true;\n       try {\n         onResponse(call, call.execute());\n       } catch (IOException e) {\n         onFailure(call, e);\n       }\n     }\n \n     synchronized (lock) {\n-      if (callFailure != null) throw callFailure;\n+      if (callFailure != null) throw propagate(callFailure);\n       if (response != null) return response;\n     }\n \n     throw new AssertionError();\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ec39c462324c0a54e6abf06cbf8079298056b7d5": {
			"type": "Yfilerename",
			"commitMessage": "Rename HttpURLConnectionImpl to OkHttpURLConnection.\n\nThis is an internal class so nobody should see the name. But having a\ncompletely different name will make it much easier to diagnose future\nstacktraces because the internal implementation has changed so much\nrecently.\n\nAlso share fewer internal details with the rest of OkHttp. In particular\nremove the OkHttp-Selected-Protocol and OkHttp-Response-Source headers\nfrom the core.\n",
			"commitDate": "2016-06-25, 1:46 PM",
			"commitName": "ec39c462324c0a54e6abf06cbf8079298056b7d5",
			"commitAuthor": "jwilson",
			"commitDateOld": "2016-06-25, 11:57 AM",
			"commitNameOld": "3f282e8bf0b8af519cbf35833fdcf69d824661fc",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 0.08,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java",
				"newPath": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java"
			}
		},
		"084b06b48bae2b566bb1be3415b6c847d8ea3682": {
			"type": "Ymultichange(Yreturntypechange,Ybodychange)",
			"commitMessage": "Reimplement HttpURLConnection on the native OkHttp API.\n",
			"commitDate": "2016-06-21, 12:30 PM",
			"commitName": "084b06b48bae2b566bb1be3415b6c847d8ea3682",
			"commitAuthor": "jwilson",
			"subchanges": [
				{
					"type": "Yreturntypechange",
					"commitMessage": "Reimplement HttpURLConnection on the native OkHttp API.\n",
					"commitDate": "2016-06-21, 12:30 PM",
					"commitName": "084b06b48bae2b566bb1be3415b6c847d8ea3682",
					"commitAuthor": "jwilson",
					"commitDateOld": "2016-05-07, 7:08 PM",
					"commitNameOld": "4f24a30c12032b7033884a630696014afd3e77cb",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 44.72,
					"commitsBetweenForRepo": 27,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,50 +1,41 @@\n-  private HttpEngine getResponse() throws IOException {\n-    initHttpEngine();\n-\n-    if (httpEngine.hasResponse()) {\n-      return httpEngine;\n+  private Response getResponse() throws IOException {\n+    if (response != null) {\n+      return response;\n+    } else if (networkResponse != null) {\n+      return networkResponse;\n+    } else if (callFailure != null) {\n+      throw callFailure;\n     }\n \n-    while (true) {\n-      if (!execute(true)) {\n-        continue;\n+    Call call = buildCall();\n+    networkInterceptor.proceed();\n+\n+    OutputStreamRequestBody requestBody = (OutputStreamRequestBody) call.request().body();\n+    if (requestBody != null) requestBody.outputStream().close();\n+\n+    if (executed) {\n+      synchronized (lock) {\n+        try {\n+          while (response == null && callFailure == null) {\n+            lock.wait(); // Wait until the response is returned or the call fails.\n+          }\n+        } catch (InterruptedException e) {\n+          throw new InterruptedIOException();\n+        }\n       }\n-\n-      Response response = httpEngine.getResponse();\n-      Request followUp = httpEngine.followUpRequest();\n-\n-      if (followUp == null) {\n-        httpEngine.releaseStreamAllocation();\n-        return httpEngine;\n+    } else {\n+      executed = true;\n+      try {\n+        onResponse(call, call.execute());\n+      } catch (IOException e) {\n+        onFailure(call, e);\n       }\n-\n-      if (++followUpCount > HttpEngine.MAX_FOLLOW_UPS) {\n-        throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n-      }\n-\n-      // The first request was insufficient. Prepare for another...\n-      url = followUp.url().url();\n-      requestHeaders = followUp.headers().newBuilder();\n-\n-      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n-      // should keep the same method, Chrome, Firefox and the RI all issue GETs\n-      // when following any redirect.\n-      Sink requestBody = httpEngine.getRequestBody();\n-      if (!followUp.method().equals(method)) {\n-        requestBody = null;\n-      }\n-\n-      if (requestBody != null && !(requestBody instanceof RetryableSink)) {\n-        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n-      }\n-\n-      StreamAllocation streamAllocation = httpEngine.close();\n-      if (!httpEngine.sameConnection(followUp.url())) {\n-        streamAllocation.release();\n-        streamAllocation = null;\n-      }\n-\n-      httpEngine = newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody,\n-          response);\n     }\n+\n+    synchronized (lock) {\n+      if (callFailure != null) throw callFailure;\n+      if (response != null) return response;\n+    }\n+\n+    throw new AssertionError();\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "HttpEngine",
						"newValue": "Response"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Reimplement HttpURLConnection on the native OkHttp API.\n",
					"commitDate": "2016-06-21, 12:30 PM",
					"commitName": "084b06b48bae2b566bb1be3415b6c847d8ea3682",
					"commitAuthor": "jwilson",
					"commitDateOld": "2016-05-07, 7:08 PM",
					"commitNameOld": "4f24a30c12032b7033884a630696014afd3e77cb",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 44.72,
					"commitsBetweenForRepo": 27,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,50 +1,41 @@\n-  private HttpEngine getResponse() throws IOException {\n-    initHttpEngine();\n-\n-    if (httpEngine.hasResponse()) {\n-      return httpEngine;\n+  private Response getResponse() throws IOException {\n+    if (response != null) {\n+      return response;\n+    } else if (networkResponse != null) {\n+      return networkResponse;\n+    } else if (callFailure != null) {\n+      throw callFailure;\n     }\n \n-    while (true) {\n-      if (!execute(true)) {\n-        continue;\n+    Call call = buildCall();\n+    networkInterceptor.proceed();\n+\n+    OutputStreamRequestBody requestBody = (OutputStreamRequestBody) call.request().body();\n+    if (requestBody != null) requestBody.outputStream().close();\n+\n+    if (executed) {\n+      synchronized (lock) {\n+        try {\n+          while (response == null && callFailure == null) {\n+            lock.wait(); // Wait until the response is returned or the call fails.\n+          }\n+        } catch (InterruptedException e) {\n+          throw new InterruptedIOException();\n+        }\n       }\n-\n-      Response response = httpEngine.getResponse();\n-      Request followUp = httpEngine.followUpRequest();\n-\n-      if (followUp == null) {\n-        httpEngine.releaseStreamAllocation();\n-        return httpEngine;\n+    } else {\n+      executed = true;\n+      try {\n+        onResponse(call, call.execute());\n+      } catch (IOException e) {\n+        onFailure(call, e);\n       }\n-\n-      if (++followUpCount > HttpEngine.MAX_FOLLOW_UPS) {\n-        throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n-      }\n-\n-      // The first request was insufficient. Prepare for another...\n-      url = followUp.url().url();\n-      requestHeaders = followUp.headers().newBuilder();\n-\n-      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n-      // should keep the same method, Chrome, Firefox and the RI all issue GETs\n-      // when following any redirect.\n-      Sink requestBody = httpEngine.getRequestBody();\n-      if (!followUp.method().equals(method)) {\n-        requestBody = null;\n-      }\n-\n-      if (requestBody != null && !(requestBody instanceof RetryableSink)) {\n-        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n-      }\n-\n-      StreamAllocation streamAllocation = httpEngine.close();\n-      if (!httpEngine.sameConnection(followUp.url())) {\n-        streamAllocation.release();\n-        streamAllocation = null;\n-      }\n-\n-      httpEngine = newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody,\n-          response);\n     }\n+\n+    synchronized (lock) {\n+      if (callFailure != null) throw callFailure;\n+      if (response != null) return response;\n+    }\n+\n+    throw new AssertionError();\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"c9a89876de476983f273edbf108c365127c18c5e": {
			"type": "Ymovefromfile",
			"commitMessage": "Rename com.squareup.okhttp to okhttp3\n\nMaven group changes will come in follow up.\n",
			"commitDate": "2015-12-15, 11:34 PM",
			"commitName": "c9a89876de476983f273edbf108c365127c18c5e",
			"commitAuthor": "jwilson",
			"commitDateOld": "2015-12-15, 7:36 PM",
			"commitNameOld": "54dc2df914f2aae37fb48cc2c2f7560ee664bc2b",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 0.17,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
				"newPath": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java",
				"oldMethodName": "getResponse",
				"newMethodName": "getResponse"
			}
		},
		"93d547dcdaecddfa456aee0571131db2342e5abb": {
			"type": "Ybodychange",
			"commitMessage": "Make HttpUrl the blessed URL method of Request.\n",
			"commitDate": "2015-12-14, 1:11 PM",
			"commitName": "93d547dcdaecddfa456aee0571131db2342e5abb",
			"commitAuthor": "Jake Wharton",
			"commitDateOld": "2015-12-13, 8:07 AM",
			"commitNameOld": "45260b51b1948abe139c568e2c400955870b9339",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 1.21,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,50 +1,50 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Response response = httpEngine.getResponse();\n       Request followUp = httpEngine.followUpRequest();\n \n       if (followUp == null) {\n         httpEngine.releaseStreamAllocation();\n         return httpEngine;\n       }\n \n       if (++followUpCount > HttpEngine.MAX_FOLLOW_UPS) {\n         throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n       }\n \n       // The first request was insufficient. Prepare for another...\n-      url = followUp.url();\n+      url = followUp.url().url();\n       requestHeaders = followUp.headers().newBuilder();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n       // should keep the same method, Chrome, Firefox and the RI all issue GETs\n       // when following any redirect.\n       Sink requestBody = httpEngine.getRequestBody();\n       if (!followUp.method().equals(method)) {\n         requestBody = null;\n       }\n \n       if (requestBody != null && !(requestBody instanceof RetryableSink)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n       StreamAllocation streamAllocation = httpEngine.close();\n-      if (!httpEngine.sameConnection(followUp.httpUrl())) {\n+      if (!httpEngine.sameConnection(followUp.url())) {\n         streamAllocation.release();\n         streamAllocation = null;\n       }\n \n       httpEngine = newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody,\n           response);\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c358656c8799d30fd422448153e99a5dd37e298a": {
			"type": "Ybodychange",
			"commitMessage": "First draft of the new new stream allocations model.\n",
			"commitDate": "2015-11-28, 7:36 AM",
			"commitName": "c358656c8799d30fd422448153e99a5dd37e298a",
			"commitAuthor": "jwilson",
			"commitDateOld": "2015-11-24, 8:03 PM",
			"commitNameOld": "6fff68b1e9be384ad134812d3e14af5ae7fef83f",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 3.48,
			"commitsBetweenForRepo": 11,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,49 +1,50 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Response response = httpEngine.getResponse();\n       Request followUp = httpEngine.followUpRequest();\n \n       if (followUp == null) {\n-        httpEngine.releaseConnection();\n+        httpEngine.releaseStreamAllocation();\n         return httpEngine;\n       }\n \n       if (++followUpCount > HttpEngine.MAX_FOLLOW_UPS) {\n         throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n       }\n \n       // The first request was insufficient. Prepare for another...\n       url = followUp.url();\n       requestHeaders = followUp.headers().newBuilder();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n       // should keep the same method, Chrome, Firefox and the RI all issue GETs\n       // when following any redirect.\n       Sink requestBody = httpEngine.getRequestBody();\n       if (!followUp.method().equals(method)) {\n         requestBody = null;\n       }\n \n       if (requestBody != null && !(requestBody instanceof RetryableSink)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n+      StreamAllocation streamAllocation = httpEngine.close();\n       if (!httpEngine.sameConnection(followUp.httpUrl())) {\n-        httpEngine.releaseConnection();\n+        streamAllocation.release();\n+        streamAllocation = null;\n       }\n \n-      Connection connection = httpEngine.close();\n-      httpEngine = newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody,\n+      httpEngine = newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody,\n           response);\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4c90a2e04a83646597a506a80b5a885d5c515bf0": {
			"type": "Ybodychange",
			"commitMessage": "Use HttpUrl internally.\n",
			"commitDate": "2015-08-02, 7:01 PM",
			"commitName": "4c90a2e04a83646597a506a80b5a885d5c515bf0",
			"commitAuthor": "jwilson",
			"commitDateOld": "2015-04-16, 6:20 PM",
			"commitNameOld": "80901a680a341a79f4bc4523b191eeb219941cd7",
			"commitAuthorOld": "",
			"daysBetweenCommits": 108.03,
			"commitsBetweenForRepo": 80,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,49 +1,49 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Response response = httpEngine.getResponse();\n       Request followUp = httpEngine.followUpRequest();\n \n       if (followUp == null) {\n         httpEngine.releaseConnection();\n         return httpEngine;\n       }\n \n       if (++followUpCount > HttpEngine.MAX_FOLLOW_UPS) {\n         throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n       }\n \n       // The first request was insufficient. Prepare for another...\n       url = followUp.url();\n       requestHeaders = followUp.headers().newBuilder();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n       // should keep the same method, Chrome, Firefox and the RI all issue GETs\n       // when following any redirect.\n       Sink requestBody = httpEngine.getRequestBody();\n       if (!followUp.method().equals(method)) {\n         requestBody = null;\n       }\n \n       if (requestBody != null && !(requestBody instanceof RetryableSink)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n-      if (!httpEngine.sameConnection(followUp.url())) {\n+      if (!httpEngine.sameConnection(followUp.httpUrl())) {\n         httpEngine.releaseConnection();\n       }\n \n       Connection connection = httpEngine.close();\n       httpEngine = newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody,\n           response);\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e49dd7a2f08deac92fab3de2b8a63e90b588f746": {
			"type": "Ybodychange",
			"commitMessage": "Limit 20 authorization attempts.\n\nWe use one count for both redirects and authorization attempts. This\nseems like good enough policy.\n\nCloses https://github.com/square/okhttp/issues/960\n",
			"commitDate": "2014-12-30, 10:14 AM",
			"commitName": "e49dd7a2f08deac92fab3de2b8a63e90b588f746",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2014-12-24, 12:33 PM",
			"commitNameOld": "15c81fdfc2ba4ecfbadac5a7ec73fcc61f6624bc",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 5.9,
			"commitsBetweenForRepo": 19,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,49 +1,49 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Response response = httpEngine.getResponse();\n       Request followUp = httpEngine.followUpRequest();\n \n       if (followUp == null) {\n         httpEngine.releaseConnection();\n         return httpEngine;\n       }\n \n-      if (response.isRedirect() && ++redirectionCount > HttpEngine.MAX_REDIRECTS) {\n-        throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n+      if (++followUpCount > HttpEngine.MAX_FOLLOW_UPS) {\n+        throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n       }\n \n       // The first request was insufficient. Prepare for another...\n       url = followUp.url();\n       requestHeaders = followUp.headers().newBuilder();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n       // should keep the same method, Chrome, Firefox and the RI all issue GETs\n       // when following any redirect.\n       Sink requestBody = httpEngine.getRequestBody();\n       if (!followUp.method().equals(method)) {\n         requestBody = null;\n       }\n \n       if (requestBody != null && !(requestBody instanceof RetryableSink)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n       if (!httpEngine.sameConnection(followUp.url())) {\n         httpEngine.releaseConnection();\n       }\n \n       Connection connection = httpEngine.close();\n       httpEngine = newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody,\n           response);\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ed70981925e64fd0cb593d09bdd401ea4ea19848": {
			"type": "Ybodychange",
			"commitMessage": "Strip auth headers when redirected to another host.\n\nThese are potentially private and we don't want to leak them to another\nhost, regardless of whether they're created by the calling application or\nby the Authenticator.\n",
			"commitDate": "2014-05-19, 9:18 PM",
			"commitName": "ed70981925e64fd0cb593d09bdd401ea4ea19848",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2014-05-17, 7:00 PM",
			"commitNameOld": "0676d8b1733589a869098b9980118644b3bade4f",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 2.1,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,49 +1,49 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Response response = httpEngine.getResponse();\n       Request followUp = httpEngine.followUpRequest();\n \n       if (followUp == null) {\n         httpEngine.releaseConnection();\n         return httpEngine;\n       }\n \n       if (response.isRedirect() && ++redirectionCount > HttpEngine.MAX_REDIRECTS) {\n         throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n       }\n \n       // The first request was insufficient. Prepare for another...\n       url = followUp.url();\n       requestHeaders = followUp.headers().newBuilder();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n       // should keep the same method, Chrome, Firefox and the RI all issue GETs\n       // when following any redirect.\n       Sink requestBody = httpEngine.getRequestBody();\n       if (!followUp.method().equals(method)) {\n         requestBody = null;\n       }\n \n       if (requestBody != null && !(requestBody instanceof RetryableSink)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n-      if (!httpEngine.sameConnection(followUp)) {\n+      if (!httpEngine.sameConnection(followUp.url())) {\n         httpEngine.releaseConnection();\n       }\n \n       Connection connection = httpEngine.close();\n       httpEngine = newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody,\n           response);\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0676d8b1733589a869098b9980118644b3bade4f": {
			"type": "Yfilerename",
			"commitMessage": "Move code to the urlconnection module.\n\nWe don't need this code for the core OkHttp API.\n",
			"commitDate": "2014-05-17, 7:00 PM",
			"commitName": "0676d8b1733589a869098b9980118644b3bade4f",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2014-05-17, 4:40 PM",
			"commitNameOld": "85a3e9bfc58040c9ffb2ee906b39702bb26a84a5",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 0.1,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
				"newPath": "okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java"
			}
		},
		"ee2ed56c9ad4563f5713ff0f572a5454af16901d": {
			"type": "Ybodychange",
			"commitMessage": "Track redirectedBy in HttpEngine.\n\nTracking it in Call meant we would need to duplicate code\nin HttpURLConnection if we wanted the same behavior.\n",
			"commitDate": "2014-05-05, 6:41 PM",
			"commitName": "ee2ed56c9ad4563f5713ff0f572a5454af16901d",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2014-04-30, 7:36 PM",
			"commitNameOld": "1044d9eea21d8be54c195fff75ca0a7b9bba79b3",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 4.96,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,48 +1,49 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Response response = httpEngine.getResponse();\n       Request followUp = httpEngine.followUpRequest();\n \n       if (followUp == null) {\n         httpEngine.releaseConnection();\n         return httpEngine;\n       }\n \n       if (response.isRedirect() && ++redirectionCount > HttpEngine.MAX_REDIRECTS) {\n         throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n       }\n \n       // The first request was insufficient. Prepare for another...\n       url = followUp.url();\n       requestHeaders = followUp.headers().newBuilder();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n       // should keep the same method, Chrome, Firefox and the RI all issue GETs\n       // when following any redirect.\n       Sink requestBody = httpEngine.getRequestBody();\n       if (!followUp.method().equals(method)) {\n         requestBody = null;\n       }\n \n       if (requestBody != null && !(requestBody instanceof RetryableSink)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n       if (!httpEngine.sameConnection(followUp)) {\n         httpEngine.releaseConnection();\n       }\n \n       Connection connection = httpEngine.close();\n-      httpEngine = newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody);\n+      httpEngine = newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody,\n+          response);\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b7542587b8e90aa4472d4d9e4b74a72ca0c42cb4": {
			"type": "Ybodychange",
			"commitMessage": "Move more behavior into HttpEngine.followUpRequest\n",
			"commitDate": "2014-04-26, 11:02 AM",
			"commitName": "b7542587b8e90aa4472d4d9e4b74a72ca0c42cb4",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2014-04-22, 9:39 AM",
			"commitNameOld": "112dcc40900d503ea7e416e0da0a8fd9b08a9c17",
			"commitAuthorOld": "Adrian Cole",
			"daysBetweenCommits": 4.06,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,59 +1,48 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Response response = httpEngine.getResponse();\n       Request followUp = httpEngine.followUpRequest();\n \n       if (followUp == null) {\n         httpEngine.releaseConnection();\n         return httpEngine;\n       }\n \n       if (response.isRedirect() && ++redirectionCount > HttpEngine.MAX_REDIRECTS) {\n         throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n       }\n \n       // The first request was insufficient. Prepare for another...\n-      if (response.isRedirect()) {\n-        url = followUp.url(); // Get the redirected URL.\n-      } else {\n-        requestHeaders = followUp.headers().newBuilder(); // Get the follow-up's credentials!\n-      }\n+      url = followUp.url();\n+      requestHeaders = followUp.headers().newBuilder();\n \n-      String retryMethod = method;\n+      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n+      // should keep the same method, Chrome, Firefox and the RI all issue GETs\n+      // when following any redirect.\n       Sink requestBody = httpEngine.getRequestBody();\n-\n-      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n-      // redirect should keep the same method, Chrome, Firefox and the\n-      // RI all issue GETs when following any redirect.\n-      int responseCode = response.code();\n-      if (responseCode == HTTP_MULT_CHOICE\n-          || responseCode == HTTP_MOVED_PERM\n-          || responseCode == HTTP_MOVED_TEMP\n-          || responseCode == HTTP_SEE_OTHER) {\n-        retryMethod = \"GET\";\n-        requestHeaders.removeAll(\"Content-Length\");\n+      if (!followUp.method().equals(method)) {\n         requestBody = null;\n       }\n \n       if (requestBody != null && !(requestBody instanceof RetryableSink)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n       if (!httpEngine.sameConnection(followUp)) {\n         httpEngine.releaseConnection();\n       }\n \n       Connection connection = httpEngine.close();\n-      httpEngine = newHttpEngine(retryMethod, connection, (RetryableSink) requestBody);\n+      httpEngine = newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody);\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9146c579dd9110d0028144c59515da9be1ce7108": {
			"type": "Ybodychange",
			"commitMessage": "Deduplicate followup request handling.\n\nThis code's currently both gnarly and subtle; there's a lot of\nnuance to the HTTP behavior, and a lot of state, but it isn't\nobvious in the state of the objects doing the work.\n\nDeduplicating work in HttpURLConnection with Job is a shy first\nstep. It also points out some potential problems with Job, where\nwe don't handle method changes or cookies correctly. That's\ncritical!\n",
			"commitDate": "2014-04-21, 10:14 PM",
			"commitName": "9146c579dd9110d0028144c59515da9be1ce7108",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2014-04-21, 10:00 AM",
			"commitNameOld": "e920196fbd71822fc284ab76204bf75f95d3265a",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 0.51,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,47 +1,59 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n-      Retry retry = processResponseHeaders();\n-      if (retry == Retry.NONE) {\n+      Response response = httpEngine.getResponse();\n+      Request followUp = httpEngine.followUpRequest();\n+\n+      if (followUp == null) {\n         httpEngine.releaseConnection();\n         return httpEngine;\n       }\n \n+      if (response.isRedirect() && ++redirectionCount > HttpEngine.MAX_REDIRECTS) {\n+        throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n+      }\n+\n       // The first request was insufficient. Prepare for another...\n+      if (response.isRedirect()) {\n+        url = followUp.url(); // Get the redirected URL.\n+      } else {\n+        requestHeaders = followUp.headers().newBuilder(); // Get the follow-up's credentials!\n+      }\n+\n       String retryMethod = method;\n       Sink requestBody = httpEngine.getRequestBody();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n       // redirect should keep the same method, Chrome, Firefox and the\n       // RI all issue GETs when following any redirect.\n-      int responseCode = httpEngine.getResponse().code();\n+      int responseCode = response.code();\n       if (responseCode == HTTP_MULT_CHOICE\n           || responseCode == HTTP_MOVED_PERM\n           || responseCode == HTTP_MOVED_TEMP\n           || responseCode == HTTP_SEE_OTHER) {\n         retryMethod = \"GET\";\n         requestHeaders.removeAll(\"Content-Length\");\n         requestBody = null;\n       }\n \n       if (requestBody != null && !(requestBody instanceof RetryableSink)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n-      if (retry == Retry.DIFFERENT_CONNECTION) {\n+      if (!httpEngine.sameConnection(followUp)) {\n         httpEngine.releaseConnection();\n       }\n \n       Connection connection = httpEngine.close();\n       httpEngine = newHttpEngine(retryMethod, connection, (RetryableSink) requestBody);\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"996e9c95bdcafd62e84c79c512d6ccac65c30758": {
			"type": "Yfilerename",
			"commitMessage": "Move HttpUrlConnection implementation to its own package.\n",
			"commitDate": "2014-04-20, 12:59 AM",
			"commitName": "996e9c95bdcafd62e84c79c512d6ccac65c30758",
			"commitAuthor": "Jake Wharton",
			"commitDateOld": "2014-04-19, 7:19 PM",
			"commitNameOld": "6486179b9d9c888a818c85384eed88fa0a8768a6",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 0.24,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
				"newPath": "okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java"
			}
		},
		"84184afdb26b42ff615896f9c0161157cc84ec73": {
			"type": "Ybodychange",
			"commitMessage": "Use Sink in HttpEngine.\n",
			"commitDate": "2014-02-23, 4:13 PM",
			"commitName": "84184afdb26b42ff615896f9c0161157cc84ec73",
			"commitAuthor": "jwilson",
			"commitDateOld": "2014-02-22, 12:23 PM",
			"commitNameOld": "2581c36905db13dcd1df9a602c6201e3a9f80965",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 1.16,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,47 +1,47 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Retry retry = processResponseHeaders();\n       if (retry == Retry.NONE) {\n         httpEngine.releaseConnection();\n         return httpEngine;\n       }\n \n       // The first request was insufficient. Prepare for another...\n       String retryMethod = method;\n-      OutputStream requestBody = httpEngine.getRequestBody();\n+      Sink requestBody = httpEngine.getRequestBody();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n       // redirect should keep the same method, Chrome, Firefox and the\n       // RI all issue GETs when following any redirect.\n       int responseCode = httpEngine.getResponse().code();\n       if (responseCode == HTTP_MULT_CHOICE\n           || responseCode == HTTP_MOVED_PERM\n           || responseCode == HTTP_MOVED_TEMP\n           || responseCode == HTTP_SEE_OTHER) {\n         retryMethod = \"GET\";\n         requestHeaders.removeAll(\"Content-Length\");\n         requestBody = null;\n       }\n \n-      if (requestBody != null && !(requestBody instanceof RetryableOutputStream)) {\n+      if (requestBody != null && !(requestBody instanceof RetryableSink)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n       if (retry == Retry.DIFFERENT_CONNECTION) {\n         httpEngine.releaseConnection();\n       }\n \n       Connection connection = httpEngine.close();\n-      httpEngine = newHttpEngine(retryMethod, connection, (RetryableOutputStream) requestBody);\n+      httpEngine = newHttpEngine(retryMethod, connection, (RetryableSink) requestBody);\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3": {
			"type": "Ybodychange",
			"commitMessage": "Move connection pooling logic.\n\nPreviously we had this ugly, awkward release() method that\nattempted to manage connection pooling, discarding streams\nfor caching, and closing broken streams.\n\nMove connection reuse to HttpConnection, with policy informed\nby HttpEngine. It specifies what to do when the connection\nbecomes idle: pool, close or hold. The connection does what\nit's told.\n",
			"commitDate": "2014-02-15, 4:44 PM",
			"commitName": "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3",
			"commitAuthor": "jwilson",
			"commitDateOld": "2014-01-26, 4:09 PM",
			"commitNameOld": "32a2b1d8d000a19d4a340cc1d77a68973a9d65dc",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 20.02,
			"commitsBetweenForRepo": 37,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,48 +1,47 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Retry retry = processResponseHeaders();\n       if (retry == Retry.NONE) {\n-        httpEngine.automaticallyReleaseConnectionToPool();\n+        httpEngine.releaseConnection();\n         return httpEngine;\n       }\n \n       // The first request was insufficient. Prepare for another...\n       String retryMethod = method;\n       OutputStream requestBody = httpEngine.getRequestBody();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n       // redirect should keep the same method, Chrome, Firefox and the\n       // RI all issue GETs when following any redirect.\n       int responseCode = httpEngine.getResponse().code();\n       if (responseCode == HTTP_MULT_CHOICE\n           || responseCode == HTTP_MOVED_PERM\n           || responseCode == HTTP_MOVED_TEMP\n           || responseCode == HTTP_SEE_OTHER) {\n         retryMethod = \"GET\";\n         requestHeaders.removeAll(\"Content-Length\");\n         requestBody = null;\n       }\n \n       if (requestBody != null && !(requestBody instanceof RetryableOutputStream)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n       if (retry == Retry.DIFFERENT_CONNECTION) {\n-        httpEngine.automaticallyReleaseConnectionToPool();\n+        httpEngine.releaseConnection();\n       }\n \n-      httpEngine.release(false);\n-      httpEngine = newHttpEngine(retryMethod, httpEngine.getConnection(),\n-          (RetryableOutputStream) requestBody);\n+      Connection connection = httpEngine.close();\n+      httpEngine = newHttpEngine(retryMethod, connection, (RetryableOutputStream) requestBody);\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4831a8dc6577f762e0f21fd15dd9700fe824740d": {
			"type": "Ybodychange",
			"commitMessage": "Rename RawHeaders to Headers.\n\nNow that Request and Response self-describe, I think the\nword Headers is sufficient. And it's a lot less ugly than\nRawHeaders.\n\nAlso move header serialization code to HttpTransport and\nSpdyTransport.\n",
			"commitDate": "2013-12-30, 11:58 PM",
			"commitName": "4831a8dc6577f762e0f21fd15dd9700fe824740d",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-12-30, 11:15 PM",
			"commitNameOld": "60f20dc23cb08d598d605f51f7526725ec42abd9",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,48 +1,48 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Retry retry = processResponseHeaders();\n       if (retry == Retry.NONE) {\n         httpEngine.automaticallyReleaseConnectionToPool();\n         return httpEngine;\n       }\n \n       // The first request was insufficient. Prepare for another...\n       String retryMethod = method;\n       OutputStream requestBody = httpEngine.getRequestBody();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n       // redirect should keep the same method, Chrome, Firefox and the\n       // RI all issue GETs when following any redirect.\n-      int responseCode = httpEngine.getResponseCode();\n+      int responseCode = httpEngine.getResponse().code();\n       if (responseCode == HTTP_MULT_CHOICE\n           || responseCode == HTTP_MOVED_PERM\n           || responseCode == HTTP_MOVED_TEMP\n           || responseCode == HTTP_SEE_OTHER) {\n         retryMethod = \"GET\";\n         requestHeaders.removeAll(\"Content-Length\");\n         requestBody = null;\n       }\n \n       if (requestBody != null && !(requestBody instanceof RetryableOutputStream)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n       if (retry == Retry.DIFFERENT_CONNECTION) {\n         httpEngine.automaticallyReleaseConnectionToPool();\n       }\n \n       httpEngine.release(false);\n       httpEngine = newHttpEngine(retryMethod, httpEngine.getConnection(),\n           (RetryableOutputStream) requestBody);\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"350c43b6fe02401a73f967d9ef322061638b372a": {
			"type": "Ybodychange",
			"commitMessage": "Make RawHeaders, RequestHeaders and ResponseHeaders immutable.\n\nThis introduces a new, poorly-named class ResponseStrategy\nthat pulls some code out of ResponseHeaders. That was necessary\nbecause the old method mutated itself and its parameters in\nplace.\n\nObvious follow-up for this is to combine ResponseHeaders with\nResponse, and RequestHeaders with Response.\n",
			"commitDate": "2013-12-29, 7:17 PM",
			"commitName": "350c43b6fe02401a73f967d9ef322061638b372a",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-12-29, 4:57 PM",
			"commitNameOld": "30ecba897fb624df201f0a014b54a604418a0e73",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 0.1,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,53 +1,48 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Retry retry = processResponseHeaders();\n       if (retry == Retry.NONE) {\n         httpEngine.automaticallyReleaseConnectionToPool();\n         return httpEngine;\n       }\n \n       // The first request was insufficient. Prepare for another...\n       String retryMethod = method;\n       OutputStream requestBody = httpEngine.getRequestBody();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n       // redirect should keep the same method, Chrome, Firefox and the\n       // RI all issue GETs when following any redirect.\n       int responseCode = httpEngine.getResponseCode();\n       if (responseCode == HTTP_MULT_CHOICE\n           || responseCode == HTTP_MOVED_PERM\n           || responseCode == HTTP_MOVED_TEMP\n           || responseCode == HTTP_SEE_OTHER) {\n         retryMethod = \"GET\";\n+        requestHeaders.removeAll(\"Content-Length\");\n         requestBody = null;\n       }\n \n       if (requestBody != null && !(requestBody instanceof RetryableOutputStream)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n       if (retry == Retry.DIFFERENT_CONNECTION) {\n         httpEngine.automaticallyReleaseConnectionToPool();\n       }\n \n       httpEngine.release(false);\n-\n-      httpEngine = newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(),\n+      httpEngine = newHttpEngine(retryMethod, httpEngine.getConnection(),\n           (RetryableOutputStream) requestBody);\n-\n-      if (requestBody == null) {\n-        // Drop the Content-Length header when redirected from POST to GET.\n-        httpEngine.getRequestHeaders().removeContentLength();\n-      }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"37c01895cca5ec2bec26a3d381611f0938acd6d0": {
			"type": "Ybodychange",
			"commitMessage": "Define async APIs and switch Job to use HttpEngine directly.\n\nUsing HttpEngine directly introduces some duplicated code with\nHttpURLConnection. It also breaks the response cache. I think\nthis is the best route going forward; and eventually we could\ninvert this relationship to have HttpURLConnection depending on\nJob directly rather than vice versa.\n",
			"commitDate": "2013-12-28, 6:24 PM",
			"commitName": "37c01895cca5ec2bec26a3d381611f0938acd6d0",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-10-31, 3:17 PM",
			"commitNameOld": "adec488f99795bcba135cbbdb1b9821880425b4c",
			"commitAuthorOld": "Jon Watson",
			"daysBetweenCommits": 58.17,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,54 +1,53 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Retry retry = processResponseHeaders();\n       if (retry == Retry.NONE) {\n         httpEngine.automaticallyReleaseConnectionToPool();\n         return httpEngine;\n       }\n \n       // The first request was insufficient. Prepare for another...\n       String retryMethod = method;\n       OutputStream requestBody = httpEngine.getRequestBody();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n       // redirect should keep the same method, Chrome, Firefox and the\n       // RI all issue GETs when following any redirect.\n-      int responseCode = getResponseCode();\n+      int responseCode = httpEngine.getResponseCode();\n       if (responseCode == HTTP_MULT_CHOICE\n           || responseCode == HTTP_MOVED_PERM\n           || responseCode == HTTP_MOVED_TEMP\n           || responseCode == HTTP_SEE_OTHER) {\n         retryMethod = \"GET\";\n         requestBody = null;\n       }\n \n       if (requestBody != null && !(requestBody instanceof RetryableOutputStream)) {\n-        throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n-            httpEngine.getResponseCode());\n+        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n       if (retry == Retry.DIFFERENT_CONNECTION) {\n         httpEngine.automaticallyReleaseConnectionToPool();\n       }\n \n       httpEngine.release(false);\n \n       httpEngine = newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(),\n           (RetryableOutputStream) requestBody);\n \n       if (requestBody == null) {\n         // Drop the Content-Length header when redirected from POST to GET.\n         httpEngine.getRequestHeaders().removeContentLength();\n       }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a948ffce1eb2b9ec46069722f6744f252d6dbfc7": {
			"type": "Ybodychange",
			"commitMessage": "Drop Content-Length when redirected from POST to GET.\n\nhttps://github.com/square/okhttp/issues/296\n",
			"commitDate": "2013-08-24, 12:11 PM",
			"commitName": "a948ffce1eb2b9ec46069722f6744f252d6dbfc7",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-07-20, 9:13 AM",
			"commitNameOld": "de1b5f244df1e29c457fdd87e91b9919c2336da7",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 35.12,
			"commitsBetweenForRepo": 32,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,49 +1,54 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Retry retry = processResponseHeaders();\n       if (retry == Retry.NONE) {\n         httpEngine.automaticallyReleaseConnectionToPool();\n         return httpEngine;\n       }\n \n       // The first request was insufficient. Prepare for another...\n       String retryMethod = method;\n       OutputStream requestBody = httpEngine.getRequestBody();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n       // redirect should keep the same method, Chrome, Firefox and the\n       // RI all issue GETs when following any redirect.\n       int responseCode = getResponseCode();\n       if (responseCode == HTTP_MULT_CHOICE\n           || responseCode == HTTP_MOVED_PERM\n           || responseCode == HTTP_MOVED_TEMP\n           || responseCode == HTTP_SEE_OTHER) {\n         retryMethod = \"GET\";\n         requestBody = null;\n       }\n \n       if (requestBody != null && !(requestBody instanceof RetryableOutputStream)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n             httpEngine.getResponseCode());\n       }\n \n       if (retry == Retry.DIFFERENT_CONNECTION) {\n         httpEngine.automaticallyReleaseConnectionToPool();\n       }\n \n       httpEngine.release(false);\n \n       httpEngine = newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(),\n           (RetryableOutputStream) requestBody);\n+\n+      if (requestBody == null) {\n+        // Drop the Content-Length header when redirected from POST to GET.\n+        httpEngine.getRequestHeaders().removeContentLength();\n+      }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7ccbf48838b7cfe42759c67790636d442ea5daa3": {
			"type": "Yfilerename",
			"commitMessage": "Move library into a module. Introduce sample module with simple GitHub client.\n",
			"commitDate": "2013-03-25, 9:04 PM",
			"commitName": "7ccbf48838b7cfe42759c67790636d442ea5daa3",
			"commitAuthor": "Jake Wharton",
			"commitDateOld": "2013-03-15, 8:39 AM",
			"commitNameOld": "ba2b7432cb9fabfc725b09a9f14878cb128ef208",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 10.52,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
				"newPath": "okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java"
			}
		},
		"7e7a3896df109ef442af9ec69423c33ec667c9f5": {
			"type": "Ybodychange",
			"commitMessage": "Switch to Square style for comments.\n",
			"commitDate": "2013-02-01, 9:13 AM",
			"commitName": "7e7a3896df109ef442af9ec69423c33ec667c9f5",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-01-31, 3:36 PM",
			"commitNameOld": "2d45a13249943cafa73460b35c3c366e5742eb6f",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 0.73,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,53 +1,49 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Retry retry = processResponseHeaders();\n       if (retry == Retry.NONE) {\n         httpEngine.automaticallyReleaseConnectionToPool();\n         return httpEngine;\n       }\n \n-            /*\n-             * The first request was insufficient. Prepare for another...\n-             */\n+      // The first request was insufficient. Prepare for another...\n       String retryMethod = method;\n       OutputStream requestBody = httpEngine.getRequestBody();\n \n-            /*\n-             * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n-             * redirect should keep the same method, Chrome, Firefox and the\n-             * RI all issue GETs when following any redirect.\n-             */\n+      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n+      // redirect should keep the same method, Chrome, Firefox and the\n+      // RI all issue GETs when following any redirect.\n       int responseCode = getResponseCode();\n       if (responseCode == HTTP_MULT_CHOICE\n           || responseCode == HTTP_MOVED_PERM\n           || responseCode == HTTP_MOVED_TEMP\n           || responseCode == HTTP_SEE_OTHER) {\n         retryMethod = \"GET\";\n         requestBody = null;\n       }\n \n       if (requestBody != null && !(requestBody instanceof RetryableOutputStream)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n             httpEngine.getResponseCode());\n       }\n \n       if (retry == Retry.DIFFERENT_CONNECTION) {\n         httpEngine.automaticallyReleaseConnectionToPool();\n       }\n \n       httpEngine.release(false);\n \n       httpEngine = newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(),\n           (RetryableOutputStream) requestBody);\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6f6d959fdae64065521990413f86bc7ab038d7c1": {
			"type": "Ybodychange",
			"commitMessage": "Improvements to connection pool\n",
			"commitDate": "2013-01-31, 3:23 PM",
			"commitName": "6f6d959fdae64065521990413f86bc7ab038d7c1",
			"commitAuthor": "Marcelo Cortes",
			"commitDateOld": "2013-01-30, 10:55 PM",
			"commitNameOld": "83de4eb552994d30451f8a3481b5a00d6b457a2e",
			"commitAuthorOld": "",
			"daysBetweenCommits": 0.69,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,53 +1,51 @@\n     private HttpEngine getResponse() throws IOException {\n         initHttpEngine();\n \n         if (httpEngine.hasResponse()) {\n             return httpEngine;\n         }\n \n         while (true) {\n             if (!execute(true)) {\n                 continue;\n             }\n \n             Retry retry = processResponseHeaders();\n             if (retry == Retry.NONE) {\n                 httpEngine.automaticallyReleaseConnectionToPool();\n                 return httpEngine;\n             }\n \n             /*\n              * The first request was insufficient. Prepare for another...\n              */\n             String retryMethod = method;\n             OutputStream requestBody = httpEngine.getRequestBody();\n \n             /*\n              * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n              * redirect should keep the same method, Chrome, Firefox and the\n              * RI all issue GETs when following any redirect.\n              */\n             int responseCode = getResponseCode();\n             if (responseCode == HTTP_MULT_CHOICE || responseCode == HTTP_MOVED_PERM\n                     || responseCode == HTTP_MOVED_TEMP || responseCode == HTTP_SEE_OTHER) {\n                 retryMethod = \"GET\";\n                 requestBody = null;\n             }\n \n             if (requestBody != null && !(requestBody instanceof RetryableOutputStream)) {\n                 throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n                         httpEngine.getResponseCode());\n             }\n \n             if (retry == Retry.DIFFERENT_CONNECTION) {\n                 httpEngine.automaticallyReleaseConnectionToPool();\n-            } else if (retry == Retry.SAME_CONNECTION && httpEngine.getConnection() != null) {\n-                httpEngine.getConnection().setRecycled();\n             }\n \n             httpEngine.release(false);\n \n             httpEngine = newHttpEngine(retryMethod, rawRequestHeaders,\n                     httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"637783ce8ae3ffb9805c2f78b436703c29b2220a": {
			"type": "Ybodychange",
			"commitMessage": "Retry if a request fails after a redirect.\n\nhttps://code.google.com/p/android/issues/detail?id=41576\n",
			"commitDate": "2013-01-30, 10:05 PM",
			"commitName": "637783ce8ae3ffb9805c2f78b436703c29b2220a",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-01-22, 2:14 PM",
			"commitNameOld": "194290e5f3819bf91d87c5d08c152946b6aa3509",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 8.33,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,51 +1,53 @@\n     private HttpEngine getResponse() throws IOException {\n         initHttpEngine();\n \n         if (httpEngine.hasResponse()) {\n             return httpEngine;\n         }\n \n         while (true) {\n             if (!execute(true)) {\n                 continue;\n             }\n \n             Retry retry = processResponseHeaders();\n             if (retry == Retry.NONE) {\n                 httpEngine.automaticallyReleaseConnectionToPool();\n                 return httpEngine;\n             }\n \n             /*\n              * The first request was insufficient. Prepare for another...\n              */\n             String retryMethod = method;\n             OutputStream requestBody = httpEngine.getRequestBody();\n \n             /*\n              * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n              * redirect should keep the same method, Chrome, Firefox and the\n              * RI all issue GETs when following any redirect.\n              */\n             int responseCode = getResponseCode();\n             if (responseCode == HTTP_MULT_CHOICE || responseCode == HTTP_MOVED_PERM\n                     || responseCode == HTTP_MOVED_TEMP || responseCode == HTTP_SEE_OTHER) {\n                 retryMethod = \"GET\";\n                 requestBody = null;\n             }\n \n             if (requestBody != null && !(requestBody instanceof RetryableOutputStream)) {\n                 throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n                         httpEngine.getResponseCode());\n             }\n \n             if (retry == Retry.DIFFERENT_CONNECTION) {\n                 httpEngine.automaticallyReleaseConnectionToPool();\n+            } else if (retry == Retry.SAME_CONNECTION && httpEngine.getConnection() != null) {\n+                httpEngine.getConnection().setRecycled();\n             }\n \n             httpEngine.release(false);\n \n             httpEngine = newHttpEngine(retryMethod, rawRequestHeaders,\n                     httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"194290e5f3819bf91d87c5d08c152946b6aa3509": {
			"type": "Ybodychange",
			"commitMessage": "Improve SPDY+HTTP integration.\n\nWriting tests shook out a few bugs:\n - Pooling wasn't working well. We were trying to connect\n   after already having been connected.\n - We weren't writing response bodies to the cache.\n - We weren't capturing the request time for the cache.\n - MockSpdyServer wasn't trimming headers.\n\nNew files in this change aren't new, they're just inner classes promoted\nto top-level classes for better sharing.\n",
			"commitDate": "2013-01-22, 2:14 PM",
			"commitName": "194290e5f3819bf91d87c5d08c152946b6aa3509",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-01-01, 8:50 PM",
			"commitNameOld": "689f66222bd8984dd69229a4ee9caf8da528ae12",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 20.73,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,51 +1,51 @@\n     private HttpEngine getResponse() throws IOException {\n         initHttpEngine();\n \n         if (httpEngine.hasResponse()) {\n             return httpEngine;\n         }\n \n         while (true) {\n             if (!execute(true)) {\n                 continue;\n             }\n \n             Retry retry = processResponseHeaders();\n             if (retry == Retry.NONE) {\n                 httpEngine.automaticallyReleaseConnectionToPool();\n                 return httpEngine;\n             }\n \n             /*\n              * The first request was insufficient. Prepare for another...\n              */\n             String retryMethod = method;\n             OutputStream requestBody = httpEngine.getRequestBody();\n \n             /*\n              * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n              * redirect should keep the same method, Chrome, Firefox and the\n              * RI all issue GETs when following any redirect.\n              */\n             int responseCode = getResponseCode();\n             if (responseCode == HTTP_MULT_CHOICE || responseCode == HTTP_MOVED_PERM\n                     || responseCode == HTTP_MOVED_TEMP || responseCode == HTTP_SEE_OTHER) {\n                 retryMethod = \"GET\";\n                 requestBody = null;\n             }\n \n             if (requestBody != null && !(requestBody instanceof RetryableOutputStream)) {\n                 throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n                         httpEngine.getResponseCode());\n             }\n \n             if (retry == Retry.DIFFERENT_CONNECTION) {\n                 httpEngine.automaticallyReleaseConnectionToPool();\n             }\n \n-            httpEngine.release(true);\n+            httpEngine.release(false);\n \n             httpEngine = newHttpEngine(retryMethod, rawRequestHeaders,\n                     httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"689f66222bd8984dd69229a4ee9caf8da528ae12": {
			"type": "Yfilerename",
			"commitMessage": "Flatten internal packages and utility classes.\n\nThe previous structure had hierarchy that was useful\nfor libcore but overkill for OkHttp.\n",
			"commitDate": "2013-01-01, 8:50 PM",
			"commitName": "689f66222bd8984dd69229a4ee9caf8da528ae12",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-01-01, 8:27 PM",
			"commitNameOld": "73516e6ab1d336ffd520e845e14f80cf08657bd0",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/com/squareup/okhttp/internal/net/http/HttpURLConnectionImpl.java",
				"newPath": "src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java"
			}
		},
		"67604f618d96ae00318ce696ec29a66bec6aafa8": {
			"type": "Ybodychange",
			"commitMessage": "Clean up utility code for submission to AOSP.\n\nThis moves methods that will have Android-specific implementations\nto Platform.java; all other utility methods are in a junk drawer\nclass called Utils.java.\n\nThis also moves method names (like \"GET\") to compare with .equals\ninstead of '=='. The old code took advantage of a hidden agreement\nbetween HttpURLConnection and HttpEngine; with these in separate\nprojects that behavior isn't as obvious and shouldn't be relied\nupon.\n",
			"commitDate": "2012-12-26, 11:31 AM",
			"commitName": "67604f618d96ae00318ce696ec29a66bec6aafa8",
			"commitAuthor": "jwilson",
			"commitDateOld": "2012-12-23, 10:39 PM",
			"commitNameOld": "78c6624b11d5f33504dae8211b4592383468343e",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 2.54,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,51 +1,51 @@\n     private HttpEngine getResponse() throws IOException {\n         initHttpEngine();\n \n         if (httpEngine.hasResponse()) {\n             return httpEngine;\n         }\n \n         while (true) {\n             if (!execute(true)) {\n                 continue;\n             }\n \n             Retry retry = processResponseHeaders();\n             if (retry == Retry.NONE) {\n                 httpEngine.automaticallyReleaseConnectionToPool();\n                 return httpEngine;\n             }\n \n             /*\n              * The first request was insufficient. Prepare for another...\n              */\n             String retryMethod = method;\n             OutputStream requestBody = httpEngine.getRequestBody();\n \n             /*\n              * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n              * redirect should keep the same method, Chrome, Firefox and the\n              * RI all issue GETs when following any redirect.\n              */\n             int responseCode = getResponseCode();\n             if (responseCode == HTTP_MULT_CHOICE || responseCode == HTTP_MOVED_PERM\n                     || responseCode == HTTP_MOVED_TEMP || responseCode == HTTP_SEE_OTHER) {\n-                retryMethod = HttpEngine.GET;\n+                retryMethod = \"GET\";\n                 requestBody = null;\n             }\n \n             if (requestBody != null && !(requestBody instanceof RetryableOutputStream)) {\n                 throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n                         httpEngine.getResponseCode());\n             }\n \n             if (retry == Retry.DIFFERENT_CONNECTION) {\n                 httpEngine.automaticallyReleaseConnectionToPool();\n             }\n \n             httpEngine.release(true);\n \n             httpEngine = newHttpEngine(retryMethod, rawRequestHeaders,\n                     httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d": {
			"type": "Yfilerename",
			"commitMessage": "Move out of the libcore package.\n\nTo promote the code into AOSP, we'll keep this package as-is\nand do the jarjar in Android instead.\n",
			"commitDate": "2012-12-15, 2:55 PM",
			"commitName": "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d",
			"commitAuthor": "jwilson",
			"commitDateOld": "2012-12-15, 2:17 PM",
			"commitNameOld": "7f7aa90bc5d41d8f818fc988d2a91d22393c7329",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/libcore/net/http/HttpURLConnectionImpl.java",
				"newPath": "src/main/java/com/squareup/okhttp/internal/net/http/HttpURLConnectionImpl.java"
			}
		},
		"3355d0c99bb946a6441f08fe6fd1c9881a9ea96a": {
			"type": "Ybodychange",
			"commitMessage": "New route selector to support multiple routes.\n",
			"commitDate": "2012-11-10, 2:05 PM",
			"commitName": "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2012-11-05, 9:25 PM",
			"commitNameOld": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 4.69,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,67 +1,51 @@\n     private HttpEngine getResponse() throws IOException {\n         initHttpEngine();\n \n         if (httpEngine.hasResponse()) {\n             return httpEngine;\n         }\n \n         while (true) {\n-            try {\n-                httpEngine.sendRequest();\n-                httpEngine.readResponse();\n-            } catch (IOException e) {\n-                /*\n-                 * If the connection was recycled, its staleness may have caused\n-                 * the failure. Silently retry with a different connection.\n-                 */\n-                OutputStream requestBody = httpEngine.getRequestBody();\n-                if (httpEngine.hasRecycledConnection()\n-                        && (requestBody == null || requestBody instanceof RetryableOutputStream)) {\n-                    httpEngine.release(false);\n-                    httpEngine = newHttpEngine(method, rawRequestHeaders, null,\n-                            (RetryableOutputStream) requestBody);\n-                    continue;\n-                }\n-                httpEngineFailure = e;\n-                throw e;\n+            if (!execute(true)) {\n+                continue;\n             }\n \n             Retry retry = processResponseHeaders();\n             if (retry == Retry.NONE) {\n                 httpEngine.automaticallyReleaseConnectionToPool();\n                 return httpEngine;\n             }\n \n             /*\n              * The first request was insufficient. Prepare for another...\n              */\n             String retryMethod = method;\n             OutputStream requestBody = httpEngine.getRequestBody();\n \n             /*\n              * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n              * redirect should keep the same method, Chrome, Firefox and the\n              * RI all issue GETs when following any redirect.\n              */\n             int responseCode = getResponseCode();\n             if (responseCode == HTTP_MULT_CHOICE || responseCode == HTTP_MOVED_PERM\n                     || responseCode == HTTP_MOVED_TEMP || responseCode == HTTP_SEE_OTHER) {\n                 retryMethod = HttpEngine.GET;\n                 requestBody = null;\n             }\n \n             if (requestBody != null && !(requestBody instanceof RetryableOutputStream)) {\n                 throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n                         httpEngine.getResponseCode());\n             }\n \n             if (retry == Retry.DIFFERENT_CONNECTION) {\n                 httpEngine.automaticallyReleaseConnectionToPool();\n             }\n \n             httpEngine.release(true);\n \n             httpEngine = newHttpEngine(retryMethod, rawRequestHeaders,\n                     httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ea63463c2ff8a67f63e541036f0d5998b5bb1f3e": {
			"type": "Yintroduced",
			"commitMessage": "Initial import.\n\nThis is a fork of okhttp from http://code.google.com/p/okhttp.\nI'm moving it to Github since that's where my code reviewers\nare. I've renamed the core package from com.google.okhttp to\ncom.squareup.okhttp because Square is where I expect ongoing\ndevelopment of this project to take place.\n\nAll code in this project is subject to be contributed upstream\nto AOSP. In particular, all code in the libcore package is\nderived from AOSP and intended to be contributed back to AOSP\non an ongoing basis.\n",
			"commitDate": "2012-07-23, 8:02 AM",
			"commitName": "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e",
			"commitAuthor": "Jesse Wilson"
		}
	},
	"sha": "5224f3045ba9b171fce521777edf389f9206173c"
}