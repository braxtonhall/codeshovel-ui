{
	"repo": "https://github.com/apache/commons-lang.git",
	"file": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
	"method": {
		"longName": "public EqualsBuilder reflectionAppend(Object lhs, Object rhs);",
		"startLine": 491,
		"methodName": "reflectionAppend",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"2e9f3a80146262511ca7bcdd3411f095dff4951d": {
			"type": "Ybodychange",
			"commitMessage": "LANG-1356: Add bypass option for classes to recursive and reflective EqualsBuilder\n\nPatch supplied by Yathos UG\n",
			"commitDate": "2018-02-11, 11:43 AM",
			"commitName": "2e9f3a80146262511ca7bcdd3411f095dff4951d",
			"commitAuthor": "pascalschumacher",
			"commitDateOld": "2017-09-08, 9:19 AM",
			"commitNameOld": "3e08af573f8b50da5202f55df62c925f88a47f3d",
			"commitAuthorOld": "namannigam",
			"daysBetweenCommits": 156.14,
			"commitsBetweenForRepo": 125,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,58 +1,64 @@\n     public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n         if (!isEquals) {\n             return this;\n         }\n         if (lhs == rhs) {\n             return this;\n         }\n         if (lhs == null || rhs == null) {\n             isEquals = false;\n             return this;\n         }\n \n         // Find the leaf class since there may be transients in the leaf\n         // class or in classes between the leaf and root.\n         // If we are not testing transients or a subclass has no ivars,\n         // then a subclass can test equals to a superclass.\n         final Class<?> lhsClass = lhs.getClass();\n         final Class<?> rhsClass = rhs.getClass();\n         Class<?> testClass;\n         if (lhsClass.isInstance(rhs)) {\n             testClass = lhsClass;\n             if (!rhsClass.isInstance(lhs)) {\n                 // rhsClass is a subclass of lhsClass\n                 testClass = rhsClass;\n             }\n         } else if (rhsClass.isInstance(lhs)) {\n             testClass = rhsClass;\n             if (!lhsClass.isInstance(rhs)) {\n                 // lhsClass is a subclass of rhsClass\n                 testClass = lhsClass;\n             }\n         } else {\n             // The two classes are not related.\n             isEquals = false;\n             return this;\n         }\n \n         try {\n             if (testClass.isArray()) {\n                 append(lhs, rhs);\n             } else {\n-                reflectionAppend(lhs, rhs, testClass);\n-                while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\n-                    testClass = testClass.getSuperclass();\n+                //If either class is being excluded, call normal object equals method on lhsClass.\n+                if (bypassReflectionClasses != null\n+                        && (bypassReflectionClasses.contains(lhsClass) || bypassReflectionClasses.contains(rhsClass))) {\n+                    isEquals = lhs.equals(rhs);\n+                } else {\n                     reflectionAppend(lhs, rhs, testClass);\n+                    while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\n+                        testClass = testClass.getSuperclass();\n+                        reflectionAppend(lhs, rhs, testClass);\n+                    }\n                 }\n             }\n         } catch (final IllegalArgumentException e) {\n             // In this case, we tried to test a subclass vs. a superclass and\n             // the subclass has ivars or the ivars are transient and\n             // we are testing transients.\n             // If a subclass has ivars that we are trying to test them, we get an\n             // exception and we know that the objects are not equal.\n             isEquals = false;\n             return this;\n         }\n         return this;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0f6a292a29fedd49741310cd517ac4ba907bf8d4": {
			"type": "Ybodychange",
			"commitMessage": "LANG-1034: Add support for recursive comparison to EqualsBuilder#reflectionEquals (closes #202)\n\nminimal clean-ups: remove getter methods, improve javadoc, add unit test for reflectionAppend\n",
			"commitDate": "2016-11-13, 9:47 AM",
			"commitName": "0f6a292a29fedd49741310cd517ac4ba907bf8d4",
			"commitAuthor": "pascalschumacher",
			"commitDateOld": "2016-11-13, 9:47 AM",
			"commitNameOld": "0095d8adf26b9469115b1be0358cb09d1fcb5fd4",
			"commitAuthorOld": "pascalschumacher",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,57 +1,58 @@\n     public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n-        if(!isEquals)\n+        if (!isEquals) {\n             return this;\n-        \n+        }\n         if (lhs == rhs) {\n             return this;\n         }\n         if (lhs == null || rhs == null) {\n             isEquals = false;\n             return this;\n         }\n+\n         // Find the leaf class since there may be transients in the leaf\n         // class or in classes between the leaf and root.\n         // If we are not testing transients or a subclass has no ivars,\n         // then a subclass can test equals to a superclass.\n         final Class<?> lhsClass = lhs.getClass();\n         final Class<?> rhsClass = rhs.getClass();\n         Class<?> testClass;\n         if (lhsClass.isInstance(rhs)) {\n             testClass = lhsClass;\n             if (!rhsClass.isInstance(lhs)) {\n                 // rhsClass is a subclass of lhsClass\n                 testClass = rhsClass;\n             }\n         } else if (rhsClass.isInstance(lhs)) {\n             testClass = rhsClass;\n             if (!lhsClass.isInstance(rhs)) {\n                 // lhsClass is a subclass of rhsClass\n                 testClass = lhsClass;\n             }\n         } else {\n             // The two classes are not related.\n             isEquals = false;\n             return this;\n         }\n-        \n+\n         try {\n             if (testClass.isArray()) {\n                 append(lhs, rhs);\n             } else {\n                 reflectionAppend(lhs, rhs, testClass);\n                 while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\n                     testClass = testClass.getSuperclass();\n                     reflectionAppend(lhs, rhs, testClass);\n                 }\n             }\n         } catch (final IllegalArgumentException e) {\n             // In this case, we tried to test a subclass vs. a superclass and\n             // the subclass has ivars or the ivars are transient and\n             // we are testing transients.\n             // If a subclass has ivars that we are trying to test them, we get an\n             // exception and we know that the objects are not equal.\n             isEquals = false;\n             return this;\n         }\n         return this;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0095d8adf26b9469115b1be0358cb09d1fcb5fd4": {
			"type": "Ymultichange(Yparameterchange,Yreturntypechange,Ymodifierchange,Ybodychange)",
			"commitMessage": "LANG-1034: Recursive and reflective EqualsBuilder (closes #202)\n\npatch by yathos UG\n",
			"commitDate": "2016-11-13, 9:47 AM",
			"commitName": "0095d8adf26b9469115b1be0358cb09d1fcb5fd4",
			"commitAuthor": "pascalschumacher",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "LANG-1034: Recursive and reflective EqualsBuilder (closes #202)\n\npatch by yathos UG\n",
					"commitDate": "2016-11-13, 9:47 AM",
					"commitName": "0095d8adf26b9469115b1be0358cb09d1fcb5fd4",
					"commitAuthor": "pascalschumacher",
					"commitDateOld": "2016-10-23, 10:55 AM",
					"commitNameOld": "eb2b89efbe15ab0b70fd94f0ecd0aa03866fb4d2",
					"commitAuthorOld": "Gary Gregory",
					"daysBetweenCommits": 20.99,
					"commitsBetweenForRepo": 30,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,36 +1,57 @@\n-    private static void reflectionAppend(\n-        final Object lhs,\n-        final Object rhs,\n-        final Class<?> clazz,\n-        final EqualsBuilder builder,\n-        final boolean useTransients,\n-        final String[] excludeFields) {\n-\n-        if (isRegistered(lhs, rhs)) {\n-            return;\n+    public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n+        if(!isEquals)\n+            return this;\n+        \n+        if (lhs == rhs) {\n+            return this;\n         }\n-\n+        if (lhs == null || rhs == null) {\n+            isEquals = false;\n+            return this;\n+        }\n+        // Find the leaf class since there may be transients in the leaf\n+        // class or in classes between the leaf and root.\n+        // If we are not testing transients or a subclass has no ivars,\n+        // then a subclass can test equals to a superclass.\n+        final Class<?> lhsClass = lhs.getClass();\n+        final Class<?> rhsClass = rhs.getClass();\n+        Class<?> testClass;\n+        if (lhsClass.isInstance(rhs)) {\n+            testClass = lhsClass;\n+            if (!rhsClass.isInstance(lhs)) {\n+                // rhsClass is a subclass of lhsClass\n+                testClass = rhsClass;\n+            }\n+        } else if (rhsClass.isInstance(lhs)) {\n+            testClass = rhsClass;\n+            if (!lhsClass.isInstance(rhs)) {\n+                // lhsClass is a subclass of rhsClass\n+                testClass = lhsClass;\n+            }\n+        } else {\n+            // The two classes are not related.\n+            isEquals = false;\n+            return this;\n+        }\n+        \n         try {\n-            register(lhs, rhs);\n-            final Field[] fields = clazz.getDeclaredFields();\n-            AccessibleObject.setAccessible(fields, true);\n-            for (int i = 0; i < fields.length && builder.isEquals; i++) {\n-                final Field f = fields[i];\n-                if (!ArrayUtils.contains(excludeFields, f.getName())\n-                    && !f.getName().contains(\"$\")\n-                    && (useTransients || !Modifier.isTransient(f.getModifiers()))\n-                    && !Modifier.isStatic(f.getModifiers())\n-                    && !f.isAnnotationPresent(EqualsExclude.class)) {\n-                    try {\n-                        builder.append(f.get(lhs), f.get(rhs));\n-                    } catch (final IllegalAccessException e) {\n-                        //this can't happen. Would get a Security exception instead\n-                        //throw a runtime exception in case the impossible happens.\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\n-                    }\n+            if (testClass.isArray()) {\n+                append(lhs, rhs);\n+            } else {\n+                reflectionAppend(lhs, rhs, testClass);\n+                while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\n+                    testClass = testClass.getSuperclass();\n+                    reflectionAppend(lhs, rhs, testClass);\n                 }\n             }\n-        } finally {\n-            unregister(lhs, rhs);\n+        } catch (final IllegalArgumentException e) {\n+            // In this case, we tried to test a subclass vs. a superclass and\n+            // the subclass has ivars or the ivars are transient and\n+            // we are testing transients.\n+            // If a subclass has ivars that we are trying to test them, we get an\n+            // exception and we know that the objects are not equal.\n+            isEquals = false;\n+            return this;\n         }\n+        return this;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[lhs-Object(modifiers-final), rhs-Object(modifiers-final), clazz-Class<?>(modifiers-final), builder-EqualsBuilder(modifiers-final), useTransients-boolean(modifiers-final), excludeFields-String[](modifiers-final)]",
						"newValue": "[lhs-Object(modifiers-final), rhs-Object(modifiers-final)]"
					}
				},
				{
					"type": "Yreturntypechange",
					"commitMessage": "LANG-1034: Recursive and reflective EqualsBuilder (closes #202)\n\npatch by yathos UG\n",
					"commitDate": "2016-11-13, 9:47 AM",
					"commitName": "0095d8adf26b9469115b1be0358cb09d1fcb5fd4",
					"commitAuthor": "pascalschumacher",
					"commitDateOld": "2016-10-23, 10:55 AM",
					"commitNameOld": "eb2b89efbe15ab0b70fd94f0ecd0aa03866fb4d2",
					"commitAuthorOld": "Gary Gregory",
					"daysBetweenCommits": 20.99,
					"commitsBetweenForRepo": 30,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,36 +1,57 @@\n-    private static void reflectionAppend(\n-        final Object lhs,\n-        final Object rhs,\n-        final Class<?> clazz,\n-        final EqualsBuilder builder,\n-        final boolean useTransients,\n-        final String[] excludeFields) {\n-\n-        if (isRegistered(lhs, rhs)) {\n-            return;\n+    public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n+        if(!isEquals)\n+            return this;\n+        \n+        if (lhs == rhs) {\n+            return this;\n         }\n-\n+        if (lhs == null || rhs == null) {\n+            isEquals = false;\n+            return this;\n+        }\n+        // Find the leaf class since there may be transients in the leaf\n+        // class or in classes between the leaf and root.\n+        // If we are not testing transients or a subclass has no ivars,\n+        // then a subclass can test equals to a superclass.\n+        final Class<?> lhsClass = lhs.getClass();\n+        final Class<?> rhsClass = rhs.getClass();\n+        Class<?> testClass;\n+        if (lhsClass.isInstance(rhs)) {\n+            testClass = lhsClass;\n+            if (!rhsClass.isInstance(lhs)) {\n+                // rhsClass is a subclass of lhsClass\n+                testClass = rhsClass;\n+            }\n+        } else if (rhsClass.isInstance(lhs)) {\n+            testClass = rhsClass;\n+            if (!lhsClass.isInstance(rhs)) {\n+                // lhsClass is a subclass of rhsClass\n+                testClass = lhsClass;\n+            }\n+        } else {\n+            // The two classes are not related.\n+            isEquals = false;\n+            return this;\n+        }\n+        \n         try {\n-            register(lhs, rhs);\n-            final Field[] fields = clazz.getDeclaredFields();\n-            AccessibleObject.setAccessible(fields, true);\n-            for (int i = 0; i < fields.length && builder.isEquals; i++) {\n-                final Field f = fields[i];\n-                if (!ArrayUtils.contains(excludeFields, f.getName())\n-                    && !f.getName().contains(\"$\")\n-                    && (useTransients || !Modifier.isTransient(f.getModifiers()))\n-                    && !Modifier.isStatic(f.getModifiers())\n-                    && !f.isAnnotationPresent(EqualsExclude.class)) {\n-                    try {\n-                        builder.append(f.get(lhs), f.get(rhs));\n-                    } catch (final IllegalAccessException e) {\n-                        //this can't happen. Would get a Security exception instead\n-                        //throw a runtime exception in case the impossible happens.\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\n-                    }\n+            if (testClass.isArray()) {\n+                append(lhs, rhs);\n+            } else {\n+                reflectionAppend(lhs, rhs, testClass);\n+                while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\n+                    testClass = testClass.getSuperclass();\n+                    reflectionAppend(lhs, rhs, testClass);\n                 }\n             }\n-        } finally {\n-            unregister(lhs, rhs);\n+        } catch (final IllegalArgumentException e) {\n+            // In this case, we tried to test a subclass vs. a superclass and\n+            // the subclass has ivars or the ivars are transient and\n+            // we are testing transients.\n+            // If a subclass has ivars that we are trying to test them, we get an\n+            // exception and we know that the objects are not equal.\n+            isEquals = false;\n+            return this;\n         }\n+        return this;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "void",
						"newValue": "EqualsBuilder"
					}
				},
				{
					"type": "Ymodifierchange",
					"commitMessage": "LANG-1034: Recursive and reflective EqualsBuilder (closes #202)\n\npatch by yathos UG\n",
					"commitDate": "2016-11-13, 9:47 AM",
					"commitName": "0095d8adf26b9469115b1be0358cb09d1fcb5fd4",
					"commitAuthor": "pascalschumacher",
					"commitDateOld": "2016-10-23, 10:55 AM",
					"commitNameOld": "eb2b89efbe15ab0b70fd94f0ecd0aa03866fb4d2",
					"commitAuthorOld": "Gary Gregory",
					"daysBetweenCommits": 20.99,
					"commitsBetweenForRepo": 30,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,36 +1,57 @@\n-    private static void reflectionAppend(\n-        final Object lhs,\n-        final Object rhs,\n-        final Class<?> clazz,\n-        final EqualsBuilder builder,\n-        final boolean useTransients,\n-        final String[] excludeFields) {\n-\n-        if (isRegistered(lhs, rhs)) {\n-            return;\n+    public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n+        if(!isEquals)\n+            return this;\n+        \n+        if (lhs == rhs) {\n+            return this;\n         }\n-\n+        if (lhs == null || rhs == null) {\n+            isEquals = false;\n+            return this;\n+        }\n+        // Find the leaf class since there may be transients in the leaf\n+        // class or in classes between the leaf and root.\n+        // If we are not testing transients or a subclass has no ivars,\n+        // then a subclass can test equals to a superclass.\n+        final Class<?> lhsClass = lhs.getClass();\n+        final Class<?> rhsClass = rhs.getClass();\n+        Class<?> testClass;\n+        if (lhsClass.isInstance(rhs)) {\n+            testClass = lhsClass;\n+            if (!rhsClass.isInstance(lhs)) {\n+                // rhsClass is a subclass of lhsClass\n+                testClass = rhsClass;\n+            }\n+        } else if (rhsClass.isInstance(lhs)) {\n+            testClass = rhsClass;\n+            if (!lhsClass.isInstance(rhs)) {\n+                // lhsClass is a subclass of rhsClass\n+                testClass = lhsClass;\n+            }\n+        } else {\n+            // The two classes are not related.\n+            isEquals = false;\n+            return this;\n+        }\n+        \n         try {\n-            register(lhs, rhs);\n-            final Field[] fields = clazz.getDeclaredFields();\n-            AccessibleObject.setAccessible(fields, true);\n-            for (int i = 0; i < fields.length && builder.isEquals; i++) {\n-                final Field f = fields[i];\n-                if (!ArrayUtils.contains(excludeFields, f.getName())\n-                    && !f.getName().contains(\"$\")\n-                    && (useTransients || !Modifier.isTransient(f.getModifiers()))\n-                    && !Modifier.isStatic(f.getModifiers())\n-                    && !f.isAnnotationPresent(EqualsExclude.class)) {\n-                    try {\n-                        builder.append(f.get(lhs), f.get(rhs));\n-                    } catch (final IllegalAccessException e) {\n-                        //this can't happen. Would get a Security exception instead\n-                        //throw a runtime exception in case the impossible happens.\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\n-                    }\n+            if (testClass.isArray()) {\n+                append(lhs, rhs);\n+            } else {\n+                reflectionAppend(lhs, rhs, testClass);\n+                while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\n+                    testClass = testClass.getSuperclass();\n+                    reflectionAppend(lhs, rhs, testClass);\n                 }\n             }\n-        } finally {\n-            unregister(lhs, rhs);\n+        } catch (final IllegalArgumentException e) {\n+            // In this case, we tried to test a subclass vs. a superclass and\n+            // the subclass has ivars or the ivars are transient and\n+            // we are testing transients.\n+            // If a subclass has ivars that we are trying to test them, we get an\n+            // exception and we know that the objects are not equal.\n+            isEquals = false;\n+            return this;\n         }\n+        return this;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[private, static]",
						"newValue": "[public]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "LANG-1034: Recursive and reflective EqualsBuilder (closes #202)\n\npatch by yathos UG\n",
					"commitDate": "2016-11-13, 9:47 AM",
					"commitName": "0095d8adf26b9469115b1be0358cb09d1fcb5fd4",
					"commitAuthor": "pascalschumacher",
					"commitDateOld": "2016-10-23, 10:55 AM",
					"commitNameOld": "eb2b89efbe15ab0b70fd94f0ecd0aa03866fb4d2",
					"commitAuthorOld": "Gary Gregory",
					"daysBetweenCommits": 20.99,
					"commitsBetweenForRepo": 30,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,36 +1,57 @@\n-    private static void reflectionAppend(\n-        final Object lhs,\n-        final Object rhs,\n-        final Class<?> clazz,\n-        final EqualsBuilder builder,\n-        final boolean useTransients,\n-        final String[] excludeFields) {\n-\n-        if (isRegistered(lhs, rhs)) {\n-            return;\n+    public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n+        if(!isEquals)\n+            return this;\n+        \n+        if (lhs == rhs) {\n+            return this;\n         }\n-\n+        if (lhs == null || rhs == null) {\n+            isEquals = false;\n+            return this;\n+        }\n+        // Find the leaf class since there may be transients in the leaf\n+        // class or in classes between the leaf and root.\n+        // If we are not testing transients or a subclass has no ivars,\n+        // then a subclass can test equals to a superclass.\n+        final Class<?> lhsClass = lhs.getClass();\n+        final Class<?> rhsClass = rhs.getClass();\n+        Class<?> testClass;\n+        if (lhsClass.isInstance(rhs)) {\n+            testClass = lhsClass;\n+            if (!rhsClass.isInstance(lhs)) {\n+                // rhsClass is a subclass of lhsClass\n+                testClass = rhsClass;\n+            }\n+        } else if (rhsClass.isInstance(lhs)) {\n+            testClass = rhsClass;\n+            if (!lhsClass.isInstance(rhs)) {\n+                // lhsClass is a subclass of rhsClass\n+                testClass = lhsClass;\n+            }\n+        } else {\n+            // The two classes are not related.\n+            isEquals = false;\n+            return this;\n+        }\n+        \n         try {\n-            register(lhs, rhs);\n-            final Field[] fields = clazz.getDeclaredFields();\n-            AccessibleObject.setAccessible(fields, true);\n-            for (int i = 0; i < fields.length && builder.isEquals; i++) {\n-                final Field f = fields[i];\n-                if (!ArrayUtils.contains(excludeFields, f.getName())\n-                    && !f.getName().contains(\"$\")\n-                    && (useTransients || !Modifier.isTransient(f.getModifiers()))\n-                    && !Modifier.isStatic(f.getModifiers())\n-                    && !f.isAnnotationPresent(EqualsExclude.class)) {\n-                    try {\n-                        builder.append(f.get(lhs), f.get(rhs));\n-                    } catch (final IllegalAccessException e) {\n-                        //this can't happen. Would get a Security exception instead\n-                        //throw a runtime exception in case the impossible happens.\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\n-                    }\n+            if (testClass.isArray()) {\n+                append(lhs, rhs);\n+            } else {\n+                reflectionAppend(lhs, rhs, testClass);\n+                while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\n+                    testClass = testClass.getSuperclass();\n+                    reflectionAppend(lhs, rhs, testClass);\n                 }\n             }\n-        } finally {\n-            unregister(lhs, rhs);\n+        } catch (final IllegalArgumentException e) {\n+            // In this case, we tried to test a subclass vs. a superclass and\n+            // the subclass has ivars or the ivars are transient and\n+            // we are testing transients.\n+            // If a subclass has ivars that we are trying to test them, we get an\n+            // exception and we know that the objects are not equal.\n+            isEquals = false;\n+            return this;\n         }\n+        return this;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"9c5b6cdc7108eb071785b0c4edd205650cdf1ca4": {
			"type": "Ybodychange",
			"commitMessage": "PMD: Remove useless parentheses\n",
			"commitDate": "2016-09-19, 4:56 AM",
			"commitName": "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4",
			"commitAuthor": "Benedikt Ritter",
			"commitDateOld": "2016-08-21, 10:14 AM",
			"commitNameOld": "b2c1afce7eb13ea44fc7d25562cc3bb83cc91b2f",
			"commitAuthorOld": "Philippe Marschall",
			"daysBetweenCommits": 28.78,
			"commitsBetweenForRepo": 60,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,36 +1,36 @@\n     private static void reflectionAppend(\n         final Object lhs,\n         final Object rhs,\n         final Class<?> clazz,\n         final EqualsBuilder builder,\n         final boolean useTransients,\n         final String[] excludeFields) {\n \n         if (isRegistered(lhs, rhs)) {\n             return;\n         }\n \n         try {\n             register(lhs, rhs);\n             final Field[] fields = clazz.getDeclaredFields();\n             AccessibleObject.setAccessible(fields, true);\n             for (int i = 0; i < fields.length && builder.isEquals; i++) {\n                 final Field f = fields[i];\n                 if (!ArrayUtils.contains(excludeFields, f.getName())\n                     && !f.getName().contains(\"$\")\n                     && (useTransients || !Modifier.isTransient(f.getModifiers()))\n-                    && (!Modifier.isStatic(f.getModifiers()))\n-                    && (!f.isAnnotationPresent(EqualsExclude.class))) {\n+                    && !Modifier.isStatic(f.getModifiers())\n+                    && !f.isAnnotationPresent(EqualsExclude.class)) {\n                     try {\n                         builder.append(f.get(lhs), f.get(rhs));\n                     } catch (final IllegalAccessException e) {\n                         //this can't happen. Would get a Security exception instead\n                         //throw a runtime exception in case the impossible happens.\n                         throw new InternalError(\"Unexpected IllegalAccessException\");\n                     }\n                 }\n             }\n         } finally {\n             unregister(lhs, rhs);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"aeb6f86bcdec061ee9c6be96066fa19c56523490": {
			"type": "Ybodychange",
			"commitMessage": "EqualsExlcude notation, HashCodeExclude notation and ToStringExludeNotation\n",
			"commitDate": "2015-05-03, 11:59 AM",
			"commitName": "aeb6f86bcdec061ee9c6be96066fa19c56523490",
			"commitAuthor": "Felipe Adorno",
			"commitDateOld": "2015-04-06, 12:44 PM",
			"commitNameOld": "11491d355da8a851d6badb6348b10d8c4acc9d8e",
			"commitAuthorOld": "Benedikt Ritter",
			"daysBetweenCommits": 26.97,
			"commitsBetweenForRepo": 81,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,35 +1,36 @@\n     private static void reflectionAppend(\n         final Object lhs,\n         final Object rhs,\n         final Class<?> clazz,\n         final EqualsBuilder builder,\n         final boolean useTransients,\n         final String[] excludeFields) {\n \n         if (isRegistered(lhs, rhs)) {\n             return;\n         }\n \n         try {\n             register(lhs, rhs);\n             final Field[] fields = clazz.getDeclaredFields();\n             AccessibleObject.setAccessible(fields, true);\n             for (int i = 0; i < fields.length && builder.isEquals; i++) {\n                 final Field f = fields[i];\n                 if (!ArrayUtils.contains(excludeFields, f.getName())\n                     && !f.getName().contains(\"$\")\n                     && (useTransients || !Modifier.isTransient(f.getModifiers()))\n-                    && !Modifier.isStatic(f.getModifiers())) {\n+                    && (!Modifier.isStatic(f.getModifiers()))\n+                    && (!f.isAnnotationPresent(EqualsExclude.class))) {\n                     try {\n                         builder.append(f.get(lhs), f.get(rhs));\n                     } catch (final IllegalAccessException e) {\n                         //this can't happen. Would get a Security exception instead\n                         //throw a runtime exception in case the impossible happens.\n                         throw new InternalError(\"Unexpected IllegalAccessException\");\n                     }\n                 }\n             }\n         } finally {\n             unregister(lhs, rhs);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9072a7615a54d5e753cf088326d9e14f1a5a6751": {
			"type": "Ybodychange",
			"commitMessage": "PMD: Useless parentheses\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1671669 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2015-04-06, 12:41 PM",
			"commitName": "9072a7615a54d5e753cf088326d9e14f1a5a6751",
			"commitAuthor": "Benedikt Ritter",
			"commitDateOld": "2015-04-06, 12:37 PM",
			"commitNameOld": "f525bc3ccd9cfb69603bd9778998263a458415d0",
			"commitAuthorOld": "Benedikt Ritter",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,35 +1,35 @@\n     private static void reflectionAppend(\n         final Object lhs,\n         final Object rhs,\n         final Class<?> clazz,\n         final EqualsBuilder builder,\n         final boolean useTransients,\n         final String[] excludeFields) {\n \n         if (isRegistered(lhs, rhs)) {\n             return;\n         }\n \n         try {\n             register(lhs, rhs);\n             final Field[] fields = clazz.getDeclaredFields();\n             AccessibleObject.setAccessible(fields, true);\n             for (int i = 0; i < fields.length && builder.isEquals; i++) {\n                 final Field f = fields[i];\n                 if (!ArrayUtils.contains(excludeFields, f.getName())\n-                    && (!f.getName().contains(\"$\"))\n+                    && !f.getName().contains(\"$\")\n                     && (useTransients || !Modifier.isTransient(f.getModifiers()))\n-                    && (!Modifier.isStatic(f.getModifiers()))) {\n+                    && !Modifier.isStatic(f.getModifiers())) {\n                     try {\n                         builder.append(f.get(lhs), f.get(rhs));\n                     } catch (final IllegalAccessException e) {\n                         //this can't happen. Would get a Security exception instead\n                         //throw a runtime exception in case the impossible happens.\n                         throw new InternalError(\"Unexpected IllegalAccessException\");\n                     }\n                 }\n             }\n         } finally {\n             unregister(lhs, rhs);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f525bc3ccd9cfb69603bd9778998263a458415d0": {
			"type": "Ybodychange",
			"commitMessage": "Use not String.contains instead of indexOf == -1\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1671666 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2015-04-06, 12:37 PM",
			"commitName": "f525bc3ccd9cfb69603bd9778998263a458415d0",
			"commitAuthor": "Benedikt Ritter",
			"commitDateOld": "2014-09-10, 4:32 AM",
			"commitNameOld": "2154d5fbf8cc02cc4d51b63d6a532af06cccd0fc",
			"commitAuthorOld": "Duncan Jones",
			"daysBetweenCommits": 208.34,
			"commitsBetweenForRepo": 139,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,35 +1,35 @@\n     private static void reflectionAppend(\n         final Object lhs,\n         final Object rhs,\n         final Class<?> clazz,\n         final EqualsBuilder builder,\n         final boolean useTransients,\n         final String[] excludeFields) {\n \n         if (isRegistered(lhs, rhs)) {\n             return;\n         }\n \n         try {\n             register(lhs, rhs);\n             final Field[] fields = clazz.getDeclaredFields();\n             AccessibleObject.setAccessible(fields, true);\n             for (int i = 0; i < fields.length && builder.isEquals; i++) {\n                 final Field f = fields[i];\n                 if (!ArrayUtils.contains(excludeFields, f.getName())\n-                    && (f.getName().indexOf('$') == -1)\n+                    && (!f.getName().contains(\"$\"))\n                     && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                     && (!Modifier.isStatic(f.getModifiers()))) {\n                     try {\n                         builder.append(f.get(lhs), f.get(rhs));\n                     } catch (final IllegalAccessException e) {\n                         //this can't happen. Would get a Security exception instead\n                         //throw a runtime exception in case the impossible happens.\n                         throw new InternalError(\"Unexpected IllegalAccessException\");\n                     }\n                 }\n             }\n         } finally {\n             unregister(lhs, rhs);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5292526e476ffbb19c6613a98464054236c86ace": {
			"type": "Ybodychange",
			"commitMessage": "Add final modifier to local variables.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436770 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-01-21, 11:09 PM",
			"commitName": "5292526e476ffbb19c6613a98464054236c86ace",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2013-01-21, 11:07 PM",
			"commitNameOld": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,35 +1,35 @@\n     private static void reflectionAppend(\n         final Object lhs,\n         final Object rhs,\n         final Class<?> clazz,\n         final EqualsBuilder builder,\n         final boolean useTransients,\n         final String[] excludeFields) {\n \n         if (isRegistered(lhs, rhs)) {\n             return;\n         }\n \n         try {\n             register(lhs, rhs);\n-            Field[] fields = clazz.getDeclaredFields();\n+            final Field[] fields = clazz.getDeclaredFields();\n             AccessibleObject.setAccessible(fields, true);\n             for (int i = 0; i < fields.length && builder.isEquals; i++) {\n-                Field f = fields[i];\n+                final Field f = fields[i];\n                 if (!ArrayUtils.contains(excludeFields, f.getName())\n                     && (f.getName().indexOf('$') == -1)\n                     && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                     && (!Modifier.isStatic(f.getModifiers()))) {\n                     try {\n                         builder.append(f.get(lhs), f.get(rhs));\n-                    } catch (IllegalAccessException e) {\n+                    } catch (final IllegalAccessException e) {\n                         //this can't happen. Would get a Security exception instead\n                         //throw a runtime exception in case the impossible happens.\n                         throw new InternalError(\"Unexpected IllegalAccessException\");\n                     }\n                 }\n             }\n         } finally {\n             unregister(lhs, rhs);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5bd622dab027ef37001a630a7c825c5b8c19d1db": {
			"type": "Yparametermetachange",
			"commitMessage": "Add final modifier to method parameters.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436768 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-01-21, 11:07 PM",
			"commitName": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2012-04-05, 10:53 AM",
			"commitNameOld": "b819343483d33cc529b785935cea9bfc2fc080e5",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 291.55,
			"commitsBetweenForRepo": 179,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,35 +1,35 @@\n     private static void reflectionAppend(\n-        Object lhs,\n-        Object rhs,\n-        Class<?> clazz,\n-        EqualsBuilder builder,\n-        boolean useTransients,\n-        String[] excludeFields) {\n+        final Object lhs,\n+        final Object rhs,\n+        final Class<?> clazz,\n+        final EqualsBuilder builder,\n+        final boolean useTransients,\n+        final String[] excludeFields) {\n \n         if (isRegistered(lhs, rhs)) {\n             return;\n         }\n \n         try {\n             register(lhs, rhs);\n             Field[] fields = clazz.getDeclaredFields();\n             AccessibleObject.setAccessible(fields, true);\n             for (int i = 0; i < fields.length && builder.isEquals; i++) {\n                 Field f = fields[i];\n                 if (!ArrayUtils.contains(excludeFields, f.getName())\n                     && (f.getName().indexOf('$') == -1)\n                     && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                     && (!Modifier.isStatic(f.getModifiers()))) {\n                     try {\n                         builder.append(f.get(lhs), f.get(rhs));\n                     } catch (IllegalAccessException e) {\n                         //this can't happen. Would get a Security exception instead\n                         //throw a runtime exception in case the impossible happens.\n                         throw new InternalError(\"Unexpected IllegalAccessException\");\n                     }\n                 }\n             }\n         } finally {\n             unregister(lhs, rhs);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[lhs-Object, rhs-Object, clazz-Class<?>, builder-EqualsBuilder, useTransients-boolean, excludeFields-String[]]",
				"newValue": "[lhs-Object(modifiers-final), rhs-Object(modifiers-final), clazz-Class<?>(modifiers-final), builder-EqualsBuilder(modifiers-final), useTransients-boolean(modifiers-final), excludeFields-String[](modifiers-final)]"
			}
		},
		"1a60c21395fe7648188d1c91f62ac7baefa12742": {
			"type": "Ybodychange",
			"commitMessage": "Applying the copy of the HashCodeBuilder code to stop cyclic references over to EqualsBuilder per LANG-606 and Oliver Sauder's patch\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@925671 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-03-20, 1:16 PM",
			"commitName": "1a60c21395fe7648188d1c91f62ac7baefa12742",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2010-02-24, 5:28 PM",
			"commitNameOld": "43fca0d7499c99f9e82e0ee2e52b81acdc954f2c",
			"commitAuthorOld": "Niall Pemberton",
			"daysBetweenCommits": 23.78,
			"commitsBetweenForRepo": 47,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,25 +1,35 @@\n     private static void reflectionAppend(\n         Object lhs,\n         Object rhs,\n         Class<?> clazz,\n         EqualsBuilder builder,\n         boolean useTransients,\n         String[] excludeFields) {\n-        Field[] fields = clazz.getDeclaredFields();\n-        AccessibleObject.setAccessible(fields, true);\n-        for (int i = 0; i < fields.length && builder.isEquals; i++) {\n-            Field f = fields[i];\n-            if (!ArrayUtils.contains(excludeFields, f.getName())\n-                && (f.getName().indexOf('$') == -1)\n-                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n-                && (!Modifier.isStatic(f.getModifiers()))) {\n-                try {\n-                    builder.append(f.get(lhs), f.get(rhs));\n-                } catch (IllegalAccessException e) {\n-                    //this can't happen. Would get a Security exception instead\n-                    //throw a runtime exception in case the impossible happens.\n-                    throw new InternalError(\"Unexpected IllegalAccessException\");\n+        \n+        if (isRegistered(lhs, rhs)) {\n+            return;\n+        }\n+        \n+        try {\n+            register(lhs, rhs);\n+            Field[] fields = clazz.getDeclaredFields();\n+            AccessibleObject.setAccessible(fields, true);\n+            for (int i = 0; i < fields.length && builder.isEquals; i++) {\n+                Field f = fields[i];\n+                if (!ArrayUtils.contains(excludeFields, f.getName())\n+                    && (f.getName().indexOf('$') == -1)\n+                    && (useTransients || !Modifier.isTransient(f.getModifiers()))\n+                    && (!Modifier.isStatic(f.getModifiers()))) {\n+                    try {\n+                        builder.append(f.get(lhs), f.get(rhs));\n+                    } catch (IllegalAccessException e) {\n+                        //this can't happen. Would get a Security exception instead\n+                        //throw a runtime exception in case the impossible happens.\n+                        throw new InternalError(\"Unexpected IllegalAccessException\");\n+                    }\n                 }\n             }\n+        } finally {\n+            unregister(lhs, rhs);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5494a87bbb6d6b6f0d176d0c93e4f25718ed3c2a": {
			"type": "Ybodychange",
			"commitMessage": "Replacing the creation of a List in the core of each Builder class to test contains on the excludeFields with a call to ArrayUtils.contains. Reported by Anthony Whitford in LANG-575\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@897421 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-01-09, 3:44 AM",
			"commitName": "5494a87bbb6d6b6f0d176d0c93e4f25718ed3c2a",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2010-01-02, 6:11 PM",
			"commitNameOld": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
			"commitAuthorOld": "Paul C. Benedict Jr",
			"daysBetweenCommits": 6.4,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,26 +1,25 @@\n     private static void reflectionAppend(\n         Object lhs,\n         Object rhs,\n         Class<?> clazz,\n         EqualsBuilder builder,\n         boolean useTransients,\n         String[] excludeFields) {\n         Field[] fields = clazz.getDeclaredFields();\n-        List<String> excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.<String>emptyList();\n         AccessibleObject.setAccessible(fields, true);\n         for (int i = 0; i < fields.length && builder.isEquals; i++) {\n             Field f = fields[i];\n-            if (!excludedFieldList.contains(f.getName())\n+            if (!ArrayUtils.contains(excludeFields, f.getName())\n                 && (f.getName().indexOf('$') == -1)\n                 && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                 && (!Modifier.isStatic(f.getModifiers()))) {\n                 try {\n                     builder.append(f.get(lhs), f.get(rhs));\n                 } catch (IllegalAccessException e) {\n                     //this can't happen. Would get a Security exception instead\n                     //throw a runtime exception in case the impossible happens.\n                     throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fc5c081e22a61bb5a6810af302be3f22f7966df4": {
			"type": "Yfilerename",
			"commitMessage": "Move main source to src/main/java\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@895322 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-01-02, 6:11 PM",
			"commitName": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
			"commitAuthor": "Paul C. Benedict Jr",
			"commitDateOld": "2010-01-02, 6:09 PM",
			"commitNameOld": "6b32246f5f9f77c74b32a5290cdbdd4e0f5c71c6",
			"commitAuthorOld": "Paul C. Benedict Jr",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
				"newPath": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java"
			}
		},
		"debc02c6d9b94c717b4182ae4dd7a97d47293a52": {
			"type": "Yfilerename",
			"commitMessage": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@889202 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2009-12-10, 3:33 AM",
			"commitName": "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2009-12-10, 3:31 AM",
			"commitNameOld": "375d7d0954cae60c4c7292cc65abbc972178857c",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/java/org/apache/commons/lang/builder/EqualsBuilder.java",
				"newPath": "src/java/org/apache/commons/lang3/builder/EqualsBuilder.java"
			}
		},
		"ca3a3baa651465310d31824250318bd500fa9e8b": {
			"type": "Ybodychange",
			"commitMessage": "Genericizing excludeFieldList variablle - LANG-336\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@772548 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2009-05-07, 1:31 AM",
			"commitName": "ca3a3baa651465310d31824250318bd500fa9e8b",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2009-03-15, 8:35 PM",
			"commitNameOld": "654fb75d80a63fa551ced73c3b652f4120573590",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 52.21,
			"commitsBetweenForRepo": 26,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,26 +1,26 @@\n     private static void reflectionAppend(\n         Object lhs,\n         Object rhs,\n         Class<?> clazz,\n         EqualsBuilder builder,\n         boolean useTransients,\n         String[] excludeFields) {\n         Field[] fields = clazz.getDeclaredFields();\n-        List excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n+        List<String> excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.<String>emptyList();\n         AccessibleObject.setAccessible(fields, true);\n         for (int i = 0; i < fields.length && builder.isEquals; i++) {\n             Field f = fields[i];\n             if (!excludedFieldList.contains(f.getName())\n                 && (f.getName().indexOf('$') == -1)\n                 && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                 && (!Modifier.isStatic(f.getModifiers()))) {\n                 try {\n                     builder.append(f.get(lhs), f.get(rhs));\n                 } catch (IllegalAccessException e) {\n                     //this can't happen. Would get a Security exception instead\n                     //throw a runtime exception in case the impossible happens.\n                     throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"654fb75d80a63fa551ced73c3b652f4120573590": {
			"type": "Yparameterchange",
			"commitMessage": "Genericize some more classes\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@754810 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2009-03-15, 8:35 PM",
			"commitName": "654fb75d80a63fa551ced73c3b652f4120573590",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2008-11-06, 12:36 PM",
			"commitNameOld": "b1e8a26177324ece7c786da8cd063076bc131ea1",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 129.29,
			"commitsBetweenForRepo": 94,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,26 +1,26 @@\n     private static void reflectionAppend(\n         Object lhs,\n         Object rhs,\n-        Class clazz,\n+        Class<?> clazz,\n         EqualsBuilder builder,\n         boolean useTransients,\n         String[] excludeFields) {\n         Field[] fields = clazz.getDeclaredFields();\n         List excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n         AccessibleObject.setAccessible(fields, true);\n         for (int i = 0; i < fields.length && builder.isEquals; i++) {\n             Field f = fields[i];\n             if (!excludedFieldList.contains(f.getName())\n                 && (f.getName().indexOf('$') == -1)\n                 && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                 && (!Modifier.isStatic(f.getModifiers()))) {\n                 try {\n                     builder.append(f.get(lhs), f.get(rhs));\n                 } catch (IllegalAccessException e) {\n                     //this can't happen. Would get a Security exception instead\n                     //throw a runtime exception in case the impossible happens.\n                     throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[lhs-Object, rhs-Object, clazz-Class, builder-EqualsBuilder, useTransients-boolean, excludeFields-String[]]",
				"newValue": "[lhs-Object, rhs-Object, clazz-Class<?>, builder-EqualsBuilder, useTransients-boolean, excludeFields-String[]]"
			}
		},
		"8393f10b791c4fd28a1031f0a6427a2c9af04977": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Adding new excludeFields functionality for EqualsBuilder and HashCodeBuilder, as submitted by Pete Gieser, Bugzilla: #39315\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@396461 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2006-04-24, 12:00 AM",
			"commitName": "8393f10b791c4fd28a1031f0a6427a2c9af04977",
			"commitAuthor": "Henri Yandell",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Adding new excludeFields functionality for EqualsBuilder and HashCodeBuilder, as submitted by Pete Gieser, Bugzilla: #39315\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@396461 13f79535-47bb-0310-9956-ffa450edef68\n",
					"commitDate": "2006-04-24, 12:00 AM",
					"commitName": "8393f10b791c4fd28a1031f0a6427a2c9af04977",
					"commitAuthor": "Henri Yandell",
					"commitDateOld": "2005-04-13, 9:30 PM",
					"commitNameOld": "4f69e5183a56d6a38a76ebafcb12637c0ecb8f4c",
					"commitAuthorOld": "Gary D. Gregory",
					"daysBetweenCommits": 375.1,
					"commitsBetweenForRepo": 266,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,23 +1,26 @@\n     private static void reflectionAppend(\n         Object lhs,\n         Object rhs,\n         Class clazz,\n         EqualsBuilder builder,\n-        boolean useTransients) {\n+        boolean useTransients,\n+        String[] excludeFields) {\n         Field[] fields = clazz.getDeclaredFields();\n+        List excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n         AccessibleObject.setAccessible(fields, true);\n         for (int i = 0; i < fields.length && builder.isEquals; i++) {\n             Field f = fields[i];\n-            if ((f.getName().indexOf('$') == -1)\n+            if (!excludedFieldList.contains(f.getName())\n+                && (f.getName().indexOf('$') == -1)\n                 && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                 && (!Modifier.isStatic(f.getModifiers()))) {\n                 try {\n                     builder.append(f.get(lhs), f.get(rhs));\n                 } catch (IllegalAccessException e) {\n                     //this can't happen. Would get a Security exception instead\n                     //throw a runtime exception in case the impossible happens.\n                     throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[lhs-Object, rhs-Object, clazz-Class, builder-EqualsBuilder, useTransients-boolean]",
						"newValue": "[lhs-Object, rhs-Object, clazz-Class, builder-EqualsBuilder, useTransients-boolean, excludeFields-String[]]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Adding new excludeFields functionality for EqualsBuilder and HashCodeBuilder, as submitted by Pete Gieser, Bugzilla: #39315\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@396461 13f79535-47bb-0310-9956-ffa450edef68\n",
					"commitDate": "2006-04-24, 12:00 AM",
					"commitName": "8393f10b791c4fd28a1031f0a6427a2c9af04977",
					"commitAuthor": "Henri Yandell",
					"commitDateOld": "2005-04-13, 9:30 PM",
					"commitNameOld": "4f69e5183a56d6a38a76ebafcb12637c0ecb8f4c",
					"commitAuthorOld": "Gary D. Gregory",
					"daysBetweenCommits": 375.1,
					"commitsBetweenForRepo": 266,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,23 +1,26 @@\n     private static void reflectionAppend(\n         Object lhs,\n         Object rhs,\n         Class clazz,\n         EqualsBuilder builder,\n-        boolean useTransients) {\n+        boolean useTransients,\n+        String[] excludeFields) {\n         Field[] fields = clazz.getDeclaredFields();\n+        List excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n         AccessibleObject.setAccessible(fields, true);\n         for (int i = 0; i < fields.length && builder.isEquals; i++) {\n             Field f = fields[i];\n-            if ((f.getName().indexOf('$') == -1)\n+            if (!excludedFieldList.contains(f.getName())\n+                && (f.getName().indexOf('$') == -1)\n                 && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                 && (!Modifier.isStatic(f.getModifiers()))) {\n                 try {\n                     builder.append(f.get(lhs), f.get(rhs));\n                 } catch (IllegalAccessException e) {\n                     //this can't happen. Would get a Security exception instead\n                     //throw a runtime exception in case the impossible happens.\n                     throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"d27569f61a49489dd72e4b8a1ed4b0648008b3d5": {
			"type": "Ybodychange",
			"commitMessage": "Severity\tDescription\tResource\tIn Folder\tLocation\tCreation Time\n\tThe static method setAccessible(AccessibleObject[], boolean) from the type AccessibleObject should be accessed directly \tEqualsBuilder.java\tApache Jakarta Commons/lang/src/java/org/apache/commons/lang/builder\tline 268\tJuly 19, 2003 6:10:35 PM\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137465 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2003-07-19, 6:11 PM",
			"commitName": "d27569f61a49489dd72e4b8a1ed4b0648008b3d5",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2003-07-14, 3:25 PM",
			"commitNameOld": "eadb45d1a7b8b16164171c7caa171fd9f911a414",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 5.12,
			"commitsBetweenForRepo": 48,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,23 +1,23 @@\n     private static void reflectionAppend(\n         Object lhs,\n         Object rhs,\n         Class clazz,\n         EqualsBuilder builder,\n         boolean useTransients) {\n         Field[] fields = clazz.getDeclaredFields();\n-        Field.setAccessible(fields, true);\n+        AccessibleObject.setAccessible(fields, true);\n         for (int i = 0; i < fields.length && builder.isEquals; i++) {\n             Field f = fields[i];\n             if ((f.getName().indexOf('$') == -1)\n                 && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                 && (!Modifier.isStatic(f.getModifiers()))) {\n                 try {\n                     builder.append(f.get(lhs), f.get(rhs));\n                 } catch (IllegalAccessException e) {\n                     //this can't happen. Would get a Security exception instead\n                     //throw a runtime exception in case the impossible happens.\n                     throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"984bc76cd36138514e8c3c2cd494cd952d22dd13": {
			"type": "Ybodychange",
			"commitMessage": "Fix infinite recursion in inner classes reflection methods\nfrom Per Velschow\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137232 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2003-01-19, 10:49 AM",
			"commitName": "984bc76cd36138514e8c3c2cd494cd952d22dd13",
			"commitAuthor": "Stephen Colebourne",
			"commitDateOld": "2003-01-19, 9:35 AM",
			"commitNameOld": "5c40090fecdacd9366bba7e3e29d94f213cf2633",
			"commitAuthorOld": "Stephen Colebourne",
			"daysBetweenCommits": 0.05,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,17 +1,18 @@\n     private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients) {\n         Field[] fields = clazz.getDeclaredFields();\n         Field.setAccessible(fields, true);\n         for (int i = 0; i < fields.length && builder.isEquals; i++) {\n             Field f = fields[i];\n-            if (useTransients || !Modifier.isTransient(f.getModifiers())) {\n-                if (!Modifier.isStatic(f.getModifiers())) {\n-                    try {\n-                        builder.append(f.get(lhs), f.get(rhs));\n-                    } catch (IllegalAccessException e) {\n-                        //this can't happen. Would get a Security exception instead\n-                        //throw a runtime exception in case the impossible happens.\n-                    }\n+            if ((f.getName().indexOf('$') == -1) &&\n+                (useTransients || !Modifier.isTransient(f.getModifiers())) &&\n+                (!Modifier.isStatic(f.getModifiers()))) {\n+                try {\n+                    builder.append(f.get(lhs), f.get(rhs));\n+                } catch (IllegalAccessException e) {\n+                    //this can't happen. Would get a Security exception instead\n+                    //throw a runtime exception in case the impossible happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5c40090fecdacd9366bba7e3e29d94f213cf2633": {
			"type": "Yintroduced",
			"commitMessage": "Add superclass behaviour to builder classes\nfrom Gary Gregory\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137228 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2003-01-19, 9:35 AM",
			"commitName": "5c40090fecdacd9366bba7e3e29d94f213cf2633",
			"commitAuthor": "Stephen Colebourne",
			"diff": "@@ -0,0 +1,17 @@\n+    private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients) {\n+        Field[] fields = clazz.getDeclaredFields();\n+        Field.setAccessible(fields, true);\n+        for (int i = 0; i < fields.length && builder.isEquals; i++) {\n+            Field f = fields[i];\n+            if (useTransients || !Modifier.isTransient(f.getModifiers())) {\n+                if (!Modifier.isStatic(f.getModifiers())) {\n+                    try {\n+                        builder.append(f.get(lhs), f.get(rhs));\n+                    } catch (IllegalAccessException e) {\n+                        //this can't happen. Would get a Security exception instead\n+                        //throw a runtime exception in case the impossible happens.\n+                    }\n+                }\n+            }\n+        }\n+    }\n\\ No newline at end of file\n"
		}
	},
	"sha": "a36c903d4f1065bc59f5e6d2bb0f9d92a5e71d83"
}