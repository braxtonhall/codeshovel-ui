{
	"repo": "https://github.com/apache/lucene-solr.git",
	"file": "lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java",
	"method": {
		"longName": "private void storeDocValues(Info info, DocValuesType docValuesType, Object docValuesValue);",
		"startLine": 515,
		"methodName": "storeDocValues",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "private"
	},
	"history": {
		"e7a0a12926c399758a4021715a7419e22e59dab6": {
			"type": "Ybodychange",
			"commitMessage": "LUCENE-8335: Enforce soft-deletes field up-front\n\nSoft deletes field must be marked as such once it's introduced\nand can't be changed after the fact.\n\nCo-authored-by: Nhat Nguyen <nhat.nguyen@elastic.co>\n",
			"commitDate": "2018-06-03, 11:28 PM",
			"commitName": "e7a0a12926c399758a4021715a7419e22e59dab6",
			"commitAuthor": "Simon Willnauer",
			"commitDateOld": "2018-06-02, 4:47 AM",
			"commitNameOld": "3dc4fa199c175ed6351f66bac5c23c73b4e3f89a",
			"commitAuthorOld": "Simon Willnauer",
			"daysBetweenCommits": 1.78,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,52 +1,52 @@\n   private void storeDocValues(Info info, DocValuesType docValuesType, Object docValuesValue) {\n     String fieldName = info.fieldInfo.name;\n     DocValuesType existingDocValuesType = info.fieldInfo.getDocValuesType();\n     if (existingDocValuesType == DocValuesType.NONE) {\n       // first time we add doc values for this field:\n       info.fieldInfo = new FieldInfo(\n           info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(),\n           info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(),\n-          info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes()\n+          info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes(), info.fieldInfo.isSoftDeletesField()\n       );\n     } else if (existingDocValuesType != docValuesType) {\n       throw new IllegalArgumentException(\"Can't add [\" + docValuesType + \"] doc values field [\" + fieldName + \"], because [\" + existingDocValuesType + \"] doc values field already exists\");\n     }\n     switch (docValuesType) {\n       case NUMERIC:\n         if (info.numericProducer.dvLongValues != null) {\n           throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n         }\n         info.numericProducer.dvLongValues = new long[]{(long) docValuesValue};\n         info.numericProducer.count++;\n         break;\n       case SORTED_NUMERIC:\n         if (info.numericProducer.dvLongValues == null) {\n           info.numericProducer.dvLongValues = new long[4];\n         }\n         info.numericProducer.dvLongValues = ArrayUtil.grow(info.numericProducer.dvLongValues, info.numericProducer.count + 1);\n         info.numericProducer.dvLongValues[info.numericProducer.count++] = (long) docValuesValue;\n         break;\n       case BINARY:\n         if (info.binaryProducer.dvBytesValuesSet != null) {\n           throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n         }\n         info.binaryProducer.dvBytesValuesSet = new BytesRefHash(byteBlockPool);\n         info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n         break;\n       case SORTED:\n         if (info.binaryProducer.dvBytesValuesSet != null) {\n           throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n         }\n         info.binaryProducer.dvBytesValuesSet = new BytesRefHash(byteBlockPool);\n         info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n         break;\n       case SORTED_SET:\n         if (info.binaryProducer.dvBytesValuesSet == null) {\n           info.binaryProducer.dvBytesValuesSet = new BytesRefHash(byteBlockPool);\n         }\n         info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n         break;\n       default:\n         throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3dc4fa199c175ed6351f66bac5c23c73b4e3f89a": {
			"type": "Ybodychange",
			"commitMessage": "Revert \"LUCENE-8335: Enforce soft-deletes field up-front.\"\n\nThis reverts commit a2d927667418d17a1f5f31a193092d5b04a4219e.\n",
			"commitDate": "2018-06-02, 4:47 AM",
			"commitName": "3dc4fa199c175ed6351f66bac5c23c73b4e3f89a",
			"commitAuthor": "Simon Willnauer",
			"commitDateOld": "2018-06-02, 4:14 AM",
			"commitNameOld": "a2d927667418d17a1f5f31a193092d5b04a4219e",
			"commitAuthorOld": "Simon Willnauer",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,52 +1,52 @@\n   private void storeDocValues(Info info, DocValuesType docValuesType, Object docValuesValue) {\n     String fieldName = info.fieldInfo.name;\n     DocValuesType existingDocValuesType = info.fieldInfo.getDocValuesType();\n     if (existingDocValuesType == DocValuesType.NONE) {\n       // first time we add doc values for this field:\n       info.fieldInfo = new FieldInfo(\n           info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(),\n           info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(),\n-          info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes(), info.fieldInfo.isSoftDeletesField()\n+          info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes()\n       );\n     } else if (existingDocValuesType != docValuesType) {\n       throw new IllegalArgumentException(\"Can't add [\" + docValuesType + \"] doc values field [\" + fieldName + \"], because [\" + existingDocValuesType + \"] doc values field already exists\");\n     }\n     switch (docValuesType) {\n       case NUMERIC:\n         if (info.numericProducer.dvLongValues != null) {\n           throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n         }\n         info.numericProducer.dvLongValues = new long[]{(long) docValuesValue};\n         info.numericProducer.count++;\n         break;\n       case SORTED_NUMERIC:\n         if (info.numericProducer.dvLongValues == null) {\n           info.numericProducer.dvLongValues = new long[4];\n         }\n         info.numericProducer.dvLongValues = ArrayUtil.grow(info.numericProducer.dvLongValues, info.numericProducer.count + 1);\n         info.numericProducer.dvLongValues[info.numericProducer.count++] = (long) docValuesValue;\n         break;\n       case BINARY:\n         if (info.binaryProducer.dvBytesValuesSet != null) {\n           throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n         }\n         info.binaryProducer.dvBytesValuesSet = new BytesRefHash(byteBlockPool);\n         info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n         break;\n       case SORTED:\n         if (info.binaryProducer.dvBytesValuesSet != null) {\n           throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n         }\n         info.binaryProducer.dvBytesValuesSet = new BytesRefHash(byteBlockPool);\n         info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n         break;\n       case SORTED_SET:\n         if (info.binaryProducer.dvBytesValuesSet == null) {\n           info.binaryProducer.dvBytesValuesSet = new BytesRefHash(byteBlockPool);\n         }\n         info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n         break;\n       default:\n         throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a2d927667418d17a1f5f31a193092d5b04a4219e": {
			"type": "Ybodychange",
			"commitMessage": "LUCENE-8335: Enforce soft-deletes field up-front.\n\nSoft deletes field must be marked as such once it's introduced\nand can't be changed after the fact.\n",
			"commitDate": "2018-06-02, 4:14 AM",
			"commitName": "a2d927667418d17a1f5f31a193092d5b04a4219e",
			"commitAuthor": "Simon Willnauer",
			"commitDateOld": "2018-05-02, 5:49 AM",
			"commitNameOld": "af680af77f3f80c779e038a0ad8a136c9dcb9f5d",
			"commitAuthorOld": "Adrien Grand",
			"daysBetweenCommits": 30.93,
			"commitsBetweenForRepo": 175,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,52 +1,52 @@\n   private void storeDocValues(Info info, DocValuesType docValuesType, Object docValuesValue) {\n     String fieldName = info.fieldInfo.name;\n     DocValuesType existingDocValuesType = info.fieldInfo.getDocValuesType();\n     if (existingDocValuesType == DocValuesType.NONE) {\n       // first time we add doc values for this field:\n       info.fieldInfo = new FieldInfo(\n           info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(),\n           info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(),\n-          info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes()\n+          info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes(), info.fieldInfo.isSoftDeletesField()\n       );\n     } else if (existingDocValuesType != docValuesType) {\n       throw new IllegalArgumentException(\"Can't add [\" + docValuesType + \"] doc values field [\" + fieldName + \"], because [\" + existingDocValuesType + \"] doc values field already exists\");\n     }\n     switch (docValuesType) {\n       case NUMERIC:\n         if (info.numericProducer.dvLongValues != null) {\n           throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n         }\n         info.numericProducer.dvLongValues = new long[]{(long) docValuesValue};\n         info.numericProducer.count++;\n         break;\n       case SORTED_NUMERIC:\n         if (info.numericProducer.dvLongValues == null) {\n           info.numericProducer.dvLongValues = new long[4];\n         }\n         info.numericProducer.dvLongValues = ArrayUtil.grow(info.numericProducer.dvLongValues, info.numericProducer.count + 1);\n         info.numericProducer.dvLongValues[info.numericProducer.count++] = (long) docValuesValue;\n         break;\n       case BINARY:\n         if (info.binaryProducer.dvBytesValuesSet != null) {\n           throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n         }\n         info.binaryProducer.dvBytesValuesSet = new BytesRefHash(byteBlockPool);\n         info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n         break;\n       case SORTED:\n         if (info.binaryProducer.dvBytesValuesSet != null) {\n           throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n         }\n         info.binaryProducer.dvBytesValuesSet = new BytesRefHash(byteBlockPool);\n         info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n         break;\n       case SORTED_SET:\n         if (info.binaryProducer.dvBytesValuesSet == null) {\n           info.binaryProducer.dvBytesValuesSet = new BytesRefHash(byteBlockPool);\n         }\n         info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n         break;\n       default:\n         throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cf3eea26406692306505d2606d7ff73ee3634c30": {
			"type": "Yintroduced",
			"commitMessage": "LUCENE-7091: Added doc values support to memory index\n",
			"commitDate": "2016-03-15, 1:57 AM",
			"commitName": "cf3eea26406692306505d2606d7ff73ee3634c30",
			"commitAuthor": "Martijn van Groningen",
			"diff": "@@ -0,0 +1,52 @@\n+  private void storeDocValues(Info info, DocValuesType docValuesType, Object docValuesValue) {\n+    String fieldName = info.fieldInfo.name;\n+    DocValuesType existingDocValuesType = info.fieldInfo.getDocValuesType();\n+    if (existingDocValuesType == DocValuesType.NONE) {\n+      // first time we add doc values for this field:\n+      info.fieldInfo = new FieldInfo(\n+          info.fieldInfo.name, info.fieldInfo.number, info.fieldInfo.hasVectors(), info.fieldInfo.hasPayloads(),\n+          info.fieldInfo.hasPayloads(), info.fieldInfo.getIndexOptions(), docValuesType, -1, info.fieldInfo.attributes(),\n+          info.fieldInfo.getPointDimensionCount(), info.fieldInfo.getPointNumBytes()\n+      );\n+    } else if (existingDocValuesType != docValuesType) {\n+      throw new IllegalArgumentException(\"Can't add [\" + docValuesType + \"] doc values field [\" + fieldName + \"], because [\" + existingDocValuesType + \"] doc values field already exists\");\n+    }\n+    switch (docValuesType) {\n+      case NUMERIC:\n+        if (info.numericProducer.dvLongValues != null) {\n+          throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n+        }\n+        info.numericProducer.dvLongValues = new long[]{(long) docValuesValue};\n+        info.numericProducer.count++;\n+        break;\n+      case SORTED_NUMERIC:\n+        if (info.numericProducer.dvLongValues == null) {\n+          info.numericProducer.dvLongValues = new long[4];\n+        }\n+        info.numericProducer.dvLongValues = ArrayUtil.grow(info.numericProducer.dvLongValues, info.numericProducer.count + 1);\n+        info.numericProducer.dvLongValues[info.numericProducer.count++] = (long) docValuesValue;\n+        break;\n+      case BINARY:\n+        if (info.binaryProducer.dvBytesValuesSet != null) {\n+          throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n+        }\n+        info.binaryProducer.dvBytesValuesSet = new BytesRefHash(byteBlockPool);\n+        info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n+        break;\n+      case SORTED:\n+        if (info.binaryProducer.dvBytesValuesSet != null) {\n+          throw new IllegalArgumentException(\"Only one value per field allowed for [\" + docValuesType + \"] doc values field [\" + fieldName + \"]\");\n+        }\n+        info.binaryProducer.dvBytesValuesSet = new BytesRefHash(byteBlockPool);\n+        info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n+        break;\n+      case SORTED_SET:\n+        if (info.binaryProducer.dvBytesValuesSet == null) {\n+          info.binaryProducer.dvBytesValuesSet = new BytesRefHash(byteBlockPool);\n+        }\n+        info.binaryProducer.dvBytesValuesSet.add((BytesRef) docValuesValue);\n+        break;\n+      default:\n+        throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n+    }\n+  }\n\\ No newline at end of file\n"
		}
	},
	"sha": "38bf976cd4b9e324c21664bd7ae3d554df803705"
}