{
	"repo": "https://github.com/javaparser/javaparser.git",
	"file": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
	"method": {
		"longName": "JavaParserFacade::getTypeConcrete(Node node, boolean solveLambdas)",
		"startLine": 465,
		"methodName": "getTypeConcrete",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "private"
	},
	"history": {
		"09232ff6b0ea19e850482f3a87ac6ef1c063c759": {
			"type": "Yfilerename",
			"commitMessage": "rename JSS modules\n",
			"commitDate": "2018-01-10, 5:52 AM",
			"commitName": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2018-01-10, 1:01 AM",
			"commitNameOld": "30c04db173cc439556df2a238c99cd81ada320ff",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.2,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
				"newPath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java"
			}
		},
		"198ba6cbe49832ac09ca84c6920e9be661a3b56a": {
			"type": "Yreturntypechange",
			"commitMessage": "issue1154: correct most compilation errors in the jp model\n",
			"commitDate": "2017-09-29, 12:30 AM",
			"commitName": "198ba6cbe49832ac09ca84c6920e9be661a3b56a",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-09-28, 2:36 PM",
			"commitNameOld": "5d8d0cb7947efcf2282f7d056302dd905f348532",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.41,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,4 +1,4 @@\n-    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n+    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         return node.accept(typeExtractor, solveLambdas);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "Type",
				"newValue": "ResolvedType"
			}
		},
		"0f40221492b47df25615a1b5909fefa6f2d6fa0e": {
			"type": "Ybodychange",
			"commitMessage": "Refactored out huge method from facade to visitor\n",
			"commitDate": "2017-02-13, 4:49 PM",
			"commitName": "0f40221492b47df25615a1b5909fefa6f2d6fa0e",
			"commitAuthor": "xdrop",
			"commitDateOld": "2017-02-01, 5:04 PM",
			"commitNameOld": "a12a91a78591323403230d5654879a44ab4afb20",
			"commitAuthorOld": "Brandon Fergerson",
			"daysBetweenCommits": 11.99,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,322 +1,4 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n-        if (node instanceof NameExpr) {\n-            NameExpr nameExpr = (NameExpr) node;\n-            logger.finest(\"getType on name expr \" + node);\n-            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n-            if (!value.isPresent()) {\n-                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n-            } else {\n-                return value.get().getType();\n-            }\n-        } else if (node instanceof MethodCallExpr) {\n-            logger.finest(\"getType on method call \" + node);\n-            // first solve the method\n-            MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n-            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n-            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n-            return ref.returnType();\n-            // the type is the return type of the method\n-        } else if (node instanceof LambdaExpr) {\n-            if (getParentNode(node) instanceof MethodCallExpr) {\n-                MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n-                int pos = JavaParserSymbolDeclaration.getParamPos(node);\n-                SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n-                if (!refMethod.isSolved()) {\n-                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n-                }\n-                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n-                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n-                if (solveLambdas) {\n-\n-                    // The type parameter referred here should be the java.util.stream.Stream.T\n-                    Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n-\n-                    // FIXME: here we should replace the type parameters that can be resolved\n-                    //        for example when invoking myListOfStrings.stream().filter(s -> s.length > 0);\n-                    //        the MethodDeclaration of filter is:\n-                    //        Stream<T> filter(Predicate<? super T> predicate)\n-                    //        but T in this case is equal to String\n-                    if (callExpr.getScope().isPresent()) {\n-                        Expression scope = callExpr.getScope().get();\n-\n-                        // If it is a static call we should not try to get the type of the scope\n-                        boolean staticCall = false;\n-                        if (scope instanceof NameExpr) {\n-                            NameExpr nameExpr = (NameExpr) scope;\n-                            try {\n-                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n-                                staticCall = true;\n-                            } catch (Exception e) {\n-\n-                            }\n-                        }\n-\n-                        if (!staticCall) {\n-                            Type scopeType = JavaParserFacade.get(typeSolver).getType(scope);\n-                            if (scopeType.isReferenceType()) {\n-                                result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n-                            }\n-                        }\n-                    }\n-\n-                    // We need to replace the type variables\n-                    Context ctx = JavaParserFactory.getContext(node, typeSolver);\n-                    result = solveGenericTypes(result, ctx, typeSolver);\n-\n-                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n-                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n-                    //lambdas\n-                    Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n-                    if (functionalMethod.isPresent()) {\n-                        LambdaExpr lambdaExpr = (LambdaExpr) node;\n-\n-                        InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n-                        // At this point parameterType\n-                        // if Function<T=? super Stream.T, ? extends map.R>\n-                        // we should replace Stream.T\n-                        Type functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n-                        //inferenceContext.addPair(parameterType, functionalInterfaceType);\n-                        //inferenceContext.addPair(parameterType, result);\n-                        inferenceContext.addPair(result, functionalInterfaceType);\n-                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n-                            ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n-                            Type actualType = getType(expressionStmt.getExpression());\n-                            Type formalType = functionalMethod.get().returnType();\n-                            inferenceContext.addPair(formalType, actualType);\n-                            result = inferenceContext.resolve(inferenceContext.addSingle(result));\n-                        } else {\n-                            throw new UnsupportedOperationException();\n-                        }\n-                    }\n-\n-                    return result;\n-                } else {\n-                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n-                }\n-            } else {\n-                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n-            }\n-        } else if (node instanceof MethodReferenceExpr) {\n-            if (getParentNode(node) instanceof MethodCallExpr) {\n-                MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n-                int pos = JavaParserSymbolDeclaration.getParamPos(node);\n-                SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n-                if (!refMethod.isSolved()) {\n-                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n-                }\n-                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n-                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n-                if (solveLambdas) {\n-                    Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n-                    // We need to replace the type variables\n-                    Context ctx = JavaParserFactory.getContext(node, typeSolver);\n-                    result = solveGenericTypes(result, ctx, typeSolver);\n-\n-                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n-                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n-                    //lambdas\n-                    Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n-                    if (functionalMethod.isPresent()) {\n-                        if (node instanceof MethodReferenceExpr) {\n-                            MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n-\n-                            Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n-                            Type formalType = functionalMethod.get().returnType();\n-\n-                            InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n-                            inferenceContext.addPair(formalType, actualType);\n-                            result = inferenceContext.resolve(inferenceContext.addSingle(result));\n-                        } else {\n-                            LambdaExpr lambdaExpr = (LambdaExpr) node;\n-\n-                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n-                                ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n-                                Type actualType = getType(expressionStmt.getExpression());\n-                                Type formalType = functionalMethod.get().returnType();\n-\n-                                InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n-                                inferenceContext.addPair(formalType, actualType);\n-                                result = inferenceContext.resolve(inferenceContext.addSingle(result));\n-                            } else {\n-                                throw new UnsupportedOperationException();\n-                            }\n-                        }\n-                    }\n-\n-                    return result;\n-                } else {\n-                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n-                }\n-            } else {\n-                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n-            }\n-        } else if (node instanceof VariableDeclarator) {\n-            if (getParentNode(node) instanceof FieldDeclaration) {\n-//                FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n-                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n-            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n-//                VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n-                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n-            } else {\n-                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n-            }\n-        } else if (node instanceof Parameter) {\n-            Parameter parameter = (Parameter) node;\n-            if (parameter.getType() instanceof UnknownType) {\n-                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n-            }\n-            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n-        } else if (node instanceof FieldAccessExpr) {\n-            FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n-            // We should understand if this is a static access\n-            if (fieldAccessExpr.getScope().isPresent() && fieldAccessExpr.getScope().get() instanceof NameExpr) {\n-                NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope().get();\n-                SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n-                if (typeAccessedStatically.isSolved()) {\n-                    // TODO here maybe we have to substitute type typeParametersValues\n-                    return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n-                }\n-            } else if (fieldAccessExpr.getScope().isPresent() && fieldAccessExpr.getScope().get().toString().indexOf('.') > 0) {\n-                // try to find fully qualified name\n-                SymbolReference<ReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n-                if (sr.isSolved()) {\n-                    return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n-                }\n-            }\n-            Optional<Value> value = null;\n-            try {\n-                value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n-            } catch (UnsolvedSymbolException use) {\n-                // Deal with badly parsed FieldAccessExpr that are in fact fqn classes\n-                if (fieldAccessExpr.getParentNode().isPresent() && fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n-                    throw use;\n-                }\n-                SymbolReference<ReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n-                if (sref.isSolved()) {\n-                    return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n-                }\n-            }\n-            if (value != null && value.isPresent()) {\n-                return value.get().getType();\n-            } else {\n-                throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n-            }\n-        } else if (node instanceof ObjectCreationExpr) {\n-            ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n-            Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n-            return type;\n-        } else if (node instanceof NullLiteralExpr) {\n-            return NullType.INSTANCE;\n-        } else if (node instanceof BooleanLiteralExpr) {\n-            return PrimitiveType.BOOLEAN;\n-        } else if (node instanceof IntegerLiteralExpr) {\n-            return PrimitiveType.INT;\n-        } else if (node instanceof LongLiteralExpr) {\n-            return PrimitiveType.LONG;\n-        } else if (node instanceof CharLiteralExpr) {\n-            return PrimitiveType.CHAR;\n-        } else if (node instanceof DoubleLiteralExpr) {\n-            if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n-                return PrimitiveType.FLOAT;\n-            }\n-            return PrimitiveType.DOUBLE;\n-        } else if (node instanceof StringLiteralExpr) {\n-            return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n-        } else if (node instanceof UnaryExpr) {\n-            UnaryExpr unaryExpr = (UnaryExpr) node;\n-            switch (unaryExpr.getOperator()) {\n-                case MINUS:\n-                case PLUS:\n-                    return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n-                case LOGICAL_COMPLEMENT:\n-                    return PrimitiveType.BOOLEAN;\n-                case POSTFIX_DECREMENT:\n-                case PREFIX_DECREMENT:\n-                case POSTFIX_INCREMENT:\n-                case PREFIX_INCREMENT:\n-                    return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n-                default:\n-                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n-            }\n-        } else if (node instanceof BinaryExpr) {\n-            BinaryExpr binaryExpr = (BinaryExpr) node;\n-            switch (binaryExpr.getOperator()) {\n-                case PLUS:\n-                case MINUS:\n-                case DIVIDE:\n-                case MULTIPLY:\n-                    return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n-                case LESS_EQUALS:\n-                case LESS:\n-                case GREATER:\n-                case GREATER_EQUALS:\n-                case EQUALS:\n-                case NOT_EQUALS:\n-                case OR:\n-                case AND:\n-                    return PrimitiveType.BOOLEAN;\n-                case BINARY_AND:\n-                case BINARY_OR:\n-                case SIGNED_RIGHT_SHIFT:\n-                case UNSIGNED_RIGHT_SHIFT:\n-                case LEFT_SHIFT:\n-                case REMAINDER:\n-                case XOR:\n-                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n-                default:\n-                    throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n-            }\n-        } else if (node instanceof VariableDeclarationExpr) {\n-            VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n-            if (expr.getVariables().size() != 1) {\n-                throw new UnsupportedOperationException();\n-            }\n-            return convertToUsageVariableType(expr.getVariables().get(0));\n-        } else if (node instanceof InstanceOfExpr) {\n-            return PrimitiveType.BOOLEAN;\n-        } else if (node instanceof EnclosedExpr) {\n-            EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n-            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n-        } else if (node instanceof CastExpr) {\n-            CastExpr enclosedExpr = (CastExpr) node;\n-            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n-        } else if (node instanceof AssignExpr) {\n-            AssignExpr assignExpr = (AssignExpr) node;\n-            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n-        } else if (node instanceof ThisExpr) {\n-            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n-        } else if (node instanceof ConditionalExpr) {\n-            ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n-            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n-        } else if (node instanceof ArrayCreationExpr) {\n-            ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n-            Type res = convertToUsage(arrayCreationExpr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n-            for (int i=0;i<arrayCreationExpr.getLevels().size();i++) {\n-                res = new ArrayType(res);\n-            }\n-            return res;\n-        } else if (node instanceof ArrayAccessExpr) {\n-            ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n-            Type arrayUsageType = getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n-            if (arrayUsageType.isArray()) {\n-                return ((ArrayType) arrayUsageType).getComponentType();\n-            }\n-            return arrayUsageType;\n-        } else if (node instanceof SuperExpr) {\n-            TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n-            if (typeOfNode instanceof ClassDeclaration) {\n-                return ((ClassDeclaration) typeOfNode).getSuperClass();\n-            } else {\n-                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n-            }\n-        } else if (node instanceof ClassExpr) {\n-            // This implementation does not regard the actual type argument of the ClassExpr.\n-            ClassExpr classExpr = (ClassExpr) node;\n-            com.github.javaparser.ast.type.Type astType = classExpr.getType();\n-            Type jssType = convertToUsage(astType, classExpr.getType());\n-            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n-        } else {\n-            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n-        }\n+        return node.accept(typeExtractor, solveLambdas);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"065875981b4d1ffa4bf3535d7c89319a4a3345f1": {
			"type": "Ybodychange",
			"commitMessage": "Update for JavaParser 3.0.0\n",
			"commitDate": "2017-01-11, 5:45 PM",
			"commitName": "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
			"commitAuthor": "xdrop",
			"commitDateOld": "2017-01-10, 3:19 PM",
			"commitNameOld": "dd73ec538fbacfc1a05acb6d0ac35da3b4e87bc3",
			"commitAuthorOld": "xdrop",
			"daysBetweenCommits": 1.1,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,321 +1,322 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -> s.length > 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream<T> filter(Predicate<? super T> predicate)\n                     //        but T in this case is equal to String\n-                    if (callExpr.getScope() != null) {\n+                    if (callExpr.getScope().isPresent()) {\n+                        Expression scope = callExpr.getScope().get();\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall = false;\n-                        if (callExpr.getScope() instanceof NameExpr) {\n-                            NameExpr nameExpr = (NameExpr) callExpr.getScope();\n+                        if (scope instanceof NameExpr) {\n+                            NameExpr nameExpr = (NameExpr) scope;\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                                 staticCall = true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n-                            Type scopeType = JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n+                            Type scopeType = JavaParserFacade.get(typeSolver).getType(scope);\n                             if (scopeType.isReferenceType()) {\n                                 result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                         // At this point parameterType\n                         // if Function<T=? super Stream.T, ? extends map.R>\n                         // we should replace Stream.T\n                         Type functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                         //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                         //inferenceContext.addPair(parameterType, result);\n                         inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             inferenceContext.addPair(formalType, actualType);\n                             result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n \n                             InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n \n                                 InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                                 inferenceContext.addPair(formalType, actualType);\n                                 result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n //                FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n //                VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope().isPresent() && fieldAccessExpr.getScope().get() instanceof NameExpr) {\n                 NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope().get();\n                 SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n                 }\n             } else if (fieldAccessExpr.getScope().isPresent() && fieldAccessExpr.getScope().get().toString().indexOf('.') > 0) {\n                 // try to find fully qualified name\n                 SymbolReference<ReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n                 if (sr.isSolved()) {\n                     return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n                 }\n             }\n             Optional<Value> value = null;\n             try {\n                 value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n             } catch (UnsolvedSymbolException use) {\n                 // Deal with badly parsed FieldAccessExpr that are in fact fqn classes\n                 if (fieldAccessExpr.getParentNode().isPresent() && fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n                     throw use;\n                 }\n                 SymbolReference<ReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n                 if (sref.isSolved()) {\n                     return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n                 }\n             }\n             if (value != null && value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n                 return PrimitiveType.FLOAT;\n             }\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case MINUS:\n                 case PLUS:\n                     return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n                 case LOGICAL_COMPLEMENT:\n                     return PrimitiveType.BOOLEAN;\n                 case POSTFIX_DECREMENT:\n                 case PREFIX_DECREMENT:\n                 case POSTFIX_INCREMENT:\n                 case PREFIX_INCREMENT:\n                     return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case PLUS:\n                 case MINUS:\n                 case DIVIDE:\n                 case MULTIPLY:\n                     return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n                 case LESS_EQUALS:\n                 case LESS:\n                 case GREATER:\n                 case GREATER_EQUALS:\n                 case EQUALS:\n                 case NOT_EQUALS:\n                 case OR:\n                 case AND:\n                     return PrimitiveType.BOOLEAN;\n                 case BINARY_AND:\n                 case BINARY_OR:\n                 case SIGNED_RIGHT_SHIFT:\n                 case UNSIGNED_RIGHT_SHIFT:\n                 case LEFT_SHIFT:\n                 case REMAINDER:\n                 case XOR:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() != 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i=0;i<arrayCreationExpr.getLevels().size();i++) {\n                 res = new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             Type arrayUsageType = getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n             if (arrayUsageType.isArray()) {\n                 return ((ArrayType) arrayUsageType).getComponentType();\n             }\n             return arrayUsageType;\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             ClassExpr classExpr = (ClassExpr) node;\n             com.github.javaparser.ast.type.Type astType = classExpr.getType();\n             Type jssType = convertToUsage(astType, classExpr.getType());\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"90c22f84a61e12130a8750d235acf7ed06305796": {
			"type": "Ybodychange",
			"commitMessage": "migration to JavaParser 3.0.0-RC.3\n",
			"commitDate": "2016-12-19, 9:01 AM",
			"commitName": "90c22f84a61e12130a8750d235acf7ed06305796",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-12-13, 12:42 PM",
			"commitNameOld": "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 5.85,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,321 +1,321 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -> s.length > 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream<T> filter(Predicate<? super T> predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope() != null) {\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall = false;\n                         if (callExpr.getScope() instanceof NameExpr) {\n                             NameExpr nameExpr = (NameExpr) callExpr.getScope();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                                 staticCall = true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType = JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                             if (scopeType.isReferenceType()) {\n                                 result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                         // At this point parameterType\n                         // if Function<T=? super Stream.T, ? extends map.R>\n                         // we should replace Stream.T\n                         Type functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                         //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                         //inferenceContext.addPair(parameterType, result);\n                         inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             inferenceContext.addPair(formalType, actualType);\n                             result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n \n                             InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n \n                                 InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                                 inferenceContext.addPair(formalType, actualType);\n                                 result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n //                FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n //                VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope().isPresent() && fieldAccessExpr.getScope().get() instanceof NameExpr) {\n                 NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope().get();\n                 SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n                 }\n             } else if (fieldAccessExpr.getScope().isPresent() && fieldAccessExpr.getScope().get().toString().indexOf('.') > 0) {\n                 // try to find fully qualified name\n                 SymbolReference<ReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n                 if (sr.isSolved()) {\n                     return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n                 }\n             }\n             Optional<Value> value = null;\n             try {\n                 value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n             } catch (UnsolvedSymbolException use) {\n                 // Deal with badly parsed FieldAccessExpr that are in fact fqn classes\n                 if (fieldAccessExpr.getParentNode().isPresent() && fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n                     throw use;\n                 }\n                 SymbolReference<ReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n                 if (sref.isSolved()) {\n                     return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n                 }\n             }\n             if (value != null && value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n                 return PrimitiveType.FLOAT;\n             }\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case MINUS:\n                 case PLUS:\n                     return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n                 case LOGICAL_COMPLEMENT:\n                     return PrimitiveType.BOOLEAN;\n                 case POSTFIX_DECREMENT:\n                 case PREFIX_DECREMENT:\n                 case POSTFIX_INCREMENT:\n                 case PREFIX_INCREMENT:\n                     return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case PLUS:\n                 case MINUS:\n                 case DIVIDE:\n                 case MULTIPLY:\n                     return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n                 case LESS_EQUALS:\n                 case LESS:\n                 case GREATER:\n                 case GREATER_EQUALS:\n                 case EQUALS:\n                 case NOT_EQUALS:\n                 case OR:\n                 case AND:\n                     return PrimitiveType.BOOLEAN;\n                 case BINARY_AND:\n                 case BINARY_OR:\n                 case SIGNED_RIGHT_SHIFT:\n                 case UNSIGNED_RIGHT_SHIFT:\n                 case LEFT_SHIFT:\n                 case REMAINDER:\n                 case XOR:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() != 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i=0;i<arrayCreationExpr.getLevels().size();i++) {\n                 res = new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             Type arrayUsageType = getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n             if (arrayUsageType.isArray()) {\n                 return ((ArrayType) arrayUsageType).getComponentType();\n             }\n             return arrayUsageType;\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             ClassExpr classExpr = (ClassExpr) node;\n-            com.github.javaparser.ast.type.Type<?> astType = classExpr.getType();\n+            com.github.javaparser.ast.type.Type astType = classExpr.getType();\n             Type jssType = convertToUsage(astType, classExpr.getType());\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"52b60cf471dc9d7b53d8f22018d9c4e4fcc15923": {
			"type": "Ybodychange",
			"commitMessage": "porting to JavaParser 3.0.0 RC2\n",
			"commitDate": "2016-12-13, 12:42 PM",
			"commitName": "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-12-13, 9:45 AM",
			"commitNameOld": "cb5ffb7fdd56f1b768d25da330fa3b29ecb74eaf",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.12,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,318 +1,321 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -> s.length > 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream<T> filter(Predicate<? super T> predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope() != null) {\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall = false;\n                         if (callExpr.getScope() instanceof NameExpr) {\n                             NameExpr nameExpr = (NameExpr) callExpr.getScope();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                                 staticCall = true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType = JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                             if (scopeType.isReferenceType()) {\n                                 result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                         // At this point parameterType\n                         // if Function<T=? super Stream.T, ? extends map.R>\n                         // we should replace Stream.T\n                         Type functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                         //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                         //inferenceContext.addPair(parameterType, result);\n                         inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             inferenceContext.addPair(formalType, actualType);\n                             result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n \n                             InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n \n                                 InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                                 inferenceContext.addPair(formalType, actualType);\n                                 result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n //                FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n //                VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope().isPresent() && fieldAccessExpr.getScope().get() instanceof NameExpr) {\n                 NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope().get();\n                 SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return ((ReferenceTypeDeclaration) typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n                 }\n             } else if (fieldAccessExpr.getScope().isPresent() && fieldAccessExpr.getScope().get().toString().indexOf('.') > 0) {\n                 // try to find fully qualified name\n                 SymbolReference<ReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n                 if (sr.isSolved()) {\n                     return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n                 }\n             }\n             Optional<Value> value = null;\n             try {\n                 value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n             } catch (UnsolvedSymbolException use) {\n                 // Deal with badly parsed FieldAccessExpr that are in fact fqn classes\n                 if (fieldAccessExpr.getParentNode().isPresent() && fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n                     throw use;\n                 }\n                 SymbolReference<ReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n                 if (sref.isSolved()) {\n                     return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n                 }\n             }\n             if (value != null && value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n                 return PrimitiveType.FLOAT;\n             }\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n-                case negative:\n-                case positive:\n-                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n-                case not:\n+                case MINUS:\n+                case PLUS:\n+                    return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n+                case LOGICAL_COMPLEMENT:\n                     return PrimitiveType.BOOLEAN;\n-                case postIncrement:\n-                case preIncrement:\n-                case preDecrement:\n-                case postDecrement:\n-                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n+                case POSTFIX_DECREMENT:\n+                case PREFIX_DECREMENT:\n+                case POSTFIX_INCREMENT:\n+                case PREFIX_INCREMENT:\n+                    return getTypeConcrete(unaryExpr.getExpression(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n-                case plus:\n-                case minus:\n-                case divide:\n-                case times:\n+                case PLUS:\n+                case MINUS:\n+                case DIVIDE:\n+                case MULTIPLY:\n                     return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n-                case lessEquals:\n-                case less:\n-                case greater:\n-                case greaterEquals:\n-                case equals:\n-                case notEquals:\n-                case or:\n-                case and:\n+                case LESS_EQUALS:\n+                case LESS:\n+                case GREATER:\n+                case GREATER_EQUALS:\n+                case EQUALS:\n+                case NOT_EQUALS:\n+                case OR:\n+                case AND:\n                     return PrimitiveType.BOOLEAN;\n-                case binAnd:\n-                case binOr:\n-                case rSignedShift:\n-                case rUnsignedShift:\n-                case lShift:\n-                case remainder:\n-                case xor:\n+                case BINARY_AND:\n+                case BINARY_OR:\n+                case SIGNED_RIGHT_SHIFT:\n+                case UNSIGNED_RIGHT_SHIFT:\n+                case LEFT_SHIFT:\n+                case REMAINDER:\n+                case XOR:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() != 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n-            Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n+            Type res = convertToUsage(arrayCreationExpr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n+            for (int i=0;i<arrayCreationExpr.getLevels().size();i++) {\n+                res = new ArrayType(res);\n+            }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             Type arrayUsageType = getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n             if (arrayUsageType.isArray()) {\n                 return ((ArrayType) arrayUsageType).getComponentType();\n             }\n             return arrayUsageType;\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             ClassExpr classExpr = (ClassExpr) node;\n             com.github.javaparser.ast.type.Type<?> astType = classExpr.getType();\n             Type jssType = convertToUsage(astType, classExpr.getType());\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c990d23490f5c4ac4322119b03d5951b63eef055": {
			"type": "Ybodychange",
			"commitMessage": "loads of changes to support our code",
			"commitDate": "2016-12-13, 6:10 AM",
			"commitName": "c990d23490f5c4ac4322119b03d5951b63eef055",
			"commitAuthor": "Fred Lefévère-Laoide",
			"commitDateOld": "2016-11-21, 1:52 PM",
			"commitNameOld": "dfebf682a440aa48a8a444562f7fdfc1819b9a1e",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 21.68,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,286 +1,318 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -> s.length > 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream<T> filter(Predicate<? super T> predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope() != null) {\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall = false;\n                         if (callExpr.getScope() instanceof NameExpr) {\n                             NameExpr nameExpr = (NameExpr) callExpr.getScope();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                                 staticCall = true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType = JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                             if (scopeType.isReferenceType()) {\n                                 result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                         // At this point parameterType\n                         // if Function<T=? super Stream.T, ? extends map.R>\n                         // we should replace Stream.T\n                         Type functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                         //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                         //inferenceContext.addPair(parameterType, result);\n                         inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             inferenceContext.addPair(formalType, actualType);\n                             result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n \n                             InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n \n                                 InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                                 inferenceContext.addPair(formalType, actualType);\n                                 result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n-                FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n+//                FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n-                VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n+//                VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope().isPresent() && fieldAccessExpr.getScope().get() instanceof NameExpr) {\n                 NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope().get();\n                 SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return ((ReferenceTypeDeclaration)typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n                 }\n+            } else if (fieldAccessExpr.getScope().isPresent() && fieldAccessExpr.getScope().get().toString().indexOf('.') > 0) {\n+              // try to find fully qualified name\n+              SymbolReference<ReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(fieldAccessExpr.getScope().get().toString());\n+              if (sr.isSolved()) {\n+                return sr.getCorrespondingDeclaration().getField(fieldAccessExpr.getField().getId()).getType();\n+              }\n             }\n-            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n-            if (value.isPresent()) {\n+            Optional<Value> value = null;\n+            try {\n+              value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n+            } catch (UnsolvedSymbolException use) {\n+              // Deal with badly parsed FieldAccessExpr that are in fact fqn classes\n+              if (fieldAccessExpr.getParentNode().isPresent() && fieldAccessExpr.getParentNode().get() instanceof FieldAccessExpr) {\n+                throw use;\n+              }\n+              SymbolReference<ReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n+              if (sref.isSolved()) {\n+                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n+              }\n+            }\n+            if (value != null && value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n+            if (((DoubleLiteralExpr) node).getValue().toLowerCase().endsWith(\"f\")) {\n+              return PrimitiveType.FLOAT;\n+            }\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n-                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n+                case divide:\n+                case times:\n+                    return getBinaryTypeConcrete(binaryExpr.getLeft(), binaryExpr.getRight(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n+                case rSignedShift:\n+                case rUnsignedShift:\n+                case lShift:\n+                case remainder:\n+                case xor:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() != 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n-            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n+            Type arrayUsageType = getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n+            if (arrayUsageType.isArray()) {\n+              return ((ArrayType) arrayUsageType).getComponentType();\n+            }\n+            return arrayUsageType;\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             ClassExpr classExpr = (ClassExpr)node;\n-            com.github.javaparser.ast.type.Type astType = classExpr.getType();\n+            com.github.javaparser.ast.type.Type<?> astType = classExpr.getType();\n             Type jssType = convertToUsage(astType, classExpr.getType());\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType),typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6e1380f412d334f1c887d15edf0b4610c3cf0da2": {
			"type": "Ybodychange",
			"commitMessage": "adapt to alpha.10\n",
			"commitDate": "2016-11-21, 11:58 AM",
			"commitName": "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-11-09, 10:15 AM",
			"commitNameOld": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 12.07,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,286 +1,286 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n-            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n+            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName().getId(), nameExpr);\n             if (!value.isPresent()) {\n-                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n+                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName().getId());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n-                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n+                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -> s.length > 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream<T> filter(Predicate<? super T> predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope() != null) {\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall = false;\n                         if (callExpr.getScope() instanceof NameExpr) {\n                             NameExpr nameExpr = (NameExpr) callExpr.getScope();\n                             try {\n-                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n+                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId(), typeSolver);\n                                 staticCall = true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType = JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                             if (scopeType.isReferenceType()) {\n                                 result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                         // At this point parameterType\n                         // if Function<T=? super Stream.T, ? extends map.R>\n                         // we should replace Stream.T\n                         Type functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                         //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                         //inferenceContext.addPair(parameterType, result);\n                         inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             inferenceContext.addPair(formalType, actualType);\n                             result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n-                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n+                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName().getId());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n \n                             InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n \n                                 InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                                 inferenceContext.addPair(formalType, actualType);\n                                 result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n-            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n-                NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n+            if (fieldAccessExpr.getScope().isPresent() && fieldAccessExpr.getScope().get() instanceof NameExpr) {\n+                NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope().get();\n                 SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n-                    return ((ReferenceTypeDeclaration)typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField()).getType();\n+                    return ((ReferenceTypeDeclaration)typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField().getId()).getType();\n                 }\n             }\n-            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField().getId(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getType();\n             } else {\n-                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n+                throw new UnsolvedSymbolException(fieldAccessExpr.getField().getId());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() != 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n-            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n+            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             ClassExpr classExpr = (ClassExpr)node;\n             com.github.javaparser.ast.type.Type astType = classExpr.getType();\n             Type jssType = convertToUsage(astType, classExpr.getType());\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType),typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5": {
			"type": "Ybodychange",
			"commitMessage": "changes necessary to support jpalpha8\n",
			"commitDate": "2016-11-09, 10:15 AM",
			"commitName": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-11-06, 1:40 AM",
			"commitNameOld": "c746c4ef7711a05c27827ab749d96155046a4f91",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 3.36,
			"commitsBetweenForRepo": 18,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,286 +1,286 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -> s.length > 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream<T> filter(Predicate<? super T> predicate)\n                     //        but T in this case is equal to String\n-                    if (callExpr.getScope().isPresent()) {\n+                    if (callExpr.getScope() != null) {\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall = false;\n-                        if (callExpr.getScope().get() instanceof NameExpr) {\n-                            NameExpr nameExpr = (NameExpr) callExpr.getScope().get();\n+                        if (callExpr.getScope() instanceof NameExpr) {\n+                            NameExpr nameExpr = (NameExpr) callExpr.getScope();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                 staticCall = true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n-                            Type scopeType = JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n+                            Type scopeType = JavaParserFacade.get(typeSolver).getType(callExpr.getScope());\n                             if (scopeType.isReferenceType()) {\n                                 result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                         // At this point parameterType\n                         // if Function<T=? super Stream.T, ? extends map.R>\n                         // we should replace Stream.T\n                         Type functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                         //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                         //inferenceContext.addPair(parameterType, result);\n                         inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             inferenceContext.addPair(formalType, actualType);\n                             result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n \n                             InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n \n                                 InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                                 inferenceContext.addPair(formalType, actualType);\n                                 result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return ((ReferenceTypeDeclaration)typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField()).getType();\n                 }\n             }\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() != 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n-            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n+            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             ClassExpr classExpr = (ClassExpr)node;\n             com.github.javaparser.ast.type.Type astType = classExpr.getType();\n             Type jssType = convertToUsage(astType, classExpr.getType());\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType),typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a1c7c58143a592965f8378767adc69709e4c0043": {
			"type": "Ybodychange",
			"commitMessage": "more refactoring for ReferenceTypeDeclaration\n",
			"commitDate": "2016-11-05, 9:22 AM",
			"commitName": "a1c7c58143a592965f8378767adc69709e4c0043",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-11-05, 9:08 AM",
			"commitNameOld": "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,286 +1,286 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -> s.length > 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream<T> filter(Predicate<? super T> predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope().isPresent()) {\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall = false;\n                         if (callExpr.getScope().get() instanceof NameExpr) {\n                             NameExpr nameExpr = (NameExpr) callExpr.getScope().get();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                 staticCall = true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType = JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                             if (scopeType.isReferenceType()) {\n                                 result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                         // At this point parameterType\n                         // if Function<T=? super Stream.T, ? extends map.R>\n                         // we should replace Stream.T\n                         Type functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                         //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                         //inferenceContext.addPair(parameterType, result);\n                         inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             inferenceContext.addPair(formalType, actualType);\n                             result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n \n                             InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n \n                                 InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                                 inferenceContext.addPair(formalType, actualType);\n                                 result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n-                SymbolReference<ReferenceTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n+                SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n-                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n+                    return ((ReferenceTypeDeclaration)typeAccessedStatically.getCorrespondingDeclaration()).getField(fieldAccessExpr.getField()).getType();\n                 }\n             }\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() != 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             ClassExpr classExpr = (ClassExpr)node;\n             com.github.javaparser.ast.type.Type astType = classExpr.getType();\n             Type jssType = convertToUsage(astType, classExpr.getType());\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType),typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6df1aa26f75ff0d716a1290007e2b63cc05001ae": {
			"type": "Ybodychange",
			"commitMessage": "creating ReferenceTypeDeclaration\n",
			"commitDate": "2016-11-05, 9:08 AM",
			"commitName": "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-11-05, 1:58 AM",
			"commitNameOld": "2fde8a6409906ab1e0b5e846f2e54b82da7878b7",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.3,
			"commitsBetweenForRepo": 16,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,286 +1,286 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -> s.length > 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream<T> filter(Predicate<? super T> predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope().isPresent()) {\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall = false;\n                         if (callExpr.getScope().get() instanceof NameExpr) {\n                             NameExpr nameExpr = (NameExpr) callExpr.getScope().get();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                 staticCall = true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType = JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                             if (scopeType.isReferenceType()) {\n                                 result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                         // At this point parameterType\n                         // if Function<T=? super Stream.T, ? extends map.R>\n                         // we should replace Stream.T\n                         Type functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                         //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                         //inferenceContext.addPair(parameterType, result);\n                         inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             inferenceContext.addPair(formalType, actualType);\n                             result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n \n                             InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                             inferenceContext.addPair(formalType, actualType);\n                             result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n \n                                 InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                                 inferenceContext.addPair(formalType, actualType);\n                                 result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n-                SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n+                SymbolReference<ReferenceTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             }\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() != 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             ClassExpr classExpr = (ClassExpr)node;\n             com.github.javaparser.ast.type.Type astType = classExpr.getType();\n             Type jssType = convertToUsage(astType, classExpr.getType());\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType),typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e0d63587820f7e8900af0c9060a2f149cc643c6c": {
			"type": "Ybodychange",
			"commitMessage": "use InferenceContext in more cases\n",
			"commitDate": "2016-11-05, 1:39 AM",
			"commitName": "e0d63587820f7e8900af0c9060a2f149cc643c6c",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-11-05, 1:19 AM",
			"commitNameOld": "e174058b92c209ba1d818e53db34993236592db7",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,291 +1,286 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -> s.length > 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream<T> filter(Predicate<? super T> predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope().isPresent()) {\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall = false;\n                         if (callExpr.getScope().get() instanceof NameExpr) {\n                             NameExpr nameExpr = (NameExpr) callExpr.getScope().get();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                 staticCall = true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType = JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                             if (scopeType.isReferenceType()) {\n                                 result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                         // At this point parameterType\n                         // if Function<T=? super Stream.T, ? extends map.R>\n                         // we should replace Stream.T\n                         Type functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                         //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                         //inferenceContext.addPair(parameterType, result);\n                         inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             inferenceContext.addPair(formalType, actualType);\n                             result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n-                            List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n-                            formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n-                            Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n-                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n-                                result = result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n-                            }\n \n+                            InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n+                            inferenceContext.addPair(formalType, actualType);\n+                            result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n-                            List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n-                                formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n-                                Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n-                                for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n-                                    result = result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n-                                }\n+\n+                                InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n+                                inferenceContext.addPair(formalType, actualType);\n+                                result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             }\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() != 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             ClassExpr classExpr = (ClassExpr)node;\n             com.github.javaparser.ast.type.Type astType = classExpr.getType();\n             Type jssType = convertToUsage(astType, classExpr.getType());\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType),typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e174058b92c209ba1d818e53db34993236592db7": {
			"type": "Ybodychange",
			"commitMessage": "derive the type parameters in ClassExpr\n",
			"commitDate": "2016-11-05, 1:19 AM",
			"commitName": "e174058b92c209ba1d818e53db34993236592db7",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-11-04, 5:05 PM",
			"commitNameOld": "6ca549e39bc3b05bd6eb96ba9dc697a8c1bd6552",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.34,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,289 +1,291 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -> s.length > 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream<T> filter(Predicate<? super T> predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope().isPresent()) {\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall = false;\n                         if (callExpr.getScope().get() instanceof NameExpr) {\n                             NameExpr nameExpr = (NameExpr) callExpr.getScope().get();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                 staticCall = true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType = JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                             if (scopeType.isReferenceType()) {\n                                 result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                         // At this point parameterType\n                         // if Function<T=? super Stream.T, ? extends map.R>\n                         // we should replace Stream.T\n-                        Type parameterType = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                         Type functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n                         //inferenceContext.addPair(parameterType, functionalInterfaceType);\n                         //inferenceContext.addPair(parameterType, result);\n                         inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             inferenceContext.addPair(formalType, actualType);\n                             result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result = result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                                 Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                     result = result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             }\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() != 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n-            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n+            ClassExpr classExpr = (ClassExpr)node;\n+            com.github.javaparser.ast.type.Type astType = classExpr.getType();\n+            Type jssType = convertToUsage(astType, classExpr.getType());\n+            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType),typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6ca549e39bc3b05bd6eb96ba9dc697a8c1bd6552": {
			"type": "Ybodychange",
			"commitMessage": "improving inference logic\n",
			"commitDate": "2016-11-04, 5:05 PM",
			"commitName": "6ca549e39bc3b05bd6eb96ba9dc697a8c1bd6552",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-11-02, 2:08 PM",
			"commitNameOld": "effd4c172ad6e4d60d68a749121a0960040edd63",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 2.12,
			"commitsBetweenForRepo": 11,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,284 +1,289 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -> s.length > 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream<T> filter(Predicate<? super T> predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope().isPresent()) {\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall = false;\n                         if (callExpr.getScope().get() instanceof NameExpr) {\n                             NameExpr nameExpr = (NameExpr) callExpr.getScope().get();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                 staticCall = true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType = JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                             if (scopeType.isReferenceType()) {\n                                 result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n-                        List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n+                        InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n+                        // At this point parameterType\n+                        // if Function<T=? super Stream.T, ? extends map.R>\n+                        // we should replace Stream.T\n+                        Type parameterType = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+                        Type functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n+                        //inferenceContext.addPair(parameterType, functionalInterfaceType);\n+                        //inferenceContext.addPair(parameterType, result);\n+                        inferenceContext.addPair(result, functionalInterfaceType);\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n-                            formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n-                            Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n-                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n-                                result = result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n-                            }\n+                            inferenceContext.addPair(formalType, actualType);\n+                            result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result = result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                                 Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                     result = result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             }\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() != 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"78ee47e2e07cdb0b3cf80664a4e892c9dc76df00": {
			"type": "Ybodychange",
			"commitMessage": "rename JreTypeSolver to ReflectionTypeSolver\n",
			"commitDate": "2016-10-26, 10:12 AM",
			"commitName": "78ee47e2e07cdb0b3cf80664a4e892c9dc76df00",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-24, 2:41 PM",
			"commitNameOld": "08322b4714f672bed5ec424d3ace0a40da9ccd47",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 1.81,
			"commitsBetweenForRepo": 15,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,284 +1,284 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -> s.length > 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream<T> filter(Predicate<? super T> predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope().isPresent()){\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall = false;\n                         if (callExpr.getScope().get() instanceof NameExpr) {\n                             NameExpr nameExpr = (NameExpr)callExpr.getScope().get();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                 staticCall = true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType = JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                             if (scopeType.isReferenceType()) {\n                                 result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result = result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result = result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                                 Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                     result = result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             }\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n-            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n+            return new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() != 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"631896a1d2f34eed89c41cc717f463ebbd69e401": {
			"type": "Ybodychange",
			"commitMessage": "commenting classes in model\n",
			"commitDate": "2016-10-23, 3:26 AM",
			"commitName": "631896a1d2f34eed89c41cc717f463ebbd69e401",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-23, 2:58 AM",
			"commitNameOld": "13d789de30e6c3d29efb17a2acdff443f8c48db1",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,284 +1,284 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -> s.length > 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream<T> filter(Predicate<? super T> predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope().isPresent()){\n \n                         // If it is a static call we should not try to get the type of the scope\n                         boolean staticCall = false;\n                         if (callExpr.getScope().get() instanceof NameExpr) {\n                             NameExpr nameExpr = (NameExpr)callExpr.getScope().get();\n                             try {\n                                 JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n                                 staticCall = true;\n                             } catch (Exception e) {\n \n                             }\n                         }\n \n                         if (!staticCall) {\n                             Type scopeType = JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n                             if (scopeType.isReferenceType()) {\n                                 result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                             }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n-                                result = result.replaceParam(typeName, inferredTypes.get(typeName));\n+                                result = result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n-                                result = result.replaceParam(typeName, inferredTypes.get(typeName));\n+                                result = result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                                 Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n-                                    result = result.replaceParam(typeName, inferredTypes.get(typeName));\n+                                    result = result.replaceTypeVariables(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                 NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                 SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                 if (typeAccessedStatically.isSolved()) {\n                     // TODO here maybe we have to substitute type typeParametersValues\n                     return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n             }\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getType();\n             } else {\n                 throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() != 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"13d789de30e6c3d29efb17a2acdff443f8c48db1": {
			"type": "Ybodychange",
			"commitMessage": "handling static calls\n",
			"commitDate": "2016-10-23, 2:58 AM",
			"commitName": "13d789de30e6c3d29efb17a2acdff443f8c48db1",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-23, 2:27 AM",
			"commitNameOld": "697432aaf0e6a42825e52f956bd51f0486b411d2",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,279 +1,284 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n \n                     // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n \n                     // FIXME: here we should replace the type parameters that can be resolved\n                     //        for example when invoking myListOfStrings.stream().filter(s -> s.length > 0);\n                     //        the MethodDeclaration of filter is:\n                     //        Stream<T> filter(Predicate<? super T> predicate)\n                     //        but T in this case is equal to String\n                     if (callExpr.getScope().isPresent()){\n \n+                        // If it is a static call we should not try to get the type of the scope\n+                        boolean staticCall = false;\n+                        if (callExpr.getScope().get() instanceof NameExpr) {\n+                            NameExpr nameExpr = (NameExpr)callExpr.getScope().get();\n+                            try {\n+                                JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName(), typeSolver);\n+                                staticCall = true;\n+                            } catch (Exception e) {\n \n-                        Type scopeType = JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n-                        if (scopeType.isReferenceType()) {\n-                            result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n+                            }\n+                        }\n+\n+                        if (!staticCall) {\n+                            Type scopeType = JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n+                            if (scopeType.isReferenceType()) {\n+                                result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n+                            }\n                         }\n                     }\n \n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                                 Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                     result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n-            try {\n-                Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n-                if (value.isPresent()) {\n-                    return value.get().getType();\n-                } else {\n-                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n+            if (fieldAccessExpr.getScope() instanceof NameExpr) {\n+                NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n+                SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n+                if (typeAccessedStatically.isSolved()) {\n+                    // TODO here maybe we have to substitute type typeParametersValues\n+                    return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                 }\n-            } catch (UnsolvedSymbolException e) {\n-                // Sure, it was not found as value because maybe it is a type and this is a static access\n-                if (fieldAccessExpr.getScope() instanceof NameExpr) {\n-                    NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n-                    SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n-                    if (!typeAccessedStatically.isSolved()) {\n-                        throw e;\n-                    } else {\n-                        // TODO here maybe we have to substitute type typeParametersValues\n-                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n-                    }\n-                } else {\n-                    throw e;\n-                }\n+            }\n+            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+            if (value.isPresent()) {\n+                return value.get().getType();\n+            } else {\n+                throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() != 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"697432aaf0e6a42825e52f956bd51f0486b411d2": {
			"type": "Ybodychange",
			"commitMessage": "working on resolving type parameters\n",
			"commitDate": "2016-10-23, 2:27 AM",
			"commitName": "697432aaf0e6a42825e52f956bd51f0486b411d2",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-22, 6:36 AM",
			"commitNameOld": "7c43ba3c700d72a0d613bce3659af6d74bc87434",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.83,
			"commitsBetweenForRepo": 24,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,262 +1,279 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n+\n+                    // The type parameter referred here should be the java.util.stream.Stream.T\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+\n+                    // FIXME: here we should replace the type parameters that can be resolved\n+                    //        for example when invoking myListOfStrings.stream().filter(s -> s.length > 0);\n+                    //        the MethodDeclaration of filter is:\n+                    //        Stream<T> filter(Predicate<? super T> predicate)\n+                    //        but T in this case is equal to String\n+                    if (callExpr.getScope().isPresent()){\n+\n+\n+                        Type scopeType = JavaParserFacade.get(typeSolver).getType(callExpr.getScope().get());\n+                        if (scopeType.isReferenceType()) {\n+                            result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n+                        }\n+                    }\n+\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                                 Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                     result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getType();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() != 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7c43ba3c700d72a0d613bce3659af6d74bc87434": {
			"type": "Ybodychange",
			"commitMessage": "using full TypeParameterDeclarations instead of names\n",
			"commitDate": "2016-10-22, 6:36 AM",
			"commitName": "7c43ba3c700d72a0d613bce3659af6d74bc87434",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-22, 3:34 AM",
			"commitNameOld": "a3b7fa9a03cb172d50bf54feddaf90300a6d8d07",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.13,
			"commitsBetweenForRepo": 10,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,262 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n-                            Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n-                            for (String typeName : inferredTypes.keySet()) {\n+                            Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n-                            Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n-                            for (String typeName : inferredTypes.keySet()) {\n+                            Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                            for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n-                                Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n-                                for (String typeName : inferredTypes.keySet()) {\n+                                Map<TypeParameterDeclaration, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                                for (TypeParameterDeclaration typeName : inferredTypes.keySet()) {\n                                     result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getType();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() != 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"15ac26bcc19e8bed431a35edd3e3c176d7d56355": {
			"type": "Ybodychange",
			"commitMessage": "minor\n",
			"commitDate": "2016-10-21, 10:08 AM",
			"commitName": "15ac26bcc19e8bed431a35edd3e3c176d7d56355",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-21, 12:55 AM",
			"commitNameOld": "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.38,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,262 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n-                return value.get().getUsage();\n+                return value.get().getType();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                                 Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator) node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n-                    return value.get().getUsage();\n+                    return value.get().getType();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n         } else if (node instanceof DoubleLiteralExpr) {\n             return PrimitiveType.DOUBLE;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() != 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration) typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9c53c2cbc607ea694438ade8630be0c155a33162": {
			"type": "Ymultichange(Yfilerename,Ybodychange)",
			"commitMessage": "renamed packages to com.github.javapaerser\n",
			"commitDate": "2016-10-20, 12:39 AM",
			"commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
			"commitAuthor": "Federico Tomassetti",
			"subchanges": [
				{
					"type": "Yfilerename",
					"commitMessage": "renamed packages to com.github.javapaerser\n",
					"commitDate": "2016-10-20, 12:39 AM",
					"commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-20, 12:32 AM",
					"commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,262 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n-            Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n+            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                                 Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n-                Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+                Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() != 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
						"newPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "renamed packages to com.github.javapaerser\n",
					"commitDate": "2016-10-20, 12:39 AM",
					"commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-20, 12:32 AM",
					"commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,262 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n-            Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n+            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                                 Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n-                Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+                Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() != 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"6624f3653734698f477561c8407357e2395d411c": {
			"type": "Ybodychange",
			"commitMessage": "fix type of ArrayCreationExpr\n",
			"commitDate": "2016-10-19, 12:21 PM",
			"commitName": "6624f3653734698f477561c8407357e2395d411c",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-19, 11:36 AM",
			"commitNameOld": "967b0302143d4d6868c3d9035a8615ccfd198b6e",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,265 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                                 Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             if (expr.getVariables().size() != 1) {\n                 throw new UnsupportedOperationException();\n             }\n             return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n-            for (int i=0; i<arrayCreationExpr.getLevels().size();i++) {\n-                res = new ArrayType(res);\n-            }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"967b0302143d4d6868c3d9035a8615ccfd198b6e": {
			"type": "Ybodychange",
			"commitMessage": "use VariableDeclarator.getType\n",
			"commitDate": "2016-10-19, 11:36 AM",
			"commitName": "967b0302143d4d6868c3d9035a8615ccfd198b6e",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-19, 11:36 AM",
			"commitNameOld": "9dc06a758c00cc235372dbc225a7e20c1f5269d3",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,262 +1,265 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                                 Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n-                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n+                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n-                return JavaParserFacade.get(typeSolver).convertToUsageVariableType(parent);\n+                return JavaParserFacade.get(typeSolver).convertToUsageVariableType((VariableDeclarator)node);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n-            return convertToUsageVariableType(expr);\n+            if (expr.getVariables().size() != 1) {\n+                throw new UnsupportedOperationException();\n+            }\n+            return convertToUsageVariableType(expr.getVariables().get(0));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i=0; i<arrayCreationExpr.getLevels().size();i++) {\n                 res = new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9dc06a758c00cc235372dbc225a7e20c1f5269d3": {
			"type": "Ybodychange",
			"commitMessage": "considering the ArrayBrackets\n",
			"commitDate": "2016-10-19, 11:36 AM",
			"commitName": "9dc06a758c00cc235372dbc225a7e20c1f5269d3",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-19, 11:36 AM",
			"commitNameOld": "4c6207acd87601844c87c13fb253ae8fd8a4a289",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,262 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (getParentNode(node) instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                                 Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n-                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n+                return JavaParserFacade.get(typeSolver).convertToUsageVariableType(parent);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n-            return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n+            return convertToUsageVariableType(expr);\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i=0; i<arrayCreationExpr.getLevels().size();i++) {\n                 res = new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0d14741fef3a17451db153cfe379e398da4b4b79": {
			"type": "Ybodychange",
			"commitMessage": "minor fix\n",
			"commitDate": "2016-10-19, 11:35 AM",
			"commitName": "0d14741fef3a17451db153cfe379e398da4b4b79",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-19, 11:35 AM",
			"commitNameOld": "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,262 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n-            if (node.getParentNode() instanceof MethodCallExpr) {\n-                MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n+            if (getParentNode(node) instanceof MethodCallExpr) {\n+                MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n-                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n+                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n-            if (node.getParentNode() instanceof MethodCallExpr) {\n-                MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n+            if (getParentNode(node) instanceof MethodCallExpr) {\n+                MethodCallExpr callExpr = (MethodCallExpr) getParentNode(node);\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n-                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n+                    throw new UnsolvedSymbolException(getParentNode(node).toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                                 Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (getParentNode(node) instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n             } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i=0; i<arrayCreationExpr.getLevels().size();i++) {\n                 res = new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4601dfb9d1acf7f564948b7ddbb9201d62849ad7": {
			"type": "Ybodychange",
			"commitMessage": "revision of modified code to use Navigator.getParentNode\n",
			"commitDate": "2016-10-19, 11:35 AM",
			"commitName": "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-19, 11:34 AM",
			"commitNameOld": "03e407957d600a18ef0a4a83224c17d155ef8645",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,262 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                                 Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n-            if (node.getParentNode().getParentNode() instanceof FieldDeclaration) {\n-                FieldDeclaration parent = (FieldDeclaration) node.getParentNode().getParentNode();\n+            if (getParentNode(node) instanceof FieldDeclaration) {\n+                FieldDeclaration parent = (FieldDeclaration) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n-            } else if (node.getParentNode().getParentNode() instanceof VariableDeclarationExpr) {\n-                VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode().getParentNode();\n+            } else if (getParentNode(node) instanceof VariableDeclarationExpr) {\n+                VariableDeclarationExpr parent = (VariableDeclarationExpr) getParentNode(node);\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n             } else {\n-                throw new UnsupportedOperationException(node.getParentNode().getParentNode().getClass().getCanonicalName());\n+                throw new UnsupportedOperationException(getParentNode(node).getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i=0; i<arrayCreationExpr.getLevels().size();i++) {\n                 res = new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"03e407957d600a18ef0a4a83224c17d155ef8645": {
			"type": "Ybodychange",
			"commitMessage": "fixing a few more tests\n",
			"commitDate": "2016-10-19, 11:34 AM",
			"commitName": "03e407957d600a18ef0a4a83224c17d155ef8645",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-19, 11:33 AM",
			"commitNameOld": "3fcd7b41f404d112b13d3bfe732b26eceec0dbfe",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,262 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                                 Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n-            if (node.getParentNode() instanceof FieldDeclaration) {\n-                FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n+            if (node.getParentNode().getParentNode() instanceof FieldDeclaration) {\n+                FieldDeclaration parent = (FieldDeclaration) node.getParentNode().getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n-            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n-                VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n+            } else if (node.getParentNode().getParentNode() instanceof VariableDeclarationExpr) {\n+                VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode().getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n             } else {\n-                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n+                throw new UnsupportedOperationException(node.getParentNode().getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i=0; i<arrayCreationExpr.getLevels().size();i++) {\n                 res = new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"341e081a5f8909a3a467671befcca2941b786d3d": {
			"type": "Ybodychange",
			"commitMessage": "issue91: solve compilation issues\n",
			"commitDate": "2016-10-19, 11:33 AM",
			"commitName": "341e081a5f8909a3a467671befcca2941b786d3d",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-19, 9:04 AM",
			"commitNameOld": "683012de2a3a28358e848f8b145d462eb8b322ba",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.1,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,262 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                                 Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n-                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n+                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n-                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n+                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getElementType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n-                case posIncrement:\n+                case postIncrement:\n                 case preIncrement:\n                 case preDecrement:\n-                case posDecrement:\n+                case postDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n-            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n+            return convertToUsage(expr.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n-            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n+            return getTypeConcrete(enclosedExpr.getInner().get(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n-            for (int i=0; i<arrayCreationExpr.getArrayCount();i++) {\n+            for (int i=0; i<arrayCreationExpr.getLevels().size();i++) {\n                 res = new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"70f3e66c944670a818922f101162226ef604b263": {
			"type": "Ybodychange",
			"commitMessage": "deprecating some methods involving type parameters\n",
			"commitDate": "2016-10-14, 11:24 AM",
			"commitName": "70f3e66c944670a818922f101162226ef604b263",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-14, 10:51 AM",
			"commitNameOld": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,262 +1,262 @@\n     private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             Type actualType = getType(expressionStmt.getExpression());\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                             List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                                 Type actualType = getType(expressionStmt.getExpression());\n                                 Type formalType = functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                                 Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n-                        // TODO here maybe we have to substitute type parameters\n+                        // TODO here maybe we have to substitute type typeParametersValues\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return type;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveType.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i=0; i<arrayCreationExpr.getArrayCount();i++) {\n                 res = new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"82eb44707b620803d424188a1eb8708fcaf093cb": {
			"type": "Ymultichange(Yreturntypechange,Ybodychange)",
			"commitMessage": "rename TypeUsage into Type\n",
			"commitDate": "2016-10-13, 2:11 PM",
			"commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
			"commitAuthor": "Federico Tomassetti",
			"subchanges": [
				{
					"type": "Yreturntypechange",
					"commitMessage": "rename TypeUsage into Type\n",
					"commitDate": "2016-10-13, 2:11 PM",
					"commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-13, 6:20 AM",
					"commitNameOld": "14c9305d49885a12acdb7c09d2e35ad29b5403cf",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.33,
					"commitsBetweenForRepo": 13,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,262 +1,262 @@\n-    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n+    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n-                    TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+                    Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n-                        List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n+                        List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n-                            TypeUsage actualType = getType(expressionStmt.getExpression());\n-                            TypeUsage formalType = functionalMethod.get().returnType();\n+                            Type actualType = getType(expressionStmt.getExpression());\n+                            Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n-                            Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                            Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n-                    TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+                    Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n-                            List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n-                            TypeUsage actualType = toMethodUsage(methodReferenceExpr).returnType();\n-                            TypeUsage formalType = functionalMethod.get().returnType();\n+                            List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n+                            Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n+                            Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n-                            Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                            Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n-                            List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n+                            List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n-                                TypeUsage actualType = getType(expressionStmt.getExpression());\n-                                TypeUsage formalType = functionalMethod.get().returnType();\n+                                Type actualType = getType(expressionStmt.getExpression());\n+                                Type formalType = functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n-                                Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                                Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n-            TypeUsage typeUsage = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n-            return typeUsage;\n+            Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n+            return type;\n         } else if (node instanceof NullLiteralExpr) {\n-            return NullTypeUsage.INSTANCE;\n+            return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n-            return PrimitiveTypeUsage.BOOLEAN;\n+            return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n-            return PrimitiveTypeUsage.INT;\n+            return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n-            return PrimitiveTypeUsage.LONG;\n+            return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n-            return PrimitiveTypeUsage.CHAR;\n+            return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n-\t\t\treturn PrimitiveTypeUsage.DOUBLE;\n+\t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n-            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n+            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n-                    return PrimitiveTypeUsage.BOOLEAN;\n+                    return PrimitiveType.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n-                    return PrimitiveTypeUsage.BOOLEAN;\n+                    return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n-            return PrimitiveTypeUsage.BOOLEAN;\n+            return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n-            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n+            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n-            TypeUsage res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n+            Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i=0; i<arrayCreationExpr.getArrayCount();i++) {\n-                res = new ArrayTypeUsage(res);\n+                res = new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n-            return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n+            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "TypeUsage",
						"newValue": "Type"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "rename TypeUsage into Type\n",
					"commitDate": "2016-10-13, 2:11 PM",
					"commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-13, 6:20 AM",
					"commitNameOld": "14c9305d49885a12acdb7c09d2e35ad29b5403cf",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.33,
					"commitsBetweenForRepo": 13,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,262 +1,262 @@\n-    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n+    private Type getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n-                    TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+                    Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n-                        List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n+                        List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n-                            TypeUsage actualType = getType(expressionStmt.getExpression());\n-                            TypeUsage formalType = functionalMethod.get().returnType();\n+                            Type actualType = getType(expressionStmt.getExpression());\n+                            Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n-                            Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                            Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n-                    TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+                    Type result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         if (node instanceof MethodReferenceExpr) {\n                             MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n-                            List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n-                            TypeUsage actualType = toMethodUsage(methodReferenceExpr).returnType();\n-                            TypeUsage formalType = functionalMethod.get().returnType();\n+                            List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n+                            Type actualType = toMethodUsage(methodReferenceExpr).returnType();\n+                            Type formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n-                            Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                            Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n \n                         } else {\n                             LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n-                            List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n+                            List<Tuple2<Type, Type>> formalActualTypePairs = new ArrayList<>();\n                             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                                 ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n-                                TypeUsage actualType = getType(expressionStmt.getExpression());\n-                                TypeUsage formalType = functionalMethod.get().returnType();\n+                                Type actualType = getType(expressionStmt.getExpression());\n+                                Type formalType = functionalMethod.get().returnType();\n                                 formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n-                                Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                                Map<String, Type> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                                 for (String typeName : inferredTypes.keySet()) {\n                                     result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n-            TypeUsage typeUsage = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n-            return typeUsage;\n+            Type type = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n+            return type;\n         } else if (node instanceof NullLiteralExpr) {\n-            return NullTypeUsage.INSTANCE;\n+            return NullType.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n-            return PrimitiveTypeUsage.BOOLEAN;\n+            return PrimitiveType.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n-            return PrimitiveTypeUsage.INT;\n+            return PrimitiveType.INT;\n         } else if (node instanceof LongLiteralExpr) {\n-            return PrimitiveTypeUsage.LONG;\n+            return PrimitiveType.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n-            return PrimitiveTypeUsage.CHAR;\n+            return PrimitiveType.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n-\t\t\treturn PrimitiveTypeUsage.DOUBLE;\n+\t\t\treturn PrimitiveType.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n-            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n+            return new ReferenceTypeImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n-                    return PrimitiveTypeUsage.BOOLEAN;\n+                    return PrimitiveType.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n-                    return PrimitiveTypeUsage.BOOLEAN;\n+                    return PrimitiveType.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n-            return PrimitiveTypeUsage.BOOLEAN;\n+            return PrimitiveType.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n-            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n+            return new ReferenceTypeImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n-            TypeUsage res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n+            Type res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i=0; i<arrayCreationExpr.getArrayCount();i++) {\n-                res = new ArrayTypeUsage(res);\n+                res = new ArrayType(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n-            return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n+            return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"acf74024c2d341bf4009af7173c9b1b972f19c32": {
			"type": "Ybodychange",
			"commitMessage": "issue80: resolving MethodRefExpr\n",
			"commitDate": "2016-10-11, 11:37 AM",
			"commitName": "acf74024c2d341bf4009af7173c9b1b972f19c32",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-10, 3:28 PM",
			"commitNameOld": "7317fe7d60ad0af88e9ee692e95dd5dde832863e",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.84,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,248 +1,262 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             TypeUsage actualType = getType(expressionStmt.getExpression());\n                             TypeUsage formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n-                        LambdaExpr lambdaExpr = (LambdaExpr)node;\n+                        if (node instanceof MethodReferenceExpr) {\n+                            MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n-                        List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n-                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n-                            ExpressionStmt expressionStmt = (ExpressionStmt)lambdaExpr.getBody();\n-                            TypeUsage actualType = getType (expressionStmt.getExpression());\n+                            List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n+                            TypeUsage actualType = toMethodUsage(methodReferenceExpr).returnType();\n                             TypeUsage formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n+\n                         } else {\n-                            throw new UnsupportedOperationException();\n+                            LambdaExpr lambdaExpr = (LambdaExpr) node;\n+\n+                            List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n+                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n+                                ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n+                                TypeUsage actualType = getType(expressionStmt.getExpression());\n+                                TypeUsage formalType = functionalMethod.get().returnType();\n+                                formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n+                                Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                                for (String typeName : inferredTypes.keySet()) {\n+                                    result = result.replaceParam(typeName, inferredTypes.get(typeName));\n+                                }\n+                            } else {\n+                                throw new UnsupportedOperationException();\n+                            }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveTypeUsage.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             TypeUsage res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i=0; i<arrayCreationExpr.getArrayCount();i++) {\n                 res = new ArrayTypeUsage(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7317fe7d60ad0af88e9ee692e95dd5dde832863e": {
			"type": "Ybodychange",
			"commitMessage": "Revert \"issue80: working on resolving methodref generic type parameters\"\n\nThis reverts commit 2c6d213f0359d5b52a9d570323aa10505415f6ac.\n",
			"commitDate": "2016-10-10, 3:28 PM",
			"commitName": "7317fe7d60ad0af88e9ee692e95dd5dde832863e",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-10, 1:51 PM",
			"commitNameOld": "2c6d213f0359d5b52a9d570323aa10505415f6ac",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.07,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,266 +1,248 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             TypeUsage actualType = getType(expressionStmt.getExpression());\n                             TypeUsage formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n-                        if (node instanceof MethodReferenceExpr) {\n-                            MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n+                        LambdaExpr lambdaExpr = (LambdaExpr)node;\n \n-                            List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n-\n-                            MethodUsage methodUsage =  resolveMethodRef(methodReferenceExpr);\n-\n-\n-                            TypeUsage actualType = methodUsage.returnType();\n+                        List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n+                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n+                            ExpressionStmt expressionStmt = (ExpressionStmt)lambdaExpr.getBody();\n+                            TypeUsage actualType = getType (expressionStmt.getExpression());\n                             TypeUsage formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n-\n                         } else {\n-                            LambdaExpr lambdaExpr = (LambdaExpr) node;\n-\n-                            List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n-                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n-                                ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n-                                TypeUsage actualType = getType(expressionStmt.getExpression());\n-                                TypeUsage formalType = functionalMethod.get().returnType();\n-                                formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n-                                Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n-                                for (String typeName : inferredTypes.keySet()) {\n-                                    result = result.replaceParam(typeName, inferredTypes.get(typeName));\n-                                }\n-                            } else {\n-                                throw new UnsupportedOperationException();\n-                            }\n+                            throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveTypeUsage.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             TypeUsage res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i=0; i<arrayCreationExpr.getArrayCount();i++) {\n                 res = new ArrayTypeUsage(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2c6d213f0359d5b52a9d570323aa10505415f6ac": {
			"type": "Ybodychange",
			"commitMessage": "issue80: working on resolving methodref generic type parameters\n",
			"commitDate": "2016-10-10, 1:51 PM",
			"commitName": "2c6d213f0359d5b52a9d570323aa10505415f6ac",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-09, 11:11 AM",
			"commitNameOld": "68b3e019e1216a941ff5d8dcf63aefc9b35a3787",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 1.11,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,248 +1,266 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr) node;\n \n                         List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n                             TypeUsage actualType = getType(expressionStmt.getExpression());\n                             TypeUsage formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof MethodReferenceExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n-                        LambdaExpr lambdaExpr = (LambdaExpr)node;\n+                        if (node instanceof MethodReferenceExpr) {\n+                            MethodReferenceExpr methodReferenceExpr = (MethodReferenceExpr) node;\n \n-                        List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n-                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n-                            ExpressionStmt expressionStmt = (ExpressionStmt)lambdaExpr.getBody();\n-                            TypeUsage actualType = getType (expressionStmt.getExpression());\n+                            List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n+\n+                            MethodUsage methodUsage =  resolveMethodRef(methodReferenceExpr);\n+\n+\n+                            TypeUsage actualType = methodUsage.returnType();\n                             TypeUsage formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n+\n                         } else {\n-                            throw new UnsupportedOperationException();\n+                            LambdaExpr lambdaExpr = (LambdaExpr) node;\n+\n+                            List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n+                            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n+                                ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n+                                TypeUsage actualType = getType(expressionStmt.getExpression());\n+                                TypeUsage formalType = functionalMethod.get().returnType();\n+                                formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n+                                Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                                for (String typeName : inferredTypes.keySet()) {\n+                                    result = result.replaceParam(typeName, inferredTypes.get(typeName));\n+                                }\n+                            } else {\n+                                throw new UnsupportedOperationException();\n+                            }\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveTypeUsage.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             TypeUsage res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i=0; i<arrayCreationExpr.getArrayCount();i++) {\n                 res = new ArrayTypeUsage(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"68b3e019e1216a941ff5d8dcf63aefc9b35a3787": {
			"type": "Ybodychange",
			"commitMessage": "issue80: progress in supporting Method references\n",
			"commitDate": "2016-10-09, 11:11 AM",
			"commitName": "68b3e019e1216a941ff5d8dcf63aefc9b35a3787",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-09, 11:00 AM",
			"commitNameOld": "91127219c066635d47cfe8d849a2814308d14cdc",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,203 +1,248 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n+                        LambdaExpr lambdaExpr = (LambdaExpr) node;\n+\n+                        List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n+                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n+                            ExpressionStmt expressionStmt = (ExpressionStmt) lambdaExpr.getBody();\n+                            TypeUsage actualType = getType(expressionStmt.getExpression());\n+                            TypeUsage formalType = functionalMethod.get().returnType();\n+                            formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n+                            Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                            for (String typeName : inferredTypes.keySet()) {\n+                                result = result.replaceParam(typeName, inferredTypes.get(typeName));\n+                            }\n+                        } else {\n+                            throw new UnsupportedOperationException();\n+                        }\n+                    }\n+\n+                    return result;\n+                } else {\n+                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+            }\n+        } else if (node instanceof MethodReferenceExpr) {\n+            if (node.getParentNode() instanceof MethodCallExpr) {\n+                MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n+                int pos = JavaParserSymbolDeclaration.getParamPos(node);\n+                SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr, false);\n+                if (!refMethod.isSolved()) {\n+                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n+                }\n+                logger.finest(\"getType on method reference expr \" + refMethod.getCorrespondingDeclaration().getName());\n+                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n+                if (solveLambdas) {\n+                    TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+                    // We need to replace the type variables\n+                    Context ctx = JavaParserFactory.getContext(node, typeSolver);\n+                    result = solveGenericTypes(result, ctx, typeSolver);\n+\n+                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n+                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n+                    //lambdas\n+                    Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n+                    if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr)node;\n \n                         List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt)lambdaExpr.getBody();\n                             TypeUsage actualType = getType (expressionStmt.getExpression());\n                             TypeUsage formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n-                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+                throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveTypeUsage.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             TypeUsage res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i=0; i<arrayCreationExpr.getArrayCount();i++) {\n                 res = new ArrayTypeUsage(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"47a5cc851b7db16ab0bcd4b1c0a4dceccfe13f74": {
			"type": "Ybodychange",
			"commitMessage": "issue80: better handling of Lambdas and FunctionInterface\n",
			"commitDate": "2016-10-09, 2:42 AM",
			"commitName": "47a5cc851b7db16ab0bcd4b1c0a4dceccfe13f74",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-08, 2:17 PM",
			"commitNameOld": "cb7655f9661f11dab8ec9e2533722d649a16e715",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.52,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,203 +1,203 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n-                    throw new UnsolvedSymbolException(callExpr.getName());\n+                    throw new UnsolvedSymbolException(node.getParentNode().toString(), callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr)node;\n \n                         List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt)lambdaExpr.getBody();\n                             TypeUsage actualType = getType (expressionStmt.getExpression());\n                             TypeUsage formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveTypeUsage.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             TypeUsage res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i=0; i<arrayCreationExpr.getArrayCount();i++) {\n                 res = new ArrayTypeUsage(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cb7655f9661f11dab8ec9e2533722d649a16e715": {
			"type": "Ybodychange",
			"commitMessage": "issue80: improving resolution of static methods\n",
			"commitDate": "2016-10-08, 2:17 PM",
			"commitName": "cb7655f9661f11dab8ec9e2533722d649a16e715",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-09-29, 9:28 AM",
			"commitNameOld": "31433fc385c0fea7ead68e4c853807752e061565",
			"commitAuthorOld": "malte_langkabel",
			"daysBetweenCommits": 9.2,
			"commitsBetweenForRepo": 19,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,203 +1,203 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n-                throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n+                throw new UnsolvedSymbolException(\"Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr)node;\n \n                         List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt)lambdaExpr.getBody();\n                             TypeUsage actualType = getType (expressionStmt.getExpression());\n                             TypeUsage formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveTypeUsage.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             TypeUsage res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i=0; i<arrayCreationExpr.getArrayCount();i++) {\n                 res = new ArrayTypeUsage(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n         } else if (node instanceof ClassExpr) {\n             // This implementation does not regard the actual type argument of the ClassExpr.\n             return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"31433fc385c0fea7ead68e4c853807752e061565": {
			"type": "Ybodychange",
			"commitMessage": "Implemented solving type of a ClassExpr. This fixes issue #64.\n",
			"commitDate": "2016-09-29, 9:28 AM",
			"commitName": "31433fc385c0fea7ead68e4c853807752e061565",
			"commitAuthor": "malte_langkabel",
			"commitDateOld": "2016-09-27, 3:57 AM",
			"commitNameOld": "cb2a7efc0de1197ac95d22171bd861623c7e0e27",
			"commitAuthorOld": "malte_langkabel",
			"daysBetweenCommits": 2.23,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,200 +1,203 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr)node;\n \n                         List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt)lambdaExpr.getBody();\n                             TypeUsage actualType = getType (expressionStmt.getExpression());\n                             TypeUsage formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveTypeUsage.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             TypeUsage res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i=0; i<arrayCreationExpr.getArrayCount();i++) {\n                 res = new ArrayTypeUsage(res);\n             }\n             return res;\n         } else if (node instanceof ArrayAccessExpr) {\n             ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n             return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n         } else if (node instanceof SuperExpr) {\n             TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n             if (typeOfNode instanceof ClassDeclaration) {\n                 return ((ClassDeclaration)typeOfNode).getSuperClass();\n             } else {\n                 throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n             }\n+        } else if (node instanceof ClassExpr) {\n+            // This implementation does not regard the actual type argument of the ClassExpr.\n+            return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Class.class, typeSolver), typeSolver);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a541f77a5a66a911e347d294aa76d8703e72e7db": {
			"type": "Ybodychange",
			"commitMessage": "Implemented solving method calls on ArrayAccessExpr and SuperExpr. This fixes issue #41.\n",
			"commitDate": "2016-09-22, 6:06 AM",
			"commitName": "a541f77a5a66a911e347d294aa76d8703e72e7db",
			"commitAuthor": "malte_langkabel",
			"commitDateOld": "2016-09-20, 2:11 PM",
			"commitNameOld": "511490972b01d148a30dce013ede4ce213b3f05e",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 1.66,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,191 +1,200 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr)node;\n \n                         List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt)lambdaExpr.getBody();\n                             TypeUsage actualType = getType (expressionStmt.getExpression());\n                             TypeUsage formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n-\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n \t\t} else if (node instanceof DoubleLiteralExpr) {\n \t\t\treturn PrimitiveTypeUsage.DOUBLE;\n \t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             TypeUsage res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i=0; i<arrayCreationExpr.getArrayCount();i++) {\n                 res = new ArrayTypeUsage(res);\n             }\n             return res;\n+        } else if (node instanceof ArrayAccessExpr) {\n+            ArrayAccessExpr arrayAccessExpr = (ArrayAccessExpr) node;\n+            return getTypeConcrete(arrayAccessExpr.getName(), solveLambdas);\n+        } else if (node instanceof SuperExpr) {\n+            TypeDeclaration typeOfNode = getTypeDeclaration(findContainingTypeDecl(node));\n+            if (typeOfNode instanceof ClassDeclaration) {\n+                return ((ClassDeclaration)typeOfNode).getSuperClass();\n+            } else {\n+                throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n+            }\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"651f1ca3e9c7a8fec6826f9da14f9abb5fe921e0": {
			"type": "Ybodychange",
			"commitMessage": "Make typesolver recognize double literals\n",
			"commitDate": "2016-01-04, 11:59 AM",
			"commitName": "651f1ca3e9c7a8fec6826f9da14f9abb5fe921e0",
			"commitAuthor": "Evan",
			"commitDateOld": "2015-11-22, 3:45 AM",
			"commitNameOld": "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 43.34,
			"commitsBetweenForRepo": 23,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,189 +1,191 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr)node;\n \n                         List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt)lambdaExpr.getBody();\n                             TypeUsage actualType = getType (expressionStmt.getExpression());\n                             TypeUsage formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n-        } else if (node instanceof StringLiteralExpr) {\n+\t\t} else if (node instanceof DoubleLiteralExpr) {\n+\t\t\treturn PrimitiveTypeUsage.DOUBLE;\n+\t\t} else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             TypeUsage res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n             for (int i=0; i<arrayCreationExpr.getArrayCount();i++) {\n                 res = new ArrayTypeUsage(res);\n             }\n             return res;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8e655d386a595ea1927ebeded58939d7b8a7ce0c": {
			"type": "Yfilerename",
			"commitMessage": "test JavaParserClassDeclaration\n",
			"commitDate": "2015-11-22, 3:45 AM",
			"commitName": "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-22, 3:03 AM",
			"commitNameOld": "68d87977d826a8c48711297732b7ae10f3dc1f1f",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
				"newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java"
			}
		},
		"ead147279ca0b84d2f479a714943b20cd689e7c7": {
			"type": "Ybodychange",
			"commitMessage": "issue7: consider type parameters and varargs combinations\n",
			"commitDate": "2015-11-20, 9:04 AM",
			"commitName": "ead147279ca0b84d2f479a714943b20cd689e7c7",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-14, 4:41 AM",
			"commitNameOld": "454904fe0cb3b15aa506e3f5fa8f0c9fb1313f61",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 6.18,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,186 +1,189 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n-            JavaParserFacade javaParserFacade = JavaParserFacade.get(typeSolver);\n-            MethodUsage ref = javaParserFacade.solveMethodAsUsage((MethodCallExpr) node);\n+            MethodUsage ref = solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr)node;\n \n                         List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt)lambdaExpr.getBody();\n                             TypeUsage actualType = getType (expressionStmt.getExpression());\n                             TypeUsage formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n-            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n+            TypeUsage res = convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n+            for (int i=0; i<arrayCreationExpr.getArrayCount();i++) {\n+                res = new ArrayTypeUsage(res);\n+            }\n+            return res;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a6849db3884e47909d2d97fcac0b057ab13d544b": {
			"type": "Ybodychange",
			"commitMessage": "fix lambda solving\n",
			"commitDate": "2015-11-14, 3:15 AM",
			"commitName": "a6849db3884e47909d2d97fcac0b057ab13d544b",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-13, 3:07 PM",
			"commitNameOld": "94446666d149c898131d04e7fd567777258e4e1e",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.51,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,185 +1,186 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n-            MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n+            JavaParserFacade javaParserFacade = JavaParserFacade.get(typeSolver);\n+            MethodUsage ref = javaParserFacade.solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n-                SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n+                SymbolReference<MethodDeclaration> refMethod = JavaParserFacade.get(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                     result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr)node;\n \n                         List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n                         if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                             ExpressionStmt expressionStmt = (ExpressionStmt)lambdaExpr.getBody();\n                             TypeUsage actualType = getType (expressionStmt.getExpression());\n                             TypeUsage formalType = functionalMethod.get().returnType();\n                             formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n                             Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n                             for (String typeName : inferredTypes.keySet()) {\n                                 result = result.replaceParam(typeName, inferredTypes.get(typeName));\n                             }\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n-                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n+                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n-                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n+                return JavaParserFacade.get(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n-            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n+            return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n-            TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n+            TypeUsage typeUsage = JavaParserFacade.get(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"94446666d149c898131d04e7fd567777258e4e1e": {
			"type": "Ybodychange",
			"commitMessage": "fix LambdaTest.lambdaMapParameter\n",
			"commitDate": "2015-11-13, 3:07 PM",
			"commitName": "94446666d149c898131d04e7fd567777258e4e1e",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-13, 12:41 PM",
			"commitNameOld": "b9725d0d363bb2b1364fb159eefdfbfbc1e3fa97",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.1,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,174 +1,185 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n-                    result = solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n+                    Context ctx = JavaParserFactory.getContext(node, typeSolver);\n+                    result = solveGenericTypes(result, ctx, typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         LambdaExpr lambdaExpr = (LambdaExpr)node;\n \n-                        //for (lambdaExpr.getParameters())\n-                        // TODO invoke GenericTypeInferenceLogic and the use results\n-                        throw new UnsupportedOperationException();\n+                        List<Tuple2<TypeUsage, TypeUsage>> formalActualTypePairs = new ArrayList<>();\n+                        if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n+                            ExpressionStmt expressionStmt = (ExpressionStmt)lambdaExpr.getBody();\n+                            TypeUsage actualType = getType (expressionStmt.getExpression());\n+                            TypeUsage formalType = functionalMethod.get().returnType();\n+                            formalActualTypePairs.add(new Tuple2<>(formalType, actualType));\n+                            Map<String, TypeUsage> inferredTypes = GenericTypeInferenceLogic.inferGenericTypes(formalActualTypePairs);\n+                            for (String typeName : inferredTypes.keySet()) {\n+                                result = result.replaceParam(typeName, inferredTypes.get(typeName));\n+                            }\n+                        } else {\n+                            throw new UnsupportedOperationException();\n+                        }\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b9725d0d363bb2b1364fb159eefdfbfbc1e3fa97": {
			"type": "Ybodychange",
			"commitMessage": "add GenericTypeInferenceLogic\n",
			"commitDate": "2015-11-13, 12:41 PM",
			"commitName": "b9725d0d363bb2b1364fb159eefdfbfbc1e3fa97",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-13, 12:06 PM",
			"commitNameOld": "a75fd9d3835fade5c3a1a6ef7a9d36d108a1367e",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,170 +1,174 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     result = solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n                     Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n+                        LambdaExpr lambdaExpr = (LambdaExpr)node;\n+\n+                        //for (lambdaExpr.getParameters())\n+                        // TODO invoke GenericTypeInferenceLogic and the use results\n                         throw new UnsupportedOperationException();\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a75fd9d3835fade5c3a1a6ef7a9d36d108a1367e": {
			"type": "Ybodychange",
			"commitMessage": "add FunctionInterfaceLogic\n",
			"commitDate": "2015-11-13, 12:06 PM",
			"commitName": "a75fd9d3835fade5c3a1a6ef7a9d36d108a1367e",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-13, 11:19 AM",
			"commitNameOld": "f20bec1be7e976300ef4857e347bc735ded0f305",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,170 +1,170 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     result = solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n \n                     //We should find out which is the functional method (e.g., apply) and replace the params of the\n                     //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                     //lambdas\n-                    Optional<MethodUsage> functionalMethod = getFunctionalMethod(result);\n+                    Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                     if (functionalMethod.isPresent()) {\n                         throw new UnsupportedOperationException();\n                     }\n \n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f20bec1be7e976300ef4857e347bc735ded0f305": {
			"type": "Ybodychange",
			"commitMessage": "add RedlectionInterfaceDeclarationTest\n",
			"commitDate": "2015-11-13, 11:19 AM",
			"commitName": "f20bec1be7e976300ef4857e347bc735ded0f305",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-13, 2:59 AM",
			"commitNameOld": "4a18b1ee8ed716d6e32e190f728f1eee57148872",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.35,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,161 +1,170 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     result = solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n+\n+                    //We should find out which is the functional method (e.g., apply) and replace the params of the\n+                    //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n+                    //lambdas\n+                    Optional<MethodUsage> functionalMethod = getFunctionalMethod(result);\n+                    if (functionalMethod.isPresent()) {\n+                        throw new UnsupportedOperationException();\n+                    }\n+\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4a18b1ee8ed716d6e32e190f728f1eee57148872": {
			"type": "Ybodychange",
			"commitMessage": "modules: extraction of the model module\n",
			"commitDate": "2015-11-13, 2:59 AM",
			"commitName": "4a18b1ee8ed716d6e32e190f728f1eee57148872",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-13, 2:12 AM",
			"commitNameOld": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,161 +1,161 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n-            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n+            Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()) {\n                 throw new UnsolvedSymbolException(\"FOO Solving \" + node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     result = solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter) node;\n             if (parameter.getType() instanceof UnknownType) {\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n-                Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+                Optional<me.tomassetti.symbolsolver.model.resolution.Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e) {\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr) {\n                     NameExpr staticValue = (NameExpr) fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n-            return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n+            return new ReferenceTypeUsageImpl(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr) node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" + binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr) node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr) node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr) node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n-            return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n+            return new ReferenceTypeUsageImpl(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr) node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr) node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f4b07b1a2deac6d1b562424ac2380b92cec77a90": {
			"type": "Yfilerename",
			"commitMessage": "modules: organization in modules\n",
			"commitDate": "2015-11-13, 2:12 AM",
			"commitName": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-13, 1:53 AM",
			"commitNameOld": "d96a8ff67d857a2988488f1fc31202f0e2ed8061",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
				"newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java"
			}
		},
		"39477e7f9375d6a539eb0ddc69eb69d986b2a8c8": {
			"type": "Ybodychange",
			"commitMessage": "removing TypeSolver from model.declarations\n",
			"commitDate": "2015-11-02, 12:48 PM",
			"commitName": "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-10-31, 9:01 AM",
			"commitNameOld": "03ec309bba14eaf50a32b05353fa9711b831de7f",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 2.2,
			"commitsBetweenForRepo": 15,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,161 +1,161 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n-                    TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n+                    TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                     // We need to replace the type variables\n                     result = solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                     return result;\n                 } else {\n-                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n+                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n-                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType(typeSolver);\n+                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType();\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr)node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fb388c36c0045c50744cf215521e5c280036aa70": {
			"type": "Yfilerename",
			"commitMessage": "move JavaParser specific code to specific package\n",
			"commitDate": "2015-10-31, 5:11 AM",
			"commitName": "fb388c36c0045c50744cf215521e5c280036aa70",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-10-31, 3:57 AM",
			"commitNameOld": "b2bf624be5d1ef59480250e66224aeaa1886df36",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.05,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
				"newPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java"
			}
		},
		"c04083d20425a664115db6b0df3ca9632e66ecca": {
			"type": "Ybodychange",
			"commitMessage": "removing TypeSolver from fields related methods of TypeDeclaration\n",
			"commitDate": "2015-10-31, 3:52 AM",
			"commitName": "c04083d20425a664115db6b0df3ca9632e66ecca",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-10-31, 3:22 AM",
			"commitNameOld": "960364fad3fc2ead6113d4c5d4b7d9ebf23e2f9a",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,161 +1,161 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result = solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n-                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n+                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField()).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr)node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0e81f51c40996b42cb262dc2397126cee8f60965": {
			"type": "Ybodychange",
			"commitMessage": "embedding TypeSolver\n",
			"commitDate": "2015-10-30, 4:37 PM",
			"commitName": "0e81f51c40996b42cb262dc2397126cee8f60965",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-10-30, 9:43 AM",
			"commitNameOld": "005ec580724781a825aaf08a496ad7f8f667b27f",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.29,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,161 +1,161 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n-                    result = solveGenericTypes(result, JavaParserFactory.getContext(node), typeSolver);\n+                    result = solveGenericTypes(result, JavaParserFactory.getContext(node, typeSolver), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n-                    SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n+                    SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr, typeSolver).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n-            return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"));\n+            return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"), typeSolver);\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr)node;\n-            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n+            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr)node;\n-            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n+            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n-            return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)));\n+            return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)), typeSolver);\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr)node;\n-            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n+            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node, typeSolver));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fb0467dc222157e9f485ae4b3f6c7a637fdfcd1c": {
			"type": "Ybodychange",
			"commitMessage": "simplify TypeUsage\n",
			"commitDate": "2015-10-30, 7:13 AM",
			"commitName": "fb0467dc222157e9f485ae4b3f6c7a637fdfcd1c",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-10-30, 3:53 AM",
			"commitNameOld": "b36f33050149a62a5b3c8c7451ae93f736715029",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.14,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,161 +1,161 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n-                    result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n+                    result = solveGenericTypes(result, JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr)node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"68aeb576ccb2b44e436d13d0be2660f85dc9ee4b": {
			"type": "Ybodychange",
			"commitMessage": "renaming\n",
			"commitDate": "2015-10-28, 9:18 AM",
			"commitName": "68aeb576ccb2b44e436d13d0be2660f85dc9ee4b",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-27, 8:40 AM",
			"commitNameOld": "bed91989f7354552d72b2b7f0c28fcbd24fee003",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 62.03,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,161 +1,161 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n-            return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n+            return new ReferenceTypeUsage(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n-            return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n+            return new ReferenceTypeUsage(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr)node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"640eb2479a4e05bb8ee0d95f74172be9dfa283f6": {
			"type": "Ybodychange",
			"commitMessage": "remove noise\n",
			"commitDate": "2015-08-24, 3:05 PM",
			"commitName": "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-24, 1:57 PM",
			"commitNameOld": "ee58eb8363ecd8fad15a63eb2fdc94a387b58807",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.05,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,168 +1,161 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n-            if (nameExpr.getName().equals(\"Boolean\") && nameExpr.getBeginLine()==452 && !new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).isPresent()) {\n-                System.out.println(\"GOTCHA\");\n-            }\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n-                //System.out.println(\"LAMBDA \" + node.getParentNode());\n-                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n-                //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n-                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr)node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"283204dd5840cb11dd6c73dbbb196e80db79c9a4": {
			"type": "Ybodychange",
			"commitMessage": "consider method override\n",
			"commitDate": "2015-08-24, 1:19 PM",
			"commitName": "283204dd5840cb11dd6c73dbbb196e80db79c9a4",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-24, 12:45 PM",
			"commitNameOld": "d0348de241a6cf6be9c51500870ee1fb26172101",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,168 +1,168 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             if (nameExpr.getName().equals(\"Boolean\") && nameExpr.getBeginLine()==452 && !new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).isPresent()) {\n                 System.out.println(\"GOTCHA\");\n             }\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n-            return new NullTypeUsage();\n+            return NullTypeUsage.INSTANCE;\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr)node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d0348de241a6cf6be9c51500870ee1fb26172101": {
			"type": "Ybodychange",
			"commitMessage": "fix switch on enums\n",
			"commitDate": "2015-08-24, 12:45 PM",
			"commitName": "d0348de241a6cf6be9c51500870ee1fb26172101",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-24, 10:29 AM",
			"commitNameOld": "6a15cd55028fc9b7c73158d05f5ee335cab1f481",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.09,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,165 +1,168 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n+            if (nameExpr.getName().equals(\"Boolean\") && nameExpr.getBeginLine()==452 && !new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).isPresent()) {\n+                System.out.println(\"GOTCHA\");\n+            }\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr)node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6a15cd55028fc9b7c73158d05f5ee335cab1f481": {
			"type": "Ybodychange",
			"commitMessage": "add test on switch on enum value\n",
			"commitDate": "2015-08-24, 10:29 AM",
			"commitName": "6a15cd55028fc9b7c73158d05f5ee335cab1f481",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-24, 8:31 AM",
			"commitNameOld": "ee35b15a04539af508d29081ac5c7f8f6fadba4a",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.08,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,165 +1,165 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n-                throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n+                throw new UnsolvedSymbolException(\"FOO Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case binAnd:\n                 case binOr:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr)node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f77a169eec5a2e0fdeea1b9d67641426af0e1176": {
			"type": "Ybodychange",
			"commitMessage": "remove JavaParserFacade.convert\n",
			"commitDate": "2015-08-24, 8:22 AM",
			"commitName": "f77a169eec5a2e0fdeea1b9d67641426af0e1176",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-24, 8:06 AM",
			"commitNameOld": "416e7b16f820700af08a94e4b38a2b4c24ef6a2c",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,162 +1,165 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n+                case binAnd:\n+                case binOr:\n+                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr)node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"416e7b16f820700af08a94e4b38a2b4c24ef6a2c": {
			"type": "Ybodychange",
			"commitMessage": "minor corrections for enums\n",
			"commitDate": "2015-08-24, 8:06 AM",
			"commitName": "416e7b16f820700af08a94e4b38a2b4c24ef6a2c",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-24, 7:58 AM",
			"commitNameOld": "1829d9560d37efd59722aaa2f1f22e392918429b",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,162 +1,162 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 default:\n-                    throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n+                    throw new UnsupportedOperationException(\"FOO \" +binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else if (node instanceof ConditionalExpr) {\n             ConditionalExpr conditionalExpr = (ConditionalExpr)node;\n             return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n         } else if (node instanceof ArrayCreationExpr) {\n             ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr)node;\n             return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"00f005b38e8b83eb1d60db9070c6e9e3beffe403": {
			"type": "Ybodychange",
			"commitMessage": "Consider ConditionalExpr and ArrayCreationExpr in getTypeConcrete\n",
			"commitDate": "2015-08-24, 7:26 AM",
			"commitName": "00f005b38e8b83eb1d60db9070c6e9e3beffe403",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-24, 7:22 AM",
			"commitNameOld": "d6edae7874d2e78cbd401619ad53a9f9e2288597",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,156 +1,162 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 default:\n                     throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n+        } else if (node instanceof ConditionalExpr) {\n+            ConditionalExpr conditionalExpr = (ConditionalExpr)node;\n+            return getTypeConcrete(conditionalExpr.getThenExpr(), solveLambdas);\n+        } else if (node instanceof ArrayCreationExpr) {\n+            ArrayCreationExpr arrayCreationExpr = (ArrayCreationExpr)node;\n+            return convertToUsage(arrayCreationExpr.getType(), JavaParserFactory.getContext(node));\n         } else {\n-            throw new UnsupportedOperationException(\"FOO \" + node.getClass().getCanonicalName());\n+            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d6edae7874d2e78cbd401619ad53a9f9e2288597": {
			"type": "Ybodychange",
			"commitMessage": "Testing access to field through this keyword\n",
			"commitDate": "2015-08-24, 7:22 AM",
			"commitName": "d6edae7874d2e78cbd401619ad53a9f9e2288597",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-23, 3:28 PM",
			"commitNameOld": "d0b5fa9e41aaf140b9a30c716ac7a74b24508451",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.66,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,156 +1,156 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                 case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case posIncrement:\n                 case preIncrement:\n                 case preDecrement:\n                 case posDecrement:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 default:\n                     throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else {\n-            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n+            throw new UnsupportedOperationException(\"FOO \" + node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d0b5fa9e41aaf140b9a30c716ac7a74b24508451": {
			"type": "Ybodychange",
			"commitMessage": "completing various missing elements\n",
			"commitDate": "2015-08-23, 3:28 PM",
			"commitName": "d0b5fa9e41aaf140b9a30c716ac7a74b24508451",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-23, 1:27 PM",
			"commitNameOld": "31b108cbfd418f43e7b568374af2e635a580e171",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.08,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,155 +1,156 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n-            if (nameExpr.getName().equals(\"commentsInsideChild\")) {\n-                System.out.println(\"Foo\");\n-            }\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n+                case positive:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n-                case inverse:\n                 case posIncrement:\n+                case preIncrement:\n+                case preDecrement:\n+                case posDecrement:\n+                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 default:\n                     throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"31b108cbfd418f43e7b568374af2e635a580e171": {
			"type": "Ybodychange",
			"commitMessage": "add StatementContextTest\n",
			"commitDate": "2015-08-23, 1:27 PM",
			"commitName": "31b108cbfd418f43e7b568374af2e635a580e171",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-23, 7:43 AM",
			"commitNameOld": "bac18a129c45335e69d811b3872fcb938e1f0ff8",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.24,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,165 +1,155 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n+            if (nameExpr.getName().equals(\"commentsInsideChild\")) {\n+                System.out.println(\"Foo\");\n+            }\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n-                /*// Maybe we are accessing a static field\n-                SymbolReference<TypeDeclaration> type = JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n-                if (!type.isSolved()) {\n-                    throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n-                } else {\n-                    throw new UnsupportedOperationException(\"da finire\");\n-                    /*value = type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n-                    if (!value.isPresent()) {\n-                        throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n-                    } else {\n-                        return value.get().getUsage();\n-                    }\n-                }*/\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case inverse:\n                 case posIncrement:\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 default:\n                     throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n             AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else if (node instanceof ThisExpr) {\n             return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"bac18a129c45335e69d811b3872fcb938e1f0ff8": {
			"type": "Ybodychange",
			"commitMessage": "wip\n",
			"commitDate": "2015-08-23, 7:43 AM",
			"commitName": "bac18a129c45335e69d811b3872fcb938e1f0ff8",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-23, 6:43 AM",
			"commitNameOld": "5c62d5981fb47c4e1e02baa91eb8e2c6ce20c969",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,163 +1,165 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 /*// Maybe we are accessing a static field\n                 SymbolReference<TypeDeclaration> type = JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n                 if (!type.isSolved()) {\n                     throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 } else {\n                     throw new UnsupportedOperationException(\"da finire\");\n                     /*value = type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n                     if (!value.isPresent()) {\n                         throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                     } else {\n                         return value.get().getUsage();\n                     }\n                 }*/\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case not:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 case inverse:\n                 case posIncrement:\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                 case or:\n                 case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 default:\n                     throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof AssignExpr) {\n-            AssignExpr assignExpr = (AssignExpr)node;\n+            AssignExpr assignExpr = (AssignExpr) node;\n             return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n+        } else if (node instanceof ThisExpr) {\n+            return new TypeUsageOfTypeDeclaration(getTypeDeclaration(findContainingTypeDecl(node)));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"46aefdd68f2f2597a19b72da36681123cb3090e6": {
			"type": "Ybodychange",
			"commitMessage": "improve resolution of calls to static methods\n",
			"commitDate": "2015-08-23, 4:34 AM",
			"commitName": "46aefdd68f2f2597a19b72da36681123cb3090e6",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-23, 3:38 AM",
			"commitNameOld": "6c297529e31036058837adbaa57cee652d4cc918",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,157 +1,163 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 /*// Maybe we are accessing a static field\n                 SymbolReference<TypeDeclaration> type = JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n                 if (!type.isSolved()) {\n                     throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 } else {\n                     throw new UnsupportedOperationException(\"da finire\");\n                     /*value = type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n                     if (!value.isPresent()) {\n                         throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                     } else {\n                         return value.get().getUsage();\n                     }\n                 }*/\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n-                case inverse:\n                 case not:\n+                    return PrimitiveTypeUsage.BOOLEAN;\n+                case inverse:\n                 case posIncrement:\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n+                case or:\n+                case and:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 default:\n                     throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else if (node instanceof InstanceOfExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof EnclosedExpr) {\n             EnclosedExpr enclosedExpr = (EnclosedExpr)node;\n             return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n         } else if (node instanceof CastExpr) {\n             CastExpr enclosedExpr = (CastExpr)node;\n             return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n+        } else if (node instanceof AssignExpr) {\n+            AssignExpr assignExpr = (AssignExpr)node;\n+            return getTypeConcrete(assignExpr.getTarget(), solveLambdas);\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6c297529e31036058837adbaa57cee652d4cc918": {
			"type": "Ybodychange",
			"commitMessage": "wip\n",
			"commitDate": "2015-08-23, 3:38 AM",
			"commitName": "6c297529e31036058837adbaa57cee652d4cc918",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-23, 2:24 AM",
			"commitNameOld": "7b2a0b366461674aa6320b11a38a17909d8a74a3",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.05,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,149 +1,157 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 /*// Maybe we are accessing a static field\n                 SymbolReference<TypeDeclaration> type = JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n                 if (!type.isSolved()) {\n                     throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 } else {\n                     throw new UnsupportedOperationException(\"da finire\");\n                     /*value = type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n                     if (!value.isPresent()) {\n                         throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                     } else {\n                         return value.get().getUsage();\n                     }\n                 }*/\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case inverse:\n                 case not:\n                 case posIncrement:\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n             BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n                 case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n                 case lessEquals:\n                 case less:\n                 case greater:\n                 case greaterEquals:\n                 case equals:\n                 case notEquals:\n                     return PrimitiveTypeUsage.BOOLEAN;\n                 default:\n                     throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n             }\n         } else if (node instanceof VariableDeclarationExpr) {\n             VariableDeclarationExpr expr = (VariableDeclarationExpr)node;\n             return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n+        } else if (node instanceof InstanceOfExpr) {\n+            return PrimitiveTypeUsage.BOOLEAN;\n+        } else if (node instanceof EnclosedExpr) {\n+            EnclosedExpr enclosedExpr = (EnclosedExpr)node;\n+            return getTypeConcrete(enclosedExpr.getInner(), solveLambdas);\n+        } else if (node instanceof CastExpr) {\n+            CastExpr enclosedExpr = (CastExpr)node;\n+            return convertToUsage(enclosedExpr.getType(), JavaParserFactory.getContext(node));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7b2a0b366461674aa6320b11a38a17909d8a74a3": {
			"type": "Ybodychange",
			"commitMessage": "wip\n",
			"commitDate": "2015-08-23, 2:24 AM",
			"commitName": "7b2a0b366461674aa6320b11a38a17909d8a74a3",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-23, 1:50 AM",
			"commitNameOld": "be64d2e61b56eafd01abc7236a7a0dcd6ce6dafd",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,138 +1,149 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 /*// Maybe we are accessing a static field\n                 SymbolReference<TypeDeclaration> type = JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n                 if (!type.isSolved()) {\n                     throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 } else {\n                     throw new UnsupportedOperationException(\"da finire\");\n                     /*value = type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n                     if (!value.isPresent()) {\n                         throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                     } else {\n                         return value.get().getUsage();\n                     }\n                 }*/\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else if (node instanceof IntegerLiteralExpr) {\n             return PrimitiveTypeUsage.INT;\n         } else if (node instanceof LongLiteralExpr) {\n             return PrimitiveTypeUsage.LONG;\n         } else if (node instanceof CharLiteralExpr) {\n             return PrimitiveTypeUsage.CHAR;\n         } else if (node instanceof StringLiteralExpr) {\n             return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n         } else if (node instanceof UnaryExpr) {\n             UnaryExpr unaryExpr = (UnaryExpr)node;\n             switch (unaryExpr.getOperator()) {\n                 case negative:\n                     return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n                 case inverse:\n                 case not:\n                 case posIncrement:\n                 default:\n                     throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n             }\n         } else if (node instanceof BinaryExpr) {\n-            BinaryExpr binaryExpr = (BinaryExpr)node;\n+            BinaryExpr binaryExpr = (BinaryExpr) node;\n             switch (binaryExpr.getOperator()) {\n                 case plus:\n+                case minus:\n                     return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n+                case lessEquals:\n+                case less:\n+                case greater:\n+                case greaterEquals:\n+                case equals:\n+                case notEquals:\n+                    return PrimitiveTypeUsage.BOOLEAN;\n                 default:\n                     throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n             }\n+        } else if (node instanceof VariableDeclarationExpr) {\n+            VariableDeclarationExpr expr = (VariableDeclarationExpr)node;\n+            return convertToUsage(expr.getType(), JavaParserFactory.getContext(node));\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"feab46de5d87b02bf38b29962613676adf14f78a": {
			"type": "Ybodychange",
			"commitMessage": "implementing missing bits while solving symbols on JavaParser\n",
			"commitDate": "2015-08-22, 4:08 AM",
			"commitName": "feab46de5d87b02bf38b29962613676adf14f78a",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-21, 3:01 PM",
			"commitNameOld": "54b73148ab5bfb5e3c2f1c2aa463265d033ac926",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.55,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,111 +1,138 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 /*// Maybe we are accessing a static field\n                 SymbolReference<TypeDeclaration> type = JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n                 if (!type.isSolved()) {\n                     throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 } else {\n                     throw new UnsupportedOperationException(\"da finire\");\n                     /*value = type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n                     if (!value.isPresent()) {\n                         throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                     } else {\n                         return value.get().getUsage();\n                     }\n                 }*/\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n+        } else if (node instanceof IntegerLiteralExpr) {\n+            return PrimitiveTypeUsage.INT;\n+        } else if (node instanceof LongLiteralExpr) {\n+            return PrimitiveTypeUsage.LONG;\n+        } else if (node instanceof CharLiteralExpr) {\n+            return PrimitiveTypeUsage.CHAR;\n+        } else if (node instanceof StringLiteralExpr) {\n+            return new TypeUsageOfTypeDeclaration(new JreTypeSolver().solveType(\"java.lang.String\"));\n+        } else if (node instanceof UnaryExpr) {\n+            UnaryExpr unaryExpr = (UnaryExpr)node;\n+            switch (unaryExpr.getOperator()) {\n+                case negative:\n+                    return getTypeConcrete(unaryExpr.getExpr(), solveLambdas);\n+                case inverse:\n+                case not:\n+                case posIncrement:\n+                default:\n+                    throw new UnsupportedOperationException(unaryExpr.getOperator().name());\n+            }\n+        } else if (node instanceof BinaryExpr) {\n+            BinaryExpr binaryExpr = (BinaryExpr)node;\n+            switch (binaryExpr.getOperator()) {\n+                case plus:\n+                    return getTypeConcrete(binaryExpr.getLeft(), solveLambdas);\n+                default:\n+                    throw new UnsupportedOperationException(binaryExpr.getOperator().name());\n+            }\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"54b73148ab5bfb5e3c2f1c2aa463265d033ac926": {
			"type": "Ybodychange",
			"commitMessage": "remove spurios log\n",
			"commitDate": "2015-08-21, 3:01 PM",
			"commitName": "54b73148ab5bfb5e3c2f1c2aa463265d033ac926",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-21, 3:00 PM",
			"commitNameOld": "0c4c859f472f7243919f1af7a0871cf8155af1ba",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,112 +1,111 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n             if (!value.isPresent()){\n                 throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 /*// Maybe we are accessing a static field\n                 SymbolReference<TypeDeclaration> type = JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n                 if (!type.isSolved()) {\n                     throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                 } else {\n                     throw new UnsupportedOperationException(\"da finire\");\n                     /*value = type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n                     if (!value.isPresent()) {\n                         throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n                     } else {\n                         return value.get().getUsage();\n                     }\n                 }*/\n             } else {\n                 return value.get().getUsage();\n             }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             // We should understand if this is a static access\n             try {\n                 Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n                 if (value.isPresent()) {\n                     return value.get().getUsage();\n                 } else {\n                     throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n                 }\n             } catch (UnsolvedSymbolException e){\n-                System.out.println(\"FOO\");\n                 // Sure, it was not found as value because maybe it is a type and this is a static access\n                 if (fieldAccessExpr.getScope() instanceof NameExpr){\n                     NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n                     SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n                     if (!typeAccessedStatically.isSolved()) {\n                         throw e;\n                     } else {\n                         // TODO here maybe we have to substitute type parameters\n                         return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n                     }\n                 } else {\n                     throw e;\n                 }\n \n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else if (node instanceof BooleanLiteralExpr) {\n             return PrimitiveTypeUsage.BOOLEAN;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0c4c859f472f7243919f1af7a0871cf8155af1ba": {
			"type": "Ybodychange",
			"commitMessage": "add tests for static field access\n",
			"commitDate": "2015-08-21, 3:00 PM",
			"commitName": "0c4c859f472f7243919f1af7a0871cf8155af1ba",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-21, 12:45 PM",
			"commitNameOld": "7b6c27e95fef9e725fbf9e15afb852bb952dfa34",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.09,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,73 +1,112 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n-            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n+            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr);\n+            if (!value.isPresent()){\n+                throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n+                /*// Maybe we are accessing a static field\n+                SymbolReference<TypeDeclaration> type = JavaParserFactory.getContext(node).solveType(nameExpr.getName(), typeSolver);\n+                if (!type.isSolved()) {\n+                    throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n+                } else {\n+                    throw new UnsupportedOperationException(\"da finire\");\n+                    /*value = type.getCorrespondingDeclaration().getContext().solveSymbolAsValue(nameExpr.getName(), typeSolver);\n+                    if (!value.isPresent()) {\n+                        throw new UnsolvedSymbolException(\"Solving \"+node, nameExpr.getName());\n+                    } else {\n+                        return value.get().getUsage();\n+                    }\n+                }*/\n+            } else {\n+                return value.get().getUsage();\n+            }\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n-                    throw new UnsolvedSymbolException(null, callExpr.getName());\n+                    throw new UnsolvedSymbolException(callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n-            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n-            if (value.isPresent()) {\n-                return value.get().getUsage();\n-            } else {\n-                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n+            // We should understand if this is a static access\n+            try {\n+                Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+                if (value.isPresent()) {\n+                    return value.get().getUsage();\n+                } else {\n+                    throw new UnsolvedSymbolException(fieldAccessExpr.getField());\n+                }\n+            } catch (UnsolvedSymbolException e){\n+                System.out.println(\"FOO\");\n+                // Sure, it was not found as value because maybe it is a type and this is a static access\n+                if (fieldAccessExpr.getScope() instanceof NameExpr){\n+                    NameExpr staticValue = (NameExpr)fieldAccessExpr.getScope();\n+                    SymbolReference<TypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(fieldAccessExpr).solveType(staticValue.toString(), typeSolver);\n+                    if (!typeAccessedStatically.isSolved()) {\n+                        throw e;\n+                    } else {\n+                        // TODO here maybe we have to substitute type parameters\n+                        return typeAccessedStatically.getCorrespondingDeclaration().getField(fieldAccessExpr.getField(), typeSolver).getType(typeSolver);\n+                    }\n+                } else {\n+                    throw e;\n+                }\n+\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n+        } else if (node instanceof BooleanLiteralExpr) {\n+            return PrimitiveTypeUsage.BOOLEAN;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"09ceccd596e6aeebb5eca309093ef32216291f1e": {
			"type": "Ybodychange",
			"commitMessage": "first step\n",
			"commitDate": "2015-08-21, 1:18 AM",
			"commitName": "09ceccd596e6aeebb5eca309093ef32216291f1e",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-18, 3:15 AM",
			"commitNameOld": "1d5332815b543d569be3d7ec672a65b7efc39a04",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 2.92,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,73 +1,73 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n-                    TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+                    TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                     // We need to replace the type variables\n                     result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n-                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n+                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver);\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else if (node instanceof NullLiteralExpr) {\n             return new NullTypeUsage();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"850c0caa4c64df32d5fc44a5512d6d41f4534a08": {
			"type": "Ybodychange",
			"commitMessage": "wip\n",
			"commitDate": "2015-08-17, 10:43 AM",
			"commitName": "850c0caa4c64df32d5fc44a5512d6d41f4534a08",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-17, 10:43 AM",
			"commitNameOld": "d393205e2ee874242b73e4fe819d1bc874587d8a",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,71 +1,73 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                     // We need to replace the type variables\n                     result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n                     return result;\n                 } else {\n                     return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n-            ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n+            ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n+        } else if (node instanceof NullLiteralExpr) {\n+            return new NullTypeUsage();\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"22bf613d486d43114d1547e5bc623535aa2aca2a": {
			"type": "Ybodychange",
			"commitMessage": "add test resolveLambdaType\n",
			"commitDate": "2015-08-17, 1:14 AM",
			"commitName": "22bf613d486d43114d1547e5bc623535aa2aca2a",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-16, 11:55 PM",
			"commitNameOld": "9f625af2721bfb3f764d5f4dd23eef55324c94bc",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.05,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,68 +1,71 @@\n     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n-                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+                    TypeUsage result = refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+                    // We need to replace the type variables\n+                    result = result.solveGenericTypes(JavaParserFactory.getContext(node), typeSolver);\n+                    return result;\n                 } else {\n                     return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"627b56302d259409e9bc50b20d77803484f18b5c": {
			"type": "Ymultichange(Yrename,Ymodifierchange)",
			"commitMessage": "introduce cache in JavaParserFacade\n",
			"commitDate": "2015-08-05, 8:25 AM",
			"commitName": "627b56302d259409e9bc50b20d77803484f18b5c",
			"commitAuthor": "Federico Tomassetti",
			"subchanges": [
				{
					"type": "Yrename",
					"commitMessage": "introduce cache in JavaParserFacade\n",
					"commitDate": "2015-08-05, 8:25 AM",
					"commitName": "627b56302d259409e9bc50b20d77803484f18b5c",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2015-08-05, 8:08 AM",
					"commitNameOld": "1adb8b4c97103ac5b15d009f3eda791a53b83d6f",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.01,
					"commitsBetweenForRepo": 2,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,68 +1,68 @@\n-    public TypeUsage getType(Node node, boolean solveLambdas) {\n+    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                 } else {\n                     return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "getType",
						"newValue": "getTypeConcrete"
					}
				},
				{
					"type": "Ymodifierchange",
					"commitMessage": "introduce cache in JavaParserFacade\n",
					"commitDate": "2015-08-05, 8:25 AM",
					"commitName": "627b56302d259409e9bc50b20d77803484f18b5c",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2015-08-05, 8:08 AM",
					"commitNameOld": "1adb8b4c97103ac5b15d009f3eda791a53b83d6f",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.01,
					"commitsBetweenForRepo": 2,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,68 +1,68 @@\n-    public TypeUsage getType(Node node, boolean solveLambdas) {\n+    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             logger.finest(\"getType on name expr \" + node);\n             return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                 } else {\n                     return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n             if (parameter.getType() instanceof UnknownType){\n                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n             }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[public]",
						"newValue": "[private]"
					}
				}
			]
		},
		"1adb8b4c97103ac5b15d009f3eda791a53b83d6f": {
			"type": "Ybodychange",
			"commitMessage": "add resolveReferenceToLambdaParamBase\n",
			"commitDate": "2015-08-05, 8:08 AM",
			"commitName": "1adb8b4c97103ac5b15d009f3eda791a53b83d6f",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-05, 7:30 AM",
			"commitNameOld": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,64 +1,68 @@\n     public TypeUsage getType(Node node, boolean solveLambdas) {\n         if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n+            logger.finest(\"getType on name expr \" + node);\n             return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n         } else if (node instanceof MethodCallExpr) {\n             logger.finest(\"getType on method call \" + node);\n             // first solve the method\n             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n             return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 if (solveLambdas) {\n                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                 } else {\n                     return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                 }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n         } else if (node instanceof Parameter) {\n             Parameter parameter = (Parameter)node;\n+            if (parameter.getType() instanceof UnknownType){\n+                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n+            }\n             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fd2e083224d3ee0e9ccca4431d63a84601e0d606": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "fix resolveReferenceToMethodWithLambda\n",
			"commitDate": "2015-08-05, 7:30 AM",
			"commitName": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
			"commitAuthor": "Federico Tomassetti",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "fix resolveReferenceToMethodWithLambda\n",
					"commitDate": "2015-08-05, 7:30 AM",
					"commitName": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2015-08-05, 2:09 AM",
					"commitNameOld": "6650e5a3818c15de2883b71cd41524b0337e26f6",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.22,
					"commitsBetweenForRepo": 2,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,57 +1,64 @@\n-    public TypeUsage getType(Node node) {\n+    public TypeUsage getType(Node node, boolean solveLambdas) {\n+        if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n-            SymbolReference<? extends ValueDeclaration> ref = new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n-            if (!ref.isSolved()) {\n-                throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n-            }\n-            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType(typeSolver));\n+            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n         } else if (node instanceof MethodCallExpr) {\n+            logger.finest(\"getType on method call \" + node);\n             // first solve the method\n-            SymbolReference<MethodDeclaration> ref = new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n-            if (!ref.isSolved()) {\n-                throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n-            }\n-            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n+            MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n+            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n+            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n+            return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n-                System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n-                System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n-                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n+                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n+                if (solveLambdas) {\n+                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+                } else {\n+                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n+                }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n+            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n+                VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n+                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n+        } else if (node instanceof Parameter) {\n+            Parameter parameter = (Parameter)node;\n+            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[node-Node]",
						"newValue": "[node-Node, solveLambdas-boolean]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "fix resolveReferenceToMethodWithLambda\n",
					"commitDate": "2015-08-05, 7:30 AM",
					"commitName": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2015-08-05, 2:09 AM",
					"commitNameOld": "6650e5a3818c15de2883b71cd41524b0337e26f6",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.22,
					"commitsBetweenForRepo": 2,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,57 +1,64 @@\n-    public TypeUsage getType(Node node) {\n+    public TypeUsage getType(Node node, boolean solveLambdas) {\n+        if (node == null) throw new IllegalArgumentException();\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n-            SymbolReference<? extends ValueDeclaration> ref = new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n-            if (!ref.isSolved()) {\n-                throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n-            }\n-            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType(typeSolver));\n+            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n         } else if (node instanceof MethodCallExpr) {\n+            logger.finest(\"getType on method call \" + node);\n             // first solve the method\n-            SymbolReference<MethodDeclaration> ref = new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n-            if (!ref.isSolved()) {\n-                throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n-            }\n-            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n+            MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n+            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n+            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n+            return ref.returnType();\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n-                System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n-                System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n-                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n+                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n+                if (solveLambdas) {\n+                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+                } else {\n+                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n+                }\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n+            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n+                VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n+                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n+        } else if (node instanceof Parameter) {\n+            Parameter parameter = (Parameter)node;\n+            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n         } else if (node instanceof FieldAccessExpr) {\n             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n             if (value.isPresent()) {\n                 return value.get().getUsage();\n             } else {\n                 throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n             }\n         } else if (node instanceof ObjectCreationExpr) {\n             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n             return typeUsage;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"80f951258992f75441239c79e0f31eda7d47e107": {
			"type": "Ybodychange",
			"commitMessage": "wip\n",
			"commitDate": "2015-08-04, 7:54 AM",
			"commitName": "80f951258992f75441239c79e0f31eda7d47e107",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-04, 3:02 AM",
			"commitNameOld": "2568d9ebe91ceb0a13c98b16f99593cd22084efa",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.2,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,57 @@\n     public TypeUsage getType(Node node) {\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             SymbolReference<? extends ValueDeclaration> ref = new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n             }\n-            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n+            return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType(typeSolver));\n         } else if (node instanceof MethodCallExpr) {\n             // first solve the method\n             SymbolReference<MethodDeclaration> ref = new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n                 System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n                 System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n-                return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n+                return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else if (node instanceof VariableDeclarator) {\n             if (node.getParentNode() instanceof FieldDeclaration) {\n-                FieldDeclaration parent = (FieldDeclaration)node.getParentNode();\n+                FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n             } else {\n                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n             }\n+        } else if (node instanceof FieldAccessExpr) {\n+            FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n+            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+            if (value.isPresent()) {\n+                return value.get().getUsage();\n+            } else {\n+                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n+            }\n+        } else if (node instanceof ObjectCreationExpr) {\n+            ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n+            TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n+            return typeUsage;\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2568d9ebe91ceb0a13c98b16f99593cd22084efa": {
			"type": "Ybodychange",
			"commitMessage": "solving first case of generic type\n",
			"commitDate": "2015-08-04, 3:02 AM",
			"commitName": "2568d9ebe91ceb0a13c98b16f99593cd22084efa",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-03, 12:53 AM",
			"commitNameOld": "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 1.09,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,38 +1,45 @@\n     public TypeUsage getType(Node node) {\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             SymbolReference<? extends ValueDeclaration> ref = new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n         } else if (node instanceof MethodCallExpr) {\n             // first solve the method\n             SymbolReference<MethodDeclaration> ref = new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n-                MethodCallExpr callExpr = (MethodCallExpr)node.getParentNode();\n+                MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n-                System.out.println(\"Method \"+refMethod.getCorrespondingDeclaration().getName());\n-                System.out.println(\"Method param \"+refMethod.getCorrespondingDeclaration().getParam(pos));\n+                System.out.println(\"Method \" + refMethod.getCorrespondingDeclaration().getName());\n+                System.out.println(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n+        } else if (node instanceof VariableDeclarator) {\n+            if (node.getParentNode() instanceof FieldDeclaration) {\n+                FieldDeclaration parent = (FieldDeclaration)node.getParentNode();\n+                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n+            } else {\n+                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n+            }\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8415b0bc2abfc2eb094745336a1cd27a4c96fa4b": {
			"type": "Ybodychange",
			"commitMessage": "wip\n",
			"commitDate": "2015-08-03, 12:53 AM",
			"commitName": "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-03, 12:37 AM",
			"commitNameOld": "630eb94d43670f2080c7273584d49c0b0d4162f1",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,38 +1,38 @@\n     public TypeUsage getType(Node node) {\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n-            SymbolReference<ValueDeclaration> ref = new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n+            SymbolReference<? extends ValueDeclaration> ref = new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n         } else if (node instanceof MethodCallExpr) {\n             // first solve the method\n             SymbolReference<MethodDeclaration> ref = new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr)node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n                 System.out.println(\"Method \"+refMethod.getCorrespondingDeclaration().getName());\n                 System.out.println(\"Method param \"+refMethod.getCorrespondingDeclaration().getParam(pos));\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"630eb94d43670f2080c7273584d49c0b0d4162f1": {
			"type": "Ybodychange",
			"commitMessage": "initial refactoring\n",
			"commitDate": "2015-08-03, 12:37 AM",
			"commitName": "630eb94d43670f2080c7273584d49c0b0d4162f1",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-02, 6:22 AM",
			"commitNameOld": "241cd249688d1e7c621c495746d2603433599eb9",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.76,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,38 +1,38 @@\n     public TypeUsage getType(Node node) {\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n-            SymbolReference<SymbolDeclaration> ref = new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n+            SymbolReference<ValueDeclaration> ref = new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n         } else if (node instanceof MethodCallExpr) {\n             // first solve the method\n             SymbolReference<MethodDeclaration> ref = new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr)node.getParentNode();\n                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n                 System.out.println(\"Method \"+refMethod.getCorrespondingDeclaration().getName());\n                 System.out.println(\"Method param \"+refMethod.getCorrespondingDeclaration().getParam(pos));\n                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fa3b6f1d0199dacb9069c24a1c2de0e31de38cb3": {
			"type": "Ybodychange",
			"commitMessage": "wip\n",
			"commitDate": "2015-08-02, 4:18 AM",
			"commitName": "fa3b6f1d0199dacb9069c24a1c2de0e31de38cb3",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-02, 3:48 AM",
			"commitNameOld": "3def8748ada27ac91166941a892adfd83ca3db2a",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,34 +1,38 @@\n     public TypeUsage getType(Node node) {\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             SymbolReference<SymbolDeclaration> ref = new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n         } else if (node instanceof MethodCallExpr) {\n             // first solve the method\n             SymbolReference<MethodDeclaration> ref = new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n             if (node.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr callExpr = (MethodCallExpr)node.getParentNode();\n+                int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                 if (!refMethod.isSolved()) {\n                     throw new UnsolvedSymbolException(null, callExpr.getName());\n                 }\n+                System.out.println(\"Method \"+refMethod.getCorrespondingDeclaration().getName());\n+                System.out.println(\"Method param \"+refMethod.getCorrespondingDeclaration().getParam(pos));\n+                return refMethod.getCorrespondingDeclaration().getParam(pos).getType().getUsage(node);\n                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n-                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             } else {\n                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n             }\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3def8748ada27ac91166941a892adfd83ca3db2a": {
			"type": "Ybodychange",
			"commitMessage": "wip\n",
			"commitDate": "2015-08-02, 3:48 AM",
			"commitName": "3def8748ada27ac91166941a892adfd83ca3db2a",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-02, 2:52 AM",
			"commitNameOld": "381c389ea62cf20d6109dac96bb5f8202ccc0b34",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,22 +1,34 @@\n     public TypeUsage getType(Node node) {\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             SymbolReference<SymbolDeclaration> ref = new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n         } else if (node instanceof MethodCallExpr) {\n             // first solve the method\n             SymbolReference<MethodDeclaration> ref = new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n             // the type is the return type of the method\n         } else if (node instanceof LambdaExpr) {\n-            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+            if (node.getParentNode() instanceof MethodCallExpr) {\n+                MethodCallExpr callExpr = (MethodCallExpr)node.getParentNode();\n+                SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n+                if (!refMethod.isSolved()) {\n+                    throw new UnsolvedSymbolException(null, callExpr.getName());\n+                }\n+                //System.out.println(\"LAMBDA \" + node.getParentNode());\n+                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n+                //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n+                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+            } else {\n+                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+            }\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"381c389ea62cf20d6109dac96bb5f8202ccc0b34": {
			"type": "Ybodychange",
			"commitMessage": "wip\n",
			"commitDate": "2015-08-02, 2:52 AM",
			"commitName": "381c389ea62cf20d6109dac96bb5f8202ccc0b34",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-07-31, 12:52 PM",
			"commitNameOld": "8b8cc6cddbf5af0c93c4ceffd015f6328c932149",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 1.58,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,20 +1,22 @@\n     public TypeUsage getType(Node node) {\n         if (node instanceof NameExpr) {\n             NameExpr nameExpr = (NameExpr) node;\n             SymbolReference<SymbolDeclaration> ref = new SymbolSolver(typeSolver).solveSymbol(nameExpr.getName(), nameExpr);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(nameExpr), nameExpr.getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getType());\n         } else if (node instanceof MethodCallExpr) {\n             // first solve the method\n             SymbolReference<MethodDeclaration> ref = new JavaParserFacade(typeSolver).solveMethod((MethodCallExpr)node);\n             if (!ref.isSolved()) {\n                 throw new UnsolvedSymbolException(JavaParserFactory.getContext(node), ((MethodCallExpr)node).getName());\n             }\n             return new TypeUsageOfTypeDeclaration(ref.getCorrespondingDeclaration().getReturnType());\n             // the type is the return type of the method\n+        } else if (node instanceof LambdaExpr) {\n+            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n         } else {\n             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8b8cc6cddbf5af0c93c4ceffd015f6328c932149": {
			"type": "Yintroduced",
			"commitMessage": "wip\n",
			"commitDate": "2015-07-31, 12:52 PM",
			"commitName": "8b8cc6cddbf5af0c93c4ceffd015f6328c932149",
			"commitAuthor": "Federico Tomassetti"
		}
	},
	"sha": "97555053af3025556efe1a168fd7943dac28a2a6"
}