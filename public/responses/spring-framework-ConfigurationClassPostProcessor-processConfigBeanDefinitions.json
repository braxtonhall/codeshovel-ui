{
	"repo": "https://github.com/spring-projects/spring-framework.git",
	"file": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
	"method": {
		"longName": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry);",
		"startLine": 261,
		"methodName": "processConfigBeanDefinitions",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"4fef1fe820627e6462413f4c4b658d24146367a2": {
			"type": "Ybodychange",
			"commitMessage": "Polishing\n",
			"commitDate": "2018-03-16, 10:49 AM",
			"commitName": "4fef1fe820627e6462413f4c4b658d24146367a2",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2018-03-08, 9:11 AM",
			"commitNameOld": "139dc1d373cc6e32ee6b516504064a2c87e0008a",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 8.03,
			"commitsBetweenForRepo": 52,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,102 +1,102 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tList<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n \t\tString[] candidateNames = registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Sort by previously determined @Order value, if applicable\n \t\tconfigCandidates.sort((bd1, bd2) -> {\n \t\t\tint i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n \t\t\tint i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n-\t\t\treturn (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n+\t\t\treturn Integer.compare(i1, i2);\n \t\t});\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry sbr = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsbr = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tif (generator != null) {\n \t\t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (this.environment == null) {\n \t\t\tthis.environment = new StandardEnvironment();\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n \t\tSet<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n \t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader == null) {\n \t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() > candidateNames.length) {\n \t\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();\n \t\t\t\tSet<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n \t\t\t\tSet<String> alreadyParsedClasses = new HashSet<>();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition bd = registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&\n \t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n \t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames = newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (sbr != null && !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n \t\t\t// for a shared cache since it'll be cleared by the ApplicationContext.\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"139dc1d373cc6e32ee6b516504064a2c87e0008a": {
			"type": "Ybodychange",
			"commitMessage": "Polishing (collapsed if checks, consistent downcasts, refined javadoc)\n",
			"commitDate": "2018-03-08, 9:11 AM",
			"commitName": "139dc1d373cc6e32ee6b516504064a2c87e0008a",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2017-06-29, 4:54 PM",
			"commitNameOld": "cc74a2891a4d2a4c7bcec059f20c35aa80bcf668",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 251.72,
			"commitsBetweenForRepo": 1211,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,104 +1,102 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tList<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n \t\tString[] candidateNames = registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Sort by previously determined @Order value, if applicable\n \t\tconfigCandidates.sort((bd1, bd2) -> {\n \t\t\tint i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n \t\t\tint i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n \t\t\treturn (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n \t\t});\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry sbr = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsbr = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tif (generator != null) {\n \t\t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (this.environment == null) {\n \t\t\tthis.environment = new StandardEnvironment();\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n \t\tSet<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n \t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader == null) {\n \t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() > candidateNames.length) {\n \t\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();\n \t\t\t\tSet<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n \t\t\t\tSet<String> alreadyParsedClasses = new HashSet<>();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition bd = registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&\n \t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n \t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames = newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n-\t\tif (sbr != null) {\n-\t\t\tif (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n-\t\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n-\t\t\t}\n+\t\tif (sbr != null && !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n+\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n \t\t\t// for a shared cache since it'll be cleared by the ApplicationContext.\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cc74a2891a4d2a4c7bcec059f20c35aa80bcf668": {
			"type": "Ybodychange",
			"commitMessage": "@Nullable all the way: null-safety at field level\n\nThis commits extends nullability declarations to the field level, formalizing the interaction between methods and their underlying fields and therefore avoiding any nullability mismatch.\n\nIssue: SPR-15720\n",
			"commitDate": "2017-06-29, 4:54 PM",
			"commitName": "cc74a2891a4d2a4c7bcec059f20c35aa80bcf668",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2017-06-13, 12:42 AM",
			"commitNameOld": "fc64b8040f7c76f2bc85387cf944436424ce408c",
			"commitAuthorOld": "Stephane Nicoll",
			"daysBetweenCommits": 16.67,
			"commitsBetweenForRepo": 81,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,100 +1,104 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tList<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n \t\tString[] candidateNames = registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Sort by previously determined @Order value, if applicable\n \t\tconfigCandidates.sort((bd1, bd2) -> {\n \t\t\tint i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n \t\t\tint i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n \t\t\treturn (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n \t\t});\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry sbr = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsbr = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tif (generator != null) {\n \t\t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n+\t\tif (this.environment == null) {\n+\t\t\tthis.environment = new StandardEnvironment();\n+\t\t}\n+\n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n \t\tSet<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n \t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader == null) {\n \t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() > candidateNames.length) {\n \t\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();\n \t\t\t\tSet<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n \t\t\t\tSet<String> alreadyParsedClasses = new HashSet<>();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition bd = registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&\n \t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n \t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames = newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (sbr != null) {\n \t\t\tif (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n \t\t\t// for a shared cache since it'll be cleared by the ApplicationContext.\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fc64b8040f7c76f2bc85387cf944436424ce408c": {
			"type": "Ybodychange",
			"commitMessage": "Polish \"Replace relevant code with lambda\"\n\nCloses gh-1454\n",
			"commitDate": "2017-06-13, 12:42 AM",
			"commitName": "fc64b8040f7c76f2bc85387cf944436424ce408c",
			"commitAuthor": "Stephane Nicoll",
			"commitDateOld": "2017-06-12, 11:55 PM",
			"commitNameOld": "4b1478d830f3cdbc4eb0d50d84f152d7900f30c3",
			"commitAuthorOld": "diguage",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,100 +1,100 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tList<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n \t\tString[] candidateNames = registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Sort by previously determined @Order value, if applicable\n-\t\tCollections.sort(configCandidates, (bd1, bd2) -> {\n+\t\tconfigCandidates.sort((bd1, bd2) -> {\n \t\t\tint i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n \t\t\tint i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n \t\t\treturn (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n \t\t});\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry sbr = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsbr = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tif (generator != null) {\n \t\t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n \t\tSet<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n \t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader == null) {\n \t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() > candidateNames.length) {\n \t\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();\n \t\t\t\tSet<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n \t\t\t\tSet<String> alreadyParsedClasses = new HashSet<>();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition bd = registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&\n \t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n \t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames = newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (sbr != null) {\n \t\t\tif (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n \t\t\t// for a shared cache since it'll be cleared by the ApplicationContext.\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4b1478d830f3cdbc4eb0d50d84f152d7900f30c3": {
			"type": "Ybodychange",
			"commitMessage": "Replace relevant code with lambda\n\nSee gh-1454\n",
			"commitDate": "2017-06-12, 11:55 PM",
			"commitName": "4b1478d830f3cdbc4eb0d50d84f152d7900f30c3",
			"commitAuthor": "diguage",
			"commitDateOld": "2017-06-07, 5:19 AM",
			"commitNameOld": "f813712f5b413b354560cd7cc006352e9defa9a3",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 5.78,
			"commitsBetweenForRepo": 46,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,103 +1,100 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tList<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n \t\tString[] candidateNames = registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Sort by previously determined @Order value, if applicable\n-\t\tCollections.sort(configCandidates, new Comparator<BeanDefinitionHolder>() {\n-\t\t\t@Override\n-\t\t\tpublic int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n-\t\t\t\tint i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n-\t\t\t\tint i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n-\t\t\t\treturn (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n-\t\t\t}\n+\t\tCollections.sort(configCandidates, (bd1, bd2) -> {\n+\t\t\tint i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n+\t\t\tint i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n+\t\t\treturn (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n \t\t});\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry sbr = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsbr = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tif (generator != null) {\n \t\t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n \t\tSet<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n \t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader == null) {\n \t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() > candidateNames.length) {\n \t\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();\n \t\t\t\tSet<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n \t\t\t\tSet<String> alreadyParsedClasses = new HashSet<>();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition bd = registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&\n \t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n \t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames = newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (sbr != null) {\n \t\t\tif (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n \t\t\t// for a shared cache since it'll be cleared by the ApplicationContext.\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f813712f5b413b354560cd7cc006352e9defa9a3": {
			"type": "Ybodychange",
			"commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
			"commitDate": "2017-06-07, 5:19 AM",
			"commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2017-05-31, 1:51 PM",
			"commitNameOld": "b494c53b40a76a3ce01a54b1bd384b6809f1a147",
			"commitAuthorOld": "Sebastien Deleuze",
			"daysBetweenCommits": 6.64,
			"commitsBetweenForRepo": 25,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,101 +1,103 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tList<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n \t\tString[] candidateNames = registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Sort by previously determined @Order value, if applicable\n \t\tCollections.sort(configCandidates, new Comparator<BeanDefinitionHolder>() {\n \t\t\t@Override\n \t\t\tpublic int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n \t\t\t\tint i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n \t\t\t\tint i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n \t\t\t\treturn (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n \t\t\t}\n \t\t});\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry sbr = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsbr = (SingletonBeanRegistry) registry;\n-\t\t\tif (!this.localBeanNameGeneratorSet && sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n+\t\t\tif (!this.localBeanNameGeneratorSet) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n-\t\t\t\tthis.componentScanBeanNameGenerator = generator;\n-\t\t\t\tthis.importBeanNameGenerator = generator;\n+\t\t\t\tif (generator != null) {\n+\t\t\t\t\tthis.componentScanBeanNameGenerator = generator;\n+\t\t\t\t\tthis.importBeanNameGenerator = generator;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n \t\tSet<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n \t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader == null) {\n \t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() > candidateNames.length) {\n \t\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();\n \t\t\t\tSet<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n \t\t\t\tSet<String> alreadyParsedClasses = new HashSet<>();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition bd = registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&\n \t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n \t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames = newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (sbr != null) {\n \t\t\tif (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n \t\t\t// for a shared cache since it'll be cleared by the ApplicationContext.\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"91df0653fe5e22477ec2ed6dbe7e44b835c99038": {
			"type": "Ybodychange",
			"commitMessage": "Polishing\n",
			"commitDate": "2017-04-17, 6:05 AM",
			"commitName": "91df0653fe5e22477ec2ed6dbe7e44b835c99038",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2016-12-29, 1:39 PM",
			"commitNameOld": "fc629bb508f950fe4a0f62b42395299677f7819e",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 108.64,
			"commitsBetweenForRepo": 645,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,101 +1,101 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tList<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n \t\tString[] candidateNames = registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Sort by previously determined @Order value, if applicable\n \t\tCollections.sort(configCandidates, new Comparator<BeanDefinitionHolder>() {\n \t\t\t@Override\n \t\t\tpublic int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n \t\t\t\tint i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n \t\t\t\tint i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n \t\t\t\treturn (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n \t\t\t}\n \t\t});\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n-\t\tSingletonBeanRegistry singletonRegistry = null;\n+\t\tSingletonBeanRegistry sbr = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n-\t\t\tsingletonRegistry = (SingletonBeanRegistry) registry;\n-\t\t\tif (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n-\t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n+\t\t\tsbr = (SingletonBeanRegistry) registry;\n+\t\t\tif (!this.localBeanNameGeneratorSet && sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n+\t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n \t\tSet<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n \t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader == null) {\n \t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() > candidateNames.length) {\n \t\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();\n \t\t\t\tSet<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n \t\t\t\tSet<String> alreadyParsedClasses = new HashSet<>();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n-\t\t\t\t\t\tBeanDefinition beanDef = registry.getBeanDefinition(candidateName);\n-\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) &&\n-\t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n-\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n+\t\t\t\t\t\tBeanDefinition bd = registry.getBeanDefinition(candidateName);\n+\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&\n+\t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n+\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames = newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n-\t\tif (singletonRegistry != null) {\n-\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n-\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n+\t\tif (sbr != null) {\n+\t\t\tif (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n+\t\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n \t\t\t// for a shared cache since it'll be cleared by the ApplicationContext.\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7818c650ba3ad567cff2975b408509679d03e663": {
			"type": "Ybodychange",
			"commitMessage": "Cache ASM metadata at the context level (if supported)\n\nIncludes streamlined ClassPathBeanDefinitionScanner setup.\n\nIssue: SPR-14654\n",
			"commitDate": "2016-12-27, 4:38 AM",
			"commitName": "7818c650ba3ad567cff2975b408509679d03e663",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2016-12-20, 3:16 AM",
			"commitNameOld": "f6b2a212066c97eabdd861044cb72dca78b0f80d",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 7.06,
			"commitsBetweenForRepo": 62,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,99 +1,101 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tList<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n \t\tString[] candidateNames = registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Sort by previously determined @Order value, if applicable\n \t\tCollections.sort(configCandidates, new Comparator<BeanDefinitionHolder>() {\n \t\t\t@Override\n \t\t\tpublic int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n \t\t\t\tint i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n \t\t\t\tint i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n \t\t\t\treturn (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n \t\t\t}\n \t\t});\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n \t\tSet<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n \t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader == null) {\n \t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() > candidateNames.length) {\n \t\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();\n \t\t\t\tSet<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n \t\t\t\tSet<String> alreadyParsedClasses = new HashSet<>();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition beanDef = registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) &&\n \t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n \t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames = newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry != null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n+\t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n+\t\t\t// for a shared cache since it'll be cleared by the ApplicationContext.\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"00d2606b000f9bdafbd7f4a16b6599fb51b53fa4": {
			"type": "Ybodychange",
			"commitMessage": "Explicit type can be replaced by <>\n\nIssue: SPR-13188\n",
			"commitDate": "2016-07-05, 8:00 AM",
			"commitName": "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
			"commitAuthor": "Stephane Nicoll",
			"commitDateOld": "2016-05-02, 6:19 AM",
			"commitNameOld": "7737c3c7e5e3ffe19e6cc151f1929982f5bba35d",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 64.07,
			"commitsBetweenForRepo": 250,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,99 +1,99 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n-\t\tList<BeanDefinitionHolder> configCandidates = new ArrayList<BeanDefinitionHolder>();\n+\t\tList<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n \t\tString[] candidateNames = registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Sort by previously determined @Order value, if applicable\n \t\tCollections.sort(configCandidates, new Comparator<BeanDefinitionHolder>() {\n \t\t\t@Override\n \t\t\tpublic int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n \t\t\t\tint i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n \t\t\t\tint i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n \t\t\t\treturn (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n \t\t\t}\n \t\t});\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n-\t\tSet<BeanDefinitionHolder> candidates = new LinkedHashSet<BeanDefinitionHolder>(configCandidates);\n-\t\tSet<ConfigurationClass> alreadyParsed = new HashSet<ConfigurationClass>(configCandidates.size());\n+\t\tSet<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n+\t\tSet<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n-\t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<ConfigurationClass>(parser.getConfigurationClasses());\n+\t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader == null) {\n \t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() > candidateNames.length) {\n \t\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();\n-\t\t\t\tSet<String> oldCandidateNames = new HashSet<String>(Arrays.asList(candidateNames));\n-\t\t\t\tSet<String> alreadyParsedClasses = new HashSet<String>();\n+\t\t\t\tSet<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n+\t\t\t\tSet<String> alreadyParsedClasses = new HashSet<>();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition beanDef = registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) &&\n \t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n \t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames = newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry != null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f0ac2784a4e9602a06bc91c3368f7cf423fc52dc": {
			"type": "Ybodychange",
			"commitMessage": "Removed unused fields from ConfigurationClassBeanDefinitionReader\n\nIssue: SPR-11740\nIssue: SPR-13280\n",
			"commitDate": "2015-07-28, 3:08 AM",
			"commitName": "f0ac2784a4e9602a06bc91c3368f7cf423fc52dc",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2015-03-13, 10:18 AM",
			"commitNameOld": "f5b4e18209c45c948ab6bce6d166ef17b3f5b25d",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 136.7,
			"commitsBetweenForRepo": 821,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,99 +1,99 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tList<BeanDefinitionHolder> configCandidates = new ArrayList<BeanDefinitionHolder>();\n \t\tString[] candidateNames = registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Sort by previously determined @Order value, if applicable\n \t\tCollections.sort(configCandidates, new Comparator<BeanDefinitionHolder>() {\n \t\t\t@Override\n \t\t\tpublic int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n \t\t\t\tint i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n \t\t\t\tint i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n \t\t\t\treturn (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n \t\t\t}\n \t\t});\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet<BeanDefinitionHolder> candidates = new LinkedHashSet<BeanDefinitionHolder>(configCandidates);\n \t\tSet<ConfigurationClass> alreadyParsed = new HashSet<ConfigurationClass>(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n \t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<ConfigurationClass>(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader == null) {\n-\t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n-\t\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n+\t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n+\t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() > candidateNames.length) {\n \t\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();\n \t\t\t\tSet<String> oldCandidateNames = new HashSet<String>(Arrays.asList(candidateNames));\n \t\t\t\tSet<String> alreadyParsedClasses = new HashSet<String>();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition beanDef = registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) &&\n \t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n \t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames = newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry != null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f5b4e18209c45c948ab6bce6d166ef17b3f5b25d": {
			"type": "Ybodychange",
			"commitMessage": "@Configuration classes get processed according to their @Order (if applicable)\n\nIssue: SPR-12657\n",
			"commitDate": "2015-03-13, 10:18 AM",
			"commitName": "f5b4e18209c45c948ab6bce6d166ef17b3f5b25d",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2014-12-01, 10:16 AM",
			"commitNameOld": "c85686ac78a815d6113371334b8ddcc49f1384ac",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 101.96,
			"commitsBetweenForRepo": 342,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,88 +1,99 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n-\t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n+\t\tList<BeanDefinitionHolder> configCandidates = new ArrayList<BeanDefinitionHolder>();\n \t\tString[] candidateNames = registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n+\t\t// Sort by previously determined @Order value, if applicable\n+\t\tCollections.sort(configCandidates, new Comparator<BeanDefinitionHolder>() {\n+\t\t\t@Override\n+\t\t\tpublic int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n+\t\t\t\tint i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n+\t\t\t\tint i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n+\t\t\t\treturn (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;\n+\t\t\t}\n+\t\t});\n+\n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n+\t\tSet<BeanDefinitionHolder> candidates = new LinkedHashSet<BeanDefinitionHolder>(configCandidates);\n \t\tSet<ConfigurationClass> alreadyParsed = new HashSet<ConfigurationClass>(configCandidates.size());\n \t\tdo {\n-\t\t\tparser.parse(configCandidates);\n+\t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n \t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<ConfigurationClass>(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader == null) {\n \t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n \t\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n-\t\t\tconfigCandidates.clear();\n+\t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() > candidateNames.length) {\n \t\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();\n \t\t\t\tSet<String> oldCandidateNames = new HashSet<String>(Arrays.asList(candidateNames));\n \t\t\t\tSet<String> alreadyParsedClasses = new HashSet<String>();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition beanDef = registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) &&\n \t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n-\t\t\t\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n+\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames = newCandidateNames;\n \t\t\t}\n \t\t}\n-\t\twhile (!configCandidates.isEmpty());\n+\t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry != null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4c59d85f690a29c45c644f9c3f13010d5cba84ed": {
			"type": "Ybodychange",
			"commitMessage": "Be defensive adding additional imported configs\n\nRefine the logic introduced in commit 71c6eb2b so that additional\nimported @Configuration classes are not considered as candidates if\nthey have already been parsed.\n\nIssue: SPR-12233\n",
			"commitDate": "2014-09-22, 3:05 PM",
			"commitName": "4c59d85f690a29c45c644f9c3f13010d5cba84ed",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2014-09-03, 3:59 AM",
			"commitNameOld": "6563405be5308954394b67608f09af35e7d35b59",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 19.46,
			"commitsBetweenForRepo": 88,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,83 +1,88 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tString[] candidateNames = registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet<ConfigurationClass> alreadyParsed = new HashSet<ConfigurationClass>(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(configCandidates);\n \t\t\tparser.validate();\n \n \t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<ConfigurationClass>(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader == null) {\n \t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n \t\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tconfigCandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() > candidateNames.length) {\n \t\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();\n \t\t\t\tSet<String> oldCandidateNames = new HashSet<String>(Arrays.asList(candidateNames));\n+\t\t\t\tSet<String> alreadyParsedClasses = new HashSet<String>();\n+\t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n+\t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n+\t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition beanDef = registry.getBeanDefinition(candidateName);\n-\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n+\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)\n+\t\t\t\t\t\t\t\t&& !alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n \t\t\t\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames = newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!configCandidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry != null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"abc343f4076d45172587197480c41f79c23f3aac": {
			"type": "Ybodychange",
			"commitMessage": "Prevent incorrect ImportAware metdata injection\n\nUpdate ImportRegistry to track all import registrations that occur\nagainst an importing class (rather than just keeping the last). In\naddition, prune imported classes from the registry when a configuration\nclass is removed during the REGISTER_BEAN ConfigurationPhase.\n\nThis update prevents incorrect metadata from being injected into an\nImportAware class which is imported twice by different configurations\nclasses (when one of the configuration classes will be ultimately skipped\ndue to a @Condition).\n\nIssue: SPR-12128\n",
			"commitDate": "2014-09-02, 8:47 PM",
			"commitName": "abc343f4076d45172587197480c41f79c23f3aac",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2014-08-21, 1:43 PM",
			"commitNameOld": "7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 12.29,
			"commitsBetweenForRepo": 66,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,83 +1,83 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tString[] candidateNames = registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet<ConfigurationClass> alreadyParsed = new HashSet<ConfigurationClass>(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(configCandidates);\n \t\t\tparser.validate();\n \n \t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<ConfigurationClass>(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader == null) {\n \t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n \t\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n-\t\t\t\t\t\tthis.importBeanNameGenerator);\n+\t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tconfigCandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() > candidateNames.length) {\n \t\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();\n \t\t\t\tSet<String> oldCandidateNames = new HashSet<String>(Arrays.asList(candidateNames));\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition beanDef = registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames = newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!configCandidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry != null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6": {
			"type": "Ybodychange",
			"commitMessage": "@PropertySource gets parsed as early as possible\n\nOther PropertySources and in particular @ComponentScan can benefit from previously declared property sources on the same configuration class.\n\nIssue: SPR-12110\nIssue: SPR-12111\n",
			"commitDate": "2014-08-21, 1:43 PM",
			"commitName": "7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2014-08-12, 8:23 AM",
			"commitNameOld": "71c6eb2bb594f29803b6ec4a50de875def98be86",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 9.22,
			"commitsBetweenForRepo": 63,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,102 +1,83 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tString[] candidateNames = registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet<ConfigurationClass> alreadyParsed = new HashSet<ConfigurationClass>(configCandidates.size());\n-\t\tint propertySourceCount = 0;\n \t\tdo {\n \t\t\tparser.parse(configCandidates);\n \t\t\tparser.validate();\n \n-\t\t\t// Handle any @PropertySource annotations\n-\t\t\tif (parser.getPropertySourceCount() > propertySourceCount) {\n-\t\t\t\tList<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n-\t\t\t\tif (!parsedPropertySources.isEmpty()) {\n-\t\t\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n-\t\t\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n-\t\t\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n-\t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\tMutablePropertySources envPropertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();\n-\t\t\t\t\t\tfor (PropertySource<?> propertySource : parsedPropertySources) {\n-\t\t\t\t\t\t\tenvPropertySources.addLast(propertySource);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tpropertySourceCount = parser.getPropertySourceCount();\n-\t\t\t}\n-\n \t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<ConfigurationClass>(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader == null) {\n \t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n \t\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator);\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tconfigCandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() > candidateNames.length) {\n \t\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();\n \t\t\t\tSet<String> oldCandidateNames = new HashSet<String>(Arrays.asList(candidateNames));\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition beanDef = registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames = newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!configCandidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry != null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"71c6eb2bb594f29803b6ec4a50de875def98be86": {
			"type": "Ybodychange",
			"commitMessage": "Additional configuration classes get detected when imported through XML or registrars\n\nIssue: SPR-11430\nIssue: SPR-11723\n",
			"commitDate": "2014-08-12, 8:23 AM",
			"commitName": "71c6eb2bb594f29803b6ec4a50de875def98be86",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2014-06-25, 4:46 AM",
			"commitNameOld": "b6255128bf7a32384f03e985d79b8bb03c3dd8a0",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 48.15,
			"commitsBetweenForRepo": 352,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,73 +1,102 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n-\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n+\t\tString[] candidateNames = registry.getBeanDefinitionNames();\n+\n+\t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n-\t\tparser.parse(configCandidates);\n-\t\tparser.validate();\n \n-\t\t// Handle any @PropertySource annotations\n-\t\tList<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n-\t\tif (!parsedPropertySources.isEmpty()) {\n-\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n-\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n-\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tMutablePropertySources envPropertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();\n-\t\t\t\tfor (PropertySource<?> propertySource : parsedPropertySources) {\n-\t\t\t\t\tenvPropertySources.addLast(propertySource);\n+\t\tSet<ConfigurationClass> alreadyParsed = new HashSet<ConfigurationClass>(configCandidates.size());\n+\t\tint propertySourceCount = 0;\n+\t\tdo {\n+\t\t\tparser.parse(configCandidates);\n+\t\t\tparser.validate();\n+\n+\t\t\t// Handle any @PropertySource annotations\n+\t\t\tif (parser.getPropertySourceCount() > propertySourceCount) {\n+\t\t\t\tList<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n+\t\t\t\tif (!parsedPropertySources.isEmpty()) {\n+\t\t\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n+\t\t\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n+\t\t\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tMutablePropertySources envPropertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();\n+\t\t\t\t\t\tfor (PropertySource<?> propertySource : parsedPropertySources) {\n+\t\t\t\t\t\t\tenvPropertySources.addLast(propertySource);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\tpropertySourceCount = parser.getPropertySourceCount();\n+\t\t\t}\n+\n+\t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<ConfigurationClass>(parser.getConfigurationClasses());\n+\t\t\tconfigClasses.removeAll(alreadyParsed);\n+\n+\t\t\t// Read the model and create bean definitions based on its content\n+\t\t\tif (this.reader == null) {\n+\t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n+\t\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n+\t\t\t\t\t\tthis.importBeanNameGenerator);\n+\t\t\t}\n+\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n+\t\t\talreadyParsed.addAll(configClasses);\n+\n+\t\t\tconfigCandidates.clear();\n+\t\t\tif (registry.getBeanDefinitionCount() > candidateNames.length) {\n+\t\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();\n+\t\t\t\tSet<String> oldCandidateNames = new HashSet<String>(Arrays.asList(candidateNames));\n+\t\t\t\tfor (String candidateName : newCandidateNames) {\n+\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n+\t\t\t\t\t\tBeanDefinition beanDef = registry.getBeanDefinition(candidateName);\n+\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n+\t\t\t\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tcandidateNames = newCandidateNames;\n \t\t\t}\n \t\t}\n-\n-\t\t// Read the model and create bean definitions based on its content\n-\t\tif (this.reader == null) {\n-\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n-\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n-\t\t\t\t\tthis.importBeanNameGenerator);\n-\t\t}\n-\n-\t\tthis.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n+\t\twhile (!configCandidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry != null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b6255128bf7a32384f03e985d79b8bb03c3dd8a0": {
			"type": "Ybodychange",
			"commitMessage": "ConfigurationClassPostProcessor skips pre-processed bean definitions now (avoiding side effects in case of multiple CCPPs)\n\nIssue: SPR-11858\n",
			"commitDate": "2014-06-25, 4:46 AM",
			"commitName": "b6255128bf7a32384f03e985d79b8bb03c3dd8a0",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2014-04-09, 8:43 AM",
			"commitNameOld": "0041e245a1f80affba828c79fd8db13b0319fb85",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 76.84,
			"commitsBetweenForRepo": 320,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,67 +1,73 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n-\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n+\t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n+\t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n+\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \t\tparser.parse(configCandidates);\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tList<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();\n \t\t\t\tfor (PropertySource<?> propertySource : parsedPropertySources) {\n \t\t\t\t\tenvPropertySources.addLast(propertySource);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tif (this.reader == null) {\n \t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n \t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n \t\t\t\t\tthis.importBeanNameGenerator);\n \t\t}\n \n \t\tthis.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry != null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"eed1a323d10de122a08db26192dc602f9fb173f8": {
			"type": "Ybodychange",
			"commitMessage": "Polishing (along with SPR-10992)\n",
			"commitDate": "2013-11-04, 2:44 PM",
			"commitName": "eed1a323d10de122a08db26192dc602f9fb173f8",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2013-10-22, 11:15 AM",
			"commitNameOld": "e95bd9e25086bf1dad37f8d08293c948621faf6b",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 13.19,
			"commitsBetweenForRepo": 99,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,67 +1,67 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \t\tparser.parse(configCandidates);\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tList<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources = ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\tfor (PropertySource<?> propertySource : parsedPropertySources) {\n \t\t\t\t\tenvPropertySources.addLast(propertySource);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tif (this.reader == null) {\n \t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n \t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n \t\t\t\t\tthis.importBeanNameGenerator);\n \t\t}\n \n-\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n+\t\tthis.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry != null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e95bd9e25086bf1dad37f8d08293c948621faf6b": {
			"type": "Ybodychange",
			"commitMessage": "Add @PropertySources and ignoreResourceNotFound\n\nSupport repeatable @PropertySource annotations in Java 8 and add\n@PropertySources container annotation for Java 6/7. Also add an\nignoreResourceNotFound attribute to @PropertySource allowing missing\nproperty resources to be silently ignored.\n\nThis commit also introduces some generally useful methods to\nAnnotationUtils for working with @Repeatable annotations.\n\nIssue: SPR-8371\n",
			"commitDate": "2013-10-22, 11:15 AM",
			"commitName": "e95bd9e25086bf1dad37f8d08293c948621faf6b",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2013-08-28, 3:49 AM",
			"commitNameOld": "bb971cecf15e8c7983cbaf7767851236d132889c",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 55.31,
			"commitsBetweenForRepo": 198,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,67 +1,67 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \t\tparser.parse(configCandidates);\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n-\t\tStack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n+\t\tList<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources = ((ConfigurableEnvironment)this.environment).getPropertySources();\n-\t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n-\t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n+\t\t\t\tfor (PropertySource<?> propertySource : parsedPropertySources) {\n+\t\t\t\t\tenvPropertySources.addLast(propertySource);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tif (this.reader == null) {\n \t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n \t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n \t\t\t\t\tthis.importBeanNameGenerator);\n \t\t}\n \n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry != null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5efe894ee4969a7c3780a2fd4d2ceab695777c50": {
			"type": "Ybodychange",
			"commitMessage": "Not exposing ApplicationContext on ConditionContext anymore\n",
			"commitDate": "2013-08-27, 3:00 PM",
			"commitName": "5efe894ee4969a7c3780a2fd4d2ceab695777c50",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2013-06-20, 8:21 PM",
			"commitNameOld": "a403e8f8b881c743e5e7a16a26690500595725be",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 67.78,
			"commitsBetweenForRepo": 236,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,69 +1,67 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n-\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry,\n-\t\t\t\tthis.applicationContext);\n+\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \t\tparser.parse(configCandidates);\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources = ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tif (this.reader == null) {\n-\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n-\t\t\t\t\tregistry, this.applicationContext, this.sourceExtractor,\n-\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory,\n-\t\t\t\t\tthis.resourceLoader, this.environment, this.importBeanNameGenerator);\n+\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n+\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n+\t\t\t\t\tthis.importBeanNameGenerator);\n \t\t}\n \n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry != null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6": {
			"type": "Ybodychange",
			"commitMessage": "Improve support for @Conditional on @Configuration\n\nIntroduce new ConfigurationCondition interface allowing more\nfine-grained control for @Conditional when used with @Configuration\nbeans.\n\nPrimarily added so that the evaluation of conditions that inspect bean\ndefinitions can be deferred until all @Configuration classes have been\nparsed.\n\nIssue: SPR-10534\n",
			"commitDate": "2013-06-12, 11:45 AM",
			"commitName": "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2013-06-04, 10:27 AM",
			"commitNameOld": "239ce1466ce118294f5c7b8e842a80815fd813de",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 8.05,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,67 +1,69 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n-\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n+\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry,\n+\t\t\t\tthis.applicationContext);\n \t\tparser.parse(configCandidates);\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources = ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tif (this.reader == null) {\n \t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n-\t\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory,\n+\t\t\t\t\tregistry, this.applicationContext, this.sourceExtractor,\n+\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory,\n \t\t\t\t\tthis.resourceLoader, this.environment, this.importBeanNameGenerator);\n \t\t}\n \n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry != null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"239ce1466ce118294f5c7b8e842a80815fd813de": {
			"type": "Ybodychange",
			"commitMessage": "Update @Conditional processing logic\n\nDefer @Conditional processing on @Configuration classes until the bean\ndefinitions are loaded, rather than when the @Configuration class is\nparsed. This provides better support for @Conditional implementations\nthat inspect bean definitions.\n\nThis commit also fixes some minor problems with original implementation\nand replaces the ConditionalAnnotationHelper class with\nConditionEvaluator.\n\nIssue: SPR-10534\n",
			"commitDate": "2013-06-04, 10:27 AM",
			"commitName": "239ce1466ce118294f5c7b8e842a80815fd813de",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2013-05-13, 3:04 PM",
			"commitNameOld": "94685481162a93666fc2f39b66223833a6bcb418",
			"commitAuthorOld": "Rob Winch",
			"daysBetweenCommits": 21.81,
			"commitsBetweenForRepo": 52,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,71 +1,67 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \t\tparser.parse(configCandidates);\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources = ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tif (this.reader == null) {\n \t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory,\n \t\t\t\t\tthis.resourceLoader, this.environment, this.importBeanNameGenerator);\n \t\t}\n-\t\tfor (ConfigurationClass configurationClass : parser.getConfigurationClasses()) {\n-\t\t\tif (!ConditionalAnnotationHelper.shouldSkip(configurationClass, registry,\n-\t\t\t\t\tthis.environment, this.importBeanNameGenerator)) {\n-\t\t\t\treader.loadBeanDefinitionsForConfigurationClass(configurationClass);\n-\t\t\t}\n-\t\t}\n+\n+\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry != null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7c7fdb07363791fb3c72f4946839f4c166196ebe": {
			"type": "Ybodychange",
			"commitMessage": "Add support for DeferredImportSelector\n\nAdd DeferredImportSelector interface that can be used to select imports\nafter all @Configuration beans have been processed.\n",
			"commitDate": "2013-05-08, 7:41 PM",
			"commitName": "7c7fdb07363791fb3c72f4946839f4c166196ebe",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2013-05-08, 7:41 PM",
			"commitNameOld": "b257253a2b6890ef532f27a662c441fc4fd21f3b",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,84 +1,71 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n-\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n-\t\t\tBeanDefinition bd = holder.getBeanDefinition();\n-\t\t\ttry {\n-\t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n-\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tcatch (IOException ex) {\n-\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n-\t\t\t}\n-\t\t}\n+\t\tparser.parse(configCandidates);\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources = ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tif (this.reader == null) {\n \t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory,\n \t\t\t\t\tthis.resourceLoader, this.environment, this.importBeanNameGenerator);\n \t\t}\n \t\tfor (ConfigurationClass configurationClass : parser.getConfigurationClasses()) {\n \t\t\tif (!ConditionalAnnotationHelper.shouldSkip(configurationClass, registry,\n \t\t\t\t\tthis.environment, this.importBeanNameGenerator)) {\n \t\t\t\treader.loadBeanDefinitionsForConfigurationClass(configurationClass);\n \t\t\t}\n \t\t}\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry != null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b257253a2b6890ef532f27a662c441fc4fd21f3b": {
			"type": "Ybodychange",
			"commitMessage": "Support for @Conditional configuration\n\nIntroduce new @Conditional annotation that can be used to filter\nwhich @Configuration classes or methods are loaded. @Conditional\ncan be used directly or as a meta-annotation. Condition implementations\nare provided via the 'Condition' interface and are free to filter based\non any criteria available at the time that they run. The\nConditionalContext provides access to the BeanDefinitionRegistry,\nEnvironment and ConfigurableListableBeanFactory along with a\nResourceLoader and ClassLoader.\n\nThe existing @Profile annotation has been refactored as a @Conditional\nwith the added benefit that it can now be used as a method level\nannotation.\n",
			"commitDate": "2013-05-08, 7:41 PM",
			"commitName": "b257253a2b6890ef532f27a662c441fc4fd21f3b",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2013-01-02, 1:33 AM",
			"commitNameOld": "70eaf02b7fab9d8a023ddb50cedcab859e93c245",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 126.71,
			"commitsBetweenForRepo": 540,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,79 +1,84 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources = ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tif (this.reader == null) {\n \t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory,\n \t\t\t\t\tthis.resourceLoader, this.environment, this.importBeanNameGenerator);\n \t\t}\n-\t\tthis.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n+\t\tfor (ConfigurationClass configurationClass : parser.getConfigurationClasses()) {\n+\t\t\tif (!ConditionalAnnotationHelper.shouldSkip(configurationClass, registry,\n+\t\t\t\t\tthis.environment, this.importBeanNameGenerator)) {\n+\t\t\t\treader.loadBeanDefinitionsForConfigurationClass(configurationClass);\n+\t\t\t}\n+\t\t}\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry != null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1cb6e3dbb6e5a5f15ec06f4abc297821606ab2a6": {
			"type": "Ybodychange",
			"commitMessage": "Several enhancements with respect to CachingMetadataReaderFactory handling.\n\nAdded \"clearCache()\" method to CachingMetadataReaderFactory, for clearing the metadata cache once not needed anymore - in particular when the MetadataReaderFactory instance is long-lived. Also added \"setMetadataReaderFactory\" method to ClassPathScanningCandidateComponentProvider, analogous to ConfigurationClassPostProcessor.\n",
			"commitDate": "2012-12-11, 6:29 PM",
			"commitName": "1cb6e3dbb6e5a5f15ec06f4abc297821606ab2a6",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2012-09-24, 2:26 AM",
			"commitNameOld": "dc4e0683aeccdabfa212d20a5335e81af13cd6d4",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 78.71,
			"commitsBetweenForRepo": 393,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,75 +1,79 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry = (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator = generator;\n \t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources = ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tif (this.reader == null) {\n \t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory,\n \t\t\t\t\tthis.resourceLoader, this.environment, this.importBeanNameGenerator);\n \t\t}\n \t\tthis.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry != null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n+\n+\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n+\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n+\t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0a42c80c1151380f7f492ec75de5648cfe62d250": {
			"type": "Ybodychange",
			"commitMessage": "@Import'ed configuration classes get properly registered in case of same class name (second try)\n\nIssue: SPR-9243\n",
			"commitDate": "2012-09-10, 2:16 PM",
			"commitName": "0a42c80c1151380f7f492ec75de5648cfe62d250",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2012-08-09, 3:38 PM",
			"commitNameOld": "92500ab9023ae2afd096be9c014423fcd4180c55",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 31.94,
			"commitsBetweenForRepo": 84,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,75 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry = null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry = (SingletonBeanRegistry) registry;\n-\t\t\tif (singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n-\t\t\t\tthis.beanNameGenerator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n+\t\t\tif (!this.localBeanNameGeneratorSet && singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n+\t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n+\t\t\t\tthis.componentScanBeanNameGenerator = generator;\n+\t\t\t\tthis.importBeanNameGenerator = generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n-\t\t\t\tthis.resourceLoader, this.beanNameGenerator, registry);\n+\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources = ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tif (this.reader == null) {\n \t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n-\t\t\t\t\tregistry, this.sourceExtractor, this.problemReporter,\n-\t\t\t\t\tthis.metadataReaderFactory, this.resourceLoader, this.environment,\n-\t\t\t\t\tthis.beanNameGenerator);\n+\t\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory,\n+\t\t\t\t\tthis.resourceLoader, this.environment, this.importBeanNameGenerator);\n \t\t}\n \t\tthis.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry != null) {\n-\t\t\tif (!singletonRegistry.containsSingleton(\"importRegistry\")) {\n-\t\t\t\tsingletonRegistry.registerSingleton(\"importRegistry\", parser.getImportRegistry());\n+\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n+\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"02a4473c62d8240837bec297f0a1f3cb67ef8a7b": {
			"type": "Yfilerename",
			"commitMessage": "Rename modules {org.springframework.*=>spring-*}\n\nThis renaming more intuitively expresses the relationship between\nsubprojects and the JAR artifacts they produce.\n\nTracking history across these renames is possible, but it requires\nuse of the --follow flag to `git log`, for example\n\n    $ git log spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history up until the renaming event, where\n\n    $ git log --follow spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history for all changes to the file, before and after the\nrenaming.\n\nSee http://chrisbeams.com/git-diff-across-renamed-directories\n",
			"commitDate": "2012-01-31, 5:37 AM",
			"commitName": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2012-01-31, 5:37 AM",
			"commitNameOld": "b6cb514d383dcef52ba6c609a863f19e1a4c1faf",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
				"newPath": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java"
			}
		},
		"4520ea8690fa8769a2d45658883eac51ea2453ed": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Revert #processConfigBeanDefinitions to 3.0.x API\n\nRevert signature of\nConfigurationClassPostProcessor#processConfigBeanDefinitions to its form\nfound in the 3.0.x line.  Refactorings made during 3.1 development\ncaused otherwise package-private types such as\nConfigurationClassBeanDefinitionReader to escape through this public\nmethod, causing issues for STS as well as being a general design issue.\n\nUpon review, the refactorings could easily be backed out in favor of a\nsimpler approach, and this has been done.\n\nThis also means that ConfigurationClassBeanDefinitionReader can return\nto package-private visibility, and this change has been made as well.\n\nIssue: SPR-8200\n",
			"commitDate": "2011-05-18, 1:53 AM",
			"commitName": "4520ea8690fa8769a2d45658883eac51ea2453ed",
			"commitAuthor": "Chris Beams",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Revert #processConfigBeanDefinitions to 3.0.x API\n\nRevert signature of\nConfigurationClassPostProcessor#processConfigBeanDefinitions to its form\nfound in the 3.0.x line.  Refactorings made during 3.1 development\ncaused otherwise package-private types such as\nConfigurationClassBeanDefinitionReader to escape through this public\nmethod, causing issues for STS as well as being a general design issue.\n\nUpon review, the refactorings could easily be backed out in favor of a\nsimpler approach, and this has been done.\n\nThis also means that ConfigurationClassBeanDefinitionReader can return\nto package-private visibility, and this change has been made as well.\n\nIssue: SPR-8200\n",
					"commitDate": "2011-05-18, 1:53 AM",
					"commitName": "4520ea8690fa8769a2d45658883eac51ea2453ed",
					"commitAuthor": "Chris Beams",
					"commitDateOld": "2011-05-17, 12:15 PM",
					"commitNameOld": "6fcea8b99da45f287149796ef2598f0d71758793",
					"commitAuthorOld": "Chris Beams",
					"daysBetweenCommits": 0.57,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,58 +1,58 @@\n-\tpublic void processConfigBeanDefinitions(ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n+\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources = ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n-\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n+\t\tthis.getConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n \t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[reader-ConfigurationClassBeanDefinitionReader, registry-BeanDefinitionRegistry]",
						"newValue": "[registry-BeanDefinitionRegistry]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Revert #processConfigBeanDefinitions to 3.0.x API\n\nRevert signature of\nConfigurationClassPostProcessor#processConfigBeanDefinitions to its form\nfound in the 3.0.x line.  Refactorings made during 3.1 development\ncaused otherwise package-private types such as\nConfigurationClassBeanDefinitionReader to escape through this public\nmethod, causing issues for STS as well as being a general design issue.\n\nUpon review, the refactorings could easily be backed out in favor of a\nsimpler approach, and this has been done.\n\nThis also means that ConfigurationClassBeanDefinitionReader can return\nto package-private visibility, and this change has been made as well.\n\nIssue: SPR-8200\n",
					"commitDate": "2011-05-18, 1:53 AM",
					"commitName": "4520ea8690fa8769a2d45658883eac51ea2453ed",
					"commitAuthor": "Chris Beams",
					"commitDateOld": "2011-05-17, 12:15 PM",
					"commitNameOld": "6fcea8b99da45f287149796ef2598f0d71758793",
					"commitAuthorOld": "Chris Beams",
					"daysBetweenCommits": 0.57,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,58 +1,58 @@\n-\tpublic void processConfigBeanDefinitions(ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n+\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources = ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n-\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n+\t\tthis.getConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n \t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"6fcea8b99da45f287149796ef2598f0d71758793": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Remove ConfigurationClassParser from public API\n\nIssue: SPR-8200\n",
			"commitDate": "2011-05-17, 12:15 PM",
			"commitName": "6fcea8b99da45f287149796ef2598f0d71758793",
			"commitAuthor": "Chris Beams",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Remove ConfigurationClassParser from public API\n\nIssue: SPR-8200\n",
					"commitDate": "2011-05-17, 12:15 PM",
					"commitName": "6fcea8b99da45f287149796ef2598f0d71758793",
					"commitAuthor": "Chris Beams",
					"commitDateOld": "2011-05-12, 5:27 AM",
					"commitNameOld": "57206db15271f865b542264c74980e6cbb4681fd",
					"commitAuthorOld": "Chris Beams",
					"daysBetweenCommits": 5.28,
					"commitsBetweenForRepo": 26,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,56 +1,58 @@\n-\tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n+\tpublic void processConfigBeanDefinitions(ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Parse each @Configuration class\n+\t\tConfigurationClassParser parser = new ConfigurationClassParser(\n+\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources = ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n \t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[parser-ConfigurationClassParser, reader-ConfigurationClassBeanDefinitionReader, registry-BeanDefinitionRegistry]",
						"newValue": "[reader-ConfigurationClassBeanDefinitionReader, registry-BeanDefinitionRegistry]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Remove ConfigurationClassParser from public API\n\nIssue: SPR-8200\n",
					"commitDate": "2011-05-17, 12:15 PM",
					"commitName": "6fcea8b99da45f287149796ef2598f0d71758793",
					"commitAuthor": "Chris Beams",
					"commitDateOld": "2011-05-12, 5:27 AM",
					"commitNameOld": "57206db15271f865b542264c74980e6cbb4681fd",
					"commitAuthorOld": "Chris Beams",
					"daysBetweenCommits": 5.28,
					"commitsBetweenForRepo": 26,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,56 +1,58 @@\n-\tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n+\tpublic void processConfigBeanDefinitions(ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Parse each @Configuration class\n+\t\tConfigurationClassParser parser = new ConfigurationClassParser(\n+\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources = ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n \t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"57206db15271f865b542264c74980e6cbb4681fd": {
			"type": "Ybodychange",
			"commitMessage": "Refine ignored @PropertySource log warning\n\nIf the enclosing environment does not implement ConfigurableEnvironment,\nthen @PropertySource annotations are ignored because there is no way to\nadd them to the Environment. Now checking first to see if there are any\n@PropertySource annotations present before issuing the warning.\n\nIssue: SPR-8314\n",
			"commitDate": "2011-05-12, 5:27 AM",
			"commitName": "57206db15271f865b542264c74980e6cbb4681fd",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2011-05-11, 6:28 AM",
			"commitNameOld": "c8bc54e0ccad49f0785856f911349283619eb8ba",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0.96,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,54 +1,56 @@\n \tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n-\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n-\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n-\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n-\t\t}\n-\t\telse {\n-\t\t\tMutablePropertySources envPropertySources = ((ConfigurableEnvironment)this.environment).getPropertySources();\n-\t\t\tStack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n-\t\t\twhile (!parsedPropertySources.isEmpty()) {\n-\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n+\t\tStack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n+\t\tif (!parsedPropertySources.isEmpty()) {\n+\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n+\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n+\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tMutablePropertySources envPropertySources = ((ConfigurableEnvironment)this.environment).getPropertySources();\n+\t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n+\t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n \t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c8bc54e0ccad49f0785856f911349283619eb8ba": {
			"type": "Ybodychange",
			"commitMessage": "Introduce @PropertySource\n\nAllows a convenient mechanism for contributing a PropertySource to the\nenclosing Spring Environment. See @PropertySource Javadoc for\ncomplete details and PropertySourceAnnotationTests for examples.\n\nIssue: SPR-8314\n",
			"commitDate": "2011-05-11, 6:28 AM",
			"commitName": "c8bc54e0ccad49f0785856f911349283619eb8ba",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2011-05-08, 6:49 AM",
			"commitNameOld": "d0c31ad84cffd7af718a45d679483a1c51f9e552",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 2.99,
			"commitsBetweenForRepo": 14,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,41 +1,54 @@\n \tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n+\t\t// Handle any @PropertySource annotations\n+\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n+\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n+\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n+\t\t}\n+\t\telse {\n+\t\t\tMutablePropertySources envPropertySources = ((ConfigurableEnvironment)this.environment).getPropertySources();\n+\t\t\tStack<PropertySource<?>> parsedPropertySources = parser.getPropertySources();\n+\t\t\twhile (!parsedPropertySources.isEmpty()) {\n+\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n+\t\t\t}\n+\t\t}\n+\n \t\t// Read the model and create bean definitions based on its content\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n \t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d0c31ad84cffd7af718a45d679483a1c51f9e552": {
			"type": "Ybodychange",
			"commitMessage": "Allow recursive use of @ComponentScan\n\nPrior to this change, @ComponentScan annotations were only processed at\nthe first level of depth.  Now, the set of bean definitions resulting\nfrom each declaration of @ComponentScan is checked for configuration\nclasses that declare @ComponentScan, and recursion is performed as\nnecessary.\n\nCycles between @ComponentScan declarations are detected as well. See\nCircularComponentScanException.\n\nIssue: SPR-8307\n",
			"commitDate": "2011-05-08, 6:49 AM",
			"commitName": "d0c31ad84cffd7af718a45d679483a1c51f9e552",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2011-05-06, 12:05 PM",
			"commitNameOld": "cdb01cbd3795f273b751d0f0a45caa22d07c62da",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 1.78,
			"commitsBetweenForRepo": 16,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,41 +1,41 @@\n \tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n-\t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n+\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n \t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cdb01cbd3795f273b751d0f0a45caa22d07c62da": {
			"type": "Ybodychange",
			"commitMessage": "Introduce ImportAware interface\n\n@Configuration classes may implement ImportAware in order to be injected\nwith the AnnotationMetadata of their @Import'ing class.\n\nIncludes the introduction of a new PriorityOrdered\nImportAwareBeanPostProcessor that handles injection of the\nimporting class metadata.\n",
			"commitDate": "2011-05-06, 12:05 PM",
			"commitName": "cdb01cbd3795f273b751d0f0a45caa22d07c62da",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2011-05-06, 12:03 PM",
			"commitNameOld": "111fb71fe1ccb8d3a5e06e61461edd87d6d025f4",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,34 +1,41 @@\n \tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n+\n+\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n+\t\tif (registry instanceof SingletonBeanRegistry) {\n+\t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n+\t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n+\t\t\t}\n+\t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"111fb71fe1ccb8d3a5e06e61461edd87d6d025f4": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Remove \"Feature\" support introduced in 3.1 M1\n\nFeature-related support such as @Feature, @FeatureConfiguration,\nand FeatureSpecification types will be replaced by framework-provided\n@Configuration classes and convenience annotations such as\n@ComponentScan (already exists), @EnableAsync, @EnableScheduling,\n@EnableTransactionManagement and others.\n\nIssue: SPR-8012,SPR-8034,SPR-8039,SPR-8188,SPR-8206,SPR-8223,\nSPR-8225,SPR-8226,SPR-8227\n",
			"commitDate": "2011-05-06, 12:03 PM",
			"commitName": "111fb71fe1ccb8d3a5e06e61461edd87d6d025f4",
			"commitAuthor": "Chris Beams",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Remove \"Feature\" support introduced in 3.1 M1\n\nFeature-related support such as @Feature, @FeatureConfiguration,\nand FeatureSpecification types will be replaced by framework-provided\n@Configuration classes and convenience annotations such as\n@ComponentScan (already exists), @EnableAsync, @EnableScheduling,\n@EnableTransactionManagement and others.\n\nIssue: SPR-8012,SPR-8034,SPR-8039,SPR-8188,SPR-8206,SPR-8223,\nSPR-8225,SPR-8226,SPR-8227\n",
					"commitDate": "2011-05-06, 12:03 PM",
					"commitName": "111fb71fe1ccb8d3a5e06e61461edd87d6d025f4",
					"commitAuthor": "Chris Beams",
					"commitDateOld": "2011-03-15, 12:09 AM",
					"commitNameOld": "d471266d44199112b6e030615a395209e5265ec0",
					"commitAuthorOld": "Chris Beams",
					"daysBetweenCommits": 52.5,
					"commitsBetweenForRepo": 121,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,35 +1,34 @@\n-\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry, ConfigurationClassBeanDefinitionReader reader) {\n+\tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n-\t\t// Populate a new configuration model by parsing each @Configuration classes\n-\t\tConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n+\t\t// Parse each @Configuration class\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[registry-BeanDefinitionRegistry, reader-ConfigurationClassBeanDefinitionReader]",
						"newValue": "[parser-ConfigurationClassParser, reader-ConfigurationClassBeanDefinitionReader, registry-BeanDefinitionRegistry]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Remove \"Feature\" support introduced in 3.1 M1\n\nFeature-related support such as @Feature, @FeatureConfiguration,\nand FeatureSpecification types will be replaced by framework-provided\n@Configuration classes and convenience annotations such as\n@ComponentScan (already exists), @EnableAsync, @EnableScheduling,\n@EnableTransactionManagement and others.\n\nIssue: SPR-8012,SPR-8034,SPR-8039,SPR-8188,SPR-8206,SPR-8223,\nSPR-8225,SPR-8226,SPR-8227\n",
					"commitDate": "2011-05-06, 12:03 PM",
					"commitName": "111fb71fe1ccb8d3a5e06e61461edd87d6d025f4",
					"commitAuthor": "Chris Beams",
					"commitDateOld": "2011-03-15, 12:09 AM",
					"commitNameOld": "d471266d44199112b6e030615a395209e5265ec0",
					"commitAuthorOld": "Chris Beams",
					"daysBetweenCommits": 52.5,
					"commitsBetweenForRepo": 121,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,35 +1,34 @@\n-\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry, ConfigurationClassBeanDefinitionReader reader) {\n+\tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n-\t\t// Populate a new configuration model by parsing each @Configuration classes\n-\t\tConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n+\t\t// Parse each @Configuration class\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"b4fea47d5cff9f3c85e62c233c2fe86b1d616592": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Introduce FeatureSpecification support\n\nIntroduce FeatureSpecification interface and implementations\n\n    FeatureSpecification objects decouple the configuration of\n    spring container features from the concern of parsing XML\n    namespaces, allowing for reuse in code-based configuration\n    (see @Feature* annotations below).\n\n    * ComponentScanSpec\n    * TxAnnotationDriven\n    * MvcAnnotationDriven\n    * MvcDefaultServletHandler\n    * MvcResources\n    * MvcViewControllers\n\nRefactor associated BeanDefinitionParsers to delegate to new impls above\n\n    The following BeanDefinitionParser implementations now deal only\n    with the concern of XML parsing.  Validation is handled by their\n    corresponding FeatureSpecification object.  Bean definition creation\n    and registration is handled by their corresponding\n    FeatureSpecificationExecutor type.\n\n    * ComponentScanBeanDefinitionParser\n    * AnnotationDrivenBeanDefinitionParser (tx)\n    * AnnotationDrivenBeanDefinitionParser (mvc)\n    * DefaultServletHandlerBeanDefinitionParser\n    * ResourcesBeanDefinitionParser\n    * ViewControllerBeanDefinitionParser\n\nUpdate AopNamespaceUtils to decouple from XML (DOM API)\n\n    Methods necessary for executing TxAnnotationDriven specification\n    (and eventually, the AspectJAutoProxy specification) have been\n    added that accept boolean arguments for whether to proxy\n    target classes and whether to expose the proxy via threadlocal.\n\n    Methods that accepted and introspected DOM Element objects still\n    exist but have been deprecated.\n\nIntroduce @FeatureConfiguration classes and @Feature methods\n\n    Allow for creation and configuration of FeatureSpecification objects\n    at the user level.  A companion for @Configuration classes allowing\n    for completely code-driven configuration of the Spring container.\n\n    See changes in ConfigurationClassPostProcessor for implementation\n    details.\n\n    See Feature*Tests for usage examples.\n\n    FeatureTestSuite in .integration-tests is a JUnit test suite designed\n    to aggregate all BDP and Feature* related tests for a convenient way\n    to confirm that Feature-related changes don't break anything.\n    Uncomment this test and execute from Eclipse / IDEA. Due to classpath\n    issues, this cannot be compiled by Ant/Ivy at the command line.\n\nIntroduce @FeatureAnnotation meta-annotation and @ComponentScan impl\n\n    @FeatureAnnotation provides an alternate mechanism for creating\n    and executing FeatureSpecification objects.  See @ComponentScan\n    and its corresponding ComponentScanAnnotationParser implementation\n    for details.  See ComponentScanAnnotationIntegrationTests for usage\n    examples\n\nIntroduce Default[Formatting]ConversionService implementations\n\n    Allows for convenient instantiation of ConversionService objects\n    containing defaults appropriate for most environments.  Replaces\n    similar support originally in ConversionServiceFactory (which is now\n    deprecated). This change was justified by the need to avoid use\n    of FactoryBeans in @Configuration classes (such as\n    FormattingConversionServiceFactoryBean). It is strongly preferred\n    that users simply instantiate and configure the objects that underlie\n    our FactoryBeans. In the case of the ConversionService types, the\n    easiest way to do this is to create Default* subtypes. This also\n    follows convention with the rest of the framework.\n\nMinor updates to util classes\n\n    All in service of changes above. See diffs for self-explanatory\n    details.\n\n    * BeanUtils\n    * ObjectUtils\n    * ReflectionUtils\n",
			"commitDate": "2011-02-08, 6:42 AM",
			"commitName": "b4fea47d5cff9f3c85e62c233c2fe86b1d616592",
			"commitAuthor": "Chris Beams",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Introduce FeatureSpecification support\n\nIntroduce FeatureSpecification interface and implementations\n\n    FeatureSpecification objects decouple the configuration of\n    spring container features from the concern of parsing XML\n    namespaces, allowing for reuse in code-based configuration\n    (see @Feature* annotations below).\n\n    * ComponentScanSpec\n    * TxAnnotationDriven\n    * MvcAnnotationDriven\n    * MvcDefaultServletHandler\n    * MvcResources\n    * MvcViewControllers\n\nRefactor associated BeanDefinitionParsers to delegate to new impls above\n\n    The following BeanDefinitionParser implementations now deal only\n    with the concern of XML parsing.  Validation is handled by their\n    corresponding FeatureSpecification object.  Bean definition creation\n    and registration is handled by their corresponding\n    FeatureSpecificationExecutor type.\n\n    * ComponentScanBeanDefinitionParser\n    * AnnotationDrivenBeanDefinitionParser (tx)\n    * AnnotationDrivenBeanDefinitionParser (mvc)\n    * DefaultServletHandlerBeanDefinitionParser\n    * ResourcesBeanDefinitionParser\n    * ViewControllerBeanDefinitionParser\n\nUpdate AopNamespaceUtils to decouple from XML (DOM API)\n\n    Methods necessary for executing TxAnnotationDriven specification\n    (and eventually, the AspectJAutoProxy specification) have been\n    added that accept boolean arguments for whether to proxy\n    target classes and whether to expose the proxy via threadlocal.\n\n    Methods that accepted and introspected DOM Element objects still\n    exist but have been deprecated.\n\nIntroduce @FeatureConfiguration classes and @Feature methods\n\n    Allow for creation and configuration of FeatureSpecification objects\n    at the user level.  A companion for @Configuration classes allowing\n    for completely code-driven configuration of the Spring container.\n\n    See changes in ConfigurationClassPostProcessor for implementation\n    details.\n\n    See Feature*Tests for usage examples.\n\n    FeatureTestSuite in .integration-tests is a JUnit test suite designed\n    to aggregate all BDP and Feature* related tests for a convenient way\n    to confirm that Feature-related changes don't break anything.\n    Uncomment this test and execute from Eclipse / IDEA. Due to classpath\n    issues, this cannot be compiled by Ant/Ivy at the command line.\n\nIntroduce @FeatureAnnotation meta-annotation and @ComponentScan impl\n\n    @FeatureAnnotation provides an alternate mechanism for creating\n    and executing FeatureSpecification objects.  See @ComponentScan\n    and its corresponding ComponentScanAnnotationParser implementation\n    for details.  See ComponentScanAnnotationIntegrationTests for usage\n    examples\n\nIntroduce Default[Formatting]ConversionService implementations\n\n    Allows for convenient instantiation of ConversionService objects\n    containing defaults appropriate for most environments.  Replaces\n    similar support originally in ConversionServiceFactory (which is now\n    deprecated). This change was justified by the need to avoid use\n    of FactoryBeans in @Configuration classes (such as\n    FormattingConversionServiceFactoryBean). It is strongly preferred\n    that users simply instantiate and configure the objects that underlie\n    our FactoryBeans. In the case of the ConversionService types, the\n    easiest way to do this is to create Default* subtypes. This also\n    follows convention with the rest of the framework.\n\nMinor updates to util classes\n\n    All in service of changes above. See diffs for self-explanatory\n    details.\n\n    * BeanUtils\n    * ObjectUtils\n    * ReflectionUtils\n",
					"commitDate": "2011-02-08, 6:42 AM",
					"commitName": "b4fea47d5cff9f3c85e62c233c2fe86b1d616592",
					"commitAuthor": "Chris Beams",
					"commitDateOld": "2011-01-03, 1:04 AM",
					"commitNameOld": "b3ff9be78f62ff1d13ab874a4772f8fc6d189eb4",
					"commitAuthorOld": "Chris Beams",
					"daysBetweenCommits": 36.23,
					"commitsBetweenForRepo": 93,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,37 +1,35 @@\n-\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry, ConfigurationClassBeanDefinitionReader reader) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Populate a new configuration model by parsing each @Configuration classes\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n-\t\tConfigurationClassBeanDefinitionReader reader = new ConfigurationClassBeanDefinitionReader(\n-\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory);\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[registry-BeanDefinitionRegistry]",
						"newValue": "[registry-BeanDefinitionRegistry, reader-ConfigurationClassBeanDefinitionReader]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Introduce FeatureSpecification support\n\nIntroduce FeatureSpecification interface and implementations\n\n    FeatureSpecification objects decouple the configuration of\n    spring container features from the concern of parsing XML\n    namespaces, allowing for reuse in code-based configuration\n    (see @Feature* annotations below).\n\n    * ComponentScanSpec\n    * TxAnnotationDriven\n    * MvcAnnotationDriven\n    * MvcDefaultServletHandler\n    * MvcResources\n    * MvcViewControllers\n\nRefactor associated BeanDefinitionParsers to delegate to new impls above\n\n    The following BeanDefinitionParser implementations now deal only\n    with the concern of XML parsing.  Validation is handled by their\n    corresponding FeatureSpecification object.  Bean definition creation\n    and registration is handled by their corresponding\n    FeatureSpecificationExecutor type.\n\n    * ComponentScanBeanDefinitionParser\n    * AnnotationDrivenBeanDefinitionParser (tx)\n    * AnnotationDrivenBeanDefinitionParser (mvc)\n    * DefaultServletHandlerBeanDefinitionParser\n    * ResourcesBeanDefinitionParser\n    * ViewControllerBeanDefinitionParser\n\nUpdate AopNamespaceUtils to decouple from XML (DOM API)\n\n    Methods necessary for executing TxAnnotationDriven specification\n    (and eventually, the AspectJAutoProxy specification) have been\n    added that accept boolean arguments for whether to proxy\n    target classes and whether to expose the proxy via threadlocal.\n\n    Methods that accepted and introspected DOM Element objects still\n    exist but have been deprecated.\n\nIntroduce @FeatureConfiguration classes and @Feature methods\n\n    Allow for creation and configuration of FeatureSpecification objects\n    at the user level.  A companion for @Configuration classes allowing\n    for completely code-driven configuration of the Spring container.\n\n    See changes in ConfigurationClassPostProcessor for implementation\n    details.\n\n    See Feature*Tests for usage examples.\n\n    FeatureTestSuite in .integration-tests is a JUnit test suite designed\n    to aggregate all BDP and Feature* related tests for a convenient way\n    to confirm that Feature-related changes don't break anything.\n    Uncomment this test and execute from Eclipse / IDEA. Due to classpath\n    issues, this cannot be compiled by Ant/Ivy at the command line.\n\nIntroduce @FeatureAnnotation meta-annotation and @ComponentScan impl\n\n    @FeatureAnnotation provides an alternate mechanism for creating\n    and executing FeatureSpecification objects.  See @ComponentScan\n    and its corresponding ComponentScanAnnotationParser implementation\n    for details.  See ComponentScanAnnotationIntegrationTests for usage\n    examples\n\nIntroduce Default[Formatting]ConversionService implementations\n\n    Allows for convenient instantiation of ConversionService objects\n    containing defaults appropriate for most environments.  Replaces\n    similar support originally in ConversionServiceFactory (which is now\n    deprecated). This change was justified by the need to avoid use\n    of FactoryBeans in @Configuration classes (such as\n    FormattingConversionServiceFactoryBean). It is strongly preferred\n    that users simply instantiate and configure the objects that underlie\n    our FactoryBeans. In the case of the ConversionService types, the\n    easiest way to do this is to create Default* subtypes. This also\n    follows convention with the rest of the framework.\n\nMinor updates to util classes\n\n    All in service of changes above. See diffs for self-explanatory\n    details.\n\n    * BeanUtils\n    * ObjectUtils\n    * ReflectionUtils\n",
					"commitDate": "2011-02-08, 6:42 AM",
					"commitName": "b4fea47d5cff9f3c85e62c233c2fe86b1d616592",
					"commitAuthor": "Chris Beams",
					"commitDateOld": "2011-01-03, 1:04 AM",
					"commitNameOld": "b3ff9be78f62ff1d13ab874a4772f8fc6d189eb4",
					"commitAuthorOld": "Chris Beams",
					"daysBetweenCommits": 36.23,
					"commitsBetweenForRepo": 93,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,37 +1,35 @@\n-\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry, ConfigurationClassBeanDefinitionReader reader) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Populate a new configuration model by parsing each @Configuration classes\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n-\t\tConfigurationClassBeanDefinitionReader reader = new ConfigurationClassBeanDefinitionReader(\n-\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory);\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"f480333d31d8307b8c96409e7bb4f06ec0cab0ca": {
			"type": "Ybodychange",
			"commitMessage": "Merge 3.1.0 development branch into trunk\n\nBranch in question is 'env' branch from git://git.springsource.org/sandbox/cbeams.git; merged into\ngit-svn repository with:\n\n    git merge -s recursive -Xtheirs --no-commit env\n\nNo merge conflicts, but did need to\n\n    git rm spring-build\n\nprior to committing.\n\nWith this change, Spring 3.1.0 development is now happening on SVN\ntrunk. Further commits to the 3.0.x line will happen in an as-yet\nuncreated SVN branch.  3.1.0 snapshots will be available\nper the usual nightly CI build from trunk.\n",
			"commitDate": "2010-10-25, 12:48 PM",
			"commitName": "f480333d31d8307b8c96409e7bb4f06ec0cab0ca",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2010-06-07, 3:36 PM",
			"commitNameOld": "8446fd1b26719fd8ea9e8a8d8258ceec9f27b9ed",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 139.88,
			"commitsBetweenForRepo": 376,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,37 +1,37 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Populate a new configuration model by parsing each @Configuration classes\n-\t\tConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n+\t\tConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tConfigurationClassBeanDefinitionReader reader = new ConfigurationClassBeanDefinitionReader(\n \t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory);\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fbd797e50b2f1c5b0dfef944ee218d826f1a0694": {
			"type": "Ybodychange",
			"commitMessage": "RESOLVED - issue SPR-6779: imported @Configuration classes do not get enhanced and fail to satisfy scoping requirements\nrefactoring, polishing.\n\n",
			"commitDate": "2010-01-29, 3:31 PM",
			"commitName": "fbd797e50b2f1c5b0dfef944ee218d826f1a0694",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-11-06, 4:32 PM",
			"commitNameOld": "0a4463fb71e6901a943a5bafc9d1957da2229333",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 83.96,
			"commitsBetweenForRepo": 508,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,35 +1,37 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n-\t\t\tif (checkConfigurationClassCandidate(beanDef)) {\n+\t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Populate a new configuration model by parsing each @Configuration classes\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n-\t\tnew ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor).loadBeanDefinitions(parser.getConfigurationClasses());\n+\t\tConfigurationClassBeanDefinitionReader reader =\n+\t\t\tnew ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory);\n+\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0a4463fb71e6901a943a5bafc9d1957da2229333": {
			"type": "Ybodychange",
			"commitMessage": "SPR-6158: Initial implementation and tests for @ImportXml\n\n",
			"commitDate": "2009-11-06, 4:32 PM",
			"commitName": "0a4463fb71e6901a943a5bafc9d1957da2229333",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-09-24, 3:45 AM",
			"commitNameOld": "b8c1130eec0732091426908a90db66e4eddeb25c",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 43.57,
			"commitsBetweenForRepo": 294,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,35 +1,35 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (checkConfigurationClassCandidate(beanDef)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Populate a new configuration model by parsing each @Configuration classes\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n-\t\tnew ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor).loadBeanDefinitions(parser.getModel());\n+\t\tnew ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor).loadBeanDefinitions(parser.getConfigurationClasses());\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cce6e2f4cdfed4233805a32fb82626fa5e901cc0": {
			"type": "Ybodychange",
			"commitMessage": "added SourceExtractor support\n",
			"commitDate": "2009-05-12, 3:27 PM",
			"commitName": "cce6e2f4cdfed4233805a32fb82626fa5e901cc0",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-05-12, 9:13 AM",
			"commitNameOld": "12d6aa232ab6066e885093e4a70a8386fdf9902d",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 0.26,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,35 +1,35 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (checkConfigurationClassCandidate(beanDef)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Populate a new configuration model by parsing each @Configuration classes\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n-\t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n+\t\tnew ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor).loadBeanDefinitions(parser.getModel());\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a6124793fc44779b569fbbba6fd4ec8804b56558": {
			"type": "Ymodifierchange",
			"commitMessage": "polishing\n",
			"commitDate": "2009-05-05, 2:36 AM",
			"commitName": "a6124793fc44779b569fbbba6fd4ec8804b56558",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-04-26, 4:41 AM",
			"commitNameOld": "cea8f7f69e8939d4d20073862890f0b1c1824499",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 8.91,
			"commitsBetweenForRepo": 27,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,35 +1,35 @@\n-\tprotected void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (checkConfigurationClassCandidate(beanDef)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Populate a new configuration model by parsing each @Configuration classes\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[protected]",
				"newValue": "[public]"
			}
		},
		"cea8f7f69e8939d4d20073862890f0b1c1824499": {
			"type": "Ymodifierchange",
			"commitMessage": "custom stereotype annotations can be meta-annotated with @Service, @Controller etc as well; @Scope and @Transactional are now supported as meta-annotations on custom annotations\n",
			"commitDate": "2009-04-26, 4:41 AM",
			"commitName": "cea8f7f69e8939d4d20073862890f0b1c1824499",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-04-24, 4:16 AM",
			"commitNameOld": "b5d21108da24f8344be3bc708c7afdfca9a1d089",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 2.02,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,35 +1,35 @@\n-\tprotected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+\tprotected void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (checkConfigurationClassCandidate(beanDef)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Populate a new configuration model by parsing each @Configuration classes\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[protected, final]",
				"newValue": "[protected]"
			}
		},
		"b5d21108da24f8344be3bc708c7afdfca9a1d089": {
			"type": "Ybodychange",
			"commitMessage": "@Configuration parsing fully relies on Spring's MetadataReader abstraction now\n",
			"commitDate": "2009-04-24, 4:16 AM",
			"commitName": "b5d21108da24f8344be3bc708c7afdfca9a1d089",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-04-22, 3:46 AM",
			"commitNameOld": "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 2.02,
			"commitsBetweenForRepo": 15,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,30 +1,35 @@\n \tprotected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n-\t\tSet<BeanDefinitionHolder> configBeanDefs = new LinkedHashSet<BeanDefinitionHolder>();\n+\t\tSet<BeanDefinitionHolder> configCandidates = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n-\t\t\tif (checkConfigurationClassBeanDefinition(beanDef)) {\n-\t\t\t\tconfigBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n+\t\t\tif (checkConfigurationClassCandidate(beanDef)) {\n+\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n-\t\tif (configBeanDefs.isEmpty()) {\n+\t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Populate a new configuration model by parsing each @Configuration classes\n \t\tConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n-\t\tfor (BeanDefinitionHolder holder : configBeanDefs) {\n-\t\t\tString beanClassName = holder.getBeanDefinition().getBeanClassName();\n+\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n+\t\t\tBeanDefinition bd = holder.getBeanDefinition();\n \t\t\ttry {\n-\t\t\t\tparser.parse(beanClassName, holder.getBeanName());\n+\t\t\t\tif (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {\n+\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n+\t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n-\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class [\" + beanClassName + \"]\", ex);\n+\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ea9d8925a27e80d31d924826cf54f70b2bbcc638": {
			"type": "Ybodychange",
			"commitMessage": "next cut of JavaConfig metadata reading revision: using cached MetadataReaders\n",
			"commitDate": "2009-04-22, 3:46 AM",
			"commitName": "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-04-19, 4:45 PM",
			"commitNameOld": "14bd47551900ced88eeacf2a5f63c187ff72028c",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 2.46,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,24 +1,30 @@\n \tprotected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet<BeanDefinitionHolder> configBeanDefs = new LinkedHashSet<BeanDefinitionHolder>();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n \t\t\tif (checkConfigurationClassBeanDefinition(beanDef)) {\n \t\t\t\tconfigBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configBeanDefs.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Populate a new configuration model by parsing each @Configuration classes\n-\t\tConfigurationClassParser parser = new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n+\t\tConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n \t\tfor (BeanDefinitionHolder holder : configBeanDefs) {\n-\t\t\tparser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+\t\t\tString beanClassName = holder.getBeanDefinition().getBeanClassName();\n+\t\t\ttry {\n+\t\t\t\tparser.parse(beanClassName, holder.getBeanName());\n+\t\t\t}\n+\t\t\tcatch (IOException ex) {\n+\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class [\" + beanClassName + \"]\", ex);\n+\t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"14bd47551900ced88eeacf2a5f63c187ff72028c": {
			"type": "Ymultichange(Ymovefromfile,Yreturntypechange,Ybodychange,Yparameterchange)",
			"commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
			"commitDate": "2009-04-19, 4:45 PM",
			"commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
			"commitAuthor": "Juergen Hoeller",
			"subchanges": [
				{
					"type": "Ymovefromfile",
					"commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
					"commitDate": "2009-04-19, 4:45 PM",
					"commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
					"commitAuthor": "Juergen Hoeller",
					"commitDateOld": "2009-04-19, 3:28 PM",
					"commitNameOld": "736169aa2a46f489cd8e75cf4d61cef997fc456f",
					"commitAuthorOld": "Juergen Hoeller",
					"daysBetweenCommits": 0.05,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,24 +1,24 @@\n-\tprotected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n-\t\tBeanDefinitionRegistry configBeanDefs = getConfigurationBeanDefinitions(false);\n-\n-\t\t// return an empty registry immediately if no @Configuration classes were found\n-\t\tif(configBeanDefs.getBeanDefinitionCount() == 0)\n-\t\t\treturn configBeanDefs;\n-\n-\t\t// populate a new ConfigurationModel by parsing each @Configuration classes\n-\t\tConfigurationClassParser parser = createConfigurationParser();\n-\n-\t\tfor(String beanName : configBeanDefs.getBeanDefinitionNames()) {\n-\t\t\tBeanDefinition beanDef = configBeanDefs.getBeanDefinition(beanName);\n-\t\t\tString className = beanDef.getBeanClassName();\n-\n-\t\t\tparser.parse(className, beanName);\n+\tprotected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+\t\tSet<BeanDefinitionHolder> configBeanDefs = new LinkedHashSet<BeanDefinitionHolder>();\n+\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n+\t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n+\t\t\tif (checkConfigurationClassBeanDefinition(beanDef)) {\n+\t\t\t\tconfigBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n+\t\t\t}\n \t\t}\n \n-\t\tConfigurationModel configModel = parser.getConfigurationModel();\n+\t\t// Return immediately if no @Configuration classes were found\n+\t\tif (configBeanDefs.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n \n-\t\tconfigModel.validate(problemReporter);\n+\t\t// Populate a new configuration model by parsing each @Configuration classes\n+\t\tConfigurationClassParser parser = new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n+\t\tfor (BeanDefinitionHolder holder : configBeanDefs) {\n+\t\t\tparser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+\t\t}\n+\t\tparser.validate();\n \n-\t\t// read the model and create bean definitions based on its content\n-\t\treturn new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n+\t\t// Read the model and create bean definitions based on its content\n+\t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/AbstractConfigurationClassProcessor.java",
						"newPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
						"oldMethodName": "processConfigBeanDefinitions",
						"newMethodName": "processConfigBeanDefinitions"
					}
				},
				{
					"type": "Yreturntypechange",
					"commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
					"commitDate": "2009-04-19, 4:45 PM",
					"commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
					"commitAuthor": "Juergen Hoeller",
					"commitDateOld": "2009-04-19, 3:28 PM",
					"commitNameOld": "736169aa2a46f489cd8e75cf4d61cef997fc456f",
					"commitAuthorOld": "Juergen Hoeller",
					"daysBetweenCommits": 0.05,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,24 +1,24 @@\n-\tprotected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n-\t\tBeanDefinitionRegistry configBeanDefs = getConfigurationBeanDefinitions(false);\n-\n-\t\t// return an empty registry immediately if no @Configuration classes were found\n-\t\tif(configBeanDefs.getBeanDefinitionCount() == 0)\n-\t\t\treturn configBeanDefs;\n-\n-\t\t// populate a new ConfigurationModel by parsing each @Configuration classes\n-\t\tConfigurationClassParser parser = createConfigurationParser();\n-\n-\t\tfor(String beanName : configBeanDefs.getBeanDefinitionNames()) {\n-\t\t\tBeanDefinition beanDef = configBeanDefs.getBeanDefinition(beanName);\n-\t\t\tString className = beanDef.getBeanClassName();\n-\n-\t\t\tparser.parse(className, beanName);\n+\tprotected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+\t\tSet<BeanDefinitionHolder> configBeanDefs = new LinkedHashSet<BeanDefinitionHolder>();\n+\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n+\t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n+\t\t\tif (checkConfigurationClassBeanDefinition(beanDef)) {\n+\t\t\t\tconfigBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n+\t\t\t}\n \t\t}\n \n-\t\tConfigurationModel configModel = parser.getConfigurationModel();\n+\t\t// Return immediately if no @Configuration classes were found\n+\t\tif (configBeanDefs.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n \n-\t\tconfigModel.validate(problemReporter);\n+\t\t// Populate a new configuration model by parsing each @Configuration classes\n+\t\tConfigurationClassParser parser = new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n+\t\tfor (BeanDefinitionHolder holder : configBeanDefs) {\n+\t\t\tparser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+\t\t}\n+\t\tparser.validate();\n \n-\t\t// read the model and create bean definitions based on its content\n-\t\treturn new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n+\t\t// Read the model and create bean definitions based on its content\n+\t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "BeanDefinitionRegistry",
						"newValue": "void"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
					"commitDate": "2009-04-19, 4:45 PM",
					"commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
					"commitAuthor": "Juergen Hoeller",
					"commitDateOld": "2009-04-19, 3:28 PM",
					"commitNameOld": "736169aa2a46f489cd8e75cf4d61cef997fc456f",
					"commitAuthorOld": "Juergen Hoeller",
					"daysBetweenCommits": 0.05,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,24 +1,24 @@\n-\tprotected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n-\t\tBeanDefinitionRegistry configBeanDefs = getConfigurationBeanDefinitions(false);\n-\n-\t\t// return an empty registry immediately if no @Configuration classes were found\n-\t\tif(configBeanDefs.getBeanDefinitionCount() == 0)\n-\t\t\treturn configBeanDefs;\n-\n-\t\t// populate a new ConfigurationModel by parsing each @Configuration classes\n-\t\tConfigurationClassParser parser = createConfigurationParser();\n-\n-\t\tfor(String beanName : configBeanDefs.getBeanDefinitionNames()) {\n-\t\t\tBeanDefinition beanDef = configBeanDefs.getBeanDefinition(beanName);\n-\t\t\tString className = beanDef.getBeanClassName();\n-\n-\t\t\tparser.parse(className, beanName);\n+\tprotected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+\t\tSet<BeanDefinitionHolder> configBeanDefs = new LinkedHashSet<BeanDefinitionHolder>();\n+\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n+\t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n+\t\t\tif (checkConfigurationClassBeanDefinition(beanDef)) {\n+\t\t\t\tconfigBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n+\t\t\t}\n \t\t}\n \n-\t\tConfigurationModel configModel = parser.getConfigurationModel();\n+\t\t// Return immediately if no @Configuration classes were found\n+\t\tif (configBeanDefs.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n \n-\t\tconfigModel.validate(problemReporter);\n+\t\t// Populate a new configuration model by parsing each @Configuration classes\n+\t\tConfigurationClassParser parser = new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n+\t\tfor (BeanDefinitionHolder holder : configBeanDefs) {\n+\t\t\tparser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+\t\t}\n+\t\tparser.validate();\n \n-\t\t// read the model and create bean definitions based on its content\n-\t\treturn new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n+\t\t// Read the model and create bean definitions based on its content\n+\t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				},
				{
					"type": "Yparameterchange",
					"commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
					"commitDate": "2009-04-19, 4:45 PM",
					"commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
					"commitAuthor": "Juergen Hoeller",
					"commitDateOld": "2009-04-19, 3:28 PM",
					"commitNameOld": "736169aa2a46f489cd8e75cf4d61cef997fc456f",
					"commitAuthorOld": "Juergen Hoeller",
					"daysBetweenCommits": 0.05,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,24 +1,24 @@\n-\tprotected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n-\t\tBeanDefinitionRegistry configBeanDefs = getConfigurationBeanDefinitions(false);\n-\n-\t\t// return an empty registry immediately if no @Configuration classes were found\n-\t\tif(configBeanDefs.getBeanDefinitionCount() == 0)\n-\t\t\treturn configBeanDefs;\n-\n-\t\t// populate a new ConfigurationModel by parsing each @Configuration classes\n-\t\tConfigurationClassParser parser = createConfigurationParser();\n-\n-\t\tfor(String beanName : configBeanDefs.getBeanDefinitionNames()) {\n-\t\t\tBeanDefinition beanDef = configBeanDefs.getBeanDefinition(beanName);\n-\t\t\tString className = beanDef.getBeanClassName();\n-\n-\t\t\tparser.parse(className, beanName);\n+\tprotected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+\t\tSet<BeanDefinitionHolder> configBeanDefs = new LinkedHashSet<BeanDefinitionHolder>();\n+\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n+\t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n+\t\t\tif (checkConfigurationClassBeanDefinition(beanDef)) {\n+\t\t\t\tconfigBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n+\t\t\t}\n \t\t}\n \n-\t\tConfigurationModel configModel = parser.getConfigurationModel();\n+\t\t// Return immediately if no @Configuration classes were found\n+\t\tif (configBeanDefs.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n \n-\t\tconfigModel.validate(problemReporter);\n+\t\t// Populate a new configuration model by parsing each @Configuration classes\n+\t\tConfigurationClassParser parser = new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n+\t\tfor (BeanDefinitionHolder holder : configBeanDefs) {\n+\t\t\tparser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+\t\t}\n+\t\tparser.validate();\n \n-\t\t// read the model and create bean definitions based on its content\n-\t\treturn new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n+\t\t// Read the model and create bean definitions based on its content\n+\t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[]",
						"newValue": "[registry-BeanDefinitionRegistry]"
					}
				}
			]
		},
		"cc713ad5241a90bc66b96364b91e5439f1ae6cb6": {
			"type": "Ybodychange",
			"commitMessage": "RESOLVED - issue SPR-5600: Make naming of @Configuration class processing-related artifacts consistent\n",
			"commitDate": "2009-03-30, 8:26 AM",
			"commitName": "cc713ad5241a90bc66b96364b91e5439f1ae6cb6",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-03-26, 9:57 PM",
			"commitNameOld": "1697932c57af5389fe07971e91866980e966403f",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 3.44,
			"commitsBetweenForRepo": 29,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,24 +1,24 @@\n \tprotected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n \t\tBeanDefinitionRegistry configBeanDefs = getConfigurationBeanDefinitions(false);\n \n \t\t// return an empty registry immediately if no @Configuration classes were found\n \t\tif(configBeanDefs.getBeanDefinitionCount() == 0)\n \t\t\treturn configBeanDefs;\n \n \t\t// populate a new ConfigurationModel by parsing each @Configuration classes\n-\t\tConfigurationParser parser = createConfigurationParser();\n+\t\tConfigurationClassParser parser = createConfigurationParser();\n \n \t\tfor(String beanName : configBeanDefs.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = configBeanDefs.getBeanDefinition(beanName);\n \t\t\tString className = beanDef.getBeanClassName();\n \n \t\t\tparser.parse(className, beanName);\n \t\t}\n \n \t\tConfigurationModel configModel = parser.getConfigurationModel();\n \n \t\tconfigModel.validate(problemReporter);\n \n \t\t// read the model and create bean definitions based on its content\n \t\treturn new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1697932c57af5389fe07971e91866980e966403f": {
			"type": "Yfilerename",
			"commitMessage": "consolidated context.annotation.support -> context.annotation\n\n",
			"commitDate": "2009-03-26, 9:57 PM",
			"commitName": "1697932c57af5389fe07971e91866980e966403f",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-03-26, 8:10 PM",
			"commitNameOld": "2c0c523d7099ed1ad77864242f25d30e218b2a95",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0.07,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/support/AbstractConfigurationClassProcessor.java",
				"newPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/AbstractConfigurationClassProcessor.java"
			}
		},
		"cd50e456457ecac48f61e2da991b6fd5dc0c6ee7": {
			"type": "Yfilerename",
			"commitMessage": "+ Moving .config.java module -> .context\n\n",
			"commitDate": "2009-03-22, 9:48 PM",
			"commitName": "cd50e456457ecac48f61e2da991b6fd5dc0c6ee7",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-03-22, 9:25 PM",
			"commitNameOld": "63b5c48461f69cc611f4378d52f46197998334db",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "org.springframework.config.java/src/main/java/org/springframework/context/annotation/support/AbstractConfigurationClassProcessor.java",
				"newPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/support/AbstractConfigurationClassProcessor.java"
			}
		},
		"ef02c61e581dcd1f3cf110608da72ed133777d62": {
			"type": "Yfilerename",
			"commitMessage": "+ Repackaged src and test from .config.java.* -> .context.annotation.*\n\n",
			"commitDate": "2009-03-22, 9:23 PM",
			"commitName": "ef02c61e581dcd1f3cf110608da72ed133777d62",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-03-22, 9:14 PM",
			"commitNameOld": "3f196517f99b7a7148e68531d1fa1b475ff81939",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/AbstractConfigurationClassProcessor.java",
				"newPath": "org.springframework.config.java/src/main/java/org/springframework/context/annotation/support/AbstractConfigurationClassProcessor.java"
			}
		},
		"b8f712621d56b2d862338a34d52839583dc1a80a": {
			"type": "Ybodychange",
			"commitMessage": "+ Added isCglibClassName() to AopUtils for checking bean class names before classloading\n+ Added tests for @Aspect support in @Configuration classes\n+ Added tests for @Inherited @Configuration behavior\n\n",
			"commitDate": "2009-03-22, 8:59 PM",
			"commitName": "b8f712621d56b2d862338a34d52839583dc1a80a",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-03-07, 1:41 PM",
			"commitNameOld": "dc191bec2dfceb7ee052ac238c84eb564d27e1ee",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 15.26,
			"commitsBetweenForRepo": 27,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,25 +1,24 @@\n \tprotected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n \t\tBeanDefinitionRegistry configBeanDefs = getConfigurationBeanDefinitions(false);\n \n \t\t// return an empty registry immediately if no @Configuration classes were found\n \t\tif(configBeanDefs.getBeanDefinitionCount() == 0)\n \t\t\treturn configBeanDefs;\n \n \t\t// populate a new ConfigurationModel by parsing each @Configuration classes\n \t\tConfigurationParser parser = createConfigurationParser();\n \n \t\tfor(String beanName : configBeanDefs.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef = configBeanDefs.getBeanDefinition(beanName);\n \t\t\tString className = beanDef.getBeanClassName();\n \n \t\t\tparser.parse(className, beanName);\n \t\t}\n \n \t\tConfigurationModel configModel = parser.getConfigurationModel();\n \n-\t\t// validate the ConfigurationModel\n-\t\tvalidateModel(configModel);\n+\t\tconfigModel.validate(problemReporter);\n \n \t\t// read the model and create bean definitions based on its content\n \t\treturn new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2e7e98248724f5f4fc054617765053e7d7b978cd": {
			"type": "Ymultichange(Ymodifierchange,Ybodychange)",
			"commitMessage": "+ Renamed Scopes -> StandardScopes\n+ Renamed ConfigurationPostProcessor -> ConfigurationClassPostProcessor\n+ JavaDoc and polish for AbstractConfigurationClassProcessor\n\n",
			"commitDate": "2009-03-05, 10:55 PM",
			"commitName": "2e7e98248724f5f4fc054617765053e7d7b978cd",
			"commitAuthor": "Chris Beams",
			"subchanges": [
				{
					"type": "Ymodifierchange",
					"commitMessage": "+ Renamed Scopes -> StandardScopes\n+ Renamed ConfigurationPostProcessor -> ConfigurationClassPostProcessor\n+ JavaDoc and polish for AbstractConfigurationClassProcessor\n\n",
					"commitDate": "2009-03-05, 10:55 PM",
					"commitName": "2e7e98248724f5f4fc054617765053e7d7b978cd",
					"commitAuthor": "Chris Beams",
					"commitDateOld": "2009-03-05, 7:12 PM",
					"commitNameOld": "b985011b24cb40671ad6d2b8cc34fbea763ed7a4",
					"commitAuthorOld": "Chris Beams",
					"daysBetweenCommits": 0.15,
					"commitsBetweenForRepo": 2,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,12 +1,25 @@\n-\tprotected BeanDefinitionRegistry processConfigBeanDefinitions() {\n+\tprotected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n \t\tBeanDefinitionRegistry configBeanDefs = getConfigurationBeanDefinitions(false);\n \t\t\n+\t\t// return an empty registry immediately if no @Configuration classes were found\n \t\tif(configBeanDefs.getBeanDefinitionCount() == 0)\n-\t\t\treturn configBeanDefs; // nothing to do - don't waste any more cycles\n+\t\t\treturn configBeanDefs;\n \t\t\n-\t\tConfigurationModel configModel = createConfigurationModelFor(configBeanDefs);\n+\t\t// populate a new ConfigurationModel by parsing each @Configuration classes\n+\t\tConfigurationParser parser = createConfigurationParser();\n+        \n+        for(String beanName : configBeanDefs.getBeanDefinitionNames()) {\n+        \tBeanDefinition beanDef = configBeanDefs.getBeanDefinition(beanName);\n+        \tString className = beanDef.getBeanClassName();\n+        \t\n+        \tparser.parse(className, beanName);\n+        }\n \t\t\n+\t\tConfigurationModel configModel = parser.getConfigurationModel();\n+\t\t\n+\t\t// validate the ConfigurationModel\n \t\tvalidateModel(configModel);\n \t\t\n-\t\treturn renderModelAsBeanDefinitions(configModel);\n-\t}\n\\ No newline at end of file\n+\t\t// read the model and create bean definitions based on its content\n+\t    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n+    }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[protected]",
						"newValue": "[protected, final]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "+ Renamed Scopes -> StandardScopes\n+ Renamed ConfigurationPostProcessor -> ConfigurationClassPostProcessor\n+ JavaDoc and polish for AbstractConfigurationClassProcessor\n\n",
					"commitDate": "2009-03-05, 10:55 PM",
					"commitName": "2e7e98248724f5f4fc054617765053e7d7b978cd",
					"commitAuthor": "Chris Beams",
					"commitDateOld": "2009-03-05, 7:12 PM",
					"commitNameOld": "b985011b24cb40671ad6d2b8cc34fbea763ed7a4",
					"commitAuthorOld": "Chris Beams",
					"daysBetweenCommits": 0.15,
					"commitsBetweenForRepo": 2,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,12 +1,25 @@\n-\tprotected BeanDefinitionRegistry processConfigBeanDefinitions() {\n+\tprotected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n \t\tBeanDefinitionRegistry configBeanDefs = getConfigurationBeanDefinitions(false);\n \t\t\n+\t\t// return an empty registry immediately if no @Configuration classes were found\n \t\tif(configBeanDefs.getBeanDefinitionCount() == 0)\n-\t\t\treturn configBeanDefs; // nothing to do - don't waste any more cycles\n+\t\t\treturn configBeanDefs;\n \t\t\n-\t\tConfigurationModel configModel = createConfigurationModelFor(configBeanDefs);\n+\t\t// populate a new ConfigurationModel by parsing each @Configuration classes\n+\t\tConfigurationParser parser = createConfigurationParser();\n+        \n+        for(String beanName : configBeanDefs.getBeanDefinitionNames()) {\n+        \tBeanDefinition beanDef = configBeanDefs.getBeanDefinition(beanName);\n+        \tString className = beanDef.getBeanClassName();\n+        \t\n+        \tparser.parse(className, beanName);\n+        }\n \t\t\n+\t\tConfigurationModel configModel = parser.getConfigurationModel();\n+\t\t\n+\t\t// validate the ConfigurationModel\n \t\tvalidateModel(configModel);\n \t\t\n-\t\treturn renderModelAsBeanDefinitions(configModel);\n-\t}\n\\ No newline at end of file\n+\t\t// read the model and create bean definitions based on its content\n+\t    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n+    }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"b985011b24cb40671ad6d2b8cc34fbea763ed7a4": {
			"type": "Ybodychange",
			"commitMessage": "+ Fleshed out, documented, tested and polished the ConfigurationPostProcessor implementation\n+ Removed @FactoryMethod indirection and extension point in favor of direct processing of @Bean annotations\n\n",
			"commitDate": "2009-03-05, 7:12 PM",
			"commitName": "b985011b24cb40671ad6d2b8cc34fbea763ed7a4",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-03-05, 4:38 PM",
			"commitNameOld": "43b2a40343be4d4a2ad12cf4dbdc0a76ddeaedbf",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0.11,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,20 +1,12 @@\n \tprotected BeanDefinitionRegistry processConfigBeanDefinitions() {\n \t\tBeanDefinitionRegistry configBeanDefs = getConfigurationBeanDefinitions(false);\n \t\t\n \t\tif(configBeanDefs.getBeanDefinitionCount() == 0)\n \t\t\treturn configBeanDefs; // nothing to do - don't waste any more cycles\n \t\t\n-\t\t// TODO: the location of this cglib check is temporary, pending removal of the\n-\t\t// @FactoryMethod meta-annotation indirection\n-\t\tif(Package.getPackage(CGLIB_PACKAGE) == null)\n-\t\t\tthrow new RuntimeException(\"CGLIB is required to process @Configuration classes. \" +\n-\t\t\t\t\t\"Either add CGLIB v2.2.3 to the classpath or remove the following \" +\n-\t\t\t\t\t\"@Configuration bean definitions: [\"\n-\t\t\t\t\t+ arrayToCommaDelimitedString(configBeanDefs.getBeanDefinitionNames()) + \"]\");\n-\t\t\n \t\tConfigurationModel configModel = createConfigurationModelFor(configBeanDefs);\n \t\t\n \t\tvalidateModel(configModel);\n \t\t\n \t\treturn renderModelAsBeanDefinitions(configModel);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"43b2a40343be4d4a2ad12cf4dbdc0a76ddeaedbf": {
			"type": "Ybodychange",
			"commitMessage": "Initial work to ensure CGLIB classes are not eagerly loaded (CGLIB should only be required if Spring users wish to process @Configuration classes)\n",
			"commitDate": "2009-03-05, 4:38 PM",
			"commitName": "43b2a40343be4d4a2ad12cf4dbdc0a76ddeaedbf",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-03-05, 12:08 PM",
			"commitNameOld": "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0.19,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,12 +1,20 @@\n \tprotected BeanDefinitionRegistry processConfigBeanDefinitions() {\n \t\tBeanDefinitionRegistry configBeanDefs = getConfigurationBeanDefinitions(false);\n \t\t\n \t\tif(configBeanDefs.getBeanDefinitionCount() == 0)\n \t\t\treturn configBeanDefs; // nothing to do - don't waste any more cycles\n \t\t\n+\t\t// TODO: the location of this cglib check is temporary, pending removal of the\n+\t\t// @FactoryMethod meta-annotation indirection\n+\t\tif(Package.getPackage(CGLIB_PACKAGE) == null)\n+\t\t\tthrow new RuntimeException(\"CGLIB is required to process @Configuration classes. \" +\n+\t\t\t\t\t\"Either add CGLIB v2.2.3 to the classpath or remove the following \" +\n+\t\t\t\t\t\"@Configuration bean definitions: [\"\n+\t\t\t\t\t+ arrayToCommaDelimitedString(configBeanDefs.getBeanDefinitionNames()) + \"]\");\n+\t\t\n \t\tConfigurationModel configModel = createConfigurationModelFor(configBeanDefs);\n \t\t\n \t\tvalidateModel(configModel);\n \t\t\n \t\treturn renderModelAsBeanDefinitions(configModel);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39": {
			"type": "Yintroduced",
			"commitMessage": "+ Adding POC tooling integration points, namely AbstractConfigurationPostProcessor and allowing for tooling-specified ClassLoader for use with ASM parsing\n+ Eliminated ModelMethod in favor of BeanMethod throughout\n\n\n",
			"commitDate": "2009-03-05, 12:08 PM",
			"commitName": "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39",
			"commitAuthor": "Chris Beams",
			"diff": "@@ -0,0 +1,12 @@\n+\tprotected BeanDefinitionRegistry processConfigBeanDefinitions() {\n+\t\tBeanDefinitionRegistry configBeanDefs = getConfigurationBeanDefinitions(false);\n+\t\t\n+\t\tif(configBeanDefs.getBeanDefinitionCount() == 0)\n+\t\t\treturn configBeanDefs; // nothing to do - don't waste any more cycles\n+\t\t\n+\t\tConfigurationModel configModel = createConfigurationModelFor(configBeanDefs);\n+\t\t\n+\t\tvalidateModel(configModel);\n+\t\t\n+\t\treturn renderModelAsBeanDefinitions(configModel);\n+\t}\n\\ No newline at end of file\n"
		}
	},
	"sha": "b325c74216fd9564a36602158fa1269e2e832874"
}