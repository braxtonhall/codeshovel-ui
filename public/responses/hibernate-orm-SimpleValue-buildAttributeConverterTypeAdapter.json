{
	"repo": "https://github.com/hibernate/hibernate-orm.git",
	"file": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
	"method": {
		"longName": "SimpleValue::buildAttributeConverterTypeAdapter()",
		"startLine": 565,
		"methodName": "buildAttributeConverterTypeAdapter",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "private"
	},
	"history": {
		"c14180ea5b16b69cdd06eb5bb159f7da1ff4db54": {
			"type": "Ybodychange",
			"commitMessage": "HHH-12410 - Cannot use AttributeConverter with spatial types\nHHH-12443 - Introduce TypeConfiguration\n",
			"commitDate": "2018-03-29, 10:16 PM",
			"commitName": "c14180ea5b16b69cdd06eb5bb159f7da1ff4db54",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2018-03-28, 4:43 PM",
			"commitNameOld": "0d82dc7c8387a954edfa971af99c16a66e33c65a",
			"commitAuthorOld": "Andrea Boriero",
			"daysBetweenCommits": 1.23,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,92 +1,96 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal JpaAttributeConverter jpaAttributeConverter = attributeConverterDescriptor.createJpaAttributeConverter(\n \t\t\t\tnew JpaAttributeConverterCreationContext() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n \t\t\t\t\t\treturn getMetadata()\n \t\t\t\t\t\t\t\t.getMetadataBuildingOptions()\n \t\t\t\t\t\t\t\t.getServiceRegistry()\n \t\t\t\t\t\t\t\t.getService( ManagedBeanRegistry.class );\n \t\t\t\t\t}\n \n \t\t\t\t\t@Override\n-\t\t\t\t\tpublic JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n+\t\t\t\t\tpublic org.hibernate.type.descriptor.java.spi.JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n \t\t\t\t\t\treturn metadata.getTypeConfiguration().getJavaTypeDescriptorRegistry();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t);\n \n-\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor = jpaAttributeConverter.getDomainJavaTypeDescriptor();\n+\t\tfinal BasicJavaDescriptor entityAttributeJavaTypeDescriptor = jpaAttributeConverter.getDomainJavaTypeDescriptor();\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter's declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n-\t\tint jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType() );\n+\t\tfinal SqlTypeDescriptor recommendedSqlType = jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJdbcRecommendedSqlType(\n+\t\t\t\t// todo (6.0) : handle the other JdbcRecommendedSqlTypeMappingContext methods\n+\t\t\t\tmetadata::getTypeConfiguration\n+\t\t);\n+\t\tint jdbcTypeCode = recommendedSqlType.getSqlType();\n \t\tif ( isLob() ) {\n \t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n \t\t\t\tjdbcTypeCode = LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaTypeDescriptor.getJavaType() ) ) {\n \t\t\t\t\tjdbcTypeCode = Types.BLOB;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tString.format(\n \t\t\t\t\t\t\t\t\tLocale.ROOT,\n \t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n \t\t\t\t\t\t\t\t\tjdbcTypeCode,\n \t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n \t\t\t\t\t\t\t)\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( isNationalized() ) {\n \t\t\tjdbcTypeCode = NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n \t\t}\n \n \t\t// find the standard SqlTypeDescriptor for that JDBC type code (allow itr to be remapped if needed!)\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor = getMetadata()\n \t\t\t\t.getMetadataBuildingOptions()\n \t\t\t\t.getServiceRegistry()\n \t\t\t\t.getService( JdbcServices.class )\n \t\t\t\t.getJdbcEnvironment()\n \t\t\t\t.getDialect()\n \t\t\t\t.remapSqlTypeDescriptor(\n \t\t\t\t\t\tmetadata.getTypeConfiguration()\n \t\t\t\t\t\t\t\t.getSqlTypeDescriptorRegistry()\n \t\t\t\t\t\t\t\t.getDescriptor( jdbcTypeCode ) );\n \n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tjpaAttributeConverter,\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor()\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n \t\tfinal String name = AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n \t\tfinal String description = String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter<%s,%s>\",\n \t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(),\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n \t\t\t\tdescription,\n \t\t\t\tjpaAttributeConverter,\n \t\t\t\tsqlTypeDescriptorAdapter,\n \t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(),\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(),\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0d82dc7c8387a954edfa971af99c16a66e33c65a": {
			"type": "Ybodychange",
			"commitMessage": "HHH-12444 - Introduce BootstrapContext\nHHH-12443 - Introduce TypeConfiguration\n",
			"commitDate": "2018-03-28, 4:43 PM",
			"commitName": "0d82dc7c8387a954edfa971af99c16a66e33c65a",
			"commitAuthor": "Andrea Boriero",
			"commitDateOld": "2018-03-28, 4:43 PM",
			"commitNameOld": "11462e786007f65f3cf9c2539e5b8259b05feaf3",
			"commitAuthorOld": "Andrea Boriero",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,89 +1,92 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal JpaAttributeConverter jpaAttributeConverter = attributeConverterDescriptor.createJpaAttributeConverter(\n \t\t\t\tnew JpaAttributeConverterCreationContext() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n \t\t\t\t\t\treturn getMetadata()\n \t\t\t\t\t\t\t\t.getMetadataBuildingOptions()\n \t\t\t\t\t\t\t\t.getServiceRegistry()\n \t\t\t\t\t\t\t\t.getService( ManagedBeanRegistry.class );\n \t\t\t\t\t}\n \n \t\t\t\t\t@Override\n \t\t\t\t\tpublic JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n-\t\t\t\t\t\treturn JavaTypeDescriptorRegistry.INSTANCE;\n+\t\t\t\t\t\treturn metadata.getTypeConfiguration().getJavaTypeDescriptorRegistry();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t);\n \n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor = jpaAttributeConverter.getDomainJavaTypeDescriptor();\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter's declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tint jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType() );\n \t\tif ( isLob() ) {\n \t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n \t\t\t\tjdbcTypeCode = LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaTypeDescriptor.getJavaType() ) ) {\n \t\t\t\t\tjdbcTypeCode = Types.BLOB;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tString.format(\n \t\t\t\t\t\t\t\t\tLocale.ROOT,\n \t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n \t\t\t\t\t\t\t\t\tjdbcTypeCode,\n \t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n \t\t\t\t\t\t\t)\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( isNationalized() ) {\n \t\t\tjdbcTypeCode = NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n \t\t}\n \n \t\t// find the standard SqlTypeDescriptor for that JDBC type code (allow itr to be remapped if needed!)\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor = getMetadata()\n \t\t\t\t.getMetadataBuildingOptions()\n \t\t\t\t.getServiceRegistry()\n \t\t\t\t.getService( JdbcServices.class )\n \t\t\t\t.getJdbcEnvironment()\n \t\t\t\t.getDialect()\n-\t\t\t\t.remapSqlTypeDescriptor( SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode ) );\n+\t\t\t\t.remapSqlTypeDescriptor(\n+\t\t\t\t\t\tmetadata.getTypeConfiguration()\n+\t\t\t\t\t\t\t\t.getSqlTypeDescriptorRegistry()\n+\t\t\t\t\t\t\t\t.getDescriptor( jdbcTypeCode ) );\n \n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tjpaAttributeConverter,\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor()\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n \t\tfinal String name = AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n \t\tfinal String description = String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter<%s,%s>\",\n \t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(),\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n \t\t\t\tdescription,\n \t\t\t\tjpaAttributeConverter,\n \t\t\t\tsqlTypeDescriptorAdapter,\n \t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(),\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(),\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9229514ed407b1610a52ab7ba97806c435352ad2": {
			"type": "Ybodychange",
			"commitMessage": "HHH-12444 - Introduce BootstrapContext\nHHH-12443 - Introduce TypeConfiguration\n",
			"commitDate": "2018-03-28, 4:43 PM",
			"commitName": "9229514ed407b1610a52ab7ba97806c435352ad2",
			"commitAuthor": "Andrea Boriero",
			"commitDateOld": "2018-03-28, 4:43 PM",
			"commitNameOld": "8f889e95d76f47945c9ec072fd08cb045767578c",
			"commitAuthorOld": "Andrea Boriero",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,91 +1,89 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal JpaAttributeConverter jpaAttributeConverter = attributeConverterDescriptor.createJpaAttributeConverter(\n \t\t\t\tnew JpaAttributeConverterCreationContext() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n-\t\t\t\t\t\treturn buildingContext\n-\t\t\t\t\t\t\t\t.getBootstrapContext()\n+\t\t\t\t\t\treturn getMetadata()\n \t\t\t\t\t\t\t\t.getMetadataBuildingOptions()\n \t\t\t\t\t\t\t\t.getServiceRegistry()\n \t\t\t\t\t\t\t\t.getService( ManagedBeanRegistry.class );\n \t\t\t\t\t}\n \n \t\t\t\t\t@Override\n \t\t\t\t\tpublic JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n \t\t\t\t\t\treturn JavaTypeDescriptorRegistry.INSTANCE;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t);\n \n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor = jpaAttributeConverter.getDomainJavaTypeDescriptor();\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter's declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tint jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType() );\n \t\tif ( isLob() ) {\n \t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n \t\t\t\tjdbcTypeCode = LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaTypeDescriptor.getJavaType() ) ) {\n \t\t\t\t\tjdbcTypeCode = Types.BLOB;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tString.format(\n \t\t\t\t\t\t\t\t\tLocale.ROOT,\n \t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n \t\t\t\t\t\t\t\t\tjdbcTypeCode,\n \t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n \t\t\t\t\t\t\t)\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( isNationalized() ) {\n \t\t\tjdbcTypeCode = NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n \t\t}\n \n \t\t// find the standard SqlTypeDescriptor for that JDBC type code (allow itr to be remapped if needed!)\n-\t\tfinal SqlTypeDescriptor sqlTypeDescriptor = buildingContext\n-\t\t\t\t.getBootstrapContext()\n+\t\tfinal SqlTypeDescriptor sqlTypeDescriptor = getMetadata()\n \t\t\t\t.getMetadataBuildingOptions()\n \t\t\t\t.getServiceRegistry()\n \t\t\t\t.getService( JdbcServices.class )\n \t\t\t\t.getJdbcEnvironment()\n \t\t\t\t.getDialect()\n \t\t\t\t.remapSqlTypeDescriptor( SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode ) );\n \n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tjpaAttributeConverter,\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor()\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n \t\tfinal String name = AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n \t\tfinal String description = String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter<%s,%s>\",\n \t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(),\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n \t\t\t\tdescription,\n \t\t\t\tjpaAttributeConverter,\n \t\t\t\tsqlTypeDescriptorAdapter,\n \t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(),\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(),\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8f889e95d76f47945c9ec072fd08cb045767578c": {
			"type": "Ybodychange",
			"commitMessage": "HHH-12444 - Introduce BootstrapContext\nHHH-12443 - Introduce TypeConfiguration\n",
			"commitDate": "2018-03-28, 4:43 PM",
			"commitName": "8f889e95d76f47945c9ec072fd08cb045767578c",
			"commitAuthor": "Andrea Boriero",
			"commitDateOld": "2018-03-07, 7:57 AM",
			"commitNameOld": "1e5a8d3c434c6791b89281c4ebf04ef08181fcd7",
			"commitAuthorOld": "Christian Beikov",
			"daysBetweenCommits": 21.32,
			"commitsBetweenForRepo": 90,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,86 +1,91 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal JpaAttributeConverter jpaAttributeConverter = attributeConverterDescriptor.createJpaAttributeConverter(\n \t\t\t\tnew JpaAttributeConverterCreationContext() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n-\t\t\t\t\t\treturn getMetadata().getMetadataBuildingOptions()\n+\t\t\t\t\t\treturn buildingContext\n+\t\t\t\t\t\t\t\t.getBootstrapContext()\n+\t\t\t\t\t\t\t\t.getMetadataBuildingOptions()\n \t\t\t\t\t\t\t\t.getServiceRegistry()\n \t\t\t\t\t\t\t\t.getService( ManagedBeanRegistry.class );\n \t\t\t\t\t}\n \n \t\t\t\t\t@Override\n \t\t\t\t\tpublic JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n \t\t\t\t\t\treturn JavaTypeDescriptorRegistry.INSTANCE;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t);\n \n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor = jpaAttributeConverter.getDomainJavaTypeDescriptor();\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter's declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tint jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType() );\n \t\tif ( isLob() ) {\n \t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n \t\t\t\tjdbcTypeCode = LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaTypeDescriptor.getJavaType() ) ) {\n \t\t\t\t\tjdbcTypeCode = Types.BLOB;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tString.format(\n \t\t\t\t\t\t\t\t\tLocale.ROOT,\n \t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n \t\t\t\t\t\t\t\t\tjdbcTypeCode,\n \t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n \t\t\t\t\t\t\t)\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( isNationalized() ) {\n \t\t\tjdbcTypeCode = NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n \t\t}\n \n \t\t// find the standard SqlTypeDescriptor for that JDBC type code (allow itr to be remapped if needed!)\n-\t\tfinal SqlTypeDescriptor sqlTypeDescriptor = metadata.getMetadataBuildingOptions().getServiceRegistry()\n+\t\tfinal SqlTypeDescriptor sqlTypeDescriptor = buildingContext\n+\t\t\t\t.getBootstrapContext()\n+\t\t\t\t.getMetadataBuildingOptions()\n+\t\t\t\t.getServiceRegistry()\n \t\t\t\t.getService( JdbcServices.class )\n \t\t\t\t.getJdbcEnvironment()\n \t\t\t\t.getDialect()\n \t\t\t\t.remapSqlTypeDescriptor( SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode ) );\n \n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tjpaAttributeConverter,\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor()\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n \t\tfinal String name = AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n \t\tfinal String description = String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter<%s,%s>\",\n \t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(),\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n \t\t\t\tdescription,\n \t\t\t\tjpaAttributeConverter,\n \t\t\t\tsqlTypeDescriptorAdapter,\n \t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(),\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(),\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"90cabb43ad8b186d73cb6b310fb2fd6774ffe44f": {
			"type": "Ybodychange",
			"commitMessage": "HHH-12135 - Support for AttributeConverters as CDI beans\n\ninitial work to get AttributeConverter support to be able to integrate with ManagedBeanRegistry.  There is a lot of \"infrastructure\" changes because the old code assumed we could instantiate the converter as soon as we knew the class which precludes lookup in the registry later.\n",
			"commitDate": "2017-12-15, 5:25 PM",
			"commitName": "90cabb43ad8b186d73cb6b310fb2fd6774ffe44f",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2016-09-29, 10:27 AM",
			"commitNameOld": "9aa164ed27b8338f592dee504a5793bc4e5bbfd9",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 442.33,
			"commitsBetweenForRepo": 985,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,81 +1,86 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n-\t\tfinal Class entityAttributeJavaType = attributeConverterDescriptor.getDomainType();\n-\t\tfinal Class databaseColumnJavaType = attributeConverterDescriptor.getJdbcType();\n+\t\tfinal JpaAttributeConverter jpaAttributeConverter = attributeConverterDescriptor.createJpaAttributeConverter(\n+\t\t\t\tnew JpaAttributeConverterCreationContext() {\n+\t\t\t\t\t@Override\n+\t\t\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n+\t\t\t\t\t\treturn getMetadata().getMetadataBuildingOptions()\n+\t\t\t\t\t\t\t\t.getServiceRegistry()\n+\t\t\t\t\t\t\t\t.getService( ManagedBeanRegistry.class );\n+\t\t\t\t\t}\n \n+\t\t\t\t\t@Override\n+\t\t\t\t\tpublic JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n+\t\t\t\t\t\treturn JavaTypeDescriptorRegistry.INSTANCE;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t);\n \n-\t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n-\t\t// the AttributeConverter to resolve the corresponding descriptor.\n-\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n+\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor = jpaAttributeConverter.getDomainJavaTypeDescriptor();\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter's declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n-\t\tint jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n+\t\tint jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType() );\n \t\tif ( isLob() ) {\n \t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n \t\t\t\tjdbcTypeCode = LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n \t\t\t}\n \t\t\telse {\n-\t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaType ) ) {\n+\t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaTypeDescriptor.getJavaType() ) ) {\n \t\t\t\t\tjdbcTypeCode = Types.BLOB;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tString.format(\n \t\t\t\t\t\t\t\t\tLocale.ROOT,\n \t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n \t\t\t\t\t\t\t\t\tjdbcTypeCode,\n \t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n \t\t\t\t\t\t\t)\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( isNationalized() ) {\n \t\t\tjdbcTypeCode = NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n \t\t}\n \n \t\t// find the standard SqlTypeDescriptor for that JDBC type code (allow itr to be remapped if needed!)\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor = metadata.getMetadataBuildingOptions().getServiceRegistry()\n \t\t\t\t.getService( JdbcServices.class )\n \t\t\t\t.getJdbcEnvironment()\n \t\t\t\t.getDialect()\n \t\t\t\t.remapSqlTypeDescriptor( SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode ) );\n \n-\t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n-\t\t// \t\tillustration, this should be the type descriptor for Strings\n-\t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n-\n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(\n-\t\t\t\tattributeConverterDescriptor.getAttributeConverter(),\n+\t\t\t\tjpaAttributeConverter,\n \t\t\t\tsqlTypeDescriptor,\n-\t\t\t\tintermediateJavaTypeDescriptor\n+\t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor()\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n-\t\tfinal String name = AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDescriptor.getAttributeConverter().getClass().getName();\n+\t\tfinal String name = AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n \t\tfinal String description = String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter<%s,%s>\",\n-\t\t\t\tentityAttributeJavaType.getSimpleName(),\n-\t\t\t\tdatabaseColumnJavaType.getSimpleName()\n+\t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(),\n+\t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n \t\t\t\tdescription,\n-\t\t\t\tattributeConverterDescriptor.getAttributeConverter(),\n+\t\t\t\tjpaAttributeConverter,\n \t\t\t\tsqlTypeDescriptorAdapter,\n-\t\t\t\tentityAttributeJavaType,\n-\t\t\t\tdatabaseColumnJavaType,\n+\t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(),\n+\t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(),\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9aa164ed27b8338f592dee504a5793bc4e5bbfd9": {
			"type": "Ybodychange",
			"commitMessage": "HHH-10818 - Allow AttributeConverter on attributes marked as Lob (REALLY this time)\n",
			"commitDate": "2016-09-29, 10:27 AM",
			"commitName": "9aa164ed27b8338f592dee504a5793bc4e5bbfd9",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2016-07-14, 4:16 PM",
			"commitNameOld": "c893577efceff237f84d7200e1ef1a2895c95639",
			"commitAuthorOld": "Gail Badner",
			"daysBetweenCommits": 76.76,
			"commitsBetweenForRepo": 178,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,81 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal Class entityAttributeJavaType = attributeConverterDescriptor.getDomainType();\n \t\tfinal Class databaseColumnJavaType = attributeConverterDescriptor.getJdbcType();\n \n \n \t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n \t\t// the AttributeConverter to resolve the corresponding descriptor.\n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter's declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tint jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n \t\tif ( isLob() ) {\n \t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n \t\t\t\tjdbcTypeCode = LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaType ) ) {\n \t\t\t\t\tjdbcTypeCode = Types.BLOB;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tString.format(\n \t\t\t\t\t\t\t\t\tLocale.ROOT,\n \t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n \t\t\t\t\t\t\t\t\tjdbcTypeCode,\n \t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n \t\t\t\t\t\t\t)\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( isNationalized() ) {\n \t\t\tjdbcTypeCode = NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n \t\t}\n-\t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n-\t\tfinal SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n+\n+\t\t// find the standard SqlTypeDescriptor for that JDBC type code (allow itr to be remapped if needed!)\n+\t\tfinal SqlTypeDescriptor sqlTypeDescriptor = metadata.getMetadataBuildingOptions().getServiceRegistry()\n+\t\t\t\t.getService( JdbcServices.class )\n+\t\t\t\t.getJdbcEnvironment()\n+\t\t\t\t.getDialect()\n+\t\t\t\t.remapSqlTypeDescriptor( SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode ) );\n+\n \t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n \t\t// \t\tillustration, this should be the type descriptor for Strings\n \t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n+\n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tattributeConverterDescriptor.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tintermediateJavaTypeDescriptor\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n \t\tfinal String name = AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDescriptor.getAttributeConverter().getClass().getName();\n \t\tfinal String description = String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter<%s,%s>\",\n \t\t\t\tentityAttributeJavaType.getSimpleName(),\n \t\t\t\tdatabaseColumnJavaType.getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n \t\t\t\tdescription,\n \t\t\t\tattributeConverterDescriptor.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptorAdapter,\n \t\t\t\tentityAttributeJavaType,\n \t\t\t\tdatabaseColumnJavaType,\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0cf66b85e03a997dc94f8f82598ca8edac04e889": {
			"type": "Ybodychange",
			"commitMessage": "HHH-10050 - AttributeConverter should supports ParameterizedType if autoApply is true\n",
			"commitDate": "2015-10-06, 3:07 PM",
			"commitName": "0cf66b85e03a997dc94f8f82598ca8edac04e889",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2015-10-03, 12:44 PM",
			"commitNameOld": "3ac508882c89ebd7c80af71d0e65ba26a017ebe3",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 3.1,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,74 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n-\t\tfinal Class entityAttributeJavaType = attributeConverterDefinition.getEntityAttributeType();\n-\t\tfinal Class databaseColumnJavaType = attributeConverterDefinition.getDatabaseColumnType();\n+\t\tfinal Class entityAttributeJavaType = attributeConverterDescriptor.getDomainType();\n+\t\tfinal Class databaseColumnJavaType = attributeConverterDescriptor.getJdbcType();\n \n \n \t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n \t\t// the AttributeConverter to resolve the corresponding descriptor.\n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter's declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tint jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n \t\tif ( isLob() ) {\n \t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n \t\t\t\tjdbcTypeCode = LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaType ) ) {\n \t\t\t\t\tjdbcTypeCode = Types.BLOB;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tString.format(\n \t\t\t\t\t\t\t\t\tLocale.ROOT,\n \t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n \t\t\t\t\t\t\t\t\tjdbcTypeCode,\n \t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n \t\t\t\t\t\t\t)\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( isNationalized() ) {\n \t\t\tjdbcTypeCode = NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n \t\t}\n \t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n \t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n \t\t// \t\tillustration, this should be the type descriptor for Strings\n \t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(\n-\t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n+\t\t\t\tattributeConverterDescriptor.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tintermediateJavaTypeDescriptor\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n-\t\tfinal String name = AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();\n+\t\tfinal String name = AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDescriptor.getAttributeConverter().getClass().getName();\n \t\tfinal String description = String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter<%s,%s>\",\n \t\t\t\tentityAttributeJavaType.getSimpleName(),\n \t\t\t\tdatabaseColumnJavaType.getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n \t\t\t\tdescription,\n-\t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n+\t\t\t\tattributeConverterDescriptor.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptorAdapter,\n \t\t\t\tentityAttributeJavaType,\n \t\t\t\tdatabaseColumnJavaType,\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3ac508882c89ebd7c80af71d0e65ba26a017ebe3": {
			"type": "Ybodychange",
			"commitMessage": "HHH-9615 - Allow AttributeConverter on attributes marked as Lob\n",
			"commitDate": "2015-10-03, 12:44 PM",
			"commitName": "3ac508882c89ebd7c80af71d0e65ba26a017ebe3",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2015-08-26, 1:55 PM",
			"commitNameOld": "5f5e5f82c4d3f64e799509d71acd08284e60670c",
			"commitAuthorOld": "Kamil Szymanski",
			"daysBetweenCommits": 37.95,
			"commitsBetweenForRepo": 82,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,54 +1,74 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal Class entityAttributeJavaType = attributeConverterDefinition.getEntityAttributeType();\n \t\tfinal Class databaseColumnJavaType = attributeConverterDefinition.getDatabaseColumnType();\n \n \n \t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n \t\t// the AttributeConverter to resolve the corresponding descriptor.\n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter's declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tint jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n+\t\tif ( isLob() ) {\n+\t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n+\t\t\t\tjdbcTypeCode = LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaType ) ) {\n+\t\t\t\t\tjdbcTypeCode = Types.BLOB;\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\t\tString.format(\n+\t\t\t\t\t\t\t\t\tLocale.ROOT,\n+\t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n+\t\t\t\t\t\t\t\t\tjdbcTypeCode,\n+\t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n+\t\t\t\t\t\t\t)\n+\t\t\t\t\t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t\tif ( isNationalized() ) {\n \t\t\tjdbcTypeCode = NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n \t\t}\n \t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n \t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n \t\t// \t\tillustration, this should be the type descriptor for Strings\n \t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tintermediateJavaTypeDescriptor\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n \t\tfinal String name = AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();\n \t\tfinal String description = String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter<%s,%s>\",\n \t\t\t\tentityAttributeJavaType.getSimpleName(),\n \t\t\t\tdatabaseColumnJavaType.getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n \t\t\t\tdescription,\n \t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptorAdapter,\n \t\t\t\tentityAttributeJavaType,\n \t\t\t\tdatabaseColumnJavaType,\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"38c004431d006ac5173d0c095f97415b5e6267a6": {
			"type": "Ybodychange",
			"commitMessage": "HHH-9599 - AnnotationException occurs when applying @Nationalized and @Convert annotations to the same field\n",
			"commitDate": "2015-03-20, 3:55 PM",
			"commitName": "38c004431d006ac5173d0c095f97415b5e6267a6",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2015-03-20, 10:17 AM",
			"commitNameOld": "22730624fc267cd12bf1e6551158fa3057fd8d58",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 0.23,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,51 +1,54 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal Class entityAttributeJavaType = attributeConverterDefinition.getEntityAttributeType();\n \t\tfinal Class databaseColumnJavaType = attributeConverterDefinition.getDatabaseColumnType();\n \n \n \t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n \t\t// the AttributeConverter to resolve the corresponding descriptor.\n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter's declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n-\t\tfinal int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n+\t\tint jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n+\t\tif ( isNationalized() ) {\n+\t\t\tjdbcTypeCode = NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n+\t\t}\n \t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n \t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n \t\t// \t\tillustration, this should be the type descriptor for Strings\n \t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tintermediateJavaTypeDescriptor\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n \t\tfinal String name = AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();\n \t\tfinal String description = String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter<%s,%s>\",\n \t\t\t\tentityAttributeJavaType.getSimpleName(),\n \t\t\t\tdatabaseColumnJavaType.getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n \t\t\t\tdescription,\n \t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptorAdapter,\n \t\t\t\tentityAttributeJavaType,\n \t\t\t\tdatabaseColumnJavaType,\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"22730624fc267cd12bf1e6551158fa3057fd8d58": {
			"type": "Ybodychange",
			"commitMessage": "HHH-9042 - Envers fails with @Converter and AttributeConverter\n",
			"commitDate": "2015-03-20, 10:17 AM",
			"commitName": "22730624fc267cd12bf1e6551158fa3057fd8d58",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2015-03-10, 3:53 PM",
			"commitNameOld": "9caca0ce37d5a2763d476c6fa2471addcca710ca",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 9.77,
			"commitsBetweenForRepo": 28,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,49 +1,51 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal Class entityAttributeJavaType = attributeConverterDefinition.getEntityAttributeType();\n \t\tfinal Class databaseColumnJavaType = attributeConverterDefinition.getDatabaseColumnType();\n \n \n \t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n \t\t// the AttributeConverter to resolve the corresponding descriptor.\n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter's declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tfinal int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n \t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n \t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n \t\t// \t\tillustration, this should be the type descriptor for Strings\n \t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tintermediateJavaTypeDescriptor\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n-\t\tfinal String name = String.format(\n+\t\tfinal String name = AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();\n+\t\tfinal String description = String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter<%s,%s>\",\n \t\t\t\tentityAttributeJavaType.getSimpleName(),\n \t\t\t\tdatabaseColumnJavaType.getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n+\t\t\t\tdescription,\n \t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptorAdapter,\n \t\t\t\tentityAttributeJavaType,\n \t\t\t\tdatabaseColumnJavaType,\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"498735aa3791097e0fc25e918d47336f359fa5ae": {
			"type": "Ybodychange",
			"commitMessage": "HHH-8478 - AttributeConverters need to be applied to JPQL and Criteria queries\n",
			"commitDate": "2013-09-23, 11:55 AM",
			"commitName": "498735aa3791097e0fc25e918d47336f359fa5ae",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2013-09-06, 12:38 PM",
			"commitNameOld": "1f6daa67854e1fd6c464fe3d2a98bda1047b252d",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 16.97,
			"commitsBetweenForRepo": 76,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,47 +1,49 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal Class entityAttributeJavaType = attributeConverterDefinition.getEntityAttributeType();\n \t\tfinal Class databaseColumnJavaType = attributeConverterDefinition.getDatabaseColumnType();\n \n \n \t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n \t\t// the AttributeConverter to resolve the corresponding descriptor.\n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter's declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tfinal int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n \t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n \t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n \t\t// \t\tillustration, this should be the type descriptor for Strings\n \t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tintermediateJavaTypeDescriptor\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n \t\tfinal String name = String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter<%s,%s>\",\n \t\t\t\tentityAttributeJavaType.getSimpleName(),\n \t\t\t\tdatabaseColumnJavaType.getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n \t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptorAdapter,\n+\t\t\t\tentityAttributeJavaType,\n+\t\t\t\tdatabaseColumnJavaType,\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1f6daa67854e1fd6c464fe3d2a98bda1047b252d": {
			"type": "Ybodychange",
			"commitMessage": "HHH-8469 - Application of JPA 2.1 AttributeConverters\n",
			"commitDate": "2013-09-06, 12:38 PM",
			"commitName": "1f6daa67854e1fd6c464fe3d2a98bda1047b252d",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2013-08-22, 8:27 AM",
			"commitNameOld": "9f86babd880b785b965f7f1b55d58dc6a6943ada",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 15.17,
			"commitsBetweenForRepo": 31,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,47 +1,47 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n-\t\tfinal Class entityAttributeJavaType = jpaAttributeConverterDefinition.getEntityAttributeType();\n-\t\tfinal Class databaseColumnJavaType = jpaAttributeConverterDefinition.getDatabaseColumnType();\n+\t\tfinal Class entityAttributeJavaType = attributeConverterDefinition.getEntityAttributeType();\n+\t\tfinal Class databaseColumnJavaType = attributeConverterDefinition.getDatabaseColumnType();\n \n \n \t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n \t\t// the AttributeConverter to resolve the corresponding descriptor.\n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter's declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tfinal int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n \t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n \t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n \t\t// \t\tillustration, this should be the type descriptor for Strings\n \t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(\n-\t\t\t\tjpaAttributeConverterDefinition.getAttributeConverter(),\n+\t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tintermediateJavaTypeDescriptor\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n \t\tfinal String name = String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter<%s,%s>\",\n \t\t\t\tentityAttributeJavaType.getSimpleName(),\n \t\t\t\tdatabaseColumnJavaType.getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n-\t\t\t\tjpaAttributeConverterDefinition.getAttributeConverter(),\n+\t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptorAdapter,\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9f86babd880b785b965f7f1b55d58dc6a6943ada": {
			"type": "Ybodychange",
			"commitMessage": "HHH-8111 - AttributeConverter doesn't override built-in type mappings\n",
			"commitDate": "2013-08-22, 8:27 AM",
			"commitName": "9f86babd880b785b965f7f1b55d58dc6a6943ada",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2013-08-19, 3:07 PM",
			"commitNameOld": "bf168ca24ef0c328bd53d6d32e79f66b99ac56db",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 2.72,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,38 +1,47 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal Class entityAttributeJavaType = jpaAttributeConverterDefinition.getEntityAttributeType();\n \t\tfinal Class databaseColumnJavaType = jpaAttributeConverterDefinition.getDatabaseColumnType();\n \n \n \t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n \t\t// the AttributeConverter to resolve the corresponding descriptor.\n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter's declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tfinal int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n \t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n \t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n \t\t// \t\tillustration, this should be the type descriptor for Strings\n \t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tjpaAttributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tintermediateJavaTypeDescriptor\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n-\t\tfinal String name = \"BasicType adapter for AttributeConverter<\" + entityAttributeJavaType + \",\" + databaseColumnJavaType + \">\";\n-\t\treturn new AttributeConverterTypeAdapter( sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor, name );\n+\t\tfinal String name = String.format(\n+\t\t\t\t\"BasicType adapter for AttributeConverter<%s,%s>\",\n+\t\t\t\tentityAttributeJavaType.getSimpleName(),\n+\t\t\t\tdatabaseColumnJavaType.getSimpleName()\n+\t\t);\n+\t\treturn new AttributeConverterTypeAdapter(\n+\t\t\t\tname,\n+\t\t\t\tjpaAttributeConverterDefinition.getAttributeConverter(),\n+\t\t\t\tsqlTypeDescriptorAdapter,\n+\t\t\t\tentityAttributeJavaTypeDescriptor\n+\t\t);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"bf168ca24ef0c328bd53d6d32e79f66b99ac56db": {
			"type": "Ybodychange",
			"commitMessage": "HHH-8111 - AttributeConverter doesn't override built-in type mappings\n",
			"commitDate": "2013-08-19, 3:07 PM",
			"commitName": "bf168ca24ef0c328bd53d6d32e79f66b99ac56db",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2013-08-19, 1:54 PM",
			"commitNameOld": "7bcf161d36d5b1e59fba1ae32e8e2d692c2fd33d",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 0.05,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,47 +1,38 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal Class entityAttributeJavaType = jpaAttributeConverterDefinition.getEntityAttributeType();\n \t\tfinal Class databaseColumnJavaType = jpaAttributeConverterDefinition.getDatabaseColumnType();\n \n \n \t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n \t\t// the AttributeConverter to resolve the corresponding descriptor.\n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter's declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tfinal int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n \t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n \t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n \t\t// \t\tillustration, this should be the type descriptor for Strings\n \t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tjpaAttributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tintermediateJavaTypeDescriptor\n \t\t);\n \n+\t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n \t\tfinal String name = \"BasicType adapter for AttributeConverter<\" + entityAttributeJavaType + \",\" + databaseColumnJavaType + \">\";\n-\t\tfinal Type type = new AbstractSingleColumnStandardBasicType( sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor ) {\n-\t\t\t@Override\n-\t\t\tpublic String getName() {\n-\t\t\t\treturn name;\n-\t\t\t}\n-\t\t};\n-\t\tlog.debug( \"Created : \" + name );\n-\n-\t\t// todo : cache the BasicType we just created in case that AttributeConverter is applied multiple times.\n-\n-\t\treturn type;\n+\t\treturn new AttributeConverterTypeAdapter( sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor, name );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7bcf161d36d5b1e59fba1ae32e8e2d692c2fd33d": {
			"type": "Yintroduced",
			"commitMessage": "HHH-8111 - AttributeConverter doesn't override built-in type mappings\n",
			"commitDate": "2013-08-19, 1:54 PM",
			"commitName": "7bcf161d36d5b1e59fba1ae32e8e2d692c2fd33d",
			"commitAuthor": "Steve Ebersole"
		}
	},
	"sha": "8bd79b29cfa7b2d539a746dc356d60b66e1e596b"
}