{
	"repo": "https://github.com/square/okhttp.git",
	"file": "okhttp/src/main/java/okhttp3/ConnectionPool.java",
	"method": {
		"longName": "RealConnection get(Address address, StreamAllocation streamAllocation, Route route);",
		"startLine": 122,
		"methodName": "get",
		"isStatic": false,
		"isAbstract": false,
		"visibility": ""
	},
	"history": {
		"77471444ec81ad9452ebde7ca2b58db58a1f77d1": {
			"type": "Ybodychange",
			"commitMessage": "Don't report connectionAcquired until actually connected. (#3566)\n\nCurrently our implementation acquires the connection early so that we have\r\nsomething to close if the call is canceled. Event listeners are simpler if\r\nthey only get a connectionAcquired event once the connection has been\r\nactually established.",
			"commitDate": "2017-08-31, 10:40 PM",
			"commitName": "77471444ec81ad9452ebde7ca2b58db58a1f77d1",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2017-05-06, 12:25 PM",
			"commitNameOld": "011b2ee76d41fc689be75e1aa4d2efd9fe33c285",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 117.43,
			"commitsBetweenForRepo": 75,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,10 +1,10 @@\n   @Nullable RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n     assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n       if (connection.isEligible(address, route)) {\n-        streamAllocation.acquire(connection);\n+        streamAllocation.acquire(connection, true);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"81c7461c98f2228c3bb1a0c80fb803b5ea2e47f0": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Connection coalescing\n\nAs described here:\n\nhttps://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/\nhttps://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding\nhttps://tools.ietf.org/html/rfc7540#section-9.1.1\n\nWhen the following is true\n- HTTP/2 so we don't overload non multiplexed connections.\n- HTTPS since we need subjectAltNames (n.b. RFC 7540 defines as safe to use over plaintext, based purely on DNS).\n- Desired url host is part of the subjectAltNames for an existing connection.\n- One of the DNS results for desired host match the established connection.\n- HostnameVerifier is *not* overridden.\n- ConnectionPinner accepts the existing certificate chain.\n\nFrom https://tools.ietf.org/html/rfc7540#section-9.1.1\n\n> A server that does not wish clients to reuse connections can indicate\n> that it is not authoritative for a request by sending a 421\n> (Misdirected Request) status code in response to the request (see\n> Section 9.1.2).\n",
			"commitDate": "2017-03-05, 5:06 PM",
			"commitName": "81c7461c98f2228c3bb1a0c80fb803b5ea2e47f0",
			"commitAuthor": "Yuri Schimke",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Connection coalescing\n\nAs described here:\n\nhttps://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/\nhttps://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding\nhttps://tools.ietf.org/html/rfc7540#section-9.1.1\n\nWhen the following is true\n- HTTP/2 so we don't overload non multiplexed connections.\n- HTTPS since we need subjectAltNames (n.b. RFC 7540 defines as safe to use over plaintext, based purely on DNS).\n- Desired url host is part of the subjectAltNames for an existing connection.\n- One of the DNS results for desired host match the established connection.\n- HostnameVerifier is *not* overridden.\n- ConnectionPinner accepts the existing certificate chain.\n\nFrom https://tools.ietf.org/html/rfc7540#section-9.1.1\n\n> A server that does not wish clients to reuse connections can indicate\n> that it is not authoritative for a request by sending a 421\n> (Misdirected Request) status code in response to the request (see\n> Section 9.1.2).\n",
					"commitDate": "2017-03-05, 5:06 PM",
					"commitName": "81c7461c98f2228c3bb1a0c80fb803b5ea2e47f0",
					"commitAuthor": "Yuri Schimke",
					"commitDateOld": "2017-01-20, 11:54 AM",
					"commitNameOld": "5af089a71997fb454b0ef063664db267d8038a73",
					"commitAuthorOld": "Jake Wharton",
					"daysBetweenCommits": 44.22,
					"commitsBetweenForRepo": 22,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,10 +1,10 @@\n-  RealConnection get(Address address, StreamAllocation streamAllocation) {\n+  RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n     assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n-      if (connection.isEligible(address)) {\n+      if (connection.isEligible(address, route)) {\n         streamAllocation.acquire(connection);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[address-Address, streamAllocation-StreamAllocation]",
						"newValue": "[address-Address, streamAllocation-StreamAllocation, route-Route]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Connection coalescing\n\nAs described here:\n\nhttps://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/\nhttps://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding\nhttps://tools.ietf.org/html/rfc7540#section-9.1.1\n\nWhen the following is true\n- HTTP/2 so we don't overload non multiplexed connections.\n- HTTPS since we need subjectAltNames (n.b. RFC 7540 defines as safe to use over plaintext, based purely on DNS).\n- Desired url host is part of the subjectAltNames for an existing connection.\n- One of the DNS results for desired host match the established connection.\n- HostnameVerifier is *not* overridden.\n- ConnectionPinner accepts the existing certificate chain.\n\nFrom https://tools.ietf.org/html/rfc7540#section-9.1.1\n\n> A server that does not wish clients to reuse connections can indicate\n> that it is not authoritative for a request by sending a 421\n> (Misdirected Request) status code in response to the request (see\n> Section 9.1.2).\n",
					"commitDate": "2017-03-05, 5:06 PM",
					"commitName": "81c7461c98f2228c3bb1a0c80fb803b5ea2e47f0",
					"commitAuthor": "Yuri Schimke",
					"commitDateOld": "2017-01-20, 11:54 AM",
					"commitNameOld": "5af089a71997fb454b0ef063664db267d8038a73",
					"commitAuthorOld": "Jake Wharton",
					"daysBetweenCommits": 44.22,
					"commitsBetweenForRepo": 22,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,10 +1,10 @@\n-  RealConnection get(Address address, StreamAllocation streamAllocation) {\n+  RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n     assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n-      if (connection.isEligible(address)) {\n+      if (connection.isEligible(address, route)) {\n         streamAllocation.acquire(connection);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"98443a9ca8ca9ad82d5fb9b05b32f180bb510601": {
			"type": "Ybodychange",
			"commitMessage": "Release duplicated multiplexed connections.\n\nIf we make concurrent requests to an HTTP/2 server, close all but\nthe first connection. Creating multiple connections and then later\nreleasing them is somewhat pessimistic; it's also much safer for\nawkward cases like connect attempts being canceled.\n\nCloses: https://github.com/square/okhttp/issues/373\n",
			"commitDate": "2017-01-07, 11:15 AM",
			"commitName": "98443a9ca8ca9ad82d5fb9b05b32f180bb510601",
			"commitAuthor": "jwilson",
			"commitDateOld": "2016-08-07, 8:51 AM",
			"commitNameOld": "ecbcd51fc99c565496be15cfd7eadca465ae4a06",
			"commitAuthorOld": "Dave Roberge",
			"daysBetweenCommits": 153.14,
			"commitsBetweenForRepo": 87,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,12 +1,10 @@\n   RealConnection get(Address address, StreamAllocation streamAllocation) {\n     assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n-      if (connection.allocations.size() < connection.allocationLimit\n-          && address.equals(connection.route().address)\n-          && !connection.noNewStreams) {\n+      if (connection.isEligible(address)) {\n         streamAllocation.acquire(connection);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"75ebcd5cd13995c3b70e0b621d3204b9a5996806": {
			"type": "Ybodychange",
			"commitMessage": "Use listeners to observe allocation limit changes.\n\nThis removes some awkward code where the synchronized connection pool is calling\na synchronized methond on a connection. Nested synchronized is gross.\n",
			"commitDate": "2016-01-15, 9:29 PM",
			"commitName": "75ebcd5cd13995c3b70e0b621d3204b9a5996806",
			"commitAuthor": "jwilson",
			"commitDateOld": "2016-01-01, 11:07 PM",
			"commitNameOld": "7826bcb2fb1facb697a4c512776756c05d8c9deb",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 13.93,
			"commitsBetweenForRepo": 32,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,14 +1,12 @@\n   RealConnection get(Address address, StreamAllocation streamAllocation) {\n     assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n-      // TODO(jwilson): this is awkward. We're already holding a lock on 'this', and\n-      //     connection.allocationLimit() may also lock the FramedConnection.\n-      if (connection.allocations.size() < connection.allocationLimit()\n+      if (connection.allocations.size() < connection.allocationLimit\n           && address.equals(connection.route().address)\n           && !connection.noNewStreams) {\n         streamAllocation.acquire(connection);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"02d6b4e78c4f1bda5f20e3089af024c58fe6baf6": {
			"type": "Ybodychange",
			"commitMessage": "Drop the get prefix on Connection accessors.\n",
			"commitDate": "2015-12-21, 6:10 PM",
			"commitName": "02d6b4e78c4f1bda5f20e3089af024c58fe6baf6",
			"commitAuthor": "jwilson",
			"commitDateOld": "2015-12-15, 10:34 PM",
			"commitNameOld": "c9a89876de476983f273edbf108c365127c18c5e",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 5.82,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,14 +1,14 @@\n   RealConnection get(Address address, StreamAllocation streamAllocation) {\n     assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n       // TODO(jwilson): this is awkward. We're already holding a lock on 'this', and\n       //     connection.allocationLimit() may also lock the FramedConnection.\n       if (connection.allocations.size() < connection.allocationLimit()\n-          && address.equals(connection.getRoute().address)\n+          && address.equals(connection.route().address)\n           && !connection.noNewStreams) {\n         streamAllocation.acquire(connection);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c9a89876de476983f273edbf108c365127c18c5e": {
			"type": "Ymovefromfile",
			"commitMessage": "Rename com.squareup.okhttp to okhttp3\n\nMaven group changes will come in follow up.\n",
			"commitDate": "2015-12-15, 10:34 PM",
			"commitName": "c9a89876de476983f273edbf108c365127c18c5e",
			"commitAuthor": "jwilson",
			"commitDateOld": "2015-12-15, 6:36 PM",
			"commitNameOld": "54dc2df914f2aae37fb48cc2c2f7560ee664bc2b",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 0.17,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java",
				"newPath": "okhttp/src/main/java/okhttp3/ConnectionPool.java",
				"oldMethodName": "get",
				"newMethodName": "get"
			}
		},
		"c099f69d0b7198a40e4a6373ae564b65d04363ef": {
			"type": "Ymultichange(Yreturntypechange,Ymodifierchange,Ybodychange)",
			"commitMessage": "Hide overly-visible APIs in ConnectionPool.\n",
			"commitDate": "2015-12-13, 6:18 AM",
			"commitName": "c099f69d0b7198a40e4a6373ae564b65d04363ef",
			"commitAuthor": "jwilson",
			"subchanges": [
				{
					"type": "Yreturntypechange",
					"commitMessage": "Hide overly-visible APIs in ConnectionPool.\n",
					"commitDate": "2015-12-13, 6:18 AM",
					"commitName": "c099f69d0b7198a40e4a6373ae564b65d04363ef",
					"commitAuthor": "jwilson",
					"commitDateOld": "2015-12-08, 7:05 PM",
					"commitNameOld": "4ae314a1f21d07ee5dbad024bc098182219e9e07",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 4.47,
					"commitsBetweenForRepo": 4,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,13 +1,14 @@\n-  public synchronized Connection get(Address address, StreamAllocation streamAllocation) {\n+  RealConnection get(Address address, StreamAllocation streamAllocation) {\n+    assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n       // TODO(jwilson): this is awkward. We're already holding a lock on 'this', and\n       //     connection.allocationLimit() may also lock the FramedConnection.\n       if (connection.allocations.size() < connection.allocationLimit()\n           && address.equals(connection.getRoute().address)\n           && !connection.noNewStreams) {\n         streamAllocation.acquire(connection);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "Connection",
						"newValue": "RealConnection"
					}
				},
				{
					"type": "Ymodifierchange",
					"commitMessage": "Hide overly-visible APIs in ConnectionPool.\n",
					"commitDate": "2015-12-13, 6:18 AM",
					"commitName": "c099f69d0b7198a40e4a6373ae564b65d04363ef",
					"commitAuthor": "jwilson",
					"commitDateOld": "2015-12-08, 7:05 PM",
					"commitNameOld": "4ae314a1f21d07ee5dbad024bc098182219e9e07",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 4.47,
					"commitsBetweenForRepo": 4,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,13 +1,14 @@\n-  public synchronized Connection get(Address address, StreamAllocation streamAllocation) {\n+  RealConnection get(Address address, StreamAllocation streamAllocation) {\n+    assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n       // TODO(jwilson): this is awkward. We're already holding a lock on 'this', and\n       //     connection.allocationLimit() may also lock the FramedConnection.\n       if (connection.allocations.size() < connection.allocationLimit()\n           && address.equals(connection.getRoute().address)\n           && !connection.noNewStreams) {\n         streamAllocation.acquire(connection);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[public, synchronized]",
						"newValue": "[]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Hide overly-visible APIs in ConnectionPool.\n",
					"commitDate": "2015-12-13, 6:18 AM",
					"commitName": "c099f69d0b7198a40e4a6373ae564b65d04363ef",
					"commitAuthor": "jwilson",
					"commitDateOld": "2015-12-08, 7:05 PM",
					"commitNameOld": "4ae314a1f21d07ee5dbad024bc098182219e9e07",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 4.47,
					"commitsBetweenForRepo": 4,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,13 +1,14 @@\n-  public synchronized Connection get(Address address, StreamAllocation streamAllocation) {\n+  RealConnection get(Address address, StreamAllocation streamAllocation) {\n+    assert (Thread.holdsLock(this));\n     for (RealConnection connection : connections) {\n       // TODO(jwilson): this is awkward. We're already holding a lock on 'this', and\n       //     connection.allocationLimit() may also lock the FramedConnection.\n       if (connection.allocations.size() < connection.allocationLimit()\n           && address.equals(connection.getRoute().address)\n           && !connection.noNewStreams) {\n         streamAllocation.acquire(connection);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"4ae314a1f21d07ee5dbad024bc098182219e9e07": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Detect leaked connections.\n\nThis is already suggesting some bugs in OkHttp itself.\n",
			"commitDate": "2015-12-08, 7:05 PM",
			"commitName": "4ae314a1f21d07ee5dbad024bc098182219e9e07",
			"commitAuthor": "jwilson",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Detect leaked connections.\n\nThis is already suggesting some bugs in OkHttp itself.\n",
					"commitDate": "2015-12-08, 7:05 PM",
					"commitName": "4ae314a1f21d07ee5dbad024bc098182219e9e07",
					"commitAuthor": "jwilson",
					"commitDateOld": "2015-12-07, 7:43 PM",
					"commitNameOld": "9ffc45dbe0b9ef80ab5cf972a176548781d2206a",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 0.97,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,13 +1,13 @@\n-  public synchronized Connection get(Address address) {\n+  public synchronized Connection get(Address address, StreamAllocation streamAllocation) {\n     for (RealConnection connection : connections) {\n       // TODO(jwilson): this is awkward. We're already holding a lock on 'this', and\n       //     connection.allocationLimit() may also lock the FramedConnection.\n-      if (connection.allocationCount < connection.allocationLimit()\n+      if (connection.allocations.size() < connection.allocationLimit()\n           && address.equals(connection.getRoute().address)\n           && !connection.noNewStreams) {\n-        connection.allocationCount++;\n+        streamAllocation.acquire(connection);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[address-Address]",
						"newValue": "[address-Address, streamAllocation-StreamAllocation]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Detect leaked connections.\n\nThis is already suggesting some bugs in OkHttp itself.\n",
					"commitDate": "2015-12-08, 7:05 PM",
					"commitName": "4ae314a1f21d07ee5dbad024bc098182219e9e07",
					"commitAuthor": "jwilson",
					"commitDateOld": "2015-12-07, 7:43 PM",
					"commitNameOld": "9ffc45dbe0b9ef80ab5cf972a176548781d2206a",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 0.97,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,13 +1,13 @@\n-  public synchronized Connection get(Address address) {\n+  public synchronized Connection get(Address address, StreamAllocation streamAllocation) {\n     for (RealConnection connection : connections) {\n       // TODO(jwilson): this is awkward. We're already holding a lock on 'this', and\n       //     connection.allocationLimit() may also lock the FramedConnection.\n-      if (connection.allocationCount < connection.allocationLimit()\n+      if (connection.allocations.size() < connection.allocationLimit()\n           && address.equals(connection.getRoute().address)\n           && !connection.noNewStreams) {\n-        connection.allocationCount++;\n+        streamAllocation.acquire(connection);\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"c5f58e45454d1ffc621c65e377cb91345018e087": {
			"type": "Ybodychange",
			"commitMessage": "Honor the max concurrent streams setting.\n\nCloses https://github.com/square/okhttp/issues/1484\n",
			"commitDate": "2015-12-02, 9:44 AM",
			"commitName": "c5f58e45454d1ffc621c65e377cb91345018e087",
			"commitAuthor": "jwilson",
			"commitDateOld": "2015-11-28, 6:36 AM",
			"commitNameOld": "c358656c8799d30fd422448153e99a5dd37e298a",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 4.13,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,11 +1,13 @@\n   public synchronized Connection get(Address address) {\n     for (RealConnection connection : connections) {\n-      if (connection.allocationCount < connection.allocationLimit\n+      // TODO(jwilson): this is awkward. We're already holding a lock on 'this', and\n+      //     connection.allocationLimit() may also lock the FramedConnection.\n+      if (connection.allocationCount < connection.allocationLimit()\n           && address.equals(connection.getRoute().address)\n           && !connection.noNewStreams) {\n         connection.allocationCount++;\n         return connection;\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c358656c8799d30fd422448153e99a5dd37e298a": {
			"type": "Ybodychange",
			"commitMessage": "First draft of the new new stream allocations model.\n",
			"commitDate": "2015-11-28, 6:36 AM",
			"commitName": "c358656c8799d30fd422448153e99a5dd37e298a",
			"commitAuthor": "jwilson",
			"commitDateOld": "2015-11-09, 5:12 AM",
			"commitNameOld": "49a331385343f3ca49d26c4ddd947546867bcd3b",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 19.06,
			"commitsBetweenForRepo": 34,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,30 +1,11 @@\n   public synchronized Connection get(Address address) {\n-    Connection foundConnection = null;\n-    for (Iterator<Connection> i = connections.descendingIterator(); i.hasNext(); ) {\n-      Connection connection = i.next();\n-      if (!connection.getRoute().getAddress().equals(address)\n-          || !connection.isAlive()\n-          || System.nanoTime() - connection.getIdleStartTimeNs() >= keepAliveDurationNs) {\n-        continue;\n+    for (RealConnection connection : connections) {\n+      if (connection.allocationCount < connection.allocationLimit\n+          && address.equals(connection.getRoute().address)\n+          && !connection.noNewStreams) {\n+        connection.allocationCount++;\n+        return connection;\n       }\n-      i.remove();\n-      if (!connection.isFramed()) {\n-        try {\n-          Platform.get().tagSocket(connection.getSocket());\n-        } catch (SocketException e) {\n-          Util.closeQuietly(connection.getSocket());\n-          // When unable to tag, skip recycling and close\n-          Platform.get().logW(\"Unable to tagSocket(): \" + e);\n-          continue;\n-        }\n-      }\n-      foundConnection = connection;\n-      break;\n     }\n-\n-    if (foundConnection != null && foundConnection.isFramed()) {\n-      connections.addFirst(foundConnection); // Add it back after iteration.\n-    }\n-\n-    return foundConnection;\n+    return null;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"49a331385343f3ca49d26c4ddd947546867bcd3b": {
			"type": "Ybodychange",
			"commitMessage": "Connection allocations model.\n\nThis is intended to replace some of the state machines in HttpConnection, HttpEngine,\nand ConnectionPool. With this we'll keep track of all streams in flight, not just\nthe connections currently idle.\n\nNote that I've sketched this out into a new Connection.java class. In a follow up\nchange I'll attempt to combine this with the existing Connection class.\n",
			"commitDate": "2015-11-09, 5:12 AM",
			"commitName": "49a331385343f3ca49d26c4ddd947546867bcd3b",
			"commitAuthor": "jwilson",
			"commitDateOld": "2015-06-17, 3:40 PM",
			"commitNameOld": "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 144.61,
			"commitsBetweenForRepo": 79,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,31 +1,30 @@\n   public synchronized Connection get(Address address) {\n     Connection foundConnection = null;\n-    for (ListIterator<Connection> i = connections.listIterator(connections.size());\n-        i.hasPrevious(); ) {\n-      Connection connection = i.previous();\n+    for (Iterator<Connection> i = connections.descendingIterator(); i.hasNext(); ) {\n+      Connection connection = i.next();\n       if (!connection.getRoute().getAddress().equals(address)\n           || !connection.isAlive()\n           || System.nanoTime() - connection.getIdleStartTimeNs() >= keepAliveDurationNs) {\n         continue;\n       }\n       i.remove();\n       if (!connection.isFramed()) {\n         try {\n           Platform.get().tagSocket(connection.getSocket());\n         } catch (SocketException e) {\n           Util.closeQuietly(connection.getSocket());\n           // When unable to tag, skip recycling and close\n           Platform.get().logW(\"Unable to tagSocket(): \" + e);\n           continue;\n         }\n       }\n       foundConnection = connection;\n       break;\n     }\n \n     if (foundConnection != null && foundConnection.isFramed()) {\n       connections.addFirst(foundConnection); // Add it back after iteration.\n     }\n \n     return foundConnection;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c753d2e41ba667f9b5a31451a16ecbaecdc65d80": {
			"type": "Ybodychange",
			"commitMessage": "Rename 'spdy' references to 'framed' where appropriate.\n",
			"commitDate": "2015-06-17, 3:40 PM",
			"commitName": "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
			"commitAuthor": "Jake Wharton",
			"commitDateOld": "2015-01-13, 3:33 PM",
			"commitNameOld": "e3d39f7ec069ad49bac7c59c2f2384dd2adf71dd",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 154.96,
			"commitsBetweenForRepo": 131,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,31 +1,31 @@\n   public synchronized Connection get(Address address) {\n     Connection foundConnection = null;\n     for (ListIterator<Connection> i = connections.listIterator(connections.size());\n         i.hasPrevious(); ) {\n       Connection connection = i.previous();\n       if (!connection.getRoute().getAddress().equals(address)\n           || !connection.isAlive()\n           || System.nanoTime() - connection.getIdleStartTimeNs() >= keepAliveDurationNs) {\n         continue;\n       }\n       i.remove();\n-      if (!connection.isSpdy()) {\n+      if (!connection.isFramed()) {\n         try {\n           Platform.get().tagSocket(connection.getSocket());\n         } catch (SocketException e) {\n           Util.closeQuietly(connection.getSocket());\n           // When unable to tag, skip recycling and close\n           Platform.get().logW(\"Unable to tagSocket(): \" + e);\n           continue;\n         }\n       }\n       foundConnection = connection;\n       break;\n     }\n \n-    if (foundConnection != null && foundConnection.isSpdy()) {\n+    if (foundConnection != null && foundConnection.isFramed()) {\n       connections.addFirst(foundConnection); // Add it back after iteration.\n     }\n \n     return foundConnection;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"98c74ace40b089f2769afb3e56c59a64eef327cb": {
			"type": "Ybodychange",
			"commitMessage": "Respect the max idle connections limit.\n\nThe structure here is a bit ugly. But it permits a single 'synchronized'\nblock, which makes the method easier to reason about.\n\nCloses https://github.com/square/okhttp/issues/1239\n",
			"commitDate": "2014-12-29, 7:10 AM",
			"commitName": "98c74ace40b089f2769afb3e56c59a64eef327cb",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2014-12-25, 10:20 PM",
			"commitNameOld": "8c7c963c24c3e347fd0d0fd641c27058d4eadc2c",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 3.37,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,32 +1,31 @@\n   public synchronized Connection get(Address address) {\n     Connection foundConnection = null;\n     for (ListIterator<Connection> i = connections.listIterator(connections.size());\n         i.hasPrevious(); ) {\n       Connection connection = i.previous();\n       if (!connection.getRoute().getAddress().equals(address)\n           || !connection.isAlive()\n           || System.nanoTime() - connection.getIdleStartTimeNs() >= keepAliveDurationNs) {\n         continue;\n       }\n       i.remove();\n       if (!connection.isSpdy()) {\n         try {\n           Platform.get().tagSocket(connection.getSocket());\n         } catch (SocketException e) {\n           Util.closeQuietly(connection.getSocket());\n           // When unable to tag, skip recycling and close\n           Platform.get().logW(\"Unable to tagSocket(): \" + e);\n           continue;\n         }\n       }\n       foundConnection = connection;\n       break;\n     }\n \n     if (foundConnection != null && foundConnection.isSpdy()) {\n       connections.addFirst(foundConnection); // Add it back after iteration.\n-      scheduleCleanupAsRequired();\n     }\n \n     return foundConnection;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a8327d121b9eeb3b61ae63f06095d423936a5da2": {
			"type": "Ybodychange",
			"commitMessage": "Fix for a socket leak in OkHttp on Android\n\nWhen the preferred Android network changes from\ncell -> wifi or wifi -> cell the HTTP connection\npool in use is abandoned to avoid reuse of\nconnections on the old network. This was added\nin commit 8bced3e.\n\nThe design for the connection pool was such that\ncontinuous use of the connection pool was required to\nclean up idle / expired connections. If a connection\npool becomes idle (as when it is dereferenced on a\nnetwork change) it is possible for some connections\nto remain in the pool indefinitely.\n\nAfter the preferred network change, because the old\nconnection pool was no longer referenced the pool\nwould be garbage collected and Android's \"Strict Mode\"\nwould complain about sockets not being closed.\n\nThe only existing way to avoid this was to call\n\"evictAll()\", which would have had issues when a\nlarge number of connections were returned to the pool\nafter evictAll() was called. It also wouldn't work\nfor SPDY connections which are shared but not reference\ncounted, which makes knowing whether it is safe to\nclose them difficult.\n\nThe cleanModeRunnable serves two purposes:\n\n1) While scheduled / executing, it pins the connection\npool in memory to avoid it being garbage collected.\n2) It continues to close connections (safely) until the\npool is empty.\n\nIf a connection is then added back to the pool the\ncleanModeRunnable is restarted.\n",
			"commitDate": "2014-12-18, 8:19 AM",
			"commitName": "a8327d121b9eeb3b61ae63f06095d423936a5da2",
			"commitAuthor": "Neil Fuller",
			"commitDateOld": "2014-06-17, 1:36 PM",
			"commitNameOld": "cdd71f1bbd32f20d63d7100787b91c327d1b5b0c",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 183.82,
			"commitsBetweenForRepo": 121,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,32 +1,32 @@\n   public synchronized Connection get(Address address) {\n     Connection foundConnection = null;\n     for (ListIterator<Connection> i = connections.listIterator(connections.size());\n         i.hasPrevious(); ) {\n       Connection connection = i.previous();\n       if (!connection.getRoute().getAddress().equals(address)\n           || !connection.isAlive()\n           || System.nanoTime() - connection.getIdleStartTimeNs() >= keepAliveDurationNs) {\n         continue;\n       }\n       i.remove();\n       if (!connection.isSpdy()) {\n         try {\n           Platform.get().tagSocket(connection.getSocket());\n         } catch (SocketException e) {\n           Util.closeQuietly(connection.getSocket());\n           // When unable to tag, skip recycling and close\n           Platform.get().logW(\"Unable to tagSocket(): \" + e);\n           continue;\n         }\n       }\n       foundConnection = connection;\n       break;\n     }\n \n     if (foundConnection != null && foundConnection.isSpdy()) {\n       connections.addFirst(foundConnection); // Add it back after iteration.\n+      scheduleCleanupAsRequired();\n     }\n \n-    executorService.execute(connectionsCleanupRunnable);\n     return foundConnection;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c26f9af0489869a9e1873ed5010c65f8464cff26": {
			"type": "Ybodychange",
			"commitMessage": "Hide ConnectionPool.recycle and share.\n",
			"commitDate": "2014-04-30, 7:02 PM",
			"commitName": "c26f9af0489869a9e1873ed5010c65f8464cff26",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2014-04-20, 8:26 AM",
			"commitNameOld": "6e373d870e1be071cd67c350928e44745c72f499",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 10.44,
			"commitsBetweenForRepo": 34,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,32 +1,32 @@\n   public synchronized Connection get(Address address) {\n     Connection foundConnection = null;\n     for (ListIterator<Connection> i = connections.listIterator(connections.size());\n         i.hasPrevious(); ) {\n       Connection connection = i.previous();\n       if (!connection.getRoute().getAddress().equals(address)\n           || !connection.isAlive()\n           || System.nanoTime() - connection.getIdleStartTimeNs() >= keepAliveDurationNs) {\n         continue;\n       }\n       i.remove();\n       if (!connection.isSpdy()) {\n         try {\n           Platform.get().tagSocket(connection.getSocket());\n         } catch (SocketException e) {\n-          Util.closeQuietly(connection);\n+          Util.closeQuietly(connection.getSocket());\n           // When unable to tag, skip recycling and close\n           Platform.get().logW(\"Unable to tagSocket(): \" + e);\n           continue;\n         }\n       }\n       foundConnection = connection;\n       break;\n     }\n \n     if (foundConnection != null && foundConnection.isSpdy()) {\n       connections.addFirst(foundConnection); // Add it back after iteration.\n     }\n \n     executorService.execute(connectionsCleanupRunnable);\n     return foundConnection;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fdee6f13a4c5bf5bd24f2c237c2996aea01cc5ff": {
			"type": "Ybodychange",
			"commitMessage": "FindBugs sweep.\n",
			"commitDate": "2014-02-05, 8:18 AM",
			"commitName": "fdee6f13a4c5bf5bd24f2c237c2996aea01cc5ff",
			"commitAuthor": "Adrian Cole and Jesse Wilson",
			"commitDateOld": "2014-01-12, 6:47 AM",
			"commitNameOld": "749a65b776c8fc4b39b6463695980275da34da51",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 24.06,
			"commitsBetweenForRepo": 66,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,32 +1,32 @@\n   public synchronized Connection get(Address address) {\n     Connection foundConnection = null;\n     for (ListIterator<Connection> i = connections.listIterator(connections.size());\n         i.hasPrevious(); ) {\n       Connection connection = i.previous();\n       if (!connection.getRoute().getAddress().equals(address)\n           || !connection.isAlive()\n           || System.nanoTime() - connection.getIdleStartTimeNs() >= keepAliveDurationNs) {\n         continue;\n       }\n       i.remove();\n       if (!connection.isSpdy()) {\n         try {\n           Platform.get().tagSocket(connection.getSocket());\n         } catch (SocketException e) {\n           Util.closeQuietly(connection);\n           // When unable to tag, skip recycling and close\n           Platform.get().logW(\"Unable to tagSocket(): \" + e);\n           continue;\n         }\n       }\n       foundConnection = connection;\n       break;\n     }\n \n     if (foundConnection != null && foundConnection.isSpdy()) {\n       connections.addFirst(foundConnection); // Add it back after iteration.\n     }\n \n-    executorService.submit(connectionsCleanupCallable);\n+    executorService.execute(connectionsCleanupRunnable);\n     return foundConnection;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1ece746c815a26782042b1fca6069eb527d1029b": {
			"type": "Ybodychange",
			"commitMessage": "RouteSelector tries previously failed routes last #106\n",
			"commitDate": "2013-04-10, 3:19 PM",
			"commitName": "1ece746c815a26782042b1fca6069eb527d1029b",
			"commitAuthor": "Marcelo Cortes",
			"commitDateOld": "2013-03-25, 8:04 PM",
			"commitNameOld": "7ccbf48838b7cfe42759c67790636d442ea5daa3",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 15.8,
			"commitsBetweenForRepo": 10,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,32 +1,32 @@\n   public synchronized Connection get(Address address) {\n     Connection foundConnection = null;\n     for (ListIterator<Connection> i = connections.listIterator(connections.size());\n         i.hasPrevious(); ) {\n       Connection connection = i.previous();\n-      if (!connection.getAddress().equals(address)\n+      if (!connection.getRoute().getAddress().equals(address)\n           || !connection.isAlive()\n           || System.nanoTime() - connection.getIdleStartTimeNs() >= keepAliveDurationNs) {\n         continue;\n       }\n       i.remove();\n       if (!connection.isSpdy()) {\n         try {\n           Platform.get().tagSocket(connection.getSocket());\n         } catch (SocketException e) {\n           Util.closeQuietly(connection);\n           // When unable to tag, skip recycling and close\n           Platform.get().logW(\"Unable to tagSocket(): \" + e);\n           continue;\n         }\n       }\n       foundConnection = connection;\n       break;\n     }\n \n     if (foundConnection != null && foundConnection.isSpdy()) {\n       connections.addFirst(foundConnection); // Add it back after iteration.\n     }\n \n     executorService.submit(connectionsCleanupCallable);\n     return foundConnection;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7ccbf48838b7cfe42759c67790636d442ea5daa3": {
			"type": "Yfilerename",
			"commitMessage": "Move library into a module. Introduce sample module with simple GitHub client.\n",
			"commitDate": "2013-03-25, 8:04 PM",
			"commitName": "7ccbf48838b7cfe42759c67790636d442ea5daa3",
			"commitAuthor": "Jake Wharton",
			"commitDateOld": "2013-03-15, 7:39 AM",
			"commitNameOld": "ba2b7432cb9fabfc725b09a9f14878cb128ef208",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 10.52,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/com/squareup/okhttp/ConnectionPool.java",
				"newPath": "okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java"
			}
		},
		"f373e2d6e5bfaa86afc147b877a72d600c224c5d": {
			"type": "Ybodychange",
			"commitMessage": "Fix froyo bug: no more descendingIterator\n",
			"commitDate": "2013-02-27, 4:19 PM",
			"commitName": "f373e2d6e5bfaa86afc147b877a72d600c224c5d",
			"commitAuthor": "Eric Denman",
			"commitDateOld": "2013-02-27, 8:31 AM",
			"commitNameOld": "220b5f9a3bac6b78f6ad2d2e159057eb9bcb9908",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 0.33,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,31 +1,32 @@\n   public synchronized Connection get(Address address) {\n     Connection foundConnection = null;\n-    for (Iterator<Connection> i = connections.descendingIterator(); i.hasNext(); ) {\n-      Connection connection = i.next();\n+    for (ListIterator<Connection> i = connections.listIterator(connections.size());\n+        i.hasPrevious(); ) {\n+      Connection connection = i.previous();\n       if (!connection.getAddress().equals(address)\n           || !connection.isAlive()\n           || System.nanoTime() - connection.getIdleStartTimeNs() >= keepAliveDurationNs) {\n         continue;\n       }\n       i.remove();\n       if (!connection.isSpdy()) {\n         try {\n           Platform.get().tagSocket(connection.getSocket());\n         } catch (SocketException e) {\n           Util.closeQuietly(connection);\n           // When unable to tag, skip recycling and close\n           Platform.get().logW(\"Unable to tagSocket(): \" + e);\n           continue;\n         }\n       }\n       foundConnection = connection;\n       break;\n     }\n \n     if (foundConnection != null && foundConnection.isSpdy()) {\n       connections.addFirst(foundConnection); // Add it back after iteration.\n     }\n \n     executorService.submit(connectionsCleanupCallable);\n     return foundConnection;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6f6d959fdae64065521990413f86bc7ab038d7c1": {
			"type": "Ymultichange(Ymodifierchange,Ybodychange)",
			"commitMessage": "Improvements to connection pool\n",
			"commitDate": "2013-01-31, 2:23 PM",
			"commitName": "6f6d959fdae64065521990413f86bc7ab038d7c1",
			"commitAuthor": "Marcelo Cortes",
			"subchanges": [
				{
					"type": "Ymodifierchange",
					"commitMessage": "Improvements to connection pool\n",
					"commitDate": "2013-01-31, 2:23 PM",
					"commitName": "6f6d959fdae64065521990413f86bc7ab038d7c1",
					"commitAuthor": "Marcelo Cortes",
					"commitDateOld": "2013-01-06, 3:30 PM",
					"commitNameOld": "06579c5bfb6a051a9fbca5be2d15a52fcf77f38c",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 24.95,
					"commitsBetweenForRepo": 10,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,34 +1,31 @@\n-    public Connection get(Address address) {\n-        // First try to reuse an existing HTTP connection.\n-        synchronized (connectionPool) {\n-            List<Connection> connections = connectionPool.get(address);\n-            while (connections != null) {\n-                Connection connection = connections.get(connections.size() - 1);\n-                boolean usable = connection.isEligibleForRecycling();\n-                if (usable && !connection.isSpdy()) {\n-                    try {\n-                        Platform.get().tagSocket(connection.getSocket());\n-                    } catch (SocketException e) {\n-                        // When unable to tag, skip recycling and close\n-                        Platform.get().logW(\"Unable to tagSocket(): \" + e);\n-                        usable = false;\n-                    }\n-                }\n-\n-                if (!connection.isSpdy() || !usable) {\n-                    connections.remove(connections.size() - 1);\n-                    if (connections.isEmpty()) {\n-                        connectionPool.remove(address);\n-                        connections = null;\n-                    }\n-                }\n-\n-                if (usable) {\n-                    return connection;\n-                } else {\n-                    Util.closeQuietly(connection);\n-                }\n-            }\n+  public synchronized Connection get(Address address) {\n+    Connection foundConnection = null;\n+    for (Iterator<Connection> i = connections.descendingIterator(); i.hasNext(); ) {\n+      Connection connection = i.next();\n+      if (!connection.getAddress().equals(address)\n+          || !connection.isAlive()\n+          || System.nanoTime() - connection.getIdleStartTimeNs() >= keepAliveDurationNs) {\n+        continue;\n+      }\n+      i.remove();\n+      if (!connection.isSpdy()) {\n+        try {\n+          Platform.get().tagSocket(connection.getSocket());\n+        } catch (SocketException e) {\n+          Util.closeQuietly(connection);\n+          // When unable to tag, skip recycling and close\n+          Platform.get().logW(\"Unable to tagSocket(): \" + e);\n+          continue;\n         }\n-        return null;\n-    }\n\\ No newline at end of file\n+      }\n+      foundConnection = connection;\n+      break;\n+    }\n+\n+    if (foundConnection != null && foundConnection.isSpdy()) {\n+      connections.addFirst(foundConnection); // Add it back after iteration.\n+    }\n+\n+    executorService.submit(connectionsCleanupCallable);\n+    return foundConnection;\n+  }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[public]",
						"newValue": "[public, synchronized]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Improvements to connection pool\n",
					"commitDate": "2013-01-31, 2:23 PM",
					"commitName": "6f6d959fdae64065521990413f86bc7ab038d7c1",
					"commitAuthor": "Marcelo Cortes",
					"commitDateOld": "2013-01-06, 3:30 PM",
					"commitNameOld": "06579c5bfb6a051a9fbca5be2d15a52fcf77f38c",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 24.95,
					"commitsBetweenForRepo": 10,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,34 +1,31 @@\n-    public Connection get(Address address) {\n-        // First try to reuse an existing HTTP connection.\n-        synchronized (connectionPool) {\n-            List<Connection> connections = connectionPool.get(address);\n-            while (connections != null) {\n-                Connection connection = connections.get(connections.size() - 1);\n-                boolean usable = connection.isEligibleForRecycling();\n-                if (usable && !connection.isSpdy()) {\n-                    try {\n-                        Platform.get().tagSocket(connection.getSocket());\n-                    } catch (SocketException e) {\n-                        // When unable to tag, skip recycling and close\n-                        Platform.get().logW(\"Unable to tagSocket(): \" + e);\n-                        usable = false;\n-                    }\n-                }\n-\n-                if (!connection.isSpdy() || !usable) {\n-                    connections.remove(connections.size() - 1);\n-                    if (connections.isEmpty()) {\n-                        connectionPool.remove(address);\n-                        connections = null;\n-                    }\n-                }\n-\n-                if (usable) {\n-                    return connection;\n-                } else {\n-                    Util.closeQuietly(connection);\n-                }\n-            }\n+  public synchronized Connection get(Address address) {\n+    Connection foundConnection = null;\n+    for (Iterator<Connection> i = connections.descendingIterator(); i.hasNext(); ) {\n+      Connection connection = i.next();\n+      if (!connection.getAddress().equals(address)\n+          || !connection.isAlive()\n+          || System.nanoTime() - connection.getIdleStartTimeNs() >= keepAliveDurationNs) {\n+        continue;\n+      }\n+      i.remove();\n+      if (!connection.isSpdy()) {\n+        try {\n+          Platform.get().tagSocket(connection.getSocket());\n+        } catch (SocketException e) {\n+          Util.closeQuietly(connection);\n+          // When unable to tag, skip recycling and close\n+          Platform.get().logW(\"Unable to tagSocket(): \" + e);\n+          continue;\n         }\n-        return null;\n-    }\n\\ No newline at end of file\n+      }\n+      foundConnection = connection;\n+      break;\n+    }\n+\n+    if (foundConnection != null && foundConnection.isSpdy()) {\n+      connections.addFirst(foundConnection); // Add it back after iteration.\n+    }\n+\n+    executorService.submit(connectionsCleanupCallable);\n+    return foundConnection;\n+  }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"06579c5bfb6a051a9fbca5be2d15a52fcf77f38c": {
			"type": "Ybodychange",
			"commitMessage": "Upgrade from spdy/2 to spdy/3.\n",
			"commitDate": "2013-01-06, 3:30 PM",
			"commitName": "06579c5bfb6a051a9fbca5be2d15a52fcf77f38c",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-01-01, 7:50 PM",
			"commitNameOld": "689f66222bd8984dd69229a4ee9caf8da528ae12",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 4.82,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,30 +1,34 @@\n     public Connection get(Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n             List<Connection> connections = connectionPool.get(address);\n             while (connections != null) {\n                 Connection connection = connections.get(connections.size() - 1);\n-                if (!connection.isSpdy()) {\n+                boolean usable = connection.isEligibleForRecycling();\n+                if (usable && !connection.isSpdy()) {\n+                    try {\n+                        Platform.get().tagSocket(connection.getSocket());\n+                    } catch (SocketException e) {\n+                        // When unable to tag, skip recycling and close\n+                        Platform.get().logW(\"Unable to tagSocket(): \" + e);\n+                        usable = false;\n+                    }\n+                }\n+\n+                if (!connection.isSpdy() || !usable) {\n                     connections.remove(connections.size() - 1);\n+                    if (connections.isEmpty()) {\n+                        connectionPool.remove(address);\n+                        connections = null;\n+                    }\n                 }\n-                if (connections.isEmpty()) {\n-                    connectionPool.remove(address);\n-                    connections = null;\n-                }\n-                if (!connection.isEligibleForRecycling()) {\n+\n+                if (usable) {\n+                    return connection;\n+                } else {\n                     Util.closeQuietly(connection);\n-                    continue;\n                 }\n-                try {\n-                    Platform.get().tagSocket(connection.getSocket());\n-                } catch (SocketException e) {\n-                    // When unable to tag, skip recycling and close\n-                    Platform.get().logW(\"Unable to tagSocket(): \" + e);\n-                    Util.closeQuietly(connection);\n-                    continue;\n-                }\n-                return connection;\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"689f66222bd8984dd69229a4ee9caf8da528ae12": {
			"type": "Ybodychange",
			"commitMessage": "Flatten internal packages and utility classes.\n\nThe previous structure had hierarchy that was useful\nfor libcore but overkill for OkHttp.\n",
			"commitDate": "2013-01-01, 7:50 PM",
			"commitName": "689f66222bd8984dd69229a4ee9caf8da528ae12",
			"commitAuthor": "jwilson",
			"commitDateOld": "2012-12-30, 11:35 PM",
			"commitNameOld": "60d5852c6676ece85b0e3d0c6e45fb0186303f83",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 1.84,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,30 +1,30 @@\n     public Connection get(Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n             List<Connection> connections = connectionPool.get(address);\n             while (connections != null) {\n                 Connection connection = connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections = null;\n                 }\n                 if (!connection.isEligibleForRecycling()) {\n-                    IoUtils.closeQuietly(connection);\n+                    Util.closeQuietly(connection);\n                     continue;\n                 }\n                 try {\n                     Platform.get().tagSocket(connection.getSocket());\n                 } catch (SocketException e) {\n                     // When unable to tag, skip recycling and close\n                     Platform.get().logW(\"Unable to tagSocket(): \" + e);\n-                    IoUtils.closeQuietly(connection);\n+                    Util.closeQuietly(connection);\n                     continue;\n                 }\n                 return connection;\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"67604f618d96ae00318ce696ec29a66bec6aafa8": {
			"type": "Ybodychange",
			"commitMessage": "Clean up utility code for submission to AOSP.\n\nThis moves methods that will have Android-specific implementations\nto Platform.java; all other utility methods are in a junk drawer\nclass called Utils.java.\n\nThis also moves method names (like \"GET\") to compare with .equals\ninstead of '=='. The old code took advantage of a hidden agreement\nbetween HttpURLConnection and HttpEngine; with these in separate\nprojects that behavior isn't as obvious and shouldn't be relied\nupon.\n",
			"commitDate": "2012-12-26, 10:31 AM",
			"commitName": "67604f618d96ae00318ce696ec29a66bec6aafa8",
			"commitAuthor": "jwilson",
			"commitDateOld": "2012-12-23, 9:39 PM",
			"commitNameOld": "78c6624b11d5f33504dae8211b4592383468343e",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 2.54,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,25 +1,30 @@\n     public Connection get(Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n             List<Connection> connections = connectionPool.get(address);\n             while (connections != null) {\n                 Connection connection = connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections = null;\n                 }\n-                if (connection.isEligibleForRecycling()) {\n-                    // Since Socket is recycled, re-tag before using\n-                    // TODO: don't tag SPDY connections\n-                    Libcore.tagSocket(connection.getSocket());\n-                    return connection;\n-                } else {\n-                    // TODO: is the connection leaked here?\n+                if (!connection.isEligibleForRecycling()) {\n+                    IoUtils.closeQuietly(connection);\n+                    continue;\n                 }\n+                try {\n+                    Platform.get().tagSocket(connection.getSocket());\n+                } catch (SocketException e) {\n+                    // When unable to tag, skip recycling and close\n+                    Platform.get().logW(\"Unable to tagSocket(): \" + e);\n+                    IoUtils.closeQuietly(connection);\n+                    continue;\n+                }\n+                return connection;\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"78c6624b11d5f33504dae8211b4592383468343e": {
			"type": "Ymultichange(Yfilerename,Yreturntypechange,Ybodychange,Yparameterchange)",
			"commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
			"commitDate": "2012-12-23, 9:39 PM",
			"commitName": "78c6624b11d5f33504dae8211b4592383468343e",
			"commitAuthor": "jwilson",
			"subchanges": [
				{
					"type": "Yfilerename",
					"commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
					"commitDate": "2012-12-23, 9:39 PM",
					"commitName": "78c6624b11d5f33504dae8211b4592383468343e",
					"commitAuthor": "jwilson",
					"commitDateOld": "2012-12-23, 1:38 PM",
					"commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
					"commitAuthorOld": "Jake Wharton",
					"daysBetweenCommits": 0.33,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,25 +1,25 @@\n-    public HttpConnection get(HttpConnection.Address address) {\n+    public Connection get(Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n-            List<HttpConnection> connections = connectionPool.get(address);\n+            List<Connection> connections = connectionPool.get(address);\n             while (connections != null) {\n-                HttpConnection connection = connections.get(connections.size() - 1);\n+                Connection connection = connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections = null;\n                 }\n                 if (connection.isEligibleForRecycling()) {\n                     // Since Socket is recycled, re-tag before using\n                     // TODO: don't tag SPDY connections\n                     Libcore.tagSocket(connection.getSocket());\n                     return connection;\n                 } else {\n                     // TODO: is the connection leaked here?\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldPath": "src/main/java/com/squareup/okhttp/internal/net/http/HttpConnectionPool.java",
						"newPath": "src/main/java/com/squareup/okhttp/ConnectionPool.java"
					}
				},
				{
					"type": "Yreturntypechange",
					"commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
					"commitDate": "2012-12-23, 9:39 PM",
					"commitName": "78c6624b11d5f33504dae8211b4592383468343e",
					"commitAuthor": "jwilson",
					"commitDateOld": "2012-12-23, 1:38 PM",
					"commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
					"commitAuthorOld": "Jake Wharton",
					"daysBetweenCommits": 0.33,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,25 +1,25 @@\n-    public HttpConnection get(HttpConnection.Address address) {\n+    public Connection get(Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n-            List<HttpConnection> connections = connectionPool.get(address);\n+            List<Connection> connections = connectionPool.get(address);\n             while (connections != null) {\n-                HttpConnection connection = connections.get(connections.size() - 1);\n+                Connection connection = connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections = null;\n                 }\n                 if (connection.isEligibleForRecycling()) {\n                     // Since Socket is recycled, re-tag before using\n                     // TODO: don't tag SPDY connections\n                     Libcore.tagSocket(connection.getSocket());\n                     return connection;\n                 } else {\n                     // TODO: is the connection leaked here?\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "HttpConnection",
						"newValue": "Connection"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
					"commitDate": "2012-12-23, 9:39 PM",
					"commitName": "78c6624b11d5f33504dae8211b4592383468343e",
					"commitAuthor": "jwilson",
					"commitDateOld": "2012-12-23, 1:38 PM",
					"commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
					"commitAuthorOld": "Jake Wharton",
					"daysBetweenCommits": 0.33,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,25 +1,25 @@\n-    public HttpConnection get(HttpConnection.Address address) {\n+    public Connection get(Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n-            List<HttpConnection> connections = connectionPool.get(address);\n+            List<Connection> connections = connectionPool.get(address);\n             while (connections != null) {\n-                HttpConnection connection = connections.get(connections.size() - 1);\n+                Connection connection = connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections = null;\n                 }\n                 if (connection.isEligibleForRecycling()) {\n                     // Since Socket is recycled, re-tag before using\n                     // TODO: don't tag SPDY connections\n                     Libcore.tagSocket(connection.getSocket());\n                     return connection;\n                 } else {\n                     // TODO: is the connection leaked here?\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				},
				{
					"type": "Yparameterchange",
					"commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
					"commitDate": "2012-12-23, 9:39 PM",
					"commitName": "78c6624b11d5f33504dae8211b4592383468343e",
					"commitAuthor": "jwilson",
					"commitDateOld": "2012-12-23, 1:38 PM",
					"commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
					"commitAuthorOld": "Jake Wharton",
					"daysBetweenCommits": 0.33,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,25 +1,25 @@\n-    public HttpConnection get(HttpConnection.Address address) {\n+    public Connection get(Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n-            List<HttpConnection> connections = connectionPool.get(address);\n+            List<Connection> connections = connectionPool.get(address);\n             while (connections != null) {\n-                HttpConnection connection = connections.get(connections.size() - 1);\n+                Connection connection = connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections = null;\n                 }\n                 if (connection.isEligibleForRecycling()) {\n                     // Since Socket is recycled, re-tag before using\n                     // TODO: don't tag SPDY connections\n                     Libcore.tagSocket(connection.getSocket());\n                     return connection;\n                 } else {\n                     // TODO: is the connection leaked here?\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[address-HttpConnection.Address]",
						"newValue": "[address-Address]"
					}
				}
			]
		},
		"70e64037ff295874602133a1d254e5a0440ae4e3": {
			"type": "Ybodychange",
			"commitMessage": "Prepare to promote HttpConnection + Pool to public API.\n\nGiving the application code access to the connection pool\nis tricky: it exposes more implementation details from\nOkHttp; details that are quite inaccessible through the\nconventional HttpURLConnection APIs. Currently the only\nthing regular users get are a pair of awkward system\nproperties.\n\nBut exposing these should also be useful: it'll allow the\napplication to observe the pool (for performance monitoring)\nand possibly also to directly manage it (by setting policy,\nor to evict when the application is paused).\n",
			"commitDate": "2012-12-22, 3:05 PM",
			"commitName": "70e64037ff295874602133a1d254e5a0440ae4e3",
			"commitAuthor": "jwilson",
			"commitDateOld": "2012-12-22, 10:40 AM",
			"commitNameOld": "3d2547f18886e771aaa9baa996a21136c93460c4",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 0.18,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,22 +1,25 @@\n     public HttpConnection get(HttpConnection.Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n             List<HttpConnection> connections = connectionPool.get(address);\n             while (connections != null) {\n                 HttpConnection connection = connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections = null;\n                 }\n                 if (connection.isEligibleForRecycling()) {\n                     // Since Socket is recycled, re-tag before using\n+                    // TODO: don't tag SPDY connections\n                     Libcore.tagSocket(connection.getSocket());\n                     return connection;\n+                } else {\n+                    // TODO: is the connection leaked here?\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3d2547f18886e771aaa9baa996a21136c93460c4": {
			"type": "Ybodychange",
			"commitMessage": "Restore tests for response caching + TLS.\n\nOne of the test cases bitrotted to failure as a consequence\nof the HTTP route selector change. I stopped assigning the\nsocket, which it needed to cache the TLS metadata. This is\nfixed.\n",
			"commitDate": "2012-12-22, 10:40 AM",
			"commitName": "3d2547f18886e771aaa9baa996a21136c93460c4",
			"commitAuthor": "jwilson",
			"commitDateOld": "2012-12-15, 1:55 PM",
			"commitNameOld": "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 6.86,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,23 +1,22 @@\n     public HttpConnection get(HttpConnection.Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n             List<HttpConnection> connections = connectionPool.get(address);\n             while (connections != null) {\n                 HttpConnection connection = connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections = null;\n                 }\n                 if (connection.isEligibleForRecycling()) {\n                     // Since Socket is recycled, re-tag before using\n-                    Socket socket = connection.getSocket();\n-                    Libcore.tagSocket(socket);\n+                    Libcore.tagSocket(connection.getSocket());\n                     return connection;\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d": {
			"type": "Yfilerename",
			"commitMessage": "Move out of the libcore package.\n\nTo promote the code into AOSP, we'll keep this package as-is\nand do the jarjar in Android instead.\n",
			"commitDate": "2012-12-15, 1:55 PM",
			"commitName": "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d",
			"commitAuthor": "jwilson",
			"commitDateOld": "2012-12-15, 1:17 PM",
			"commitNameOld": "7f7aa90bc5d41d8f818fc988d2a91d22393c7329",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/libcore/net/http/HttpConnectionPool.java",
				"newPath": "src/main/java/com/squareup/okhttp/internal/net/http/HttpConnectionPool.java"
			}
		},
		"40ff76547064c3fb5acb9047a6f679dd4379a4d0": {
			"type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
			"commitMessage": "Make HttpConnection.connect return full working connections.\n\nPreviously the returned connections required the caller to\ndo extra work: setting up tunnels (which could require auth)\nand performing an SSL handshake. With this change we make a\ncomplete working connection in HttpConnection.connect().\n\nThis will make it easier to fix fallback when a single domain\nhas multiple IP addresses and some of those addresses are not\nreachable.\n\nThis will also make it easier to do SPDY through HTTP proxies.\n",
			"commitDate": "2012-11-05, 8:25 PM",
			"commitName": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
			"commitAuthor": "Jesse Wilson",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Make HttpConnection.connect return full working connections.\n\nPreviously the returned connections required the caller to\ndo extra work: setting up tunnels (which could require auth)\nand performing an SSL handshake. With this change we make a\ncomplete working connection in HttpConnection.connect().\n\nThis will make it easier to fix fallback when a single domain\nhas multiple IP addresses and some of those addresses are not\nreachable.\n\nThis will also make it easier to do SPDY through HTTP proxies.\n",
					"commitDate": "2012-11-05, 8:25 PM",
					"commitName": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
					"commitAuthor": "Jesse Wilson",
					"commitDateOld": "2012-09-25, 11:29 AM",
					"commitNameOld": "60b3a6dd6240f40c29fffd897c2dac314af49836",
					"commitAuthorOld": "Jesse Wilson",
					"daysBetweenCommits": 41.41,
					"commitsBetweenForRepo": 14,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,29 +1,23 @@\n-    public HttpConnection get(HttpConnection.Address address, int connectTimeout)\n-            throws IOException {\n+    public HttpConnection get(HttpConnection.Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n             List<HttpConnection> connections = connectionPool.get(address);\n             while (connections != null) {\n                 HttpConnection connection = connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections = null;\n                 }\n                 if (connection.isEligibleForRecycling()) {\n                     // Since Socket is recycled, re-tag before using\n                     Socket socket = connection.getSocket();\n                     Libcore.tagSocket(socket);\n                     return connection;\n                 }\n             }\n         }\n-\n-        /*\n-         * We couldn't find a reusable connection, so we need to create a new\n-         * connection. We're careful not to do so while holding a lock!\n-         */\n-        return address.connect(connectTimeout);\n+        return null;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[address-HttpConnection.Address, connectTimeout-int]",
						"newValue": "[address-HttpConnection.Address]"
					}
				},
				{
					"type": "Yexceptionschange",
					"commitMessage": "Make HttpConnection.connect return full working connections.\n\nPreviously the returned connections required the caller to\ndo extra work: setting up tunnels (which could require auth)\nand performing an SSL handshake. With this change we make a\ncomplete working connection in HttpConnection.connect().\n\nThis will make it easier to fix fallback when a single domain\nhas multiple IP addresses and some of those addresses are not\nreachable.\n\nThis will also make it easier to do SPDY through HTTP proxies.\n",
					"commitDate": "2012-11-05, 8:25 PM",
					"commitName": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
					"commitAuthor": "Jesse Wilson",
					"commitDateOld": "2012-09-25, 11:29 AM",
					"commitNameOld": "60b3a6dd6240f40c29fffd897c2dac314af49836",
					"commitAuthorOld": "Jesse Wilson",
					"daysBetweenCommits": 41.41,
					"commitsBetweenForRepo": 14,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,29 +1,23 @@\n-    public HttpConnection get(HttpConnection.Address address, int connectTimeout)\n-            throws IOException {\n+    public HttpConnection get(HttpConnection.Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n             List<HttpConnection> connections = connectionPool.get(address);\n             while (connections != null) {\n                 HttpConnection connection = connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections = null;\n                 }\n                 if (connection.isEligibleForRecycling()) {\n                     // Since Socket is recycled, re-tag before using\n                     Socket socket = connection.getSocket();\n                     Libcore.tagSocket(socket);\n                     return connection;\n                 }\n             }\n         }\n-\n-        /*\n-         * We couldn't find a reusable connection, so we need to create a new\n-         * connection. We're careful not to do so while holding a lock!\n-         */\n-        return address.connect(connectTimeout);\n+        return null;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[IOException]",
						"newValue": "[]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Make HttpConnection.connect return full working connections.\n\nPreviously the returned connections required the caller to\ndo extra work: setting up tunnels (which could require auth)\nand performing an SSL handshake. With this change we make a\ncomplete working connection in HttpConnection.connect().\n\nThis will make it easier to fix fallback when a single domain\nhas multiple IP addresses and some of those addresses are not\nreachable.\n\nThis will also make it easier to do SPDY through HTTP proxies.\n",
					"commitDate": "2012-11-05, 8:25 PM",
					"commitName": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
					"commitAuthor": "Jesse Wilson",
					"commitDateOld": "2012-09-25, 11:29 AM",
					"commitNameOld": "60b3a6dd6240f40c29fffd897c2dac314af49836",
					"commitAuthorOld": "Jesse Wilson",
					"daysBetweenCommits": 41.41,
					"commitsBetweenForRepo": 14,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,29 +1,23 @@\n-    public HttpConnection get(HttpConnection.Address address, int connectTimeout)\n-            throws IOException {\n+    public HttpConnection get(HttpConnection.Address address) {\n         // First try to reuse an existing HTTP connection.\n         synchronized (connectionPool) {\n             List<HttpConnection> connections = connectionPool.get(address);\n             while (connections != null) {\n                 HttpConnection connection = connections.get(connections.size() - 1);\n                 if (!connection.isSpdy()) {\n                     connections.remove(connections.size() - 1);\n                 }\n                 if (connections.isEmpty()) {\n                     connectionPool.remove(address);\n                     connections = null;\n                 }\n                 if (connection.isEligibleForRecycling()) {\n                     // Since Socket is recycled, re-tag before using\n                     Socket socket = connection.getSocket();\n                     Libcore.tagSocket(socket);\n                     return connection;\n                 }\n             }\n         }\n-\n-        /*\n-         * We couldn't find a reusable connection, so we need to create a new\n-         * connection. We're careful not to do so while holding a lock!\n-         */\n-        return address.connect(connectTimeout);\n+        return null;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"ea63463c2ff8a67f63e541036f0d5998b5bb1f3e": {
			"type": "Yintroduced",
			"commitMessage": "Initial import.\n\nThis is a fork of okhttp from http://code.google.com/p/okhttp.\nI'm moving it to Github since that's where my code reviewers\nare. I've renamed the core package from com.google.okhttp to\ncom.squareup.okhttp because Square is where I expect ongoing\ndevelopment of this project to take place.\n\nAll code in this project is subject to be contributed upstream\nto AOSP. In particular, all code in the libcore package is\nderived from AOSP and intended to be contributed back to AOSP\non an ongoing basis.\n",
			"commitDate": "2012-07-23, 7:02 AM",
			"commitName": "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e",
			"commitAuthor": "Jesse Wilson",
			"diff": "@@ -0,0 +1,29 @@\n+    public HttpConnection get(HttpConnection.Address address, int connectTimeout)\n+            throws IOException {\n+        // First try to reuse an existing HTTP connection.\n+        synchronized (connectionPool) {\n+            List<HttpConnection> connections = connectionPool.get(address);\n+            while (connections != null) {\n+                HttpConnection connection = connections.get(connections.size() - 1);\n+                if (!connection.isSpdy()) {\n+                    connections.remove(connections.size() - 1);\n+                }\n+                if (connections.isEmpty()) {\n+                    connectionPool.remove(address);\n+                    connections = null;\n+                }\n+                if (connection.isEligibleForRecycling()) {\n+                    // Since Socket is recycled, re-tag before using\n+                    Socket socket = connection.getSocket();\n+                    Libcore.tagSocket(socket);\n+                    return connection;\n+                }\n+            }\n+        }\n+\n+        /*\n+         * We couldn't find a reusable connection, so we need to create a new\n+         * connection. We're careful not to do so while holding a lock!\n+         */\n+        return address.connect(connectTimeout);\n+    }\n\\ No newline at end of file\n"
		}
	},
	"sha": "5224f3045ba9b171fce521777edf389f9206173c"
}