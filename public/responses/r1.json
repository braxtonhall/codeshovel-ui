{
  "repo": "https://github.com/kiegroup/drools.git",
  "files": [
    "drools-compiler/src/test/resources/org/drools/compiler/factmodel/SimpleEnum.java",
    "drools-compiler/src/test/java/org/acme/sensors/SensorReading.java",
    "drools-compiler/src/test/java/org/acme/healthcare/Exception.java",
    "drools-compiler/src/test/java/org/acme/healthcare/Claim.java",
    "drools-compiler/src/test/java/org/acme/insurance/Driver.java",
    "drools-compiler/src/test/java/org/acme/insurance/Rejection.java",
    "drools-compiler/src/test/java/org/acme/insurance/Approve.java",
    "drools-compiler/src/test/java/org/acme/insurance/Policy.java",
    "drools-compiler/src/test/java/org/drools/compiler/FirstClass.java",
    "drools-compiler/src/test/java/org/drools/compiler/beliefsystem/defeasible/DefeasibilityTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/beliefsystem/jtms/JTMSTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/beliefsystem/abductive/AbductionTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/Message.java",
    "drools-compiler/src/test/java/org/drools/compiler/Bin.java",
    "drools-compiler/src/test/java/org/drools/compiler/MockPersistentSet.java",
    "drools-compiler/src/test/java/org/drools/compiler/LongAddress.java",
    "drools-compiler/src/test/java/org/drools/compiler/OuterFact.java",
    "drools-compiler/src/test/java/org/drools/compiler/I18nPerson.java",
    "drools-compiler/src/test/java/org/drools/compiler/Order.java",
    "drools-compiler/src/test/java/org/drools/compiler/kproject/memory/MemoryURLConnection.java",
    "drools-compiler/src/test/java/org/drools/compiler/kproject/memory/MemorytURLStreamHandler.java",
    "drools-compiler/src/test/java/org/drools/compiler/kproject/memory/MemoryFolderTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/kproject/memory/MemoryFileTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/kproject/ReleaseIdTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/OOPathCastTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/graph/OOPathOnGraphTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/graph/Vertex.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/graph/Edge.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/OOPathMultilevelTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/OOPathAccumulateTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/OOPathBenchmarkTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/OOPathBindTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/Room.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/Woman.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/School.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/Child.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/TMDirectory.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/Group.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/Disease.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/Thing.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/Man.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/BabyBoy.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/Person.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/SensorEvent.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/TMFileWithParentObj.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/TMFile.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/BodyMeasurement.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/Adult.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/Company.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/Toy.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/TMFileSet.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/Appliance.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/Sensor.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/Employee.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/model/BabyGirl.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/OOPathTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/RecursiveQueryBenchmark.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/OOPathQueriesTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/oopath/OOPathReactiveTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/NodeHashingTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/Cheesery.java",
    "drools-compiler/src/test/java/org/drools/compiler/OrderItem.java",
    "drools-compiler/src/test/java/org/drools/compiler/PersonHolder.java",
    "drools-compiler/src/test/java/org/drools/compiler/EmergencyTeam.java",
    "drools-compiler/src/test/java/org/drools/compiler/Child.java",
    "drools-compiler/src/test/java/org/drools/compiler/DomainObject.java",
    "drools-compiler/src/test/java/org/drools/compiler/PersonFinal.java",
    "drools-compiler/src/test/java/org/drools/compiler/SecondClass.java",
    "drools-compiler/src/test/java/org/drools/compiler/test/Man.java",
    "drools-compiler/src/test/java/org/drools/compiler/test/Person.java",
    "drools-compiler/src/test/java/org/drools/compiler/test/PositionalTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/PersonInterface.java",
    "drools-compiler/src/test/java/org/drools/compiler/CommonTestMethodBase.java",
    "drools-compiler/src/test/java/org/drools/compiler/Process.java",
    "drools-compiler/src/test/java/org/drools/compiler/util/debug/SessionInspectorTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/util/debug/DebugList.java",
    "drools-compiler/src/test/java/org/drools/compiler/Interval.java",
    "drools-compiler/src/test/java/org/drools/compiler/TotalHolder.java",
    "drools-compiler/src/test/java/org/drools/compiler/SpecialString.java",
    "drools-compiler/src/test/java/org/drools/compiler/commons/jci/compilers/JavaCompilerI18NTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/commons/jci/compilers/NativeJavaCompilerSettingsTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/TestEnum.java",
    "drools-compiler/src/test/java/org/drools/compiler/Pet.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/LogicalTraitTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/StandaloneTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/Imp2.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/TraitFieldsAndLegacyClassesTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/SomeInterface.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/IStudent.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/LegacyTraitTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/DoSomethingProxy.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/PojoFact.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/ISomethingWithBehaviour.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/StudentImpl.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/Imp.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/StudentProxy3.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/TraitMapCoreTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/SomethingImpl.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/TraitTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/ImpCoreWrapper.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/StudentProxy2.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/SomeClass.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/StudentProxyWrapper3.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/IPerson.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/IDoSomething.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/IRole.java",
    "drools-compiler/src/test/java/org/drools/compiler/factmodel/traits/StudentProxyWrapper2.java",
    "drools-compiler/src/test/java/org/drools/compiler/MyUtil.java",
    "drools-compiler/src/test/java/org/drools/compiler/YoungestFather.java",
    "drools-compiler/src/test/java/org/drools/compiler/Option.java",
    "drools-compiler/src/test/java/org/drools/compiler/FactA.java",
    "drools-compiler/src/test/java/org/drools/compiler/runtime/pipeline/impl/DroolsJaxbHelperTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/InsertedObject.java",
    "drools-compiler/src/test/java/org/drools/compiler/Neighbor.java",
    "drools-compiler/src/test/java/org/drools/compiler/Triangle.java",
    "drools-compiler/src/test/java/org/drools/compiler/ReviseTraitTestWithPRAlwaysCategory.java",
    "drools-compiler/src/test/java/org/drools/compiler/NestedAccessorsTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/simulation/SimulateTestBase.java",
    "drools-compiler/src/test/java/org/drools/compiler/simulation/BatchRunFluentTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/simulation/BatchRunUnitFluentTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/LegacyBean.java",
    "drools-compiler/src/test/java/org/drools/compiler/reteoo/MockRightTupleSink.java",
    "drools-compiler/src/test/java/org/drools/compiler/reteoo/ReteooBuilderPerformanceTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/reteoo/MockLeftTupleSink.java",
    "drools-compiler/src/test/java/org/drools/compiler/reteoo/ReteooBuilderTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/B.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/PhreakJoinNodeTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/Pair.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/C.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/PhreakNotNodeTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/Scenario.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/D.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/E.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/PhreakLiaNodeTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/ReteTesterHelper.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/LeftBuilder.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/BaseLeftTuplesBuilder.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/RemoveRuleTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/LeftMemory.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/StagedBuilder.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/AddRuleTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/RightMemory.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/ScenarioTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/RightBuilder.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/BetaNodeBuilder.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/A.java",
    "drools-compiler/src/test/java/org/drools/compiler/phreak/SegmentPropagationTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/BinTask.java",
    "drools-compiler/src/test/java/org/drools/compiler/Bar.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/JittingTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/NodePositionInPathTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/Query3Test.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/Query2Test.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/FailureOnRemovalTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/DynamicRuleLoadTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/TestFact.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/SerializedPackageMergeTwoSteps2Test.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/IteratorToList.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/DateComparisonTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/FireUntilHaltAccumulateTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/TypeDeclarationTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/GeneratedBeansTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/DateCoercionTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/ShadowProxyTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/waltz/Stage.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/waltz/WaltzMain.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/waltz/ReteOOWaltzTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/waltz/Junction.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/waltz/Waltz.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/waltz/WaltzUtil.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/waltz/Edge.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/waltz/Line.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/EnumTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/KnowledgeBuilderTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/DynamicRuleRemovalTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/RuleUnitCoordinationTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/JBRULESTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/KieContainerTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/NullCheckOnExistentialNodeTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/KieRepositoryTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/MergePackageTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/ExecutionFlowControlTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/RuleExtensionTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/SerializationHelper.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/PolymorphismTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/KieSessionIterationTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/KieCompilationCacheTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/DeclarativeAgendaTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/StatelessStressTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/NewLineAtEoFTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/DynamicRulesChangesTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/ParserTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/FunctionsTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/StrictAnnotationTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/KieLoggersTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/NodesPartitioningTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/StrEvaluatorTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/TestObject.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/KieServicesTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/marshalling/MarshallingIssuesTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/marshalling/MarshallingTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/marshalling/util/OldOutputMarshallerMethods.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/marshalling/InputStreamMarkResetTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/marshalling/FactHandleMarshallingTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/DroolsEventList.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/PropertyReactivityTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/OutOfMemoryTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/KnowledgeContextTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/RuleExecutionTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/QueryCepFireUntilHaltTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/sequential/SequentialTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/SegmentMemoryPrototypeTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/SwitchOverStringTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/MBeansMonitoringTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/eventgenerator/SimpleEventGeneratorTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/eventgenerator/example/Status.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/eventgenerator/example/ProductionEvent.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/eventgenerator/example/FailureEvent.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/eventgenerator/example/Resource.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/eventgenerator/example/HeartbeatEvent.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/eventgenerator/example/Tools.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/eventgenerator/example/SlidingWindow.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/eventgenerator/example/ExampleScenario.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/eventgenerator/example/StatusChangedEvent.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/eventgenerator/AbstractEventListener.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/eventgenerator/Event.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/eventgenerator/SimpleEventListener.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/eventgenerator/PseudoSessionClock.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/eventgenerator/SimpleEventGenerator.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/TemporalOperatorTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/UnlinkingTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/DynamicEvalTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/NamedConsequencesTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/MapConstraintTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/WorkingMemoryLoggerTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/PropertySpecificTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/NullSafeDereferencingTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/DroolsFromRHSTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/PseudoClockEventsTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/SeveralKieSessionsTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/MessageImplTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/ObjectTypeNodeTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/LifecycleTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/concurrency/MultithreadTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/concurrency/AbstractConcurrentInsertionsTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/concurrency/AbstractConcurrentTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/concurrency/BasicConcurrentInsertionsTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/concurrency/ConcurrentInsertionsToSubnetworksTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/concurrency/SubnetworkConcurrentSessionsTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/concurrency/JoinsConcurrentSessionsTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/concurrency/SharedSessionParallelTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/concurrency/ConcurrentBasesParallelTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/concurrency/DataTypeEvaluationConcurrentSessionsTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/concurrency/EnumEvaluationConcurrentSessionsTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/PassiveQueryTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/TruthMaintenanceTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/MatchTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/QueryTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/ParallelCompilationTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/SerializationSecurityPolicyTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/DynamicRulesTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/Misc2Test.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/NullTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/FireAllRulesCommandTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/FirstOrderLogicTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/FireUntilHaltTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/EnableAuditLogCommandTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/MTEntryPointsTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/QueryCepTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/KieHelloWorldTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/DslTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/UnmarshallingTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/FactHandleSerializationTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/ListenersTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/ExistentialOperatorTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/DroolsTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/VarargsTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/MVELTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/XSDResourceTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/I18nTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/SecurityPolicyTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/SerializedPackageMergeTwoSteps1Test.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/TreeTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/EventAccessorRestoreTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/ExtendsTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/WindowTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/LinkingTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/KieDefaultPackageTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/ParallelBuildTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/ChildFact4WithFirings.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/FactWithDouble.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/FactWithBoolean.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/AnEnum.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/FactWithFloat.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/FactWithEnum.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/BeanA.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/InterfaceA.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/ClassA.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/ChildFact3WithEnum.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/CategoryTypeEnum.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/FactWithBigDecimal.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/Product.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/FactWithShort.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/ChildFact1.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/AFact.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/FactWithCharacter.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/RootFact.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/ChildFact2.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/BasicEvent.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/FactWithLong.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/BeanB.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/InterfaceB.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/FactWithInteger.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/ClassB.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/FactWithString.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/FactWithList.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/TestEvent.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/facts/FactWithByte.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/KieBuilderTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/QueryInRHSCepTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/PropertyReactivityBlockerTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/PathEndNodeTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/ParallelEvaluationTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/LengthSlidingWindowTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/KieBaseIncludesTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/DRLDumperTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/HelloWorldTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/PackageProtected.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/DroolsEventListTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/IntegrationInterfacesTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/SegmentCreationTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/KieRuntimeTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/RuleMetadataTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/SerializedPackageMergeTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/RuleEventListenerTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/WorkingMemoryActionsSerializationTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/PhreakConcurrencyTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/ExpirationTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/session/EntryPointTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/session/FieldAccessTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/session/SessionsPoolTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/session/StatefulSessionTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/session/InsertTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/session/BasicUpdateTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/session/AgendaFilterTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/session/CrossProductTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/session/RuleRuntimeEventTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/session/LocaleTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/session/DeleteTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/session/StatelessSessionTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/session/UpdateTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/session/TypeCoercionTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/integrationtests/LargeRuleBase.java",
    "drools-compiler/src/test/java/org/drools/compiler/ScenarioType.java",
    "drools-compiler/src/test/java/org/drools/compiler/Address.java",
    "drools-compiler/src/test/java/org/drools/compiler/Foo.java",
    "drools-compiler/src/test/java/org/drools/compiler/rule/builder/dialect/JavaAndMVELCombinedTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/rule/builder/dialect/asm/ClassGeneratorTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/rule/builder/dialect/asm/InvokerGeneratorTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/rule/builder/dialect/mvel/MVELDebugTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/rule/builder/dialect/mvel/MVELEvalBuilderTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/rule/builder/dialect/mvel/InstrumentedDeclarationScopeResolver.java",
    "drools-compiler/src/test/java/org/drools/compiler/rule/builder/dialect/mvel/MVELAccumulateBuilderTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/rule/builder/dialect/mvel/MVELSalienceBuilderTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/rule/builder/dialect/mvel/MVELExprAnalyzerTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/rule/builder/dialect/mvel/MVELConsequenceBuilderTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/rule/builder/dialect/java/JavaAccumulateBuilderTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/rule/builder/dialect/java/KnowledgeHelperFixerTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/rule/builder/dialect/java/AccumulateTemplateTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/rule/builder/dialect/java/RuleBuilderTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/rule/builder/dialect/java/JavaDialectBinaryEqualityTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/rule/builder/dialect/java/AsmGeneratorTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/rule/builder/dialect/java/JavaConsequenceBuilderTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/rule/builder/dialect/java/JavaConsequenceBuilderPRAlwaysTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/rule/builder/dialect/java/JavaDialectTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/rule/builder/dialect/java/JavaExprAnalyzerTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/rule/builder/XpathAnalysisTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/InlineCastTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/Worker.java",
    "drools-compiler/src/test/java/org/drools/compiler/lang/Tree2TestDRL.java",
    "drools-compiler/src/test/java/org/drools/compiler/lang/ErrorsParserTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/lang/DRLContextTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/lang/DRLIncompleteCodeTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/lang/TestDRL.java",
    "drools-compiler/src/test/java/org/drools/compiler/lang/RuleParserTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/lang/DRLExprParserTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/lang/DroolsSoftKeywordsTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/lang/MVELDumperTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/lang/MockExpander.java",
    "drools-compiler/src/test/java/org/drools/compiler/lang/MockExpanderResolver.java",
    "drools-compiler/src/test/java/org/drools/compiler/lang/api/DescrBuilderTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/lang/descr/ConnectiveDescrTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/lang/descr/PackageDescrTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/lang/descr/AndDescrTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/lang/dsl/ANTLRDSLTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/lang/dsl/DSLTokenizedMappingFileTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/lang/dsl/DefaultExpanderTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/lang/dsl/DSLMappingFileTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/lang/dsl/DSLMappingEntryTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/Func.java",
    "drools-compiler/src/test/java/org/drools/compiler/RoutingMessage.java",
    "drools-compiler/src/test/java/org/drools/compiler/common/MarshallerTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/common/TerminalNodeIteratorTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/common/ActiveActivationsIteratorTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/common/ActivationIteratorTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/Cheese.java",
    "drools-compiler/src/test/java/org/drools/compiler/FactC.java",
    "drools-compiler/src/test/java/org/drools/compiler/StockTickInterface.java",
    "drools-compiler/src/test/java/org/drools/compiler/Person.java",
    "drools-compiler/src/test/java/org/drools/compiler/FromTestClass.java",
    "drools-compiler/src/test/java/org/drools/compiler/PolymorphicFact.java",
    "drools-compiler/src/test/java/org/drools/compiler/StockTick.java",
    "drools-compiler/src/test/java/org/drools/compiler/Win.java",
    "drools-compiler/src/test/java/org/drools/compiler/StaticMethods.java",
    "drools-compiler/src/test/java/org/drools/compiler/GrandParent.java",
    "drools-compiler/src/test/java/org/drools/compiler/Approach.java",
    "drools-compiler/src/test/java/org/drools/compiler/CheeseEqual.java",
    "drools-compiler/src/test/java/org/drools/compiler/FactB.java",
    "drools-compiler/src/test/java/org/drools/compiler/Cat.java",
    "drools-compiler/src/test/java/org/drools/compiler/api/KnowledgeBuilderTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/api/KnowledgeSessionTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/Close.java",
    "drools-compiler/src/test/java/org/drools/compiler/IndexedNumber.java",
    "drools-compiler/src/test/java/org/drools/compiler/Precondition.java",
    "drools-compiler/src/test/java/org/drools/compiler/Parent.java",
    "drools-compiler/src/test/java/org/drools/compiler/Attribute.java",
    "drools-compiler/src/test/java/org/drools/compiler/command/PropagationListTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/command/MoreBatchExecutionTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/command/RegisterWorkItemHandlerTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/command/SimpleBatchExecutionTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/command/DisposeCommandPublicAPITest.java",
    "drools-compiler/src/test/java/org/drools/compiler/TestUtil.java",
    "drools-compiler/src/test/java/org/drools/compiler/StockTickEvent.java",
    "drools-compiler/src/test/java/org/drools/compiler/MockPersistentSetException.java",
    "drools-compiler/src/test/java/org/drools/compiler/State.java",
    "drools-compiler/src/test/java/org/drools/compiler/Move.java",
    "drools-compiler/src/test/java/org/drools/compiler/Target.java",
    "drools-compiler/src/test/java/org/drools/compiler/OuterClass.java",
    "drools-compiler/src/test/java/org/drools/compiler/testframework/DumbFact.java",
    "drools-compiler/src/test/java/org/drools/compiler/testframework/MockFactHandle.java",
    "drools-compiler/src/test/java/org/drools/compiler/testframework/FactPopulatorTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/testframework/RuleCoverageListenerTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/StaticMethods2.java",
    "drools-compiler/src/test/java/org/drools/compiler/definitions/KnowledgePackageMetaDataTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/builder/impl/KnowledgeBuilderConfigurationImplTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/builder/impl/KnowledgeBuilderTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/builder/impl/KnowledgeBuilderImplTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/builder/impl/KnowledgeBuilderWithSecurityManagerTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/builder/impl/KieFileSystemScannerTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/builder/KnowledgeBuilderConfigurationTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/builder/KieBuilderTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/kie/util/ChangeSetBuilderTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/kie/builder/impl/KieFileSystemImplTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/kie/builder/impl/ClasspathKieProjectTransformUrlToFileSystemPathTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/kie/builder/impl/KieBuilderSetImplTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/kie/builder/impl/MemoryKieModuleResourceProviderTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/kie/builder/impl/KieModuleRepoTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/kie/builder/DslExpansionTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/kie/builder/WireChannelTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/kie/builder/WireListenerTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/conf/KnowledgeSessionConfigurationTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/conf/KnowledgeBaseConfigurationTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/ObjectWithSet.java",
    "drools-compiler/src/test/java/org/drools/compiler/Alarm.java",
    "drools-compiler/src/test/java/org/drools/compiler/Car.java",
    "drools-compiler/src/test/java/org/drools/compiler/compiler/DescrResourceSetTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/compiler/CompilerPerfProfileTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/compiler/TypeDeclarationTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/compiler/RuleErrorTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/compiler/RuleFlowErrorTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/compiler/TypeDeclarationMergingTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/compiler/io/memory/MemoryFileSystemTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/compiler/PackageDescrResourceVisitor.java",
    "drools-compiler/src/test/java/org/drools/compiler/compiler/IB.java",
    "drools-compiler/src/test/java/org/drools/compiler/compiler/xml/changeset/ChangeSetTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/compiler/xml/rules/DumperTestHelper.java",
    "drools-compiler/src/test/java/org/drools/compiler/compiler/xml/rules/DumperTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/compiler/xml/rules/XmlPackageReaderTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/compiler/CImpl.java",
    "drools-compiler/src/test/java/org/drools/compiler/compiler/IA.java",
    "drools-compiler/src/test/java/org/drools/compiler/compiler/PackageBuilderConfigurationTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/compiler/DrlParserTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/compiler/QueryBuilderTest.java",
    "drools-compiler/src/test/java/org/drools/compiler/compiler/DImpl.java",
    "drools-compiler/src/test/java/org/drools/compiler/Father.java",
    "drools-compiler/src/test/java/org/drools/compiler/Cell.java",
    "drools-compiler/src/test/java/org/drools/compiler/Primitives.java",
    "drools-compiler/src/test/java/org/drools/compiler/ChildHolder.java",
    "drools-compiler/src/test/java/org/drools/compiler/Sensor.java",
    "drools-compiler/src/test/java/org/drools/compiler/MemoryLeakTest.java",
    "drools-compiler/src/main/java/org/drools/compiler/kproject/models/ListenerModelImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/kproject/models/ChannelModelImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/kproject/models/QualifierModelImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/kproject/models/RuleTemplateModelImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/kproject/models/KieBaseModelImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/kproject/models/KieSessionModelImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/kproject/models/WorkItemHandlerModelImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/kproject/models/FileLoggerModelImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/kproject/models/KieModuleModelImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/kproject/ReleaseIdImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/commons/jci/stores/ResourceStore.java",
    "drools-compiler/src/main/java/org/drools/compiler/commons/jci/problems/CompilationProblemHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/commons/jci/readers/DiskResourceReader.java",
    "drools-compiler/src/main/java/org/drools/compiler/commons/jci/readers/MemoryResourceReader.java",
    "drools-compiler/src/main/java/org/drools/compiler/commons/jci/readers/ResourceReader.java",
    "drools-compiler/src/main/java/org/drools/compiler/commons/jci/compilers/JavaCompilerFactory.java",
    "drools-compiler/src/main/java/org/drools/compiler/commons/jci/compilers/JaninoJavaCompilerSettings.java",
    "drools-compiler/src/main/java/org/drools/compiler/commons/jci/compilers/JaninoCompilationProblem.java",
    "drools-compiler/src/main/java/org/drools/compiler/commons/jci/compilers/NativeJavaCompilerSettings.java",
    "drools-compiler/src/main/java/org/drools/compiler/commons/jci/compilers/EclipseCompilationProblem.java",
    "drools-compiler/src/main/java/org/drools/compiler/commons/jci/compilers/EclipseJavaCompiler.java",
    "drools-compiler/src/main/java/org/drools/compiler/commons/jci/compilers/NativeCompilationProblem.java",
    "drools-compiler/src/main/java/org/drools/compiler/commons/jci/compilers/JavaCompilerSettings.java",
    "drools-compiler/src/main/java/org/drools/compiler/commons/jci/compilers/CompilationResult.java",
    "drools-compiler/src/main/java/org/drools/compiler/commons/jci/compilers/JaninoJavaCompiler.java",
    "drools-compiler/src/main/java/org/drools/compiler/commons/jci/compilers/AbstractJavaCompiler.java",
    "drools-compiler/src/main/java/org/drools/compiler/commons/jci/compilers/EclipseJavaCompilerSettings.java",
    "drools-compiler/src/main/java/org/drools/compiler/commons/jci/compilers/NativeJavaCompiler.java",
    "drools-compiler/src/main/java/org/drools/compiler/commons/jci/compilers/JavaCompiler.java",
    "drools-compiler/src/main/java/org/drools/compiler/osgi/Activator.java",
    "drools-compiler/src/main/java/org/drools/compiler/runtime/pipeline/impl/DroolsJaxbHelperProviderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/management/KieContainerMonitor.java",
    "drools-compiler/src/main/java/org/drools/compiler/reteoo/compiled/ObjectTypeNodeCompiler.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/PredicateBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/MVELConstraintBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/ConsequenceBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/AccumulateBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/EnabledBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/QueryElementBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/util/PackageBuilderUtil.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/util/AccumulateUtil.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/util/AnnotationFactory.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/QueryBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/RuleBuildContext.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/NamedConsequenceBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/ConditionalBranchBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/EntryPointBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/DefaultConstraintBuilderFactory.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/ReturnValueBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/RuleBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/WindowReferenceBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/PatternBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/DroolsCompilerComponentFactory.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/ConstraintBuilderFactory.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/GroupElementBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/RuleConditionBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/ForallBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/FromBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/FunctionBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/asm/InvokerContext.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/asm/ASMConsequenceBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/asm/InvokerGenerator.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/asm/ASMConsequenceStubBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/asm/AbstractASMEvalBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/asm/ASMEvalStubBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/asm/AbstractASMReturnValueBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/asm/ASMPredicateStubBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/asm/AbstractASMConsequenceBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/asm/AbstractASMPredicateBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/asm/ASMReturnValueStubBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/mvel/MVELSalienceBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/mvel/MVELFromBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/mvel/MVELConsequenceBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/mvel/MVELEvalBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/mvel/MVELDialect.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/mvel/MVELReturnValueBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/mvel/MVELExprAnalyzer.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/mvel/MVELDialectConfiguration.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/mvel/MVELObjectExpressionBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/mvel/MVELAccumulateBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/mvel/MVELAnalysisResult.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/mvel/MVELEnabledBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/DialectSession.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/KnowledgeHelperFixer.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/JavaDialectConfiguration.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/JavaDialect.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/parser/JavaThrowBlockDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/parser/JavaIfBlockDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/parser/JavaElseBlockDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/parser/JavaExitPointsDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/parser/AbstractJavaContainerBlockDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/parser/JavaFinalBlockDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/parser/JavaInterfacePointsDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/parser/JavaTryBlockDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/parser/JavaCatchBlockDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/parser/JavaLexer.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/parser/JavaStatementBlockDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/parser/JavaWhileBlockDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/parser/JavaBlockDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/parser/JavaForBlockDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/parser/JavaModifyBlockDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/parser/JavaParser.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/parser/JavaLocalDeclarationDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/parser/AbstractJavaBlockDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/parser/JavaContainerBlockDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/parser/JavaRootBlockDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/JavaFunctionBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/PackageStore.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/JavaExprAnalyzer.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/JavaAnalysisResult.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/JavaAccumulateBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/JavaDialectSession.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/JavaDialectError.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/JavaRuleBuilderHelper.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/java/JavaRuleClassBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/DialectError.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/dialect/DialectUtil.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/CollectBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/ConstraintBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/RuleClassBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/PackageBuildContext.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/SalienceBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/EngineElementBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/rule/builder/XpathAnalysis.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DroolsEditorType.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DroolsMissingTokenException.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/AbstractDRLLexer.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DRL6Parser.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DRLParser.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DroolsMismatchedSetException.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DroolsTree.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/ExpressionRewriter.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DRL6Expressions.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/Expander.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DRLLexer.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DroolsUnexpectedAnnotationException.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/ParserHelper.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DroolsSentence.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DroolsParserExceptionFactory.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DroolsMismatchedTokenException.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DRL6Lexer.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DroolsToken.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/ParseException.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/GeneralParseException.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DRL6StrictParser.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DRL5Expressions.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/MVELDumper.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/AbstractDRLParser.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DrlDumper.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DRL5Lexer.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/ExpanderResolver.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/Location.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/WindowDeclarationDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/AttributeDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/AccumulateDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/GlobalDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/DeclareDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/NamedConsequenceDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/AnnotationDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/FunctionDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/PatternDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/EvalDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/PackageDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/AccumulateImportDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/BehaviorDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/CollectDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/CEDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/QueryDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/TypeDeclarationDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/ForallDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/RuleDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/ConditionalBranchDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/SourceDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/ImportDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/EntryPointDeclarationDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/EnumLiteralDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/UnitDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/BaseDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/EnumDeclarationDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/impl/FieldDescrBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/EnumDeclarationDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/ForallDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/AnnotatedDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/DeclareDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/FunctionDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/AttributeDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/CollectDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/PackageDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/AccumulateImportDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/NamedConsequenceDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/TypeDeclarationDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/WindowDeclarationDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/AbstractClassTypeDeclarationBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/UnitDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/EvalDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/BehaviorDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/ConditionalBranchDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/DescrFactory.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/ImportDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/ParameterSupportBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/AttributeSupportBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/EntryPointDeclarationDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/RuleDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/PatternContainerDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/GlobalDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/FieldDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/DescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/QueryDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/EnumLiteralDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/SourceDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/AccumulateDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/AnnotationDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/PatternDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/api/CEDescrBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DRLExpressions.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DroolsSentenceType.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DRL5Parser.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/MultiPatternDestinationDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/EnumDeclarationDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/FieldTemplateDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/Restriction.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/ConnectiveType.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/BaseDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/RestrictionDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/CompositePackageDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/DeclarativeInvokerDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/EntryPointDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/PatternDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/FieldConstraintDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/WindowDeclarationDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/VariableRestrictionDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/WindowReferenceDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/PredicateDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/ImportDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/EntryPointDeclarationDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/ForFunctionDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/PackageDescrDumper.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/AbstractClassTypeDeclarationDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/FromDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/AccumulateImportDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/AnnotationDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/FunctionImportDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/ConditionalBranchDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/FactTemplateDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/ReturnValueRestrictionDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/AnnotatedBaseDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/ProcessDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/LiteralRestrictionDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/GlobalDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/FunctionDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/PackageDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/AndDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/RelationalExprDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/ExistsDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/ExprConstraintDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/QualifiedName.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/EvaluatorBasedRestrictionDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/NotDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/QueryDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/OrDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/AtomicExprDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/QualifiedIdentifierRestrictionDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/EvalDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/ActionDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/ConditionalElementDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/MVELExprDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/EnumLiteralDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/DescrVisitor.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/OperatorDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/PatternDestinationDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/ConnectiveDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/RestrictionConnectiveDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/BindingDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/CollectDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/NamedConsequenceDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/TypeFieldDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/ConstraintConnectiveDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/AccumulateDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/BehaviorDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/TypeDeclarationDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/RuleDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/ForallDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/ExpressionDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/PatternSourceDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/AttributeDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/UnitDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/AccessorDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/descr/LiteralDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/ExpanderException.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DroolsParaphraseTypes.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/dsl/MappingError.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/dsl/AntlrDSLMappingEntry.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/dsl/DefaultExpanderResolver.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/dsl/DSLMappingEntry.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/dsl/DSLMapLexer.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/dsl/DSLMappingParseException.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/dsl/DSLMapWalker.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/dsl/DefaultDSLMapping.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/dsl/DSLMapParser.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/dsl/DSLMapping.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/dsl/DSLTokenizedMappingFile.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/dsl/DefaultExpander.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/dsl/AbstractDSLMappingEntry.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/dsl/DSLMappingFile.java",
    "drools-compiler/src/main/java/org/drools/compiler/lang/DroolsSoftKeywords.java",
    "drools-compiler/src/main/java/org/drools/compiler/testframework/RuleCoverageListener.java",
    "drools-compiler/src/main/java/org/drools/compiler/testframework/TestingEventListener.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/KnowledgeBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/TypeDeclarationNameResolver.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/KnowledgeTypeManager.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/TypeDeclarationConfigurator.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/TypeDeclarationCache.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/TypeDeclarationUtils.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/CompositeKnowledgeBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/ClassDefinitionFactory.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/ClassHierarchyManager.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/TypeDefinition.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/KnowledgeBuilderConfigurationImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/TypeDeclarationBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/ResourceBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/DeclaredClassBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/errors/SrcError.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/errors/FunctionErrorHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/errors/MissingImplementationException.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/errors/RuleInvokerErrorHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/errors/SrcErrorHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/errors/ErrorHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/errors/RuleErrorHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/TypeDeclarationFactory.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/impl/KnowledgeBuilderFactoryServiceImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/ResourceProcessor.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/AbstractAssemblerService.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/DroolsAssemblerContext.java",
    "drools-compiler/src/main/java/org/drools/compiler/builder/AbstractResourceProcessor.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/util/ReflectionBeanCreator.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/util/ChangeSetBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/util/BeanCreator.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/util/KieJarChangeSet.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/util/MVELBeanCreator.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/util/InjectionHelper.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/KieBuilderSetImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/KieContainerImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/KieRepositoryImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/KieBaseUpdater.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/MemoryKieModule.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/ResultsImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/InternalKieModuleProvider.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/DrlProject.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/AbstractKieScanner.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/KieModuleKieProject.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/KnowledgePackagesBuildResult.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/KieBaseUpdateContext.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/AbstractKieModule.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/KieServicesImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/KieModuleCache.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/KieProject.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/KieModuleCacheHelper.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/ClasspathKieProject.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/InternalKieModule.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/KieFileSystemImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/ZipKieModule.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/InternalKieScanner.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/AbstractKieProject.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/FileKieModule.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/event/KieScannerStatusChangeEventImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/event/KieScannerUpdateResultsEventImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/event/KieScannerEventSupport.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/event/KieServicesEventListerner.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/event/KieModuleDiscovered.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/event/AbstractKieServicesEventListerner.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/KieMetaInfoBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/KieContainerSessionsPoolImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/InternalKieServices.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/KieFileSystemScannerImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/KieBuilderImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/kie/builder/impl/IncrementalResultsImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/CMMNCaseProvider.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/DescrBuildWarning.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/FieldTemplateError.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/BusinessRuleProvider.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/ScoreCardFactory.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/SerializableDroolsError.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/Dialect.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/PackageRegistry.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/RuleBuildWarning.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/GuidedDecisionTableFactory.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/DrlParser.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/AnalysisResult.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/DescrBuildError.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/ParserError.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/ImportError.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/DroolsError.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/DecisionTableFactory.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/DecisionTableProvider.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/ProcessBuilder.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/DeprecatedResourceTypeWarning.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/PackageBuilderErrors.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/io/FileSystem.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/io/memory/MemoryFileSystem.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/io/memory/MemoryFolder.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/io/memory/MemoryFile.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/io/memory/MemoryPath.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/io/Resource.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/io/File.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/io/Folder.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/io/Path.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/ProcessBuilderFactory.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/FactTemplateError.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/DroolsParserException.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/ProjectJavaCompiler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/DialectConfiguration.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/BPMN2ProcessProvider.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/AnnotationDeclarationError.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/GlobalError.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/GuidedScoreCardFactory.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/XmlDumper.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/RulesSemanticModule.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/XmlPackageReader.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/RestrictionConnectiveHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/PredicateHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/OrHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/AccumulateHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/QueryHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/AndHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/ExpressionHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/PackageHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/LiteralRestrictionHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/RuleHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/QualifiedIdentifierRestrictionHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/ExistsHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/AccumulateHelperHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/EvalHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/ExprConstraintHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/FieldBindingHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/PatternHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/VariableRestrictionsHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/NotHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/ForallHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/FunctionHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/FromHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/CollectHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/FieldConstraintHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/rules/ReturnValueRestrictionHandler.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/xml/package-info.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/DRLFactory.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/ConfigurableSeverityResult.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/BaseKnowledgeBuilderResultImpl.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/FunctionError.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/BPMN2ProcessFactory.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/BuilderResultUtils.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/GuidedRuleTemplateFactory.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/ProcessLoadError.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/PackageBuilderResults.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/DroolsWarning.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/GuidedScoreCardProvider.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/TypeDeclarationWarning.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/BoundIdentifiers.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/GuidedDecisionTableProvider.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/ActionError.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/DialectCompiletimeRegistry.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/CMMNCaseFactory.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/DuplicateFunction.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/DuplicateRule.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/ProcessBuilderFactoryService.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/ScoreCardProvider.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/ReturnValueDescr.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/DuplicateProcess.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/ResourceConversionResult.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/DrlExprParser.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/ResourceTypeDeclarationWarning.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/TypeDeclarationError.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/DroolsErrorWrapper.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/RuleBuildError.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/GuidedRuleTemplateProvider.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/package-info.java",
    "drools-compiler/src/main/java/org/drools/compiler/compiler/DroolsWarningWrapper.java",
    "kie-test-util/src/test/java/org/kie/test/util/StaticMethodTestHelperTest.java",
    "kie-test-util/src/main/java/org/kie/test/util/TestStatusListener.java",
    "kie-test-util/src/main/java/org/kie/test/util/StaticMethodTestHelper.java",
    "kie-test-util/src/main/java/org/kie/test/util/network/AvailablePortFinder.java",
    "kie-test-util/src/main/java/org/kie/test/util/db/PoolingDataSourceWrapper.java",
    "kie-test-util/src/main/java/org/kie/test/util/db/internal/PoolingDataSourceFactory.java",
    "kie-test-util/src/main/java/org/kie/test/util/db/internal/DatabaseProvider.java",
    "kie-test-util/src/main/java/org/kie/test/util/db/internal/PoolingDataSourceWrapperImpl.java",
    "kie-test-util/src/main/java/org/kie/test/util/db/DataSourceFactory.java",
    "kie-test-util/src/main/java/org/kie/test/util/db/CloseSafeMemoryContextFactory.java",
    "kie-test-util/src/main/java/org/kie/test/util/db/PersistenceUtil.java",
    "kie-test-util/src/main/java/org/kie/test/util/logging/LoggingPrintStream.java",
    "kie-test-util/src/main/java/org/kie/test/testcategory/TurtleTestCategory.java",
    "drools-model/drools-mvel-parser/src/test/java/org/drools/mvel/parser/DroolsMvelParserTest.java",
    "drools-model/drools-mvel-parser/src/main/javacc-support/org/drools/mvel/parser/TokenBase.java",
    "drools-model/drools-mvel-parser/src/main/javacc-support/org/drools/mvel/parser/GeneratedDrlConstraintParserTokenManagerBase.java",
    "drools-model/drools-mvel-parser/src/main/javacc-support/org/drools/mvel/parser/RangedList.java",
    "drools-model/drools-mvel-parser/src/main/javacc-support/org/drools/mvel/parser/GeneratedDrlConstraintParserBase.java",
    "drools-model/drools-mvel-parser/src/main/javacc-support/org/drools/mvel/parser/ModifierHolder.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ParseStart.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/MvelParser.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/TokenTypes.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/JavaToken.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/printer/PrintUtil.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/printer/ConstraintPrintVisitor.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/utils/AstUtils.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/Providers.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/BigDecimalLiteralExpr.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/RulePattern.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/DrlNameExpr.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/OOPathChunk.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/NullSafeMethodCallExpr.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/TemporalLiteralInfiniteChunkExpr.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/HalfPointFreeExpr.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/RuleItem.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/RuleConsequence.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/ModifyStatement.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/TemporalLiteralArguments.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/BigIntegerLiteralExpr.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/TemporalLiteralChunkExpr.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/RuleBody.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/RuleDeclaration.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/TemporalChunkExpr.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/InlineCastExpr.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/WithStatement.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/NullSafeFieldAccessExpr.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/MapCreationLiteralExpression.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/TemporalLiteralExpr.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/PointFreeExpr.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/DrlxExpression.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/HalfBinaryExpr.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/OOPathExpr.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/expr/MapCreationLiteralExpressionKeyValuePair.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/visitor/DrlGenericVisitor.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/ast/visitor/DrlVoidVisitor.java",
    "drools-model/drools-mvel-parser/src/main/java/org/drools/mvel/parser/DrlxParser.java",
    "drools-model/drools-model-compiler/src/test/resources/unit2/AdultUnit.java",
    "drools-model/drools-model-compiler/src/test/resources/unit4/AdultUnit.java",
    "drools-model/drools-model-compiler/src/test/resources/unit3/AdultUnit.java",
    "drools-model/drools-model-compiler/src/test/resources/unit1/AdultUnit.java",
    "drools-model/drools-model-compiler/src/test/resources/model/Child.java",
    "drools-model/drools-model-compiler/src/test/resources/model/Person.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/benchmark/BenchmarkUtil.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/benchmark/KJarWithKnowledgeFiles.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/benchmark/BenchmarkMain.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/benchmark/BuildFromKJarBenchmark.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/ComplexRulesTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/PatternDSLTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/exchange/SendReceiveTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/CompilationFailuresTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/DeclaredTypesTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/OOPathFlowTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/util/TrackingAgendaEventListener.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/IndexTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/FunctionsTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/RuleUnitTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/IncrementalCompilationTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/PropertyReactivityTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/FlowTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/AccumulateTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/OrTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/NullSafeDereferencingTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/GlobalTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/CompilerTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/MvelDialectTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/FromTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/QueryTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/drlx/UnitCompilationTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/CepTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/fireandalarm/FireAndAlarmTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/fireandalarm/CompilerTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/fireandalarm/model/Room.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/fireandalarm/model/Fire.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/fireandalarm/model/Sprinkler.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/fireandalarm/model/Alarm.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/fireandalarm/FireAndAlarmUsingDroolsTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/variables/VariablesTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/variables/SimpleObject.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/variables/Result.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/RuleUnitCompilerTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/inlinecast/ICB.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/inlinecast/ICC.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/inlinecast/ICAbstractA.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/inlinecast/InlineCastTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/inlinecast/ICAbstractC.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/inlinecast/ICAbstractB.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/inlinecast/ICA.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/alphaNetworkCompiler/ObjectTypeNodeCompilerTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/EvalTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/KJARUtils.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/BaseModelTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/DroolsContextTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/FactTemplateTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/MapInitializationDrools3800Test.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/InTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/OOPathTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/KieBuilderTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/MultiKieBaseTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/builder/generator/ConsequenceTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/builder/generator/expressiontyper/FlattenScopeTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/builder/generator/DrlxParseUtilTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/builder/generator/ExpressionTyperTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/builder/generator/StringUtilTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/builder/generator/drlxparse/CoercedExpressionTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/NodeSharingTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/Woman.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/StockFact.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/Child.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/ChildFactWithObject.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/ChildFactWithFirings1.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/ChildFactComplex.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/ChildFactWithId1.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/Customer.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/Pet.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/EnumFact2.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/Man.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/Overloaded.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/ChildFactWithEnum1.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/Address.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/TargetPolicy.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/ChildFactWithEnum2.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/RootFact.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/Person.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/StockTick.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/PetPerson.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/EnumFact1.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/ChildFactWithEnum3.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/Adult.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/ChildFactWithId2.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/Result.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/Toy.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/InternationalAddress.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/Relationship.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/ChildFactWithId3.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/InterfaceAsEnum.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/domain/Employee.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/ExisistentialTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/ReteDumper.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/BuildFromKJarTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/oopathdtables/Address.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/oopathdtables/Person.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/oopathdtables/InternationalAddress.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/bigdecimaltest/Customer.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/bigdecimaltest/BigDecimalTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/bigdecimaltest/Policy.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/RuleAttributesTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/UseClassFieldsInRulesTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/TypeCoercionTest.java",
    "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/MvelOperatorsTest.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/RuleContext.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/CanonicalKieModuleProvider.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/constraints/AbstractConstraint.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/constraints/BindingEvaluator.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/constraints/LambdaAccumulator.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/constraints/ConstraintEvaluator.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/constraints/LambdaEvalExpression.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/constraints/MvelReadAccessor.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/constraints/BindingInnerObjectEvaluator.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/constraints/LambdaDataProvider.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/constraints/SupplierDataProvider.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/constraints/LambdaConstraint.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/constraints/TemporalConstraintEvaluator.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/constraints/CombinedConstraint.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/constraints/UnificationConstraint.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/constraints/LambdaReadAccessor.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/MvelUtil.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/StringUtil.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/LambdaIntrospector.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/TypeDeclarationUtil.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/ClassUtil.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/JavaParserUtil.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/EvaluationUtil.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/CanonicalKieModule.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/facttemplate/FactFactory.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/facttemplate/HashMapFactImpl.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/KiePackagesBuilder.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/attributes/LambdaEnabled.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/attributes/DynamicAttributeEvaluator.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/attributes/LambdaSalience.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/drlx/CompiledUnit.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/drlx/DrlxCompiler.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/ExecutableModelProject.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/DroolsImpl.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/MVELConsequence.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/DroolsEntryPointImpl.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/ExecutableModelFlowProject.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/CanonicalKiePackages.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/ModelBuilderImpl.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/GeneratedClassWithPackage.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/RuleDescrImpl.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/JavaParserCompiler.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/RuleContext.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/TypedExpression.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/WindowReferenceGenerator.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/QueryGenerator.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/expressiontyper/TypedExpressionResult.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/expressiontyper/ExpressionTyper.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/expressiontyper/ExpressionTyperContext.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/expressiontyper/FlattenScope.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/DslMethodNames.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/POJOGenerator.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/DRLIdGenerator.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/Consequence.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/DSLNode.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/NamedConsequenceVisitor.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/ModelGeneratorVisitor.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/FromCollectVisitor.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/AndVisitor.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/accumulate/LegacyAccumulate.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/accumulate/AccumulateVisitor.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/accumulate/AccumulateVisitorFlowDSL.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/accumulate/AccumulateVisitorPatternDSL.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/OrVisitor.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/ConditionalElementVisitor.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/FromVisitor.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/pattern/PatternDSL.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/pattern/PatternDSLPattern.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/pattern/PatternAccumulateConstraint.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/pattern/ConstraintOOPath.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/pattern/PatternDSLSimpleConstraint.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/pattern/FlowDSLSimpleConstraint.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/pattern/QueryCall.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/pattern/Query.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/pattern/FlowDSLPattern.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/pattern/FlowAccumulateConstraint.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/pattern/PatternVisitor.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/pattern/PatternConstraintParseResult.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/visitor/EvalVisitor.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/OOPathExprGenerator.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/operatorspec/TemporalOperatorSpec.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/operatorspec/CustomOperatorSpec.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/operatorspec/CustomOperatorWrapper.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/operatorspec/OperatorSpec.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/operatorspec/NativeOperatorSpec.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/drlxparse/MultipleDrlxParseSuccess.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/drlxparse/SingleDrlxParseSuccess.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/drlxparse/CoercedExpression.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/drlxparse/ParseResultVoidVisitor.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/drlxparse/DrlxParseResult.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/drlxparse/ConstraintParser.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/drlxparse/AbstractDrlxParseSuccess.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/drlxparse/ConstraintExpression.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/drlxparse/DrlxParseFail.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/drlxparse/DrlxParseSuccess.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/drlxparse/ParseResultVisitor.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/expression/FlowExpressionBuilder.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/expression/AbstractExpressionBuilder.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/expression/PatternExpressionBuilder.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/DeclarationSpec.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/FunctionGenerator.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/DrlxParseUtil.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/IndexIdGenerator.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/query/PatternDSLQueryGenerator.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/query/QueryGenerator.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/query/QueryDefGenerator.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/query/QueryDefImplGenerator.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/query/FlowDSLQueryGenerator.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/query/Generator.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/ModelGenerator.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/QueryParameter.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/PackageModel.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/KieBaseBuilder.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/ModelWriter.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/errors/MvelCompilationError.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/errors/UnknownRuleUnitError.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/errors/CompilationProblemErrorResult.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/errors/ParseExpressionErrorResult.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/errors/InvalidExpressionErrorResult.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/errors/UnknownDeclarationError.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/CanonicalKieBaseUpdater.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/CanonicalModelKieProject.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/dsl/pattern/D.java",
    "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/dsl/flow/D.java",
    "drools-model/drools-mvel-compiler/src/test/java/org/drools/mvelcompiler/ModifyCompilerTest.java",
    "drools-model/drools-mvel-compiler/src/test/java/org/drools/mvelcompiler/CompilerTest.java",
    "drools-model/drools-mvel-compiler/src/test/java/org/drools/mvelcompiler/MvelCompilerTest.java",
    "drools-model/drools-mvel-compiler/src/test/java/org/drools/Address.java",
    "drools-model/drools-mvel-compiler/src/test/java/org/drools/Person.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/ParsingResult.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/RHSPhase.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/context/Declarations.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/context/Declaration.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/context/MvelCompilerContext.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/MvelCompilerException.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/util/OptionalUtils.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/PreprocessPhase.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/ModifyCompiler.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/LHSPhase.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/ast/SimpleNameTExpr.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/ast/TypedExpression.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/ast/ObjectCreationExpressionT.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/ast/VariableDeclaratorTExpr.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/ast/MethodCallExprT.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/ast/UnalteredTypedExpression.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/ast/CharacterLiteralExpressionT.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/ast/BinaryTExpr.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/ast/ExpressionStmtT.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/ast/IntegerLiteralExpressionT.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/ast/AssignExprT.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/ast/FieldAccessTExpr.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/ast/StringLiteralExpressionT.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/ast/CastExprT.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/ast/FieldToAccessorTExpr.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/ast/ListAccessExprT.java",
    "drools-model/drools-mvel-compiler/src/main/java/org/drools/mvelcompiler/MvelCompiler.java",
    "drools-model/drools-canonical-model/src/test/java/org/drools/model/Person.java",
    "drools-model/drools-canonical-model/src/test/java/org/drools/model/engine/BruteForceEngine.java",
    "drools-model/drools-canonical-model/src/test/java/org/drools/model/FlowDSLTest.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/datasources/impl/ListDataStore.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/datasources/impl/AbstractObservable.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/datasources/impl/SetDataStore.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/datasources/impl/DataStreamImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/datasources/ReactiveDataStore.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/datasources/Observable.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/datasources/PassiveDataSource.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/datasources/DataStream.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/datasources/PassiveDataStore.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/datasources/DataStore.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/datasources/DataSourceObserver.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/datasources/ReactiveDataSource.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/datasources/DataSource.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/Query4DefImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/ValueImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/ViewFlowBuilder.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/Query8DefImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/EntryPointImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/Query1DefImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/ModelImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/ViewBuilder.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/DataSourceDefinitionImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/Query10DefImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/WindowReferenceImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/Query2DefImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/From0Impl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/From1Impl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/TypeMetaDataImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/ModelComponent.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/AbstractWindow.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/AnnotationValueImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/QueryDefImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/TupleHandleImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/RuleImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/RuleBuilder.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/PrototypeVariableImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/Query7DefImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/Query0DefImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/UnitDataImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/DeclarationImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/Query9DefImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/GlobalImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/QueryImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/VariableImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/Query5DefImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/Query6DefImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/PrototypeImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/WindowImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/Query3DefImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/ViewPatternBuilder.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/NamesGenerator.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/From3Impl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/From2Impl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/Exchange.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/PatternDSL.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/DroolsEntryPoint.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/TypeMetaData.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Argument.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Query5Def.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Index.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Window.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Query4Def.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/RuleItem.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/patterns/ExistentialPatternImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/patterns/CompositePatterns.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/patterns/AbstractSinglePattern.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/patterns/QueryCallPattern.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/patterns/AccumulatePatternImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/patterns/PatternBuilder.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/patterns/EvalImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/patterns/PatternImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/constraints/AbstractConstraint.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/constraints/SingleConstraint3.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/constraints/SingleConstraint10.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/constraints/SingleConstraint11.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/constraints/SingleConstraint2.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/constraints/MultipleConstraints.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/constraints/SingleConstraint5.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/constraints/SingleConstraint9.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/constraints/SingleConstraint8.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/constraints/FixedTemporalConstraint.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/constraints/SingleConstraint4.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/constraints/SingleConstraint7.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/constraints/SingleConstraint6.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/constraints/OrConstraints.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/constraints/AndConstraints.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/constraints/AbstractSingleConstraint.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/constraints/TemporalConstraint.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/constraints/VariableTemporalConstraint.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/constraints/SingleConstraint12.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/constraints/SingleConstraint1.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/constraints/SingleConstraint13.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Prototype.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/PrototypeVariable.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/operators/StringStartsWithOperator.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/operators/SoundsLikeOperator.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/operators/ContainsOperator.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/operators/MemberOfOperator.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/operators/MatchesOperator.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/operators/StringEndsWithOperator.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/operators/StringLengthWithOperator.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/operators/InOperator.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/operators/ExcludesOperator.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/InvokerPattern.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Tuple.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Global.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Query6Def.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Pattern.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/RuleItemBuilder.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/DynamicValueSupplier.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/AccumulatePattern.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/From3.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/From2.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/BitMask.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/AnnotationValue.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/UnitData.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/AlphaIndex.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Query7Def.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Consequence.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/bitmask/LongBitMask.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/bitmask/EmptyMask.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/bitmask/AllSetMask.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/bitmask/BitMaskUtil.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/bitmask/AllSetBitMask.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/bitmask/AllSetButLastBitMask.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/bitmask/EmptyBitMask.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/bitmask/OpenBitSet.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/bitmask/EmptyButLastBitMask.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/bitmask/SingleLongBitMask.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/InvokerMultiValuePattern.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Query2Def.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Variable.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/BetaIndex.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/PrototypeFact.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/From1.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Declaration.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/TupleHandle.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/QueryDef.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/DeclarationSource.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/From0.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/View.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Query.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Query3Def.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/ExprNViewItem.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/Expr5ViewItemImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/TemporalExprViewItem.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/ViewItem.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/ViewItemBuilder.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/Expr12ViewItemImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/Expr2ViewItem.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/QueryCallViewItem.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/Expr1ViewItemImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/VariableTemporalExprViewItem.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/Expr4ViewItemImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/BindViewItem1.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/InputViewItemImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/Expr13ViewItemImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/FixedValueItem.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/AccumulateExprViewItem.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/CombinedExprViewItem.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/InputViewItem.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/Expr7ViewItemImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/BindViewItem2.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/Expr3ViewItemImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/Expr8ViewItemImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/Expr10ViewItemImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/ExprViewItem.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/FixedTemporalExprViewItem.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/ExistentialExprViewItem.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/Expr6ViewItemImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/Expr1ViewItem.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/Expr2ViewItemImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/QueryCallViewItemImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/Expr11ViewItemImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/AbstractExprViewItem.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/view/Expr9ViewItemImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Condition.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/WindowReference.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Constraint.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Function0.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Block8.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/temporal/FinishesPredicate.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/temporal/MetbyPredicate.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/temporal/OverlappedbyPredicate.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/temporal/TemporalPredicate.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/temporal/IncludesPredicate.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/temporal/Interval.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/temporal/CoincidesPredicate.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/temporal/FinishedbyPredicate.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/temporal/MeetsPredicate.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/temporal/DuringPredicate.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/temporal/OverlapsPredicate.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/temporal/StartedbyPredicate.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/temporal/TimeUtil.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/temporal/AfterPredicate.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/temporal/AbstractTemporalPredicate.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/temporal/BeforePredicate.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/temporal/StartsPredicate.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/FunctionUtils.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Predicate3.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Block4.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Block5.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/BlockN.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Predicate2.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Block9.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Function1.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Predicate5.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/PredicateN.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Block2.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Block12.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Operator.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/accumulate/AccumulateFunction.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Predicate10.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Function6.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Predicate9.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Predicate8.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Predicate11.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/ScriptBlock.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Block3.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Block13.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Predicate4.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Block10.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Block0.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Predicate7.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Function4.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Predicate12.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Predicate13.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/FunctionN.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Function5.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Predicate6.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Block11.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Block1.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/LambdaPrinter.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Function2.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Block6.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/IntrospectableLambda.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Predicate1.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Block7.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/functions/Function3.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/index/BetaIndexImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/index/AlphaIndexImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/index/AbstractIndex.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/From.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Query8Def.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/WindowDefinition.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Value.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/DSL.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/DataSourceDefinition.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/FlowDSL.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/NamedModelItem.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Drools.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Binding.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Query10Def.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/InvokerSingleValuePattern.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Query1Def.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Handle.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Query0Def.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/consequences/ConsequenceBuilder.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/consequences/ConsequenceImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/consequences/ConditionalConsequenceBuilder.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/consequences/NamedConsequenceImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/consequences/ConditionalConsequenceImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/consequences/ConditionalNamedConsequenceImpl.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Rule.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Model.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/Query9Def.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/EntryPoint.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/ConditionalConsequence.java",
    "drools-model/drools-canonical-model/src/main/java/org/drools/model/SingleConstraint.java",
    "drools-test-coverage/standalone/kie-ci-with-domain/test-domain/src/main/java/org/drools/testcoverage/domain/Drink.java",
    "drools-test-coverage/standalone/kie-ci-with-domain/test-domain/src/main/java/org/drools/testcoverage/domain/Order.java",
    "drools-test-coverage/standalone/kie-ci-with-domain/test-domain/src/main/java/org/drools/testcoverage/domain/Customer.java",
    "drools-test-coverage/standalone/kie-ci-with-domain/tests/src/test/java/org/drools/testcoverage/kieci/withdomain/util/KJarLoadUtils.java",
    "drools-test-coverage/standalone/kie-ci-with-domain/tests/src/test/java/org/drools/testcoverage/kieci/withdomain/KJarLoadingTest.java",
    "drools-test-coverage/standalone/kie-ci-without-domain/test-domain/src/main/java/org/drools/testcoverage/domain/Drink.java",
    "drools-test-coverage/standalone/kie-ci-without-domain/test-domain/src/main/java/org/drools/testcoverage/domain/Order.java",
    "drools-test-coverage/standalone/kie-ci-without-domain/test-domain/src/main/java/org/drools/testcoverage/domain/Customer.java",
    "drools-test-coverage/standalone/kie-ci-without-domain/tests/src/test/java/org/drools/testcoverage/kieci/withoutdomain/util/KJarLoadUtils.java",
    "drools-test-coverage/standalone/kie-ci-without-domain/tests/src/test/java/org/drools/testcoverage/kieci/withoutdomain/KJarLoadingTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/CepJavaTypeTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/KieBaseIncludeTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/CepQueryTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/incrementalcompilation/AddRemoveGenerated2RulesEval2Test.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/incrementalcompilation/AddRemoveGenerated2RulesNotNotTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/incrementalcompilation/StringPermutation.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/incrementalcompilation/IncrementalCompilationTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/incrementalcompilation/AddRemoveGenerated2RulesStringTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/incrementalcompilation/AddRemoveGenerated2RulesMapContainsTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/incrementalcompilation/AbstractAddRemoveGenerated2RulesTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/incrementalcompilation/ConstraintsPair.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/incrementalcompilation/AddRemoveTestCases.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/incrementalcompilation/AddRemoveGenerated2RulesEvalTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/incrementalcompilation/RemoveRuleTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/incrementalcompilation/AddRemoveGenerated2RulesNotTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/incrementalcompilation/AddRemoveGenerated2RulesStringIntegerTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/incrementalcompilation/IncrementalCompilationCepTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/incrementalcompilation/AddRemoveRulesAddDeleteFactsTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/incrementalcompilation/AddRemoveRulesAdvOperatorsTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/incrementalcompilation/AddRemoveGenerated2RulesIntegerTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/incrementalcompilation/AddRuleTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/incrementalcompilation/TestUtil.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/incrementalcompilation/AddRemoveRulesTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/AnnotationsOnPatternTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/AbstractCepEspTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/drl/ConsequenceTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/drl/RuleFlowGroupTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/drl/CommentTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/drl/RHSTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/drl/AbstractDeclareTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/drl/LiteralTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/drl/DRLCepTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/drl/GlobalTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/drl/ImportsTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/drl/VariableTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/drl/ExceptionTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/drl/StaticMethods.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/drl/DeclareTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/drl/BindTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/drl/PatternTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/drl/StaticMethods2.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/drl/DrlSpecificFeaturesTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/drl/DRLTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/drl/NestingTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/StreamsTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/equalitymode/CellEqualityModeTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/equalitymode/FactWithEquals.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/equalitymode/BackwardChainingEqualityModeTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/equalitymode/AccumulateCepEqualityModeTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/equalitymode/DeclareEqualityModeTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/equalitymode/CepEspEqualityModeTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/equalitymode/EqualityModeTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/AlphaNetworkModifyTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/BetaTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/PassivePatternTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/operators/EvalRewriteTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/operators/InstanceOfTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/operators/SoundsLikeTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/operators/NotTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/operators/ExistsTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/operators/FormulaTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/operators/MathTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/operators/EqualsTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/operators/OrTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/operators/FromTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/operators/MemberOfTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/operators/MatchesTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/operators/EvalTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/operators/AndTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/operators/InTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/operators/ContainsTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/operators/EnabledTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/RuleUnitTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/AlphaTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/CalendarTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/SharingTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/ArrayTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/SubnetworkCEPTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/AlphaNodeSharingWithDiffPackageNameTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/CompositeAgendaTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/CepFireUntilHaltTimerTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/AccumulateTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/TimerAndCalendarTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/CustomOperatorTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/ChangesetUndoTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/AnnotationsCepTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/AccumulateCepTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/SubnetworkTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/CepEspTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/AbstractCellTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/BackwardChainingUnsupportedModelTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/IndexingTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/BackwardChainingTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/PropertyChangeSupportTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/NegativePatternsTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/ClassLoaderTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/ConstraintsTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/CommandsTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/CepEspNegativeCloudTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/ActivateAndDeleteOnListenerTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/ConsequenceOffsetTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/RuleChainingTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/AnnotationsTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/AbstractBackwardChainingTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/AccumulateUnsupportedWithModelTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/FromSharingTest.java",
    "drools-test-coverage/test-compiler-integration/src/test/java/org/drools/compiler/integrationtests/CellTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/memory/KieScannerMemoryTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/listener/TrackingAgendaEventListener.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/listener/OrderListener.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/util/KieSessionUtil.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/util/SerializationHelper.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/util/MavenUtil.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/util/KieBaseTestConfiguration.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/util/TestParametersUtil.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/util/DebugList.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/util/TestConstants.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/util/KieBaseUtil.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/util/KieSessionModelProvider.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/util/FileUtil.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/util/KieUtil.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/util/ResourceUtil.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/util/KieSessionTestConfiguration.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/util/PropertiesUtil.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/util/TimeUtil.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/util/Session.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/util/EngineTestConfiguration.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/util/KieBaseModelProvider.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/KieSessionTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/FirstClass.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/B.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Message.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/LongAddress.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/AggregableFact.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/ListHolder.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Order.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Cheesery.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/OrderItem.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/InterfaceA.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/ClassA.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/DomainObject.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/SecondClass.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Subject.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Interval.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Customer.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/C.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/TestEnum.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Pet.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Promotion.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/D.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Sample.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/EventB.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/FactA.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/AFact.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/E.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/OrderEvent.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Overloaded.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Address.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/MessageEvent.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/SimplePerson.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/PersonWithSpecificEquals.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Event.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/AbstractBean.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Cheese.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/MyFact.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/FactC.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Person.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/StockTick.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/EventA.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/FactB.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/TestParam.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/DomainObjectHolder.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Attribute.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/StockTickEvent.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Sale.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/InterfaceB.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Record.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/State.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/ClassB.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/OuterClass.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Alarm.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/InternationalAddress.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Cell.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Primitives.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/FactWithList.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/A.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Sensor.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/TestEvent.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/common/model/Employee.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/PropertyListenerTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/GenericsWithModifyTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/UnwantedStringConversionTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/SerializableInstantiationTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/DeclarationWithOrTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/EventDeserializationInPastTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/MultipleSheetsLoadingTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/DeserializationWithCompositeTriggerTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/NumberRestriction.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/mvel/MvelLinkageErrorTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/mvel/NotLoadableClass.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/GlobalOnLHSTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/DateExtendingFactTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/InaccurateComparisonTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/FromGenericCollectionTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/NullInListInFromTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/MultipleSalienceUpdateFactTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/DroolsGcCausesNPETest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/EscapesInMetadataTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/MultipleKieBaseListenersTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/SerializationWithCollectTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/SerializableGeneratedTypesTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/ActivationTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/EqualityKeyOverrideTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/POJOAnnotationMergeTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/AbstractCompositeRestrictionTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/SessionInsertMultiThreadingTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/LogicalInsertionsSerializationTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/ImportReplaceTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/BetaMemoryLeakOnDeleteTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/EventFactHandleDeserializationTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/FusionAfterBeforeTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/XSDResourceTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/NotInFusionTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/AccumulateRecalculationTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/StarImportTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/MvelOverloadedMethodsUsageTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/MultiRestrictionPatternTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/FixedPatternTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/AmbiguousExceptionTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/regression/NonStringCompareTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/oopath/OOPathLogicalBranchesTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/oopath/OOPathDslTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/oopath/OOPathSmokeTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/oopath/OOPathCepTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/oopath/OOPathDtablesTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/QueryBadResultTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/RuleTemplateTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/KieContainerTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/KieRepositoryTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/DeclarativeAgendaTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/KieContainerDefaultsTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/LogicalInsertFromCollectionTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/TemplatesTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/LiveQueriesBadResultTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/DuplicityTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/parser/SmokeParserTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/parser/ParserTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/parser/DrlParserTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/parser/DslParserTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/ResourcesTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/DecisionTableTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/model/RulesWithInTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/model/BuildtimeUtil.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/UnicodeTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/decisiontable/DecisionTableKieContainerTest.java",
    "drools-test-coverage/test-suite/src/test/java/org/drools/testcoverage/functional/GuidedDecisionTableTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/RangeCheckIntegersTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/misc/DrlPackageDataTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/misc/DrlRuleDataTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/misc/FindMissingNumberTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/VerifyingScopeTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/missingEquality/MissingEqualityTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/RangeCheckDatesTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/alwaysTrue/AlwaysTrueRuleTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/alwaysTrue/AlwaysTruePatternTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/VerifierTestStandalone.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/TestBaseOld.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/overlaps/OverlappingRestrictionsTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/PatternSolverDRLTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/redundancy/WarningsTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/redundancy/NotesTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/redundancy/RedundancyTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/RangeCheckTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/solver/PatternSolverTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/ConditionalBranchDescrTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/jarloader/PackageHeaderLoaderTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/jarloader/VerifierMapBackedClassLoaderTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/components/LiteralRestrictionTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/opposites/OppositeRestrictionsTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/opposites/OppositesBase.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/opposites/OppositePatternsTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/equivalence/EquivalentRulesTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/incompatibility/IncompatibilityBase.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/incompatibility/IncompatibilityRestrictionsTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/incompatibility/IncompatibilityPatternsTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/subsumption/SubsumptantSubPatternsTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/subsumption/SubsumptantSubRulesTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/subsumption/SubsumptantRestrictionsTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/visitor/ExprConstraintDescrVisitorTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/visitor/NestedPatternsTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/visitor/PatternDescrVisitorTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/visitor/PackageDescrVisitorTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/visitor/VerifierComponentTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/RangeCheckCleanTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/consequence/ConsequenceTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/consequence/NamedConsequencesTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/SolversTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/doc/StandaloneDocBuilder.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/report/components/CauseTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/report/VerifierReportBuilderTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/incoherence/IncoherentRestrictionsTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/incoherence/IncoherentPatternsTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/VerifierTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/RangeCheckDoublesTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/TestBase.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/VerifierComponentMockFactory.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/data/VerifierDataMapsTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/alwaysFalse/AlwaysFalseTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/optimisation/RestrictionOrderTest.java",
    "drools-verifier/drools-verifier-drl/src/test/java/org/drools/verifier/optimisation/PatternOrderTest.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/misc/DrlRuleParser.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/misc/FindMissingNumber.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/misc/DrlPackageParser.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/DefaultVerifierConfiguration.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/Verifier.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/VerifierConfiguration.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/VerifierError.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/solver/RuleSolver.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/solver/Solver.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/solver/PatternSolver.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/solver/Solvers.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/jarloader/VerifierMapBackedClassLoader.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/jarloader/PackageHeaderLoader.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/TextConsequence.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/StringRestriction.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/Restriction.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/Eval.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/NumberRestriction.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/RuleComponent.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/RulePackage.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/QualifiedIdentifierRestriction.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/EnumField.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/VerifierAccumulateDescr.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/Pattern.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/VerifierComponentType.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/ChildComponent.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/PatternVariable.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/PatternEval.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/VerifierComponentSource.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/RuleOperatorDescr.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/VerifierFromDescr.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/Consequence.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/PatternOperatorDescr.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/Variable.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/BooleanRestriction.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/VerifierFieldAccessDescr.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/SubPattern.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/PackageComponent.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/VerifierCollectDescr.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/VerifierRule.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/EnumRestriction.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/Import.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/DateRestriction.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/SubRule.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/ObjectType.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/PatternComponent.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/OperatorDescrType.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/WorkingMemory.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/VariableRestriction.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/Source.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/Field.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/LiteralRestriction.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/ReturnValueRestriction.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/InlineEvalDescr.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/VerifierFunctionCallDescr.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/Possibility.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/VerifierMethodAccessDescr.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/NamedConsequence.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/FieldVariable.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/RuleEval.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/PatternComponentSource.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/ReturnValueFieldDescr.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/EntryPoint.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/components/VerifierAccessorDescr.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/VerifierConfigurationOptions.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/VerifierConfigurationImpl.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/visitor/ObjectTypeFactory.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/visitor/TypeDeclarationDescrVisitor.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/visitor/ExprConstraintDescrVisitor.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/visitor/ConditionalElementDescrVisitor.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/visitor/PackageDescrVisitor.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/visitor/FieldConstraintDescrVisitor.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/visitor/PatternDescrVisitor.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/visitor/RuleDescrVisitor.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/visitor/UnknownDescriptionException.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/EmptyVerifierConfiguration.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/doc/DroolsDocsBuilder.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/doc/DroolsDocsComponentFactory.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/VerifierReportWriterFactory.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/VerifierReportConfiguration.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/html/ComponentsReportVisitor.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/html/UrlFactory.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/html/ReportModeller.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/html/VerifierMessagesVisitor.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/html/HTMLReportWriter.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/html/ReportVisitor.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/html/MissingRangesReportVisitor.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/components/Subsumption.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/components/VerifierMessageBase.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/components/Redundancy.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/components/MissingNumberPattern.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/components/VerifierMessage.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/components/PartialRedundancy.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/components/ReasonType.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/components/Gap.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/components/Cause.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/components/Severity.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/components/AlwaysTrue.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/components/Overlap.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/components/Equivalence.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/components/Opposites.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/components/Reason.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/components/MissingRange.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/components/Incompatibility.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/components/MessageType.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/components/VerifierRangeCheckMessage.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/XMLReportWriter.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/VerifierReportWriter.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/VerfierReportConfigurationOptions.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/VerifierReportConfigurationImpl.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/report/PlainTextReportWriter.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/data/VerifierData.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/data/VerifierComponent.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/data/VerifierDataKnowledgeSession.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/data/VerifierDataMaps.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/data/VerifierReportImpl.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/data/VerifierReportFactory.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/data/VerifierReport.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/builder/VerifierBuilder.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/builder/ScopesAgendaFilter.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/builder/VerifierBuilderFactory.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/builder/VerifierBuilderErrors.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/builder/VerifierBuilderConfigurationImpl.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/builder/VerifierBuilderConfiguration.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/builder/VerifierKnowledgeBaseBuilder.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/builder/VerifierBuilderError.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/builder/VerifierBuilderImpl.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/builder/VerifierPackageBuilder.java",
    "drools-verifier/drools-verifier-drl/src/main/java/org/drools/verifier/builder/VerifierImpl.java",
    "drools-verifier/drools-verifier-api/src/main/java/org/drools/verifier/api/StatusUpdate.java",
    "drools-verifier/drools-verifier-api/src/main/java/org/drools/verifier/api/reporting/ValueForActionIsSetTwiceIssue.java",
    "drools-verifier/drools-verifier-api/src/main/java/org/drools/verifier/api/reporting/SingleHitLostIssue.java",
    "drools-verifier/drools-verifier-api/src/main/java/org/drools/verifier/api/reporting/Issues.java",
    "drools-verifier/drools-verifier-api/src/main/java/org/drools/verifier/api/reporting/Severity.java",
    "drools-verifier/drools-verifier-api/src/main/java/org/drools/verifier/api/reporting/CheckType.java",
    "drools-verifier/drools-verifier-api/src/main/java/org/drools/verifier/api/reporting/ValueForFactFieldIsSetTwiceIssue.java",
    "drools-verifier/drools-verifier-api/src/main/java/org/drools/verifier/api/reporting/Issue.java",
    "drools-verifier/drools-verifier-api/src/main/java/org/drools/verifier/api/reporting/MultipleValuesForOneActionIssue.java",
    "drools-verifier/drools-verifier-api/src/main/java/org/drools/verifier/api/reporting/ImpossibleMatchIssue.java",
    "drools-verifier/drools-verifier-api/src/main/java/org/drools/verifier/api/reporting/RedundantConditionsIssue.java",
    "drools-verifier/drools-verifier-api/src/main/java/org/drools/verifier/api/Status.java",
    "drools-verifier/drools-verifier-api/src/main/java/org/drools/verifier/api/Command.java",
    "drools-verifier/drools-verifier-api/src/main/java/org/drools/verifier/api/Callback.java",
    "drools-verifier/drools-verifier-api/src/main/java/org/drools/verifier/api/Reporter.java",
    "drools-verifier/drools-verifier-api/src/main/java/org/drools/verifier/api/CancellableRepeatingCommand.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/maps/KeyTreeMapTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/maps/KnownKeysKeyTreeMapTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/maps/ChangeHandledMultiMapPreExistingDataTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/maps/KeyTreeMapUUIDKeyTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/maps/UpdatableInspectorListTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/maps/KeyDefinitionBuilderTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/maps/ChangeHandledMultiMapTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/maps/KeyTreeMapMergeTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/maps/IndexedKeyTreeMapTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/maps/KeyTreeMapMultiValueKeyTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/maps/MultiMapFactoryTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/RuleInspectorCacheTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/Util.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/cache/inspectors/ConditionsInspectorTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/cache/inspectors/FieldInspectorRelationsTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/cache/inspectors/action/ActionInspectorConflictResolverTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/cache/inspectors/condition/StringConditionInspectorSubsumptionResolverTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/cache/inspectors/condition/NumericIntegerConditionInspectorSubsumptionTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/cache/inspectors/condition/StringConditionInspectorCoverTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/cache/inspectors/condition/DoubleComparableConditionInspectorCoverTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/cache/inspectors/condition/StringConditionInspectorConflictResolverOverlapTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/cache/inspectors/condition/NumericIntegerConditionInspectorConflictResolverOverlapTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/cache/inspectors/condition/ComparableConditionInspectorConflictResolverTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/cache/inspectors/condition/NumericIntegerConditionInspectorSubsumptionResolverTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/cache/inspectors/condition/StringConditionInspectorOverlapTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/cache/inspectors/condition/StringConditionInspectorToHumanReadableTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/cache/inspectors/condition/ComparableConditionInspectorSubsumptionTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/cache/inspectors/condition/BooleanConditionInspectorTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/cache/inspectors/condition/DateConditionInspectorSubsumptionTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/cache/inspectors/condition/StringConditionInspectorSubsumptionTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/cache/inspectors/PatternInspectorTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/cache/inspectors/FieldInspectorUpdateTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/relations/RelationResolverConflictsTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/relations/OperatorTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/relations/RelationResolverSubsumptionTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/checks/CheckRunManagerTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/checks/base/CheckFactoryTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/checks/base/PairCheckStorageListTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/checks/base/CheckRunManagerRepeatingCommandTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/AnalyzerConfigurationMock.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/index/ConditionTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/index/ConditionsListenerTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/index/model/ActivationTimeTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/index/keys/KeyTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/index/keys/ValueTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/index/keys/ValueNullTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/index/keys/ValuesTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/index/select/SelectExactMatcherNegateTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/index/select/SelectEmptyMapTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/index/select/ListenAllTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/index/select/SelectNoMatchesTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/index/select/ListenAddTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/index/select/ListenRemoveTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/index/select/SelectKeyMatcherTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/index/select/SelectExactMatcherTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/index/select/ExactMatcherSearchTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/index/select/SelectWithNegativeExactMatcherWhenTheValueIsNotInTheMapTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/index/select/SelectNullTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/index/select/ListenAddToEmptyTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/index/query/QueryableIndexTest.java",
    "drools-verifier/drools-verifier-core/src/test/java/org/drools/verifier/core/index/ActionTest.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/InspectorList.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/MultiSet.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/ArrayMultiMap.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/ArrayListSubMapProvider.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/UpdatableInspectorList.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/util/HasConflicts.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/util/HasIndex.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/util/RedundancyResult.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/util/HasKeys.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/util/HasRedundancy.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/util/HasUUID.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/RawMultiMap.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/NewSubMapProvider.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/RetractHandler.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/InspectorFactory.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/MultiMapFactory.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/KeyTreeMap.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/LeafInspectorList.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/UUIDKeySet.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/KeyDefinition.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/MultiMapChangeHandler.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/ChangeHandledMultiMap.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/IndexedKeyTreeMap.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/MultiMap.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/InspectorMultiMap.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/maps/KeyChangeListener.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/configuration/CheckConfiguration.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/configuration/RunnerType.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/configuration/DateTimeFormatProvider.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/configuration/AnalyzerConfiguration.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/cache/inspectors/RuleInspectorUpdater.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/cache/inspectors/PatternInspector.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/cache/inspectors/FieldInspector.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/cache/inspectors/action/ActionsInspectorMultiMap.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/cache/inspectors/action/ActionInspector.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/cache/inspectors/action/FieldActionInspector.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/cache/inspectors/action/ActionInspectorFactory.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/cache/inspectors/action/BRLActionInspector.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/cache/inspectors/condition/StringConditionInspector.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/cache/inspectors/condition/BooleanConditionInspector.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/cache/inspectors/condition/ConditionsInspectorMultiMap.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/cache/inspectors/condition/ComparableConditionInspector.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/cache/inspectors/condition/BRLConditionInspector.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/cache/inspectors/condition/ConditionInspectorFactory.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/cache/inspectors/condition/NumericIntegerConditionInspector.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/cache/inspectors/condition/ConditionInspector.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/cache/inspectors/RuleInspectorDumper.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/cache/inspectors/RuleInspector.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/cache/inspectors/FieldActionsInspectorMultiMap.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/cache/RuleInspectorCache.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/util/PortablePreconditions.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/relations/Conflicts.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/relations/IsConflicting.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/relations/SubsumptionBlockers.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/relations/SubsumptionBlocker.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/relations/IsOverlapping.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/relations/ConflictResolver.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/relations/Operator.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/relations/IsDeficient.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/relations/Conflict.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/relations/RelationResolver.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/relations/IsSubsuming.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/relations/SubsumptionResolver.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/relations/HumanReadable.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/relations/IsRedundant.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/relations/Relation.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/DetectRedundantActionFactFieldCheck.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/DetectRedundantActionBase.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/DetectMissingConditionCheck.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/DetectMissingActionCheck.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/DetectRedundantRowsCheck.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/DetectRedundantActionValueCheck.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/DetectDeficientRowsCheck.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/DetectRedundantConditionsCheck.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/DetectImpossibleMatchCheck.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/SingleRangeCheck.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/DetectConflictingRowsCheck.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/DetectMultipleValuesForOneActionCheck.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/DetectEmptyRowCheck.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/SingleHitCheck.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/base/PairCheckStorage.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/base/SingleCheck.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/base/PriorityListCheck.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/base/JavaCheckRunner.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/base/CheckBase.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/base/Check.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/base/CheckFactory.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/base/OneToManyCheck.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/base/PairCheckBundle.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/base/ChecksRepeatingCommand.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/base/CheckRunManager.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/base/CheckStorage.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/base/CheckRunner.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/checks/base/PairCheck.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/IndexImpl.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/Index.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/ObjectTypes.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/Actions.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/Patterns.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/WorkItemAction.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/ActionSuperType.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/ObjectFields.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/DataType.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/Pattern.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/Rules.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/FieldBase.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/ObjectField.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/FieldsBase.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/FieldCondition.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/Columns.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/RuleAttribute.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/Fields.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/ActivationTime.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/Column.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/DateEffectiveRuleAttribute.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/ObjectType.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/Condition.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/BRLCondition.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/Conditions.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/RetractAction.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/Action.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/FieldAction.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/Field.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/DateExpiresRuleAttribute.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/ConditionSuperType.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/BRLAction.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/model/Rule.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/keys/UUIDKeyProvider.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/keys/Values.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/keys/UUIDKey.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/keys/IndexKey.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/keys/UpdatableKey.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/keys/KeyType.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/keys/Value.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/keys/Key.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/matchers/UUIDMatcher.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/matchers/FieldMatchers.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/matchers/Matcher.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/matchers/ExactMatcher.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/matchers/ToMatcher.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/matchers/UUIDMatchers.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/matchers/KeyMatcher.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/matchers/ComparableMatchers.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/matchers/FromMatcher.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/select/Select.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/select/AllListener.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/select/QueryCallback.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/select/ExactMatcherSearch.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/select/ChangeHelper.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/select/Listen.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/select/LastListener.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/select/FirstListener.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/query/MapBy.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/query/QueryableIndex.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/query/Where.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/query/Matchers.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/index/query/Query.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/main/Analyzer.java",
    "drools-verifier/drools-verifier-core/src/main/java/org/drools/verifier/core/main/Reporter.java",
    "drools-beliefs/src/test/java/org/drools/beliefs/bayes/GraphTest.java",
    "drools-beliefs/src/test/java/org/drools/beliefs/bayes/example/SprinkerTest.java",
    "drools-beliefs/src/test/java/org/drools/beliefs/bayes/example/EarthQuakeTest.java",
    "drools-beliefs/src/test/java/org/drools/beliefs/bayes/integration/ParserTest.java",
    "drools-beliefs/src/test/java/org/drools/beliefs/bayes/integration/BayesBeliefSystemTest.java",
    "drools-beliefs/src/test/java/org/drools/beliefs/bayes/integration/AssemblerTest.java",
    "drools-beliefs/src/test/java/org/drools/beliefs/bayes/integration/Garden.java",
    "drools-beliefs/src/test/java/org/drools/beliefs/bayes/integration/BayesRuntimeTest.java",
    "drools-beliefs/src/test/java/org/drools/beliefs/bayes/integration/WeaverTest.java",
    "drools-beliefs/src/test/java/org/drools/beliefs/bayes/JunctionTreeTest.java",
    "drools-beliefs/src/test/java/org/drools/beliefs/bayes/GlobalUpdateTest.java",
    "drools-beliefs/src/test/java/org/drools/beliefs/bayes/LikelyhoodTest.java",
    "drools-beliefs/src/test/java/org/drools/beliefs/bayes/BayesProjectionTest.java",
    "drools-beliefs/src/test/java/org/drools/beliefs/bayes/PassMessageTest.java",
    "drools-beliefs/src/test/java/org/drools/beliefs/bayes/MarginalizerTest.java",
    "drools-beliefs/src/test/java/org/drools/beliefs/bayes/JunctionTreeBuilderTest.java",
    "drools-beliefs/src/test/java/org/drools/beliefs/bayes/BayesAbsorbtionTest.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/BayesBeliefService.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/graph/impl/GraphImpl.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/graph/impl/ListGraphStore.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/graph/impl/MapGraphStore.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/graph/impl/GraphNodeImpl.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/graph/impl/EdgeImpl.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/graph/impl/GraphStore.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/graph/Graph.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/graph/GraphNode.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/graph/Edge.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/graph/Direction.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/BayesInstanceManager.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/BayesVariableConstructor.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/CliqueBitSet.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/JunctionTreeClique.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/BayesVariableState.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/BayesModeFactory.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/assembler/BayesAssemblerService.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/assembler/JunctionTreeProcessor.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/assembler/BayesPackage.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/assembler/BayesNetworkAssemblerError.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/BayesHardEvidence.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/GlobalUpdateListener.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/NonConflictingModeSet.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/BayesNetwork.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/BayesBeliefSystem.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/runtime/BayesRuntimeService.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/runtime/BayesRuntimeImpl.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/runtime/BayesRuntime.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/VarName.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/BayesLikelyhood.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/BayesProjection.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/PotentialMultiplier.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/BayesAbsorption.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/SeparatorState.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/PassMessageListener.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/EliminationCandidate.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/weaver/BayesWeaverService.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/SeparatorSet.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/JunctionTreeSeparator.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/model/Definition.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/model/XmlBifParser.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/model/Probability.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/model/Network.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/model/Variable.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/model/Bif.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/model/VariableXml.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/BayesFact.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/BayesModeFactoryImpl.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/JunctionTreeBuilder.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/CliqueState.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/BayesVariable.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/BayesInstance.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/PropertyReference.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/Marginalizer.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/bayes/JunctionTree.java",
    "drools-beliefs/src/main/java/org/drools/beliefs/PropertyChangeMask.java",
    "drools-decisiontables/src/test/java/org/acme/insurance/launcher/PricingRuleLauncher.java",
    "drools-decisiontables/src/test/java/org/acme/insurance/Driver.java",
    "drools-decisiontables/src/test/java/org/acme/insurance/Policy.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/MakeSureMultiLinesWorkTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/DumpGeneratedDrlTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/UnicodeInCSVTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/PrioritySetWithFormulaTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/ChangeSetTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/SpreadsheetCompilerUnitTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/LineBreakXLSTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/integrationtests/IncrementalCompilationTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/integrationtests/KModuleWithDecisionTablesTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/parser/PropertiesSheetListenerTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/parser/xls/ExcelParserTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/parser/RuleWorksheetParseLargeTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/parser/LhsBuilderTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/parser/RhsBuilderTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/parser/ColumnFactoryTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/parser/RuleWorksheetParseTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/parser/RuleSheetParserUtilTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/parser/csv/CsvLineParserTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/parser/csv/CsvParserTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/parser/RulesheetUtil.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/parser/ActionTypeTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/ExternalSpreadsheetCompilerTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/project/Person.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/project/Result.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/project/MultiKieBaseTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/Cheese.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/Person.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/UnicodeInXLSTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/DecimalSeparatorTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/LinkedWorkbookTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/XlsFormulaTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/EmptyHeaderTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/CalendarTimerResourcesTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/FixedPatternTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/ColumnReplaceTest.java",
    "drools-decisiontables/src/test/java/org/drools/decisiontable/SpreadsheetIntegrationExampleTest.java",
    "drools-decisiontables/src/test/java/com/sample/FactData.java",
    "drools-decisiontables/src/main/java/org/drools/decisiontable/osgi/Activator.java",
    "drools-decisiontables/src/main/java/org/drools/decisiontable/parser/RhsBuilder.java",
    "drools-decisiontables/src/main/java/org/drools/decisiontable/parser/RuleSheetParserUtil.java",
    "drools-decisiontables/src/main/java/org/drools/decisiontable/parser/xls/ExcelParser.java",
    "drools-decisiontables/src/main/java/org/drools/decisiontable/parser/xls/PropertiesSheetListener.java",
    "drools-decisiontables/src/main/java/org/drools/decisiontable/parser/xls/NullSheetListener.java",
    "drools-decisiontables/src/main/java/org/drools/decisiontable/parser/DecisionTableParser.java",
    "drools-decisiontables/src/main/java/org/drools/decisiontable/parser/ActionType.java",
    "drools-decisiontables/src/main/java/org/drools/decisiontable/parser/DefaultRuleSheetListener.java",
    "drools-decisiontables/src/main/java/org/drools/decisiontable/parser/LhsBuilder.java",
    "drools-decisiontables/src/main/java/org/drools/decisiontable/parser/RuleMatrixSheetListener.java",
    "drools-decisiontables/src/main/java/org/drools/decisiontable/parser/RuleSheetListener.java",
    "drools-decisiontables/src/main/java/org/drools/decisiontable/parser/csv/CsvParser.java",
    "drools-decisiontables/src/main/java/org/drools/decisiontable/parser/csv/CsvLineParser.java",
    "drools-decisiontables/src/main/java/org/drools/decisiontable/parser/SourceBuilder.java",
    "drools-decisiontables/src/main/java/org/drools/decisiontable/InputType.java",
    "drools-decisiontables/src/main/java/org/drools/decisiontable/DecisionTableProviderImpl.java",
    "drools-decisiontables/src/main/java/org/drools/decisiontable/SpreadsheetCompiler.java",
    "drools-decisiontables/src/main/java/org/drools/decisiontable/package-info.java",
    "drools-decisiontables/src/main/java/org/drools/decisiontable/ExternalSpreadsheetCompiler.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/predictive/TargetsAndOutputsTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/predictive/AttributesTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/predictive/models/ClusteringTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/predictive/models/CleanupTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/predictive/models/DecisionTreeTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/predictive/models/NeuralNetworkTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/predictive/models/mining/MiningModelWeightedAverageTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/predictive/models/mining/MiningModelSelectFirstTreeTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/predictive/models/mining/MiningModelSumRegressionTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/predictive/models/mining/MiningModelSelectFirstRegressionTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/predictive/models/mining/MiningModelSelectAllRegressionTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/predictive/models/mining/MiningModelChainRegressionTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/predictive/models/SimpleRegressionTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/predictive/models/NaiveBayesTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/predictive/models/MiningmodelTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/predictive/models/DecisionTreeWithSurrogateTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/predictive/models/SVMTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/predictive/models/MultipleModelTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/predictive/models/ScorecardTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/predictive/MiningSchemaTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/PMMLGenerationTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/transformations/AliasedFieldsTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/transformations/DiscretizeFieldsTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/transformations/MapValuesTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/transformations/FunctionsWithNestedTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/transformations/FunctionsTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/transformations/AggregateFieldsTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/transformations/UserDefinedFunctionsTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/transformations/NormDiscreteFieldsTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/transformations/LinearNormalizedFieldsTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/PMMLExecutor.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/PMMLErrorTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/DroolsAbstractPMMLTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/model/mining/SimpleSegmentPredicateTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/model/mining/CompoundSegmentPredicateTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/model/mining/SimpleSetSegmentPredicateTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/model/mining/MiningSegmentTransferTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/model/ExternalBeanRefTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/PMMLUsageDemoTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/PMMLKieBaseUtil.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/global/HeaderTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/global/AdapterTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/global/DataDictionaryTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/global/ConstrainedDataDictionaryTest.java",
    "kie-pmml/src/test/java/org/kie/pmml/pmml_4_2/KieBaseTest.java",
    "kie-pmml/src/main/java/org/kie/pmml/assembler/PMMLAssemblerService.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/osgi/Activator.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/ModelMarker.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/PMMLWarning.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/PMML4Compiler.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/PMML4Model.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/PMMLRequestDataBuilder.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/extensions/PMMLExtensionNames.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/extensions/AggregationStrategy.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/extensions/PMMLIOAdapterMode.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/PMMLGeneratorUtils.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/PMML4Exception.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/PMMLDataType.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/tree/ScoreDistributionInfo.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/tree/AbstractTreeToken.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/tree/TreeNode.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/AbstractPMMLData.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/AbstractModel.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/PMMLOutputField.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/ExternalBeanRef.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/datatypes/PMML4Placeholder.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/datatypes/PMML4Integer.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/datatypes/PMML4Date.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/datatypes/PMML4Double.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/datatypes/PMML4DataFactory.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/datatypes/PMML4String.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/datatypes/PMML4Boolean.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/PMML4ModelType.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/ScoreCard.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/Miningmodel.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/ScorecardModel.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/mining/CompoundSegmentPredicate.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/mining/SimpleSetSegmentPredicate.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/mining/PredicateRuleProducer.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/mining/PredicateRuleFactory.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/mining/MiningSegmentation.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/mining/SegmentExecution.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/mining/MiningSegmentWeight.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/mining/MiningSegment.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/mining/MiningSegmentTransfer.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/mining/MiningSegmentPredicateType.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/mining/SimpleSegmentPredicate.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/mining/BooleanSegmentPredicate.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/mining/SegmentExecutionState.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/DataXstreamConverter.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/PMML4UnitImpl.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/Treemodel.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/PMML4ModelFactory.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/PMMLDataField.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/PMMLMiningField.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/ExternalBeanDefinition.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/regression/RegTable.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/regression/RegNormalizationFactor.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/regression/RegTargetBit.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/scorecard/PartialScore.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/scorecard/BaselineScore.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/scorecard/CodeScore.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/scorecard/ComplexScore.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/scorecard/ScoreRank.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/scorecard/ScoreRow.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/scorecard/Score.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/scorecard/InitialScore.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/Regression.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/model/PMMLOutputConverter.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/PMMLResource.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/PMML4Unit.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/PMML4Helper.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/PMML4ExecutionHelper.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/compiler/FieldScope.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/compiler/QueryMarker.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/compiler/ModelStat.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/compiler/TypeOfField.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/compiler/FieldMarker.java",
    "kie-pmml/src/main/java/org/kie/pmml/pmml_4_2/PMMLError.java",
    "drools-examples/src/main/java/org/drools/benchmark/waltz/Stage.java",
    "drools-examples/src/main/java/org/drools/benchmark/waltz/WaltzBenchmark.java",
    "drools-examples/src/main/java/org/drools/benchmark/waltz/Junction.java",
    "drools-examples/src/main/java/org/drools/benchmark/waltz/WaltzUtil.java",
    "drools-examples/src/main/java/org/drools/benchmark/waltz/Edge.java",
    "drools-examples/src/main/java/org/drools/benchmark/waltz/Line.java",
    "drools-examples/src/main/java/org/drools/benchmark/DroolsBenchmarkExamplesApp.java",
    "drools-examples/src/main/java/org/drools/benchmark/waltzdb/Stage.java",
    "drools-examples/src/main/java/org/drools/benchmark/waltzdb/Label.java",
    "drools-examples/src/main/java/org/drools/benchmark/waltzdb/Illegal.java",
    "drools-examples/src/main/java/org/drools/benchmark/waltzdb/EdgeLabel.java",
    "drools-examples/src/main/java/org/drools/benchmark/waltzdb/Junction.java",
    "drools-examples/src/main/java/org/drools/benchmark/waltzdb/WaltzDbBenchmark.java",
    "drools-examples/src/main/java/org/drools/benchmark/waltzdb/Edge.java",
    "drools-examples/src/main/java/org/drools/benchmark/waltzdb/Line.java",
    "drools-examples/src/main/java/org/drools/examples/datadriventemplate/DataDrivenTemplateExample.java",
    "drools-examples/src/main/java/org/drools/examples/helloworld/HelloWorldExample.java",
    "drools-examples/src/main/java/org/drools/examples/troubleticket/Customer.java",
    "drools-examples/src/main/java/org/drools/examples/troubleticket/TroubleTicketExampleWithDT.java",
    "drools-examples/src/main/java/org/drools/examples/troubleticket/TroubleTicketExampleWithDSL.java",
    "drools-examples/src/main/java/org/drools/examples/troubleticket/Ticket.java",
    "drools-examples/src/main/java/org/drools/examples/troubleticket/TroubleTicketExample.java",
    "drools-examples/src/main/java/org/drools/examples/shopping/ShoppingExample.java",
    "drools-examples/src/main/java/org/drools/examples/traits/ScholarImpl.java",
    "drools-examples/src/main/java/org/drools/examples/traits/TraitExample.java",
    "drools-examples/src/main/java/org/drools/examples/traits/Scholar.java",
    "drools-examples/src/main/java/org/drools/examples/workitemconsequence/WorkItemConsequenceExample1.java",
    "drools-examples/src/main/java/org/drools/examples/workitemconsequence/WorkItemConsequenceExample2.java",
    "drools-examples/src/main/java/org/drools/examples/birdsfly/Bird.java",
    "drools-examples/src/main/java/org/drools/examples/birdsfly/Broken.java",
    "drools-examples/src/main/java/org/drools/examples/birdsfly/BirdsFlyExample.java",
    "drools-examples/src/main/java/org/drools/examples/birdsfly/Fly.java",
    "drools-examples/src/main/java/org/drools/examples/birdsfly/Rocket.java",
    "drools-examples/src/main/java/org/drools/examples/cashflow/CashFlow.java",
    "drools-examples/src/main/java/org/drools/examples/cashflow/CashFlowType.java",
    "drools-examples/src/main/java/org/drools/examples/cashflow/Account.java",
    "drools-examples/src/main/java/org/drools/examples/cashflow/AccountPeriod.java",
    "drools-examples/src/main/java/org/drools/examples/cashflow/CashFlowMain.java",
    "drools-examples/src/main/java/org/drools/examples/state/StateExampleUsingAgendaGroup.java",
    "drools-examples/src/main/java/org/drools/examples/state/State.java",
    "drools-examples/src/main/java/org/drools/examples/state/StateExampleUsingSalience.java",
    "drools-examples/src/main/java/org/drools/examples/circularTms/CircularTmsExample.java",
    "drools-examples/src/main/java/org/drools/examples/sudoku/swing/SudokuGridEvent.java",
    "drools-examples/src/main/java/org/drools/examples/sudoku/swing/SudokuGridView.java",
    "drools-examples/src/main/java/org/drools/examples/sudoku/swing/SudokuGridModel.java",
    "drools-examples/src/main/java/org/drools/examples/sudoku/swing/SudokuGridSamples.java",
    "drools-examples/src/main/java/org/drools/examples/sudoku/swing/AbstractSudokuGridModel.java",
    "drools-examples/src/main/java/org/drools/examples/sudoku/swing/SudokuGridListener.java",
    "drools-examples/src/main/java/org/drools/examples/sudoku/Stepping.java",
    "drools-examples/src/main/java/org/drools/examples/sudoku/CellGroup.java",
    "drools-examples/src/main/java/org/drools/examples/sudoku/Sudoku.java",
    "drools-examples/src/main/java/org/drools/examples/sudoku/Counter.java",
    "drools-examples/src/main/java/org/drools/examples/sudoku/SetOfNine.java",
    "drools-examples/src/main/java/org/drools/examples/sudoku/CellSqr.java",
    "drools-examples/src/main/java/org/drools/examples/sudoku/Setting.java",
    "drools-examples/src/main/java/org/drools/examples/sudoku/CellCol.java",
    "drools-examples/src/main/java/org/drools/examples/sudoku/CellFile.java",
    "drools-examples/src/main/java/org/drools/examples/sudoku/Cell.java",
    "drools-examples/src/main/java/org/drools/examples/sudoku/CellRow.java",
    "drools-examples/src/main/java/org/drools/examples/sudoku/SudokuExample.java",
    "drools-examples/src/main/java/org/drools/examples/golfing/GolfingExample.java",
    "drools-examples/src/main/java/org/drools/examples/banking/Cashflow.java",
    "drools-examples/src/main/java/org/drools/examples/banking/SimpleDate.java",
    "drools-examples/src/main/java/org/drools/examples/banking/BankingExample1.java",
    "drools-examples/src/main/java/org/drools/examples/banking/BankingExample6.java",
    "drools-examples/src/main/java/org/drools/examples/banking/RuleRunner.java",
    "drools-examples/src/main/java/org/drools/examples/banking/AllocatedCashflow.java",
    "drools-examples/src/main/java/org/drools/examples/banking/Account.java",
    "drools-examples/src/main/java/org/drools/examples/banking/BankingExamplesApp.java",
    "drools-examples/src/main/java/org/drools/examples/banking/TypedCashflow.java",
    "drools-examples/src/main/java/org/drools/examples/banking/BankingExample4.java",
    "drools-examples/src/main/java/org/drools/examples/banking/BankingExample5.java",
    "drools-examples/src/main/java/org/drools/examples/banking/BankingExample2.java",
    "drools-examples/src/main/java/org/drools/examples/banking/BankingExample3.java",
    "drools-examples/src/main/java/org/drools/examples/fire/Room.java",
    "drools-examples/src/main/java/org/drools/examples/fire/FireExample.java",
    "drools-examples/src/main/java/org/drools/examples/fire/FireLogicalExample.java",
    "drools-examples/src/main/java/org/drools/examples/fire/Fire.java",
    "drools-examples/src/main/java/org/drools/examples/fire/Sprinkler.java",
    "drools-examples/src/main/java/org/drools/examples/fire/Alarm.java",
    "drools-examples/src/main/java/org/drools/examples/honestpolitician/Hope.java",
    "drools-examples/src/main/java/org/drools/examples/honestpolitician/Politician.java",
    "drools-examples/src/main/java/org/drools/examples/honestpolitician/HonestPoliticianExample.java",
    "drools-examples/src/main/java/org/drools/examples/backwardchaining/HouseOfDoomMain.java",
    "drools-examples/src/main/java/org/drools/examples/backwardchaining/Location.java",
    "drools-examples/src/main/java/org/drools/examples/DroolsExamplesApp.java",
    "drools-examples/src/main/java/org/drools/examples/diagnostics/Solution.java",
    "drools-examples/src/main/java/org/drools/examples/diagnostics/Answer.java",
    "drools-examples/src/main/java/org/drools/examples/diagnostics/WontStart.java",
    "drools-examples/src/main/java/org/drools/examples/diagnostics/Question.java",
    "drools-examples/src/main/java/org/drools/examples/diagnostics/DiagnosticsExample.java",
    "drools-examples/src/main/java/org/drools/examples/templates/SimpleRuleTemplateExample.java",
    "drools-examples/src/main/java/org/drools/examples/templates/FeeType.java",
    "drools-examples/src/main/java/org/drools/examples/templates/FeeScheduleType.java",
    "drools-examples/src/main/java/org/drools/examples/templates/Cheese.java",
    "drools-examples/src/main/java/org/drools/examples/templates/ProductType.java",
    "drools-examples/src/main/java/org/drools/examples/templates/Person.java",
    "drools-examples/src/main/java/org/drools/examples/templates/ActivityType.java",
    "drools-examples/src/main/java/org/drools/examples/templates/FeeScheduleRule.java",
    "drools-examples/src/main/java/org/drools/examples/petstore/PetStoreExample.java",
    "drools-examples/src/main/java/org/drools/examples/buspass/ChildBusPass.java",
    "drools-examples/src/main/java/org/drools/examples/buspass/BadBehaviour.java",
    "drools-examples/src/main/java/org/drools/examples/buspass/IsAdult.java",
    "drools-examples/src/main/java/org/drools/examples/buspass/Person.java",
    "drools-examples/src/main/java/org/drools/examples/buspass/AdultBusPass.java",
    "drools-examples/src/main/java/org/drools/examples/buspass/BusPass.java",
    "drools-examples/src/main/java/org/drools/examples/buspass/BussPassBadExample.java",
    "drools-examples/src/main/java/org/drools/examples/buspass/BussPassJTMSExample.java",
    "drools-examples/src/main/java/org/drools/examples/buspass/BussPassGoodExample.java",
    "drools-examples/src/main/java/org/drools/examples/buspass/IsChild.java",
    "drools-examples/src/main/java/org/drools/examples/fibonacci/FibonacciExample.java",
    "drools-examples/src/main/java/org/drools/examples/decisiontable/PricingRuleDTExample.java",
    "drools-examples/src/main/java/org/drools/examples/decisiontable/Driver.java",
    "drools-examples/src/main/java/org/drools/examples/decisiontable/Policy.java",
    "drools-examples/src/main/java/org/drools/examples/decisiontable/PricingRuleTemplateExample.java",
    "drools-examples/src/main/java/org/drools/examples/performance/PerformanceExample.java",
    "drools-examples/src/main/java/org/drools/games/Run.java",
    "drools-examples/src/main/java/org/drools/games/KeyPressed.java",
    "drools-examples/src/main/java/org/drools/games/numberguess/Guess.java",
    "drools-examples/src/main/java/org/drools/games/numberguess/RandomNumber.java",
    "drools-examples/src/main/java/org/drools/games/numberguess/GameRules.java",
    "drools-examples/src/main/java/org/drools/games/numberguess/Game.java",
    "drools-examples/src/main/java/org/drools/games/numberguess/NumberGuessMain.java",
    "drools-examples/src/main/java/org/drools/games/GameConfiguration.java",
    "drools-examples/src/main/java/org/drools/games/invaders/Invaders1Main.java",
    "drools-examples/src/main/java/org/drools/games/invaders/Unit.java",
    "drools-examples/src/main/java/org/drools/games/invaders/InvadersConfiguration.java",
    "drools-examples/src/main/java/org/drools/games/invaders/Ship.java",
    "drools-examples/src/main/java/org/drools/games/invaders/Invaders6Main.java",
    "drools-examples/src/main/java/org/drools/games/invaders/Bullet.java",
    "drools-examples/src/main/java/org/drools/games/invaders/FPSTimer.java",
    "drools-examples/src/main/java/org/drools/games/invaders/Invaders2Main.java",
    "drools-examples/src/main/java/org/drools/games/invaders/Invaders3Main.java",
    "drools-examples/src/main/java/org/drools/games/invaders/Invader.java",
    "drools-examples/src/main/java/org/drools/games/invaders/Invaders5Main.java",
    "drools-examples/src/main/java/org/drools/games/invaders/Invaders4Main.java",
    "drools-examples/src/main/java/org/drools/games/adventures/Response.java",
    "drools-examples/src/main/java/org/drools/games/adventures/GameEngine.java",
    "drools-examples/src/main/java/org/drools/games/adventures/UserSession.java",
    "drools-examples/src/main/java/org/drools/games/adventures/AdventureFrame.java",
    "drools-examples/src/main/java/org/drools/games/adventures/Counter.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/ExitEvent.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/GiveEvent.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/Room.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/Door.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/LookCommand.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/Holding.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/DropCommand.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/DropEvent.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/GiveCommand.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/Thing.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/Command.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/SearchCommand.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/Character.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/EnterEvent.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/PickupCommand.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/GameEvent.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/UseCommand.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/Location.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/Key.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/PickupEvent.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/LockStatus.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/Item.java",
    "drools-examples/src/main/java/org/drools/games/adventures/model/MoveCommand.java",
    "drools-examples/src/main/java/org/drools/games/adventures/TextAdventure.java",
    "drools-examples/src/main/java/org/drools/games/adventures/Action.java",
    "drools-examples/src/main/java/org/drools/games/adventures/Request.java",
    "drools-examples/src/main/java/org/drools/games/GameFrame.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/Hero.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/Reset.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/Play.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/Init.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/Wumpus.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/MoveEvent.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/HearScream.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/WumpusDeath.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/GrabCommand.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/Thing.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/SeeGlitter.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/WumpusWorldConfiguration.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/Command.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/StartNewTurnEvent.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/EndEvent.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/Start.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/FeelBreeze.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/SmellStench.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/WumpusWorldMain.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/ShootCommand.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/SensorArray.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/StartGameEvent.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/EndNewTurnEvent.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/Arrow.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/StartEvent.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/Score.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/PitDeath.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/view/GameView.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/view/GameUI.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/Pit.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/FeelBump.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/Move.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/GoldWin.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/Cell.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/Direction.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/ClimbCommand.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/Gold.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/EndGameEvent.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/Sensor.java",
    "drools-examples/src/main/java/org/drools/games/wumpus/MoveCommand.java",
    "drools-examples/src/main/java/org/drools/games/GameUI.java",
    "drools-examples/src/main/java/org/drools/games/pong/PointWin.java",
    "drools-examples/src/main/java/org/drools/games/pong/PongMain.java",
    "drools-examples/src/main/java/org/drools/games/pong/PongGame.java",
    "drools-examples/src/main/java/org/drools/games/pong/Bat.java",
    "drools-examples/src/main/java/org/drools/games/pong/Collision.java",
    "drools-examples/src/main/java/org/drools/games/pong/PongUI.java",
    "drools-examples/src/main/java/org/drools/games/pong/Player.java",
    "drools-examples/src/main/java/org/drools/games/pong/Ball.java",
    "drools-examples/src/main/java/org/drools/games/pong/CollisionType.java",
    "drools-examples/src/main/java/org/drools/games/pong/PongConfiguration.java",
    "drools-examples/src/main/java/org/drools/games/pong/PlayerId.java",
    "drools-examples/src/main/java/org/drools/games/GamePanel.java",
    "drools-cdi/src/test/java/org/drools/cdi/KieBaseDefaultInjectionTest.java",
    "drools-cdi/src/test/java/org/drools/cdi/KieContainerInjectionTest.java",
    "drools-cdi/src/test/java/org/drools/cdi/kproject/KProjectTestClass.java",
    "drools-cdi/src/test/java/org/drools/cdi/kproject/KPTest.java",
    "drools-cdi/src/test/java/org/drools/cdi/kproject/AbstractKnowledgeTest.java",
    "drools-cdi/src/test/java/org/drools/cdi/kproject/KProjectTestClassImpl.java",
    "drools-cdi/src/test/java/org/drools/cdi/kproject/KieProjectRuntimeModulesTest.java",
    "drools-cdi/src/test/java/org/drools/cdi/kproject/KieModuleModelTest.java",
    "drools-cdi/src/test/java/org/drools/cdi/kproject/KieProjectDefaultClasspathTest.java",
    "drools-cdi/src/test/java/org/drools/cdi/kproject/KieProjectCDITest.java",
    "drools-cdi/src/test/java/org/drools/cdi/kproject/ClasspathKieProjectTest.java",
    "drools-cdi/src/test/java/org/drools/cdi/CDIScopeTest.java",
    "drools-cdi/src/test/java/org/drools/cdi/KieSessionInjectionTest.java",
    "drools-cdi/src/test/java/org/drools/cdi/StatelessKieSessionInjectionTest.java",
    "drools-cdi/src/test/java/org/drools/cdi/example/Message.java",
    "drools-cdi/src/test/java/org/drools/cdi/example/TestClass.java",
    "drools-cdi/src/test/java/org/drools/cdi/example/MessageProducers2.java",
    "drools-cdi/src/test/java/org/drools/cdi/example/Message2Impl2.java",
    "drools-cdi/src/test/java/org/drools/cdi/example/Msg.java",
    "drools-cdi/src/test/java/org/drools/cdi/example/Message2.java",
    "drools-cdi/src/test/java/org/drools/cdi/example/MessageImpl.java",
    "drools-cdi/src/test/java/org/drools/cdi/example/CDIExamplesTest.java",
    "drools-cdi/src/test/java/org/drools/cdi/example/Msg2.java",
    "drools-cdi/src/test/java/org/drools/cdi/example/Msg1.java",
    "drools-cdi/src/test/java/org/drools/cdi/example/MessageProducers.java",
    "drools-cdi/src/test/java/org/drools/cdi/example/Message2Impl1.java",
    "drools-cdi/src/test/java/org/drools/cdi/example/TestClassImpl.java",
    "drools-cdi/src/test/java/org/drools/cdi/StatelessKieSessionDefaultInjectionTest.java",
    "drools-cdi/src/test/java/org/drools/cdi/KieSessionDefaultInjectionTest.java",
    "drools-cdi/src/test/java/org/drools/cdi/KieServicesInjectionTest.java",
    "drools-cdi/src/test/java/org/drools/cdi/KieBaseInjectionTest.java",
    "drools-cdi/src/test/java/org/drools/cdi/CDITestRunner.java",
    "drools-cdi/src/main/java/org/drools/cdi/CDIHelper.java",
    "drools-cdi/src/main/java/org/drools/cdi/KieCDIExtension.java",
    "drools-cdi/src/main/java/org/drools/cdi/CDIProducer.java",
    "drools-core/src/test/java/org/drools/core/impl/KnowledgeBaseImplTest.java",
    "drools-core/src/test/java/org/drools/core/test/model/FirstClass.java",
    "drools-core/src/test/java/org/drools/core/test/model/RuleBaseConfigurationTest.java",
    "drools-core/src/test/java/org/drools/core/test/model/TestRuleRuntimeEventListener.java",
    "drools-core/src/test/java/org/drools/core/test/model/SecondClass.java",
    "drools-core/src/test/java/org/drools/core/test/model/CheeseInterface.java",
    "drools-core/src/test/java/org/drools/core/test/model/MockFactHandle.java",
    "drools-core/src/test/java/org/drools/core/test/model/Address.java",
    "drools-core/src/test/java/org/drools/core/test/model/Cheese.java",
    "drools-core/src/test/java/org/drools/core/test/model/Person.java",
    "drools-core/src/test/java/org/drools/core/test/model/StockTick.java",
    "drools-core/src/test/java/org/drools/core/test/model/CheeseEqual.java",
    "drools-core/src/test/java/org/drools/core/test/model/DroolsTestCase.java",
    "drools-core/src/test/java/org/drools/core/test/model/MockActivation.java",
    "drools-core/src/test/java/org/drools/core/util/LinkedListTest.java",
    "drools-core/src/test/java/org/drools/core/util/IoUtilsTest.java",
    "drools-core/src/test/java/org/drools/core/util/KeyStoreHelperTest.java",
    "drools-core/src/test/java/org/drools/core/util/HierarchyTest.java",
    "drools-core/src/test/java/org/drools/core/util/asm/BeanInherit.java",
    "drools-core/src/test/java/org/drools/core/util/asm/InterfaceParent2.java",
    "drools-core/src/test/java/org/drools/core/util/asm/BaseBean.java",
    "drools-core/src/test/java/org/drools/core/util/asm/TestObject.java",
    "drools-core/src/test/java/org/drools/core/util/asm/MethodComparerTest.java",
    "drools-core/src/test/java/org/drools/core/util/asm/TestBean.java",
    "drools-core/src/test/java/org/drools/core/util/asm/TestAbstractImpl.java",
    "drools-core/src/test/java/org/drools/core/util/asm/MethodCompareB.java",
    "drools-core/src/test/java/org/drools/core/util/asm/ClassFieldInspectorTest.java",
    "drools-core/src/test/java/org/drools/core/util/asm/TestInterface.java",
    "drools-core/src/test/java/org/drools/core/util/asm/AbstractClass.java",
    "drools-core/src/test/java/org/drools/core/util/asm/MethodCompareA.java",
    "drools-core/src/test/java/org/drools/core/util/asm/TestInterfaceImpl.java",
    "drools-core/src/test/java/org/drools/core/util/asm/InterfaceParent.java",
    "drools-core/src/test/java/org/drools/core/util/asm/TestAbstract.java",
    "drools-core/src/test/java/org/drools/core/util/asm/InterfaceChild.java",
    "drools-core/src/test/java/org/drools/core/util/asm/InterfaceChildImpl.java",
    "drools-core/src/test/java/org/drools/core/util/ClassUtilsTest.java",
    "drools-core/src/test/java/org/drools/core/util/TripleStoreTest.java",
    "drools-core/src/test/java/org/drools/core/util/DroolsAssert.java",
    "drools-core/src/test/java/org/drools/core/util/BinaryHeapQueueTest.java",
    "drools-core/src/test/java/org/drools/core/util/ObjectHashMapTest.java",
    "drools-core/src/test/java/org/drools/core/util/FieldIndexEntryTest.java",
    "drools-core/src/test/java/org/drools/core/util/RBTreeTest.java",
    "drools-core/src/test/java/org/drools/core/util/RightTupleListTest.java",
    "drools-core/src/test/java/org/drools/core/util/KieFunctionsTest.java",
    "drools-core/src/test/java/org/drools/core/util/LeftTupleRBTreeTest.java",
    "drools-core/src/test/java/org/drools/core/util/NaturalComparator.java",
    "drools-core/src/test/java/org/drools/core/util/MVELSafeHelperTest.java",
    "drools-core/src/test/java/org/drools/core/util/RightTupleIndexHashTableTest.java",
    "drools-core/src/test/java/org/drools/core/util/IndexedHashtableIteratorTest.java",
    "drools-core/src/test/java/org/drools/core/util/LeftLeftTupleIndexHashTableIteratorTest.java",
    "drools-core/src/test/java/org/drools/core/util/LongQueueable.java",
    "drools-core/src/test/java/org/drools/core/util/BaseQueueable.java",
    "drools-core/src/test/java/org/drools/core/util/StringUtilsTest.java",
    "drools-core/src/test/java/org/drools/core/util/BinaryHeapPriorityQueueTest.java",
    "drools-core/src/test/java/org/drools/core/util/FileManager.java",
    "drools-core/src/test/java/org/drools/core/util/RightTupleIndexHashTableIteratorTest.java",
    "drools-core/src/test/java/org/drools/core/util/HeapDump.java",
    "drools-core/src/test/java/org/drools/core/util/ScalablePoolTest.java",
    "drools-core/src/test/java/org/drools/core/util/DroolsTestUtil.java",
    "drools-core/src/test/java/org/drools/core/factmodel/ClassBuilderTest.java",
    "drools-core/src/test/java/org/drools/core/factmodel/JeneratorTest.java",
    "drools-core/src/test/java/org/drools/core/factmodel/InstancesHashcodedTest.java",
    "drools-core/src/test/java/org/drools/core/marshalling/impl/ObjectMarshallingStrategyStoreTest.java",
    "drools-core/src/test/java/org/drools/core/marshalling/common/MarshallerTest.java",
    "drools-core/src/test/java/org/drools/core/io/impl/ByteArrayResourceToStringTest.java",
    "drools-core/src/test/java/org/drools/core/io/impl/ReaderResourceTest.java",
    "drools-core/src/test/java/org/drools/core/runtime/help/impl/XStreamXMLTest.java",
    "drools-core/src/test/java/org/drools/core/meta/org/test/SubKlassImpl.java",
    "drools-core/src/test/java/org/drools/core/meta/org/test/AnotherKlass_.java",
    "drools-core/src/test/java/org/drools/core/meta/org/test/SubKlass.java",
    "drools-core/src/test/java/org/drools/core/meta/org/test/Klass_.java",
    "drools-core/src/test/java/org/drools/core/meta/org/test/AnotherKlass.java",
    "drools-core/src/test/java/org/drools/core/meta/org/test/SubKlass_.java",
    "drools-core/src/test/java/org/drools/core/meta/org/test/Klass.java",
    "drools-core/src/test/java/org/drools/core/meta/org/test/KlassImpl.java",
    "drools-core/src/test/java/org/drools/core/meta/org/test/AnotherKlassImpl.java",
    "drools-core/src/test/java/org/drools/core/meta/MetadataTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/NodeTypeEnumTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/CompositeObjectSinkAdapterTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/AlphaNodeTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/RuleUnlinkingWithSegmentMemoryTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/MockEvalCondition.java",
    "drools-core/src/test/java/org/drools/core/reteoo/MockRightTupleSink.java",
    "drools-core/src/test/java/org/drools/core/reteoo/PropertyChangeListenerTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/ObjectSourceTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/BetaNodeTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/ReteComparator.java",
    "drools-core/src/test/java/org/drools/core/reteoo/TupleIterationTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/ReteooWorkingMemoryTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/CrossProductTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/AddRemoveTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/MockTupleSource.java",
    "drools-core/src/test/java/org/drools/core/reteoo/MockAccumulator.java",
    "drools-core/src/test/java/org/drools/core/reteoo/ReteTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/TupleSourceTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/RuleUnlinkingTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/NodeSegmentUnlinkingTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/ReteooRuleBaseMultiThreadedTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/FactHandleTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/QueryElementNodeTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/ObjectTypeConfTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/builder/ReteooRuleBuilderTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/builder/BuildUtilsTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/BaseNodeTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/MockObjectSink.java",
    "drools-core/src/test/java/org/drools/core/reteoo/ReteMemoryChecker.java",
    "drools-core/src/test/java/org/drools/core/reteoo/ReteDumper.java",
    "drools-core/src/test/java/org/drools/core/reteoo/MockLeftTupleSink.java",
    "drools-core/src/test/java/org/drools/core/reteoo/DefaultFactHandleFactoryTest.java",
    "drools-core/src/test/java/org/drools/core/reteoo/MockObjectSource.java",
    "drools-core/src/test/java/org/drools/core/integrationtests/SerializationHelper.java",
    "drools-core/src/test/java/org/drools/core/xml/XmlChangeSetReaderTest.java",
    "drools-core/src/test/java/org/drools/core/xml/GenericsTest.java",
    "drools-core/src/test/java/org/drools/core/ruleunit/TestRuleUnit.java",
    "drools-core/src/test/java/org/drools/core/ruleunit/RuleUnitDescriptionRegistryTest.java",
    "drools-core/src/test/java/org/drools/core/ruleunit/RuleUnitDescriptionTest.java",
    "drools-core/src/test/java/org/drools/core/ruleunit/SimpleFact.java",
    "drools-core/src/test/java/org/drools/core/ruleunit/RuleUnitWithDataSource.java",
    "drools-core/src/test/java/org/drools/core/ruleunit/GuardTest.java",
    "drools-core/src/test/java/org/drools/core/ruleunit/RuleUnitFactoryTest.java",
    "drools-core/src/test/java/org/drools/core/ruleunit/RuleUnitTestUtil.java",
    "drools-core/src/test/java/org/drools/core/ruleunit/RuleUnitDescriptionLoaderTest.java",
    "drools-core/src/test/java/org/drools/core/ruleunit/TestRuleUnit2.java",
    "drools-core/src/test/java/org/drools/core/ruleunit/RuleUnitGuardSystemTest.java",
    "drools-core/src/test/java/org/drools/core/time/impl/CronExpressionTest.java",
    "drools-core/src/test/java/org/drools/core/time/impl/CompositeMaxDurationTimerTest.java",
    "drools-core/src/test/java/org/drools/core/time/impl/PseudoClockSchedulerTest.java",
    "drools-core/src/test/java/org/drools/core/time/impl/SerializationTestSupport.java",
    "drools-core/src/test/java/org/drools/core/time/impl/Quartz601Test.java",
    "drools-core/src/test/java/org/drools/core/time/impl/CronJobTest.java",
    "drools-core/src/test/java/org/drools/core/time/impl/JDKTimerServiceTest.java",
    "drools-core/src/test/java/org/drools/core/time/TemporalDistanceTest.java",
    "drools-core/src/test/java/org/drools/core/rule/RuleTest.java",
    "drools-core/src/test/java/org/drools/core/rule/PackageCompilationDataTest.java",
    "drools-core/src/test/java/org/drools/core/rule/LogicTransformerTest.java",
    "drools-core/src/test/java/org/drools/core/rule/GroupElementTest.java",
    "drools-core/src/test/java/org/drools/core/rule/DeclarationTest.java",
    "drools-core/src/test/java/org/drools/core/rule/FieldConstraintTest.java",
    "drools-core/src/test/java/org/drools/core/rule/FixedDurationTest.java",
    "drools-core/src/test/java/org/drools/core/rule/PatternTest.java",
    "drools-core/src/test/java/org/drools/core/rule/EnumSerialiationTest.java",
    "drools-core/src/test/java/org/drools/core/rule/MvelConstraintTestUtil.java",
    "drools-core/src/test/java/org/drools/core/common/SingleBetaConstraintsTest.java",
    "drools-core/src/test/java/org/drools/core/common/LazyTMSEnablingTest.java",
    "drools-core/src/test/java/org/drools/core/common/BaseBetaConstraintsTest.java",
    "drools-core/src/test/java/org/drools/core/common/DroolsObjectIOTest.java",
    "drools-core/src/test/java/org/drools/core/common/QuadroupleBetaConstraintsTest.java",
    "drools-core/src/test/java/org/drools/core/common/DefaultBetaConstraintsTest.java",
    "drools-core/src/test/java/org/drools/core/common/ClassAwareObjectStoreTest.java",
    "drools-core/src/test/java/org/drools/core/common/ClassLoaderTest.java",
    "drools-core/src/test/java/org/drools/core/common/EqualityKeyTest.java",
    "drools-core/src/test/java/org/drools/core/common/DoubleBetaConstraintsTest.java",
    "drools-core/src/test/java/org/drools/core/common/TripleBetaConstraintsTest.java",
    "drools-core/src/test/java/org/drools/core/spi/ProcessContextTest.java",
    "drools-core/src/test/java/org/drools/core/facttemplates/FieldTemplateTest.java",
    "drools-core/src/test/java/org/drools/core/facttemplates/FactTemplateFieldExtractorTest.java",
    "drools-core/src/test/java/org/drools/core/facttemplates/FactTemplateTest.java",
    "drools-core/src/test/java/org/drools/core/command/runtime/rule/CommandSerializationTest.java",
    "drools-core/src/test/java/org/drools/core/command/runtime/rule/InternalExecutableTest.java",
    "drools-core/src/test/java/org/drools/core/command/runtime/rule/GetFactHandlesCommandTest.java",
    "drools-core/src/test/java/org/drools/core/command/runtime/rule/ExecuteCommandDisconnectedTest.java",
    "drools-core/src/test/java/org/drools/core/command/runtime/pmml/ApplyPmmlModelCommandTest.java",
    "drools-core/src/test/java/org/drools/core/event/RuleRuntimeEventSupportTest.java",
    "drools-core/src/test/java/org/drools/core/event/rule/RuleRuntimeEventSupportTest.java",
    "drools-core/src/test/java/org/drools/core/event/rule/AgendaEventSupportTest.java",
    "drools-core/src/test/java/org/drools/core/event/knowledgebase/KnowledgeBaseEventSupportTest.java",
    "drools-core/src/test/java/org/drools/core/event/RuleBaseEventSupportTest.java",
    "drools-core/src/test/java/org/drools/core/base/SimulateMacOSXClassLoader.java",
    "drools-core/src/test/java/org/drools/core/base/ConcreteChild.java",
    "drools-core/src/test/java/org/drools/core/base/mvel/MVELDateCoercionTest.java",
    "drools-core/src/test/java/org/drools/core/base/mvel/MVELCalendarCoercionTest.java",
    "drools-core/src/test/java/org/drools/core/base/dataproviders/TestVariable.java",
    "drools-core/src/test/java/org/drools/core/base/ClassFieldAccessorTest.java",
    "drools-core/src/test/java/org/drools/core/base/ClassTypeResolverTest.java",
    "drools-core/src/test/java/org/drools/core/base/TestBean.java",
    "drools-core/src/test/java/org/drools/core/base/evaluators/TimeIntervalParserTest.java",
    "drools-core/src/test/java/org/drools/core/base/TemporalEvaluatorFactoryTest.java",
    "drools-core/src/test/java/org/drools/core/base/accumulators/VarianceNaNTest.java",
    "drools-core/src/test/java/org/drools/core/base/BaseClassFieldAccessorFactoryTest.java",
    "drools-core/src/test/java/org/drools/core/base/extractors/LongClassFieldExtractorTest.java",
    "drools-core/src/test/java/org/drools/core/base/extractors/DoubleClassFieldExtractorTest.java",
    "drools-core/src/test/java/org/drools/core/base/extractors/BaseClassFieldExtractorsTest.java",
    "drools-core/src/test/java/org/drools/core/base/extractors/IntClassFieldExtractorTest.java",
    "drools-core/src/test/java/org/drools/core/base/extractors/BooleanClassFieldExtractorTest.java",
    "drools-core/src/test/java/org/drools/core/base/extractors/ObjectClassFieldExtractorTest.java",
    "drools-core/src/test/java/org/drools/core/base/extractors/CharClassFieldExtractorTest.java",
    "drools-core/src/test/java/org/drools/core/base/extractors/FloatClassFieldExtractorTest.java",
    "drools-core/src/test/java/org/drools/core/base/extractors/MVELClassFieldExtractorTest.java",
    "drools-core/src/test/java/org/drools/core/base/extractors/ByteClassFieldExtractorTest.java",
    "drools-core/src/test/java/org/drools/core/base/extractors/ShortClassFieldExtractorTest.java",
    "drools-core/src/test/java/org/drools/core/base/ValueTypeTest.java",
    "drools-core/src/test/java/org/drools/core/base/FieldValueTest.java",
    "drools-core/src/test/java/org/drools/core/base/FieldFactoryTest.java",
    "drools-core/src/test/java/org/drools/core/workitem/CustomWorkItemHandlerTest.java",
    "drools-core/src/test/java/org/drools/core/workitem/CustomWorkItemHandler.java",
    "drools-core/src/main/java/org/drools/core/datasources/CursoredDataSource.java",
    "drools-core/src/main/java/org/drools/core/datasources/BindableIterable.java",
    "drools-core/src/main/java/org/drools/core/datasources/BindableDataProvider.java",
    "drools-core/src/main/java/org/drools/core/datasources/InternalDataSource.java",
    "drools-core/src/main/java/org/drools/core/datasources/BindableArray.java",
    "drools-core/src/main/java/org/drools/core/datasources/BindableObject.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/BeliefSystem.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/defeasible/Join.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/defeasible/DefeasibleMode.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/defeasible/Defeasible.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/defeasible/DefeasibleLogicalDependency.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/defeasible/DefeasibleBeliefSystem.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/defeasible/DefeasibilityStatus.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/defeasible/Strict.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/defeasible/Defeats.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/defeasible/Defeater.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/defeasible/DefeasibleBeliefSet.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/defeasible/DefeasibleRuleNature.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/jtms/JTMSBeliefSystem.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/jtms/JTMSBeliefSetImpl.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/jtms/JTMSMode.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/jtms/JTMSBeliefSet.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/BeliefSet.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/simple/SimpleLogicalDependency.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/simple/SimpleMode.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/simple/BeliefSystemLogicalCallback.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/simple/SimpleBeliefSystem.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/simple/SimpleBeliefSet.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/abductive/Abductive.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/abductive/Abducible.java",
    "drools-core/src/main/java/org/drools/core/beliefsystem/ModedAssertion.java",
    "drools-core/src/main/java/org/drools/core/impl/KnowledgeBaseFactory.java",
    "drools-core/src/main/java/org/drools/core/impl/SerializedRule.java",
    "drools-core/src/main/java/org/drools/core/impl/KieSessionsPoolImpl.java",
    "drools-core/src/main/java/org/drools/core/impl/InternalKieContainer.java",
    "drools-core/src/main/java/org/drools/core/impl/StatelessKnowledgeSessionImpl.java",
    "drools-core/src/main/java/org/drools/core/impl/InternalKnowledgeBase.java",
    "drools-core/src/main/java/org/drools/core/impl/StatelessKnowledgeSessionResultsImpl.java",
    "drools-core/src/main/java/org/drools/core/impl/RuleUnitExecutorSession.java",
    "drools-core/src/main/java/org/drools/core/impl/StatefulSessionPool.java",
    "drools-core/src/main/java/org/drools/core/impl/AbstractRuntime.java",
    "drools-core/src/main/java/org/drools/core/impl/EnvironmentFactory.java",
    "drools-core/src/main/java/org/drools/core/impl/StatefulKnowledgeSessionImpl.java",
    "drools-core/src/main/java/org/drools/core/impl/AbstractKieSessionsPool.java",
    "drools-core/src/main/java/org/drools/core/impl/EnvironmentImpl.java",
    "drools-core/src/main/java/org/drools/core/impl/KnowledgeBaseImpl.java",
    "drools-core/src/main/java/org/drools/core/impl/InternalRuleUnitExecutor.java",
    "drools-core/src/main/java/org/drools/core/RuleActivationListenerFactory.java",
    "drools-core/src/main/java/org/drools/core/WorkingMemoryEventManager.java",
    "drools-core/src/main/java/org/drools/core/RuleBaseConfiguration.java",
    "drools-core/src/main/java/org/drools/core/ClassObjectFilter.java",
    "drools-core/src/main/java/org/drools/core/util/HierarchyEncoder.java",
    "drools-core/src/main/java/org/drools/core/util/AbstractXStreamConverter.java",
    "drools-core/src/main/java/org/drools/core/util/IoUtils.java",
    "drools-core/src/main/java/org/drools/core/util/StandaloneTraitFactory.java",
    "drools-core/src/main/java/org/drools/core/util/SafeMVELEvaluator.java",
    "drools-core/src/main/java/org/drools/core/util/KeyStoreHelper.java",
    "drools-core/src/main/java/org/drools/core/util/TripleImpl.java",
    "drools-core/src/main/java/org/drools/core/util/StringUtils.java",
    "drools-core/src/main/java/org/drools/core/util/LinkedList.java",
    "drools-core/src/main/java/org/drools/core/util/ExternalizableLinkedHashMap.java",
    "drools-core/src/main/java/org/drools/core/util/FastIterator.java",
    "drools-core/src/main/java/org/drools/core/util/asm/ClassFieldInspector.java",
    "drools-core/src/main/java/org/drools/core/util/asm/DumpMethodVisitor.java",
    "drools-core/src/main/java/org/drools/core/util/asm/FieldAccessor.java",
    "drools-core/src/main/java/org/drools/core/util/asm/FieldAccessorMap.java",
    "drools-core/src/main/java/org/drools/core/util/asm/MethodComparator.java",
    "drools-core/src/main/java/org/drools/core/util/MVELSafeHelper.java",
    "drools-core/src/main/java/org/drools/core/util/TripleStore.java",
    "drools-core/src/main/java/org/drools/core/util/ByteArrayClassLoader.java",
    "drools-core/src/main/java/org/drools/core/util/MemoryUtil.java",
    "drools-core/src/main/java/org/drools/core/util/ObjectHashMap.java",
    "drools-core/src/main/java/org/drools/core/util/LinkedListEntry.java",
    "drools-core/src/main/java/org/drools/core/util/ConfFileUtils.java",
    "drools-core/src/main/java/org/drools/core/util/NumberUtils.java",
    "drools-core/src/main/java/org/drools/core/util/AbstractHashTable.java",
    "drools-core/src/main/java/org/drools/core/util/ClassUtils.java",
    "drools-core/src/main/java/org/drools/core/util/HashTableIterator.java",
    "drools-core/src/main/java/org/drools/core/util/BitMaskUtil.java",
    "drools-core/src/main/java/org/drools/core/util/Queue.java",
    "drools-core/src/main/java/org/drools/core/util/CodedHierarchy.java",
    "drools-core/src/main/java/org/drools/core/util/JavaIteratorAdapter.java",
    "drools-core/src/main/java/org/drools/core/util/HierarchyEncoderImpl.java",
    "drools-core/src/main/java/org/drools/core/util/TripleFactoryImpl.java",
    "drools-core/src/main/java/org/drools/core/util/MathUtils.java",
    "drools-core/src/main/java/org/drools/core/util/ArrayIterator.java",
    "drools-core/src/main/java/org/drools/core/util/AbstractBaseLinkedListNode.java",
    "drools-core/src/main/java/org/drools/core/util/ReflectiveVisitor.java",
    "drools-core/src/main/java/org/drools/core/util/CodedHierarchyImpl.java",
    "drools-core/src/main/java/org/drools/core/util/Bag.java",
    "drools-core/src/main/java/org/drools/core/util/bitmask/LongBitMask.java",
    "drools-core/src/main/java/org/drools/core/util/bitmask/EmptyMask.java",
    "drools-core/src/main/java/org/drools/core/util/bitmask/AllSetMask.java",
    "drools-core/src/main/java/org/drools/core/util/bitmask/AllSetBitMask.java",
    "drools-core/src/main/java/org/drools/core/util/bitmask/BitMask.java",
    "drools-core/src/main/java/org/drools/core/util/bitmask/AllSetButLastBitMask.java",
    "drools-core/src/main/java/org/drools/core/util/bitmask/EmptyBitMask.java",
    "drools-core/src/main/java/org/drools/core/util/bitmask/OpenBitSet.java",
    "drools-core/src/main/java/org/drools/core/util/bitmask/EmptyButLastBitMask.java",
    "drools-core/src/main/java/org/drools/core/util/bitmask/SingleLongBitMask.java",
    "drools-core/src/main/java/org/drools/core/util/BinaryHeapQueue.java",
    "drools-core/src/main/java/org/drools/core/util/TripleFactory.java",
    "drools-core/src/main/java/org/drools/core/util/LinkedListNode.java",
    "drools-core/src/main/java/org/drools/core/util/Iterator.java",
    "drools-core/src/main/java/org/drools/core/util/FactEntry.java",
    "drools-core/src/main/java/org/drools/core/util/HierNode.java",
    "drools-core/src/main/java/org/drools/core/util/AbstractBitwiseHierarchyImpl.java",
    "drools-core/src/main/java/org/drools/core/util/CompositeIterator.java",
    "drools-core/src/main/java/org/drools/core/util/TupleRBTree.java",
    "drools-core/src/main/java/org/drools/core/util/index/TupleIndexHashTable.java",
    "drools-core/src/main/java/org/drools/core/util/index/IndexUtil.java",
    "drools-core/src/main/java/org/drools/core/util/index/TupleList.java",
    "drools-core/src/main/java/org/drools/core/util/index/TupleIndexRBTree.java",
    "drools-core/src/main/java/org/drools/core/util/index/LeftTupleIndexRangeRBTree.java",
    "drools-core/src/main/java/org/drools/core/util/index/RightTupleIndexRangeRBTree.java",
    "drools-core/src/main/java/org/drools/core/util/Triple.java",
    "drools-core/src/main/java/org/drools/core/util/KeyStoreConstants.java",
    "drools-core/src/main/java/org/drools/core/util/DateUtils.java",
    "drools-core/src/main/java/org/drools/core/util/Drools.java",
    "drools-core/src/main/java/org/drools/core/util/KieFunctions.java",
    "drools-core/src/main/java/org/drools/core/util/AtomicBitwiseLong.java",
    "drools-core/src/main/java/org/drools/core/util/ObjectHashSet.java",
    "drools-core/src/main/java/org/drools/core/util/AbstractCodedHierarchy.java",
    "drools-core/src/main/java/org/drools/core/util/ScalablePool.java",
    "drools-core/src/main/java/org/drools/core/util/HierarchySorter.java",
    "drools-core/src/main/java/org/drools/core/util/AbstractCodedHierarchyImpl.java",
    "drools-core/src/main/java/org/drools/core/util/RBTree.java",
    "drools-core/src/main/java/org/drools/core/util/Entry.java",
    "drools-core/src/main/java/org/drools/core/util/debug/LeftInputAdapterNodeVisitor.java",
    "drools-core/src/main/java/org/drools/core/util/debug/QueryTerminalNodeVisitor.java",
    "drools-core/src/main/java/org/drools/core/util/debug/NetworkNodeVisitor.java",
    "drools-core/src/main/java/org/drools/core/util/debug/DefaultNodeInfo.java",
    "drools-core/src/main/java/org/drools/core/util/debug/StatefulKnowledgeSessionInfo.java",
    "drools-core/src/main/java/org/drools/core/util/debug/AlphaNodeVisitor.java",
    "drools-core/src/main/java/org/drools/core/util/debug/SessionInspector.java",
    "drools-core/src/main/java/org/drools/core/util/debug/LeftMemorySizeComparator.java",
    "drools-core/src/main/java/org/drools/core/util/debug/FromNodeVisitor.java",
    "drools-core/src/main/java/org/drools/core/util/debug/SessionReporter.java",
    "drools-core/src/main/java/org/drools/core/util/debug/PropagationQueueingNodeVisitor.java",
    "drools-core/src/main/java/org/drools/core/util/debug/DefaultNetworkNodeVisitor.java",
    "drools-core/src/main/java/org/drools/core/util/debug/EvalConditionNodeVisitor.java",
    "drools-core/src/main/java/org/drools/core/util/debug/AbstractNetworkNodeVisitor.java",
    "drools-core/src/main/java/org/drools/core/util/debug/RightInputAdapterNodeVisitor.java",
    "drools-core/src/main/java/org/drools/core/util/debug/NodeInfo.java",
    "drools-core/src/main/java/org/drools/core/util/debug/ObjectTypeNodeVisitor.java",
    "drools-core/src/main/java/org/drools/core/util/debug/AccumulateNodeVisitor.java",
    "drools-core/src/main/java/org/drools/core/util/debug/BetaNodeVisitor.java",
    "drools-core/src/main/java/org/drools/core/util/debug/RightMemorySizeComparator.java",
    "drools-core/src/main/java/org/drools/core/util/debug/RuleTerminalNodeVisitor.java",
    "drools-core/src/main/java/org/drools/core/util/DroolsStreamUtils.java",
    "drools-core/src/main/java/org/drools/core/Visitor.java",
    "drools-core/src/main/java/org/drools/core/factmodel/DefaultEnumClassBuilder.java",
    "drools-core/src/main/java/org/drools/core/factmodel/BuildUtils.java",
    "drools-core/src/main/java/org/drools/core/factmodel/DefaultBeanClassBuilder.java",
    "drools-core/src/main/java/org/drools/core/factmodel/PropertyMap.java",
    "drools-core/src/main/java/org/drools/core/factmodel/AnnotationDefinition.java",
    "drools-core/src/main/java/org/drools/core/factmodel/EnumLiteralDefinition.java",
    "drools-core/src/main/java/org/drools/core/factmodel/TraitableMap.java",
    "drools-core/src/main/java/org/drools/core/factmodel/MapCore.java",
    "drools-core/src/main/java/org/drools/core/factmodel/GeneratedFact.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/LogicalTypeInconsistencyException.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitFieldDefaultValue.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitType.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TripleBasedBean.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TypeWrapper.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/LatticeElement.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TypeCache.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitProxyClassBuilder.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/InstantiatorFactory.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitClassBuilderImpl.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TripleBasedTypes.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/AbstractPropertyWrapperClassBuilderImpl.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/Alias.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitFieldTMS.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitableBean.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/CoreWrapper.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/AbstractProxyClassBuilderImpl.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/Thing.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitRegistry.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitMapPropertyWrapperClassBuilderImpl.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitBuilderUtil.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitCoreWrapperClassBuilderImpl.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/LogicalMapCore.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/AbstractTraitFactory.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitTriplePropertyWrapperClassBuilderImpl.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitProxy.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/BitMaskKey.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/IndexedTypeHierarchy.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/Trait.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitFieldTMSImpl.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitTripleProxyClassBuilderImpl.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TypeLattice.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitTypeMap.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitPropertyWrapperClassBuilder.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitTypeEnum.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/MapWrapper.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/ThingProxyPlaceHolder.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TripleBasedStruct.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/Key.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/Traitable.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitCoreWrapperClassBuilder.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitFactory.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitClassBuilder.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitMapProxyClassBuilderImpl.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/NullTraitType.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/Entity.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TypeHierarchy.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/VirtualPropertyMode.java",
    "drools-core/src/main/java/org/drools/core/factmodel/traits/TraitField.java",
    "drools-core/src/main/java/org/drools/core/factmodel/Jenerator.java",
    "drools-core/src/main/java/org/drools/core/factmodel/FieldDefinition.java",
    "drools-core/src/main/java/org/drools/core/factmodel/BeanClassBuilder.java",
    "drools-core/src/main/java/org/drools/core/factmodel/EnumClassBuilder.java",
    "drools-core/src/main/java/org/drools/core/factmodel/ClassDefinition.java",
    "drools-core/src/main/java/org/drools/core/factmodel/Field.java",
    "drools-core/src/main/java/org/drools/core/factmodel/ClassBuilder.java",
    "drools-core/src/main/java/org/drools/core/factmodel/EnumClassDefinition.java",
    "drools-core/src/main/java/org/drools/core/factmodel/Fact.java",
    "drools-core/src/main/java/org/drools/core/factmodel/ClassBuilderFactory.java",
    "drools-core/src/main/java/org/drools/core/ObjectFilter.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/ProtobufMessages.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/ProcessMarshaller.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/SerializablePlaceholderResolverStrategy.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/ProtobufOutputMarshaller.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/JavaSerializableResolverStrategy.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/TimersOutputMarshaller.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/InternalMarshaller.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/MarshallerProviderImpl.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/ProcessMarshallerFactoryService.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/MarshallingConfigurationImpl.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/MarshallerWriteContext.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/PersisterEnums.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/InputMarshaller.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/ProcessMarshallerWriteContext.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/MarshallerReaderContext.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/ProcessMarshallerFactory.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/ProtobufMarshaller.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/ClassObjectMarshallingStrategyAcceptor.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/KieSessionInitializer.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/IdentityPlaceholderResolverStrategy.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/PersisterHelper.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/RuleBaseNodes.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/ReadSessionResult.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/ProtobufInputMarshaller.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/TimersInputMarshaller.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/RightTupleKey.java",
    "drools-core/src/main/java/org/drools/core/marshalling/impl/ObjectMarshallingStrategyStoreImpl.java",
    "drools-core/src/main/java/org/drools/core/fluent/impl/DataSourceFluentImpl.java",
    "drools-core/src/main/java/org/drools/core/fluent/impl/BatchImpl.java",
    "drools-core/src/main/java/org/drools/core/fluent/impl/SetCommand.java",
    "drools-core/src/main/java/org/drools/core/fluent/impl/NewContextCommand.java",
    "drools-core/src/main/java/org/drools/core/fluent/impl/ExecutableBuilderImpl.java",
    "drools-core/src/main/java/org/drools/core/fluent/impl/KieContainerFluentImpl.java",
    "drools-core/src/main/java/org/drools/core/fluent/impl/Batch.java",
    "drools-core/src/main/java/org/drools/core/fluent/impl/BaseBatchFluent.java",
    "drools-core/src/main/java/org/drools/core/fluent/impl/PseudoClockRunner.java",
    "drools-core/src/main/java/org/drools/core/fluent/impl/KieSessionFluentImpl.java",
    "drools-core/src/main/java/org/drools/core/fluent/impl/SetVarAsRegistryEntry.java",
    "drools-core/src/main/java/org/drools/core/fluent/impl/BaseBatchWithProcessFluent.java",
    "drools-core/src/main/java/org/drools/core/fluent/impl/ExecutableImpl.java",
    "drools-core/src/main/java/org/drools/core/fluent/impl/GetContextCommand.java",
    "drools-core/src/main/java/org/drools/core/fluent/impl/FluentComponentFactory.java",
    "drools-core/src/main/java/org/drools/core/fluent/impl/GetCommand.java",
    "drools-core/src/main/java/org/drools/core/fluent/impl/RuleUnitExecutorFluentImpl.java",
    "drools-core/src/main/java/org/drools/core/fluent/impl/InternalExecutable.java",
    "drools-core/src/main/java/org/drools/core/fluent/impl/CommandRegister.java",
    "drools-core/src/main/java/org/drools/core/osgi/Activator.java",
    "drools-core/src/main/java/org/drools/core/WorkingMemoryEntryPoint.java",
    "drools-core/src/main/java/org/drools/core/io/impl/ReaderResource.java",
    "drools-core/src/main/java/org/drools/core/io/impl/ReaderInputStream.java",
    "drools-core/src/main/java/org/drools/core/io/impl/ChangeSetImpl.java",
    "drools-core/src/main/java/org/drools/core/io/impl/KnowledgeResource.java",
    "drools-core/src/main/java/org/drools/core/io/impl/DescrResource.java",
    "drools-core/src/main/java/org/drools/core/io/impl/ByteArrayResource.java",
    "drools-core/src/main/java/org/drools/core/io/impl/FileSystemResource.java",
    "drools-core/src/main/java/org/drools/core/io/impl/ResourceFactoryServiceImpl.java",
    "drools-core/src/main/java/org/drools/core/io/impl/EncodedResource.java",
    "drools-core/src/main/java/org/drools/core/io/impl/BaseResource.java",
    "drools-core/src/main/java/org/drools/core/io/impl/UrlResource.java",
    "drools-core/src/main/java/org/drools/core/io/impl/ClassPathResource.java",
    "drools-core/src/main/java/org/drools/core/io/impl/InputStreamResource.java",
    "drools-core/src/main/java/org/drools/core/io/internal/InternalResource.java",
    "drools-core/src/main/java/org/drools/core/runtime/impl/ExecutionResultImpl.java",
    "drools-core/src/main/java/org/drools/core/runtime/impl/ObjectFactory.java",
    "drools-core/src/main/java/org/drools/core/runtime/impl/ExecutionResultsMap.java",
    "drools-core/src/main/java/org/drools/core/runtime/ChainableRunner.java",
    "drools-core/src/main/java/org/drools/core/runtime/rule/impl/SerializedRule.java",
    "drools-core/src/main/java/org/drools/core/runtime/rule/impl/FlatQueryResults.java",
    "drools-core/src/main/java/org/drools/core/runtime/rule/impl/RowAdapter.java",
    "drools-core/src/main/java/org/drools/core/runtime/rule/impl/LiveQueryImpl.java",
    "drools-core/src/main/java/org/drools/core/runtime/rule/impl/QueryResultsJaxbAdapter.java",
    "drools-core/src/main/java/org/drools/core/runtime/rule/impl/DefaultConsequenceExceptionHandler.java",
    "drools-core/src/main/java/org/drools/core/runtime/rule/impl/FlatQueryResultRow.java",
    "drools-core/src/main/java/org/drools/core/runtime/rule/impl/ObjectFactory.java",
    "drools-core/src/main/java/org/drools/core/runtime/rule/impl/OpenQueryViewChangedEventListenerAdapter.java",
    "drools-core/src/main/java/org/drools/core/runtime/InternalLocalRunner.java",
    "drools-core/src/main/java/org/drools/core/runtime/help/impl/ParameterContainer.java",
    "drools-core/src/main/java/org/drools/core/runtime/help/impl/BatchExecutionHelperProviderImpl.java",
    "drools-core/src/main/java/org/drools/core/runtime/help/impl/WorkItemResultsContainer.java",
    "drools-core/src/main/java/org/drools/core/runtime/help/impl/CommandsList.java",
    "drools-core/src/main/java/org/drools/core/runtime/help/impl/XStreamXML.java",
    "drools-core/src/main/java/org/drools/core/runtime/help/impl/IdentifiersContainer.java",
    "drools-core/src/main/java/org/drools/core/runtime/help/impl/RowItemContainer.java",
    "drools-core/src/main/java/org/drools/core/runtime/help/impl/XStreamHelper.java",
    "drools-core/src/main/java/org/drools/core/runtime/help/impl/CommandsObjectContainer.java",
    "drools-core/src/main/java/org/drools/core/runtime/help/impl/ObjectsObjectContainer.java",
    "drools-core/src/main/java/org/drools/core/runtime/help/impl/XStreamJSon.java",
    "drools-core/src/main/java/org/drools/core/runtime/process/ProcessRuntimeFactory.java",
    "drools-core/src/main/java/org/drools/core/runtime/process/InternalProcessRuntime.java",
    "drools-core/src/main/java/org/drools/core/runtime/process/ProcessRuntimeFactoryService.java",
    "drools-core/src/main/java/org/drools/core/management/ObjectTypeNodeMonitor.java",
    "drools-core/src/main/java/org/drools/core/management/KieSessionMonitoringImpl.java",
    "drools-core/src/main/java/org/drools/core/management/GenericKieSessionMonitoringImpl.java",
    "drools-core/src/main/java/org/drools/core/management/StatelessKieSessionMonitoringImpl.java",
    "drools-core/src/main/java/org/drools/core/management/DroolsManagementAgent.java",
    "drools-core/src/main/java/org/drools/core/management/KieBaseConfigurationMonitor.java",
    "drools-core/src/main/java/org/drools/core/management/KnowledgeBaseMonitoring.java",
    "drools-core/src/main/java/org/drools/core/ClassObjectSerializationFilter.java",
    "drools-core/src/main/java/org/drools/core/world/impl/ContextManagerImpl.java",
    "drools-core/src/main/java/org/drools/core/reteoo/FromNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/ReactiveFromNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/RightTupleImpl.java",
    "drools-core/src/main/java/org/drools/core/reteoo/WindowTupleList.java",
    "drools-core/src/main/java/org/drools/core/reteoo/SingleLeftTupleSinkAdapter.java",
    "drools-core/src/main/java/org/drools/core/reteoo/RuleBuilderFactory.java",
    "drools-core/src/main/java/org/drools/core/reteoo/InitialFactImpl.java",
    "drools-core/src/main/java/org/drools/core/reteoo/LeftTupleNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/TraitProxyObjectTypeNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/LeftTupleSinkPropagator.java",
    "drools-core/src/main/java/org/drools/core/reteoo/TimerNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/EvalConditionNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/FromNodeLeftTuple.java",
    "drools-core/src/main/java/org/drools/core/reteoo/ReteooFactHandleFactory.java",
    "drools-core/src/main/java/org/drools/core/reteoo/RuleRemovalContext.java",
    "drools-core/src/main/java/org/drools/core/reteoo/ObjectTypeNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/ObjectSinkPropagator.java",
    "drools-core/src/main/java/org/drools/core/reteoo/BaseLeftTuple.java",
    "drools-core/src/main/java/org/drools/core/reteoo/SegmentMemory.java",
    "drools-core/src/main/java/org/drools/core/reteoo/PropagationQueuingNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/FactTemplateTypeConf.java",
    "drools-core/src/main/java/org/drools/core/reteoo/WindowNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/LeftInputAdapterNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/ConditionalBranchNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/SubnetworkTuple.java",
    "drools-core/src/main/java/org/drools/core/reteoo/AsyncReceiveNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/LeftTupleSinkNodeList.java",
    "drools-core/src/main/java/org/drools/core/reteoo/JoinNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/Sink.java",
    "drools-core/src/main/java/org/drools/core/reteoo/AsyncMessage.java",
    "drools-core/src/main/java/org/drools/core/reteoo/SingleObjectSinkAdapter.java",
    "drools-core/src/main/java/org/drools/core/reteoo/LeftTupleSink.java",
    "drools-core/src/main/java/org/drools/core/reteoo/RuleBuilder.java",
    "drools-core/src/main/java/org/drools/core/reteoo/compiled/DelegateMethodsHandler.java",
    "drools-core/src/main/java/org/drools/core/reteoo/compiled/DeclarationsHandler.java",
    "drools-core/src/main/java/org/drools/core/reteoo/compiled/SwitchCompilerHandler.java",
    "drools-core/src/main/java/org/drools/core/reteoo/compiled/CompiledNetwork.java",
    "drools-core/src/main/java/org/drools/core/reteoo/compiled/ModifyHandler.java",
    "drools-core/src/main/java/org/drools/core/reteoo/compiled/NetworkHandler.java",
    "drools-core/src/main/java/org/drools/core/reteoo/compiled/SetNodeReferenceHandler.java",
    "drools-core/src/main/java/org/drools/core/reteoo/compiled/NetworkHandlerAdaptor.java",
    "drools-core/src/main/java/org/drools/core/reteoo/compiled/HashedAlphasDeclaration.java",
    "drools-core/src/main/java/org/drools/core/reteoo/compiled/AssertHandler.java",
    "drools-core/src/main/java/org/drools/core/reteoo/compiled/ObjectTypeNodeParser.java",
    "drools-core/src/main/java/org/drools/core/reteoo/compiled/AbstractCompilerHandler.java",
    "drools-core/src/main/java/org/drools/core/reteoo/ObjectSource.java",
    "drools-core/src/main/java/org/drools/core/reteoo/ContextOwner.java",
    "drools-core/src/main/java/org/drools/core/reteoo/KieComponentFactory.java",
    "drools-core/src/main/java/org/drools/core/reteoo/LeftTupleSource.java",
    "drools-core/src/main/java/org/drools/core/reteoo/QueryElementNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/BetaMemory.java",
    "drools-core/src/main/java/org/drools/core/reteoo/NodeSet.java",
    "drools-core/src/main/java/org/drools/core/reteoo/EntryPointNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/PathEndNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/CompositeObjectSinkAdapter.java",
    "drools-core/src/main/java/org/drools/core/reteoo/CompositeLeftTupleSinkAdapter.java",
    "drools-core/src/main/java/org/drools/core/reteoo/LeftTuple.java",
    "drools-core/src/main/java/org/drools/core/reteoo/NotNodeLeftTuple.java",
    "drools-core/src/main/java/org/drools/core/reteoo/RuleTerminalNodeLeftTuple.java",
    "drools-core/src/main/java/org/drools/core/reteoo/ClassObjectTypeConf.java",
    "drools-core/src/main/java/org/drools/core/reteoo/CompositePartitionAwareObjectSinkAdapter.java",
    "drools-core/src/main/java/org/drools/core/reteoo/QueryRiaFixerNodeLeftTuple.java",
    "drools-core/src/main/java/org/drools/core/reteoo/SegmentNodeMemory.java",
    "drools-core/src/main/java/org/drools/core/reteoo/JoinNodeLeftTuple.java",
    "drools-core/src/main/java/org/drools/core/reteoo/ReactiveFromNodeLeftTuple.java",
    "drools-core/src/main/java/org/drools/core/reteoo/QueryElementNodeLeftTuple.java",
    "drools-core/src/main/java/org/drools/core/reteoo/BetaNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/WindowTuple.java",
    "drools-core/src/main/java/org/drools/core/reteoo/SegmentMemoryInitializer.java",
    "drools-core/src/main/java/org/drools/core/reteoo/AbstractLeftTupleSinkAdapter.java",
    "drools-core/src/main/java/org/drools/core/reteoo/MemoryVisitor.java",
    "drools-core/src/main/java/org/drools/core/reteoo/NotNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/AsyncMessagesCoordinator.java",
    "drools-core/src/main/java/org/drools/core/reteoo/ReteObjectTypeNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/ModifyPreviousTuples.java",
    "drools-core/src/main/java/org/drools/core/reteoo/AsyncSendNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/LeftTupleImpl.java",
    "drools-core/src/main/java/org/drools/core/reteoo/AbstractTerminalNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/ExistsNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/AlphaNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/TraitObjectTypeNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/NodeTypeEnums.java",
    "drools-core/src/main/java/org/drools/core/reteoo/ReteooRuleBuilderFactory.java",
    "drools-core/src/main/java/org/drools/core/reteoo/ReteooBuilder.java",
    "drools-core/src/main/java/org/drools/core/reteoo/BaseTuple.java",
    "drools-core/src/main/java/org/drools/core/reteoo/PropertySpecificUtil.java",
    "drools-core/src/main/java/org/drools/core/reteoo/EmptyLeftTupleSinkAdapter.java",
    "drools-core/src/main/java/org/drools/core/reteoo/RightTupleSink.java",
    "drools-core/src/main/java/org/drools/core/reteoo/EmptyObjectSinkAdapter.java",
    "drools-core/src/main/java/org/drools/core/reteoo/ObjectTypeConf.java",
    "drools-core/src/main/java/org/drools/core/reteoo/Rete.java",
    "drools-core/src/main/java/org/drools/core/reteoo/QueryTerminalNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/ObjectSinkNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/BuildUtils.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/AccumulateBuilder.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/QueryElementBuilder.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/PhreakNodeFactory.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/AsyncReceiveBuilder.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/NamedConsequenceBuilder.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/ConditionalBranchBuilder.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/EntryPointBuilder.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/BuildContext.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/WindowReferenceBuilder.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/ReteooComponentBuilder.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/EvalBuilder.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/PatternBuilder.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/ReactiveFromBuilder.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/GroupElementBuilder.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/ForallBuilder.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/WindowBuilder.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/TimerBuilder.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/FromBuilder.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/ReteooRuleBuilder.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/CollectBuilder.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/NodeFactory.java",
    "drools-core/src/main/java/org/drools/core/reteoo/builder/AsyncSendBuilder.java",
    "drools-core/src/main/java/org/drools/core/reteoo/RiaPathMemory.java",
    "drools-core/src/main/java/org/drools/core/reteoo/ConditionalBranchEvaluator.java",
    "drools-core/src/main/java/org/drools/core/reteoo/RightTuple.java",
    "drools-core/src/main/java/org/drools/core/reteoo/EvalNodeLeftTuple.java",
    "drools-core/src/main/java/org/drools/core/reteoo/LeftTupleSinkNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/PathMemory.java",
    "drools-core/src/main/java/org/drools/core/reteoo/TupleMemory.java",
    "drools-core/src/main/java/org/drools/core/reteoo/RightInputAdapterNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/ObjectSinkNodeList.java",
    "drools-core/src/main/java/org/drools/core/reteoo/TerminalNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/TupleIterator.java",
    "drools-core/src/main/java/org/drools/core/reteoo/ObjectSink.java",
    "drools-core/src/main/java/org/drools/core/reteoo/AccumulateNode.java",
    "drools-core/src/main/java/org/drools/core/reteoo/RuleTerminalNode.java",
    "drools-core/src/main/java/org/drools/core/conflict/AbstractConflictResolver.java",
    "drools-core/src/main/java/org/drools/core/conflict/PhreakConflictResolver.java",
    "drools-core/src/main/java/org/drools/core/conflict/SequentialConflictResolver.java",
    "drools-core/src/main/java/org/drools/core/conflict/DepthConflictResolver.java",
    "drools-core/src/main/java/org/drools/core/conflict/SalienceConflictResolver.java",
    "drools-core/src/main/java/org/drools/core/phreak/PropagationList.java",
    "drools-core/src/main/java/org/drools/core/phreak/PhreakNotNode.java",
    "drools-core/src/main/java/org/drools/core/phreak/SegmentPropagator.java",
    "drools-core/src/main/java/org/drools/core/phreak/ReactiveList.java",
    "drools-core/src/main/java/org/drools/core/phreak/PhreakReactiveFromNode.java",
    "drools-core/src/main/java/org/drools/core/phreak/RuleExecutor.java",
    "drools-core/src/main/java/org/drools/core/phreak/PhreakExistsNode.java",
    "drools-core/src/main/java/org/drools/core/phreak/Reactive.java",
    "drools-core/src/main/java/org/drools/core/phreak/ReactiveCollection.java",
    "drools-core/src/main/java/org/drools/core/phreak/SegmentUtilities.java",
    "drools-core/src/main/java/org/drools/core/phreak/PhreakBranchNode.java",
    "drools-core/src/main/java/org/drools/core/phreak/RuleAgendaItem.java",
    "drools-core/src/main/java/org/drools/core/phreak/PhreakAsyncReceiveNode.java",
    "drools-core/src/main/java/org/drools/core/phreak/AbstractReactiveObject.java",
    "drools-core/src/main/java/org/drools/core/phreak/SynchronizedPropagationList.java",
    "drools-core/src/main/java/org/drools/core/phreak/PhreakTimerNode.java",
    "drools-core/src/main/java/org/drools/core/phreak/PhreakAsyncSendNode.java",
    "drools-core/src/main/java/org/drools/core/phreak/PhreakJoinNode.java",
    "drools-core/src/main/java/org/drools/core/phreak/LeftTupleEntry.java",
    "drools-core/src/main/java/org/drools/core/phreak/PhreakQueryTerminalNode.java",
    "drools-core/src/main/java/org/drools/core/phreak/PhreakQueryNode.java",
    "drools-core/src/main/java/org/drools/core/phreak/RightTupleEntry.java",
    "drools-core/src/main/java/org/drools/core/phreak/ReactiveObjectUtil.java",
    "drools-core/src/main/java/org/drools/core/phreak/SynchronizedBypassPropagationList.java",
    "drools-core/src/main/java/org/drools/core/phreak/TupleEntry.java",
    "drools-core/src/main/java/org/drools/core/phreak/StackEntry.java",
    "drools-core/src/main/java/org/drools/core/phreak/PhreakFromNode.java",
    "drools-core/src/main/java/org/drools/core/phreak/ExecutableEntry.java",
    "drools-core/src/main/java/org/drools/core/phreak/PhreakAccumulateNode.java",
    "drools-core/src/main/java/org/drools/core/phreak/ReactiveObject.java",
    "drools-core/src/main/java/org/drools/core/phreak/PhreakRuleTerminalNode.java",
    "drools-core/src/main/java/org/drools/core/phreak/ReactiveSet.java",
    "drools-core/src/main/java/org/drools/core/phreak/AddRemoveRule.java",
    "drools-core/src/main/java/org/drools/core/phreak/PhreakEvalNode.java",
    "drools-core/src/main/java/org/drools/core/phreak/PropagationEntry.java",
    "drools-core/src/main/java/org/drools/core/phreak/RuleNetworkEvaluator.java",
    "drools-core/src/main/java/org/drools/core/InitialFact.java",
    "drools-core/src/main/java/org/drools/core/xml/DefaultSemanticModule.java",
    "drools-core/src/main/java/org/drools/core/xml/BaseAbstractHandler.java",
    "drools-core/src/main/java/org/drools/core/xml/XmlChangeSetReader.java",
    "drools-core/src/main/java/org/drools/core/xml/Handler.java",
    "drools-core/src/main/java/org/drools/core/xml/changeset/DecisionTableConfigurationHandler.java",
    "drools-core/src/main/java/org/drools/core/xml/changeset/AddHandler.java",
    "drools-core/src/main/java/org/drools/core/xml/changeset/ChangeSetHandler.java",
    "drools-core/src/main/java/org/drools/core/xml/changeset/RemoveHandler.java",
    "drools-core/src/main/java/org/drools/core/xml/changeset/DefinitionHandler.java",
    "drools-core/src/main/java/org/drools/core/xml/changeset/ModifyHandler.java",
    "drools-core/src/main/java/org/drools/core/xml/changeset/ResourceHandler.java",
    "drools-core/src/main/java/org/drools/core/xml/WrapperSemanticModule.java",
    "drools-core/src/main/java/org/drools/core/xml/ChangeSetSemanticModule.java",
    "drools-core/src/main/java/org/drools/core/xml/ExtensibleXmlParser.java",
    "drools-core/src/main/java/org/drools/core/xml/SemanticModules.java",
    "drools-core/src/main/java/org/drools/core/xml/jaxb/util/JaxbListWrapper.java",
    "drools-core/src/main/java/org/drools/core/xml/jaxb/util/JaxbUnknownAdapter.java",
    "drools-core/src/main/java/org/drools/core/xml/jaxb/util/JaxbStringObjectPair.java",
    "drools-core/src/main/java/org/drools/core/xml/jaxb/util/JaxbMapAdapter.java",
    "drools-core/src/main/java/org/drools/core/xml/jaxb/util/JaxbObjectObjectPair.java",
    "drools-core/src/main/java/org/drools/core/xml/jaxb/util/ObjectFactory.java",
    "drools-core/src/main/java/org/drools/core/xml/jaxb/util/JaxbListAdapter.java",
    "drools-core/src/main/java/org/drools/core/xml/SemanticModule.java",
    "drools-core/src/main/java/org/drools/core/ruleunit/RuleUnitDescription.java",
    "drools-core/src/main/java/org/drools/core/ruleunit/RuleUnitDescriptionLoader.java",
    "drools-core/src/main/java/org/drools/core/ruleunit/RuleUnitGuardSystem.java",
    "drools-core/src/main/java/org/drools/core/ruleunit/RuleUnitDescriptionRegistry.java",
    "drools-core/src/main/java/org/drools/core/ruleunit/RuleUnitFactory.java",
    "drools-core/src/main/java/org/drools/core/ruleunit/State.java",
    "drools-core/src/main/java/org/drools/core/ruleunit/Guard.java",
    "drools-core/src/main/java/org/drools/core/ruleunit/RuleUnitUtil.java",
    "drools-core/src/main/java/org/drools/core/time/impl/DefaultTimerJobInstance.java",
    "drools-core/src/main/java/org/drools/core/time/impl/CronTimer.java",
    "drools-core/src/main/java/org/drools/core/time/impl/PointInTimeTrigger.java",
    "drools-core/src/main/java/org/drools/core/time/impl/TrackableTimeJobFactoryManager.java",
    "drools-core/src/main/java/org/drools/core/time/impl/DefaultTimerJobFactoryManager.java",
    "drools-core/src/main/java/org/drools/core/time/impl/ExpressionIntervalTimer.java",
    "drools-core/src/main/java/org/drools/core/time/impl/CompositeMaxDurationTrigger.java",
    "drools-core/src/main/java/org/drools/core/time/impl/CronTrigger.java",
    "drools-core/src/main/java/org/drools/core/time/impl/MultiJobHandle.java",
    "drools-core/src/main/java/org/drools/core/time/impl/JDKTimerService.java",
    "drools-core/src/main/java/org/drools/core/time/impl/DefaultJobHandle.java",
    "drools-core/src/main/java/org/drools/core/time/impl/ThreadSafeTrackableTimeJobFactoryManager.java",
    "drools-core/src/main/java/org/drools/core/time/impl/DurationTimer.java",
    "drools-core/src/main/java/org/drools/core/time/impl/BaseTimer.java",
    "drools-core/src/main/java/org/drools/core/time/impl/Timer.java",
    "drools-core/src/main/java/org/drools/core/time/impl/CompositeMaxDurationTimer.java",
    "drools-core/src/main/java/org/drools/core/time/impl/CronExpression.java",
    "drools-core/src/main/java/org/drools/core/time/impl/TimerJobInstance.java",
    "drools-core/src/main/java/org/drools/core/time/impl/IntervalTrigger.java",
    "drools-core/src/main/java/org/drools/core/time/impl/TimerJobFactoryManager.java",
    "drools-core/src/main/java/org/drools/core/time/impl/PseudoClockScheduler.java",
    "drools-core/src/main/java/org/drools/core/time/impl/AbstractJobHandle.java",
    "drools-core/src/main/java/org/drools/core/time/impl/IntervalTimer.java",
    "drools-core/src/main/java/org/drools/core/time/impl/CommandServiceTimerJobFactoryManager.java",
    "drools-core/src/main/java/org/drools/core/time/InternalSchedulerService.java",
    "drools-core/src/main/java/org/drools/core/time/Interval.java",
    "drools-core/src/main/java/org/drools/core/time/JobHandle.java",
    "drools-core/src/main/java/org/drools/core/time/Scheduler.java",
    "drools-core/src/main/java/org/drools/core/time/TimerService.java",
    "drools-core/src/main/java/org/drools/core/time/Job.java",
    "drools-core/src/main/java/org/drools/core/time/TimerServiceFactory.java",
    "drools-core/src/main/java/org/drools/core/time/SchedulerService.java",
    "drools-core/src/main/java/org/drools/core/time/TemporalDependencyMatrix.java",
    "drools-core/src/main/java/org/drools/core/time/EnqueuedSelfRemovalJobContext.java",
    "drools-core/src/main/java/org/drools/core/time/TimeUtils.java",
    "drools-core/src/main/java/org/drools/core/time/Trigger.java",
    "drools-core/src/main/java/org/drools/core/time/SessionPseudoClock.java",
    "drools-core/src/main/java/org/drools/core/time/SelfRemovalJob.java",
    "drools-core/src/main/java/org/drools/core/time/JobContext.java",
    "drools-core/src/main/java/org/drools/core/time/SelfRemovalJobContext.java",
    "drools-core/src/main/java/org/drools/core/rule/JavaDialectRuntimeData.java",
    "drools-core/src/main/java/org/drools/core/rule/MutableTypeConstraint.java",
    "drools-core/src/main/java/org/drools/core/rule/IndexEvaluator.java",
    "drools-core/src/main/java/org/drools/core/rule/SlidingLengthWindow.java",
    "drools-core/src/main/java/org/drools/core/rule/QueryElement.java",
    "drools-core/src/main/java/org/drools/core/rule/ConsequenceMetaData.java",
    "drools-core/src/main/java/org/drools/core/rule/DynamicFact.java",
    "drools-core/src/main/java/org/drools/core/rule/FactType.java",
    "drools-core/src/main/java/org/drools/core/rule/AbductiveQuery.java",
    "drools-core/src/main/java/org/drools/core/rule/TypeMetaInfo.java",
    "drools-core/src/main/java/org/drools/core/rule/SlidingTimeWindow.java",
    "drools-core/src/main/java/org/drools/core/rule/InvalidRuleException.java",
    "drools-core/src/main/java/org/drools/core/rule/Dialectable.java",
    "drools-core/src/main/java/org/drools/core/rule/ContextEntry.java",
    "drools-core/src/main/java/org/drools/core/rule/Collect.java",
    "drools-core/src/main/java/org/drools/core/rule/Annotated.java",
    "drools-core/src/main/java/org/drools/core/rule/MapBackedClassLoader.java",
    "drools-core/src/main/java/org/drools/core/rule/AbstractCompositeConstraint.java",
    "drools-core/src/main/java/org/drools/core/rule/Accumulate.java",
    "drools-core/src/main/java/org/drools/core/rule/AbstractCompositeRestriction.java",
    "drools-core/src/main/java/org/drools/core/rule/Pattern.java",
    "drools-core/src/main/java/org/drools/core/rule/AsyncSend.java",
    "drools-core/src/main/java/org/drools/core/rule/Namespaceable.java",
    "drools-core/src/main/java/org/drools/core/rule/ConditionalElement.java",
    "drools-core/src/main/java/org/drools/core/rule/KieModuleMetaInfo.java",
    "drools-core/src/main/java/org/drools/core/rule/MVELDialectRuntimeData.java",
    "drools-core/src/main/java/org/drools/core/rule/DialectRuntimeData.java",
    "drools-core/src/main/java/org/drools/core/rule/DefaultLogicTransformerFactory.java",
    "drools-core/src/main/java/org/drools/core/rule/NoConsequenceException.java",
    "drools-core/src/main/java/org/drools/core/rule/SingleAccumulate.java",
    "drools-core/src/main/java/org/drools/core/rule/InvalidPatternException.java",
    "drools-core/src/main/java/org/drools/core/rule/ImportDeclaration.java",
    "drools-core/src/main/java/org/drools/core/rule/NamedConsequenceInvoker.java",
    "drools-core/src/main/java/org/drools/core/rule/EntryPointId.java",
    "drools-core/src/main/java/org/drools/core/rule/QueryArgument.java",
    "drools-core/src/main/java/org/drools/core/rule/ConditionalBranch.java",
    "drools-core/src/main/java/org/drools/core/rule/Forall.java",
    "drools-core/src/main/java/org/drools/core/rule/XpathBackReference.java",
    "drools-core/src/main/java/org/drools/core/rule/Declaration.java",
    "drools-core/src/main/java/org/drools/core/rule/RuleConditionElement.java",
    "drools-core/src/main/java/org/drools/core/rule/WindowDeclaration.java",
    "drools-core/src/main/java/org/drools/core/rule/FactField.java",
    "drools-core/src/main/java/org/drools/core/rule/PatternSource.java",
    "drools-core/src/main/java/org/drools/core/rule/BehaviorManager.java",
    "drools-core/src/main/java/org/drools/core/rule/LogicTransformer.java",
    "drools-core/src/main/java/org/drools/core/rule/QueryImpl.java",
    "drools-core/src/main/java/org/drools/core/rule/EvalCondition.java",
    "drools-core/src/main/java/org/drools/core/rule/WindowReference.java",
    "drools-core/src/main/java/org/drools/core/rule/DuplicateRuleNameException.java",
    "drools-core/src/main/java/org/drools/core/rule/MultiAccumulate.java",
    "drools-core/src/main/java/org/drools/core/rule/From.java",
    "drools-core/src/main/java/org/drools/core/rule/FixedDuration.java",
    "drools-core/src/main/java/org/drools/core/rule/VariableRestriction.java",
    "drools-core/src/main/java/org/drools/core/rule/IntervalProviderConstraint.java",
    "drools-core/src/main/java/org/drools/core/rule/DialectRuntimeRegistry.java",
    "drools-core/src/main/java/org/drools/core/rule/GroupElement.java",
    "drools-core/src/main/java/org/drools/core/rule/AsyncReceive.java",
    "drools-core/src/main/java/org/drools/core/rule/Behavior.java",
    "drools-core/src/main/java/org/drools/core/rule/RuleConstructionException.java",
    "drools-core/src/main/java/org/drools/core/rule/ReturnValueRestriction.java",
    "drools-core/src/main/java/org/drools/core/rule/InvalidRulePackage.java",
    "drools-core/src/main/java/org/drools/core/rule/builder/dialect/asm/EvalStub.java",
    "drools-core/src/main/java/org/drools/core/rule/builder/dialect/asm/PredicateStub.java",
    "drools-core/src/main/java/org/drools/core/rule/builder/dialect/asm/GeneratorHelper.java",
    "drools-core/src/main/java/org/drools/core/rule/builder/dialect/asm/ReturnValueStub.java",
    "drools-core/src/main/java/org/drools/core/rule/builder/dialect/asm/InvokerDataProvider.java",
    "drools-core/src/main/java/org/drools/core/rule/builder/dialect/asm/ConsequenceStub.java",
    "drools-core/src/main/java/org/drools/core/rule/builder/dialect/asm/PredicateGenerator.java",
    "drools-core/src/main/java/org/drools/core/rule/builder/dialect/asm/ClassGenerator.java",
    "drools-core/src/main/java/org/drools/core/rule/builder/dialect/asm/ReturnValueGenerator.java",
    "drools-core/src/main/java/org/drools/core/rule/builder/dialect/asm/ClassLevel.java",
    "drools-core/src/main/java/org/drools/core/rule/builder/dialect/asm/EvalGenerator.java",
    "drools-core/src/main/java/org/drools/core/rule/builder/dialect/asm/ConsequenceGenerator.java",
    "drools-core/src/main/java/org/drools/core/rule/builder/dialect/asm/InvokerStub.java",
    "drools-core/src/main/java/org/drools/core/rule/IndexableConstraint.java",
    "drools-core/src/main/java/org/drools/core/rule/Function.java",
    "drools-core/src/main/java/org/drools/core/rule/NamedConsequence.java",
    "drools-core/src/main/java/org/drools/core/rule/TypeDeclaration.java",
    "drools-core/src/main/java/org/drools/core/rule/package-info.java",
    "drools-core/src/main/java/org/drools/core/rule/constraint/EvaluatorHelper.java",
    "drools-core/src/main/java/org/drools/core/rule/constraint/ASMConditionEvaluatorJitter.java",
    "drools-core/src/main/java/org/drools/core/rule/constraint/ConditionAnalyzer.java",
    "drools-core/src/main/java/org/drools/core/rule/constraint/MvelConstraint.java",
    "drools-core/src/main/java/org/drools/core/rule/constraint/XpathConstraint.java",
    "drools-core/src/main/java/org/drools/core/rule/constraint/QueryNameConstraint.java",
    "drools-core/src/main/java/org/drools/core/rule/constraint/ConditionEvaluator.java",
    "drools-core/src/main/java/org/drools/core/rule/constraint/EvaluatorConstraint.java",
    "drools-core/src/main/java/org/drools/core/rule/constraint/MvelConditionEvaluator.java",
    "drools-core/src/main/java/org/drools/core/rule/constraint/NegConstraint.java",
    "drools-core/src/main/java/org/drools/core/rule/LineMappings.java",
    "drools-core/src/main/java/org/drools/core/rule/PredicateConstraint.java",
    "drools-core/src/main/java/org/drools/core/rule/LogicTransformerFactory.java",
    "drools-core/src/main/java/org/drools/core/rule/GroupElementFactory.java",
    "drools-core/src/main/java/org/drools/core/QueryActivationListenerFactory.java",
    "drools-core/src/main/java/org/drools/core/common/ActiveActivationIterator.java",
    "drools-core/src/main/java/org/drools/core/common/AgendaFactory.java",
    "drools-core/src/main/java/org/drools/core/common/InstanceNotEqualsConstraint.java",
    "drools-core/src/main/java/org/drools/core/common/LeftTupleIterator.java",
    "drools-core/src/main/java/org/drools/core/common/InternalAgenda.java",
    "drools-core/src/main/java/org/drools/core/common/InternalWorkingMemoryEntryPoint.java",
    "drools-core/src/main/java/org/drools/core/common/TripleBetaConstraints.java",
    "drools-core/src/main/java/org/drools/core/common/DefaultBetaConstraints.java",
    "drools-core/src/main/java/org/drools/core/common/NetworkNode.java",
    "drools-core/src/main/java/org/drools/core/common/TupleStartEqualsConstraint.java",
    "drools-core/src/main/java/org/drools/core/common/RuleFlowGroupImpl.java",
    "drools-core/src/main/java/org/drools/core/common/DoubleBetaConstraints.java",
    "drools-core/src/main/java/org/drools/core/common/InternalFactHandle.java",
    "drools-core/src/main/java/org/drools/core/common/AgendaItem.java",
    "drools-core/src/main/java/org/drools/core/common/EventSupport.java",
    "drools-core/src/main/java/org/drools/core/common/EqualityAssertMapComparator.java",
    "drools-core/src/main/java/org/drools/core/common/AgendaItemImpl.java",
    "drools-core/src/main/java/org/drools/core/common/IdentityAssertMapComparator.java",
    "drools-core/src/main/java/org/drools/core/common/PhreakPropagationContext.java",
    "drools-core/src/main/java/org/drools/core/common/WorkingMemoryFactory.java",
    "drools-core/src/main/java/org/drools/core/common/DisconnectedFactHandle.java",
    "drools-core/src/main/java/org/drools/core/common/PhreakActiveActivationIterator.java",
    "drools-core/src/main/java/org/drools/core/common/DoubleNonIndexSkipBetaConstraints.java",
    "drools-core/src/main/java/org/drools/core/common/ActivationsFilter.java",
    "drools-core/src/main/java/org/drools/core/common/QueryElementFactHandle.java",
    "drools-core/src/main/java/org/drools/core/common/TerminalNodeIterator.java",
    "drools-core/src/main/java/org/drools/core/common/InstanceEqualsConstraint.java",
    "drools-core/src/main/java/org/drools/core/common/BeliefSystemFactory.java",
    "drools-core/src/main/java/org/drools/core/common/SingleBetaConstraints.java",
    "drools-core/src/main/java/org/drools/core/common/BetaConstraints.java",
    "drools-core/src/main/java/org/drools/core/common/ActivationGroupImpl.java",
    "drools-core/src/main/java/org/drools/core/common/CompositeDefaultAgenda.java",
    "drools-core/src/main/java/org/drools/core/common/UpdateContext.java",
    "drools-core/src/main/java/org/drools/core/common/TripleNonIndexSkipBetaConstraints.java",
    "drools-core/src/main/java/org/drools/core/common/DynamicEntryPoint.java",
    "drools-core/src/main/java/org/drools/core/common/DisconnectedWorkingMemoryEntryPoint.java",
    "drools-core/src/main/java/org/drools/core/common/DroolsObjectInputStream.java",
    "drools-core/src/main/java/org/drools/core/common/ObjectStore.java",
    "drools-core/src/main/java/org/drools/core/common/NodeMemories.java",
    "drools-core/src/main/java/org/drools/core/common/PriorityQueueAgendaGroupFactory.java",
    "drools-core/src/main/java/org/drools/core/common/QuadroupleBetaConstraints.java",
    "drools-core/src/main/java/org/drools/core/common/NamedEntryPoint.java",
    "drools-core/src/main/java/org/drools/core/common/TruthMaintenanceSystemHelper.java",
    "drools-core/src/main/java/org/drools/core/common/EqualityKey.java",
    "drools-core/src/main/java/org/drools/core/common/TruthMaintenanceSystem.java",
    "drools-core/src/main/java/org/drools/core/common/DefaultFactHandle.java",
    "drools-core/src/main/java/org/drools/core/common/SharedWorkingMemoryContext.java",
    "drools-core/src/main/java/org/drools/core/common/PropagationContextFactory.java",
    "drools-core/src/main/java/org/drools/core/common/ObjectFactory.java",
    "drools-core/src/main/java/org/drools/core/common/InternalWorkingMemory.java",
    "drools-core/src/main/java/org/drools/core/common/ProjectClassLoader.java",
    "drools-core/src/main/java/org/drools/core/common/RuleBasePartitionId.java",
    "drools-core/src/main/java/org/drools/core/common/ObjectTypeConfigurationRegistry.java",
    "drools-core/src/main/java/org/drools/core/common/MemoryFactory.java",
    "drools-core/src/main/java/org/drools/core/common/BaseNode.java",
    "drools-core/src/main/java/org/drools/core/common/AgendaGroupFactory.java",
    "drools-core/src/main/java/org/drools/core/common/TupleSets.java",
    "drools-core/src/main/java/org/drools/core/common/ActivationIterator.java",
    "drools-core/src/main/java/org/drools/core/common/PartitionedDefaultAgenda.java",
    "drools-core/src/main/java/org/drools/core/common/DroolsObjectStreamConstants.java",
    "drools-core/src/main/java/org/drools/core/common/AbstractFactHandleFactory.java",
    "drools-core/src/main/java/org/drools/core/common/ConcurrentNodeMemories.java",
    "drools-core/src/main/java/org/drools/core/common/InternalKnowledgeRuntime.java",
    "drools-core/src/main/java/org/drools/core/common/VisitedAgendaGroup.java",
    "drools-core/src/main/java/org/drools/core/common/EventFactHandle.java",
    "drools-core/src/main/java/org/drools/core/common/EmptyBetaConstraints.java",
    "drools-core/src/main/java/org/drools/core/common/QuadroupleNonIndexSkipBetaConstraints.java",
    "drools-core/src/main/java/org/drools/core/common/Memory.java",
    "drools-core/src/main/java/org/drools/core/common/PhreakPropagationContextFactory.java",
    "drools-core/src/main/java/org/drools/core/common/InternalAgendaGroup.java",
    "drools-core/src/main/java/org/drools/core/common/EqualityKeyComparator.java",
    "drools-core/src/main/java/org/drools/core/common/ResourceProvider.java",
    "drools-core/src/main/java/org/drools/core/common/ClassAwareObjectStore.java",
    "drools-core/src/main/java/org/drools/core/common/PhreakBeliefSystemFactory.java",
    "drools-core/src/main/java/org/drools/core/common/PhreakWorkingMemoryFactory.java",
    "drools-core/src/main/java/org/drools/core/common/MultipleBetaConstraint.java",
    "drools-core/src/main/java/org/drools/core/common/InternalRuleFlowGroup.java",
    "drools-core/src/main/java/org/drools/core/common/PhreakActivationIterator.java",
    "drools-core/src/main/java/org/drools/core/common/TupleSetsImpl.java",
    "drools-core/src/main/java/org/drools/core/common/DefaultAgendaFactory.java",
    "drools-core/src/main/java/org/drools/core/common/ActivationGroupNode.java",
    "drools-core/src/main/java/org/drools/core/common/EndOperationListener.java",
    "drools-core/src/main/java/org/drools/core/common/DroolsObjectOutputStream.java",
    "drools-core/src/main/java/org/drools/core/common/SingleNonIndexSkipBetaConstraints.java",
    "drools-core/src/main/java/org/drools/core/common/DefaultAgenda.java",
    "drools-core/src/main/java/org/drools/core/common/LogicalDependency.java",
    "drools-core/src/main/java/org/drools/core/common/WorkingMemoryAction.java",
    "drools-core/src/main/java/org/drools/core/common/RuleFlowGroupListener.java",
    "drools-core/src/main/java/org/drools/core/common/AgendaGroupQueueImpl.java",
    "drools-core/src/main/java/org/drools/core/common/ActivationNode.java",
    "drools-core/src/main/java/org/drools/core/common/InternalWorkingMemoryActions.java",
    "drools-core/src/main/java/org/drools/core/common/DroolsObjectInput.java",
    "drools-core/src/main/java/org/drools/core/spi/GlobalResolver.java",
    "drools-core/src/main/java/org/drools/core/spi/Restriction.java",
    "drools-core/src/main/java/org/drools/core/spi/SelfDateExtractor.java",
    "drools-core/src/main/java/org/drools/core/spi/WriteAccessor.java",
    "drools-core/src/main/java/org/drools/core/spi/AcceptsWriteAccessor.java",
    "drools-core/src/main/java/org/drools/core/spi/AsyncExceptionHandler.java",
    "drools-core/src/main/java/org/drools/core/spi/Enabled.java",
    "drools-core/src/main/java/org/drools/core/spi/Functions.java",
    "drools-core/src/main/java/org/drools/core/spi/AlphaNodeFieldConstraint.java",
    "drools-core/src/main/java/org/drools/core/spi/PatternExtractor.java",
    "drools-core/src/main/java/org/drools/core/spi/Duration.java",
    "drools-core/src/main/java/org/drools/core/spi/ConsequenceException.java",
    "drools-core/src/main/java/org/drools/core/spi/DataProvider.java",
    "drools-core/src/main/java/org/drools/core/spi/RuleComponent.java",
    "drools-core/src/main/java/org/drools/core/spi/ClassWireable.java",
    "drools-core/src/main/java/org/drools/core/spi/PredicateExpression.java",
    "drools-core/src/main/java/org/drools/core/spi/ProcessContext.java",
    "drools-core/src/main/java/org/drools/core/spi/ConflictResolver.java",
    "drools-core/src/main/java/org/drools/core/spi/Tuple.java",
    "drools-core/src/main/java/org/drools/core/spi/KnowledgeHelper.java",
    "drools-core/src/main/java/org/drools/core/spi/AcceptsReadAccessor.java",
    "drools-core/src/main/java/org/drools/core/spi/ReadAccessor.java",
    "drools-core/src/main/java/org/drools/core/spi/FieldValue.java",
    "drools-core/src/main/java/org/drools/core/spi/MvelAccumulator.java",
    "drools-core/src/main/java/org/drools/core/spi/InternalActivationGroup.java",
    "drools-core/src/main/java/org/drools/core/spi/Wireable.java",
    "drools-core/src/main/java/org/drools/core/spi/AgendaGroup.java",
    "drools-core/src/main/java/org/drools/core/spi/FactHandleFactory.java",
    "drools-core/src/main/java/org/drools/core/spi/PropagationContext.java",
    "drools-core/src/main/java/org/drools/core/spi/AcceptsClassObjectType.java",
    "drools-core/src/main/java/org/drools/core/spi/Writable.java",
    "drools-core/src/main/java/org/drools/core/spi/Consequence.java",
    "drools-core/src/main/java/org/drools/core/spi/Accumulator.java",
    "drools-core/src/main/java/org/drools/core/spi/ConsequenceExceptionHandler.java",
    "drools-core/src/main/java/org/drools/core/spi/InternalReadAccessor.java",
    "drools-core/src/main/java/org/drools/core/spi/SelfNumberExtractor.java",
    "drools-core/src/main/java/org/drools/core/spi/GlobalNumberExtractor.java",
    "drools-core/src/main/java/org/drools/core/spi/GlobalDateExtractor.java",
    "drools-core/src/main/java/org/drools/core/spi/ObjectType.java",
    "drools-core/src/main/java/org/drools/core/spi/SelfEventExtractor.java",
    "drools-core/src/main/java/org/drools/core/spi/Evaluator.java",
    "drools-core/src/main/java/org/drools/core/spi/Constraint.java",
    "drools-core/src/main/java/org/drools/core/spi/AccesptsClassObjectType.java",
    "drools-core/src/main/java/org/drools/core/spi/DeclarationScopeResolver.java",
    "drools-core/src/main/java/org/drools/core/spi/GlobalExporter.java",
    "drools-core/src/main/java/org/drools/core/spi/Acceptor.java",
    "drools-core/src/main/java/org/drools/core/spi/CompiledInvoker.java",
    "drools-core/src/main/java/org/drools/core/spi/EvalExpression.java",
    "drools-core/src/main/java/org/drools/core/spi/FunctionResolver.java",
    "drools-core/src/main/java/org/drools/core/spi/Invoker.java",
    "drools-core/src/main/java/org/drools/core/spi/Activation.java",
    "drools-core/src/main/java/org/drools/core/spi/BetaNodeFieldConstraint.java",
    "drools-core/src/main/java/org/drools/core/spi/Salience.java",
    "drools-core/src/main/java/org/drools/core/spi/GlobalExtractor.java",
    "drools-core/src/main/java/org/drools/core/spi/ReturnValueExpression.java",
    "drools-core/src/main/java/org/drools/core/spi/RuleFlowGroup.java",
    "drools-core/src/main/java/org/drools/core/SessionConfiguration.java",
    "drools-core/src/main/java/org/drools/core/ClockType.java",
    "drools-core/src/main/java/org/drools/core/TimerJobFactoryType.java",
    "drools-core/src/main/java/org/drools/core/audit/KnowledgeRuntimeLoggerProviderImpl.java",
    "drools-core/src/main/java/org/drools/core/audit/WorkingMemoryConsoleLogger.java",
    "drools-core/src/main/java/org/drools/core/audit/WorkingMemoryInMemoryLogger.java",
    "drools-core/src/main/java/org/drools/core/audit/WorkingMemoryLog.java",
    "drools-core/src/main/java/org/drools/core/audit/WorkingMemoryLogger.java",
    "drools-core/src/main/java/org/drools/core/audit/WorkingMemoryFileLogger.java",
    "drools-core/src/main/java/org/drools/core/audit/event/LogEvent.java",
    "drools-core/src/main/java/org/drools/core/audit/event/ActivationLogEvent.java",
    "drools-core/src/main/java/org/drools/core/audit/event/RuleFlowGroupLogEvent.java",
    "drools-core/src/main/java/org/drools/core/audit/event/WorkingMemoryLogEventFilter.java",
    "drools-core/src/main/java/org/drools/core/audit/event/RuleFlowVariableLogEvent.java",
    "drools-core/src/main/java/org/drools/core/audit/event/RuleFlowLogEvent.java",
    "drools-core/src/main/java/org/drools/core/audit/event/ILogEventFilter.java",
    "drools-core/src/main/java/org/drools/core/audit/event/RuleBaseLogEvent.java",
    "drools-core/src/main/java/org/drools/core/audit/event/ObjectLogEvent.java",
    "drools-core/src/main/java/org/drools/core/audit/event/RuleFlowNodeLogEvent.java",
    "drools-core/src/main/java/org/drools/core/audit/event/ActivationLogEventFilter.java",
    "drools-core/src/main/java/org/drools/core/audit/package-info.java",
    "drools-core/src/main/java/org/drools/core/audit/ThreadedWorkingMemoryFileLogger.java",
    "drools-core/src/main/java/org/drools/core/concurrent/ParallelRuleEvaluator.java",
    "drools-core/src/main/java/org/drools/core/concurrent/SequentialRuleEvaluator.java",
    "drools-core/src/main/java/org/drools/core/concurrent/AbstractRuleEvaluator.java",
    "drools-core/src/main/java/org/drools/core/concurrent/ExecutorProviderImpl.java",
    "drools-core/src/main/java/org/drools/core/concurrent/RuleEvaluator.java",
    "drools-core/src/main/java/org/drools/core/facttemplates/FieldTemplateImpl.java",
    "drools-core/src/main/java/org/drools/core/facttemplates/FactTemplateFieldExtractor.java",
    "drools-core/src/main/java/org/drools/core/facttemplates/FactTemplateObjectType.java",
    "drools-core/src/main/java/org/drools/core/facttemplates/FieldTemplate.java",
    "drools-core/src/main/java/org/drools/core/facttemplates/FactTemplate.java",
    "drools-core/src/main/java/org/drools/core/facttemplates/FactImpl.java",
    "drools-core/src/main/java/org/drools/core/facttemplates/FactTemplateImpl.java",
    "drools-core/src/main/java/org/drools/core/facttemplates/Fact.java",
    "drools-core/src/main/java/org/drools/core/WorkingMemory.java",
    "drools-core/src/main/java/org/drools/core/SessionConfigurationImpl.java",
    "drools-core/src/main/java/org/drools/core/WorkItemHandlerNotFoundException.java",
    "drools-core/src/main/java/org/drools/core/command/impl/ContextImpl.java",
    "drools-core/src/main/java/org/drools/core/command/impl/ExecutableCommand.java",
    "drools-core/src/main/java/org/drools/core/command/impl/ContextImplWithEviction.java",
    "drools-core/src/main/java/org/drools/core/command/impl/AsynchronousInterceptor.java",
    "drools-core/src/main/java/org/drools/core/command/impl/LoggingInterceptor.java",
    "drools-core/src/main/java/org/drools/core/command/impl/CommandBasedEntryPoint.java",
    "drools-core/src/main/java/org/drools/core/command/impl/FireAllRulesInterceptor.java",
    "drools-core/src/main/java/org/drools/core/command/impl/AbstractInterceptor.java",
    "drools-core/src/main/java/org/drools/core/command/impl/FluentCommandFactoryServiceImpl.java",
    "drools-core/src/main/java/org/drools/core/command/impl/CommandFactoryServiceImpl.java",
    "drools-core/src/main/java/org/drools/core/command/impl/CommandBasedStatefulKnowledgeSession.java",
    "drools-core/src/main/java/org/drools/core/command/impl/NotTransactionalCommand.java",
    "drools-core/src/main/java/org/drools/core/command/NewRuleUnitExecutorCommand.java",
    "drools-core/src/main/java/org/drools/core/command/EndConversationCommand.java",
    "drools-core/src/main/java/org/drools/core/command/NewKieSessionCommand.java",
    "drools-core/src/main/java/org/drools/core/command/IdentifiableResult.java",
    "drools-core/src/main/java/org/drools/core/command/LeaveConversationCommand.java",
    "drools-core/src/main/java/org/drools/core/command/BindVariableToUnitCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/UnregisterChannelCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/GetCalendarsCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/RemoveEventListenerCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/UnpersistableCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/GetGlobalsCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/GetChannelsCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/RegisterChannelCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/KBuilderSetPropertyCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/GetFactCountInEntryPointCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/GetKieBaseCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/DestroySessionCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/GetIdCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/AdvanceSessionTimeCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/DisposeCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/GetSessionTimeCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/ObjectFactory.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/GetEntryPointsCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/InsertElementsCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/DeleteCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/UpdateInEntryPointCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/GetObjectCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/ClearAgendaGroupCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/AgendaGroupSetFocusCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/GetFactHandleInEntryPointCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/GetAgendaEventListenersCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/InsertObjectCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/ClearRuleFlowGroupCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/UpdateCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/DeleteObjectCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/QueryCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/FireUntilHaltCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/GetFactHandlesCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/EnableAuditLogCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/FireAllRulesCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/ObjectFactory.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/DeleteFromEntryPointCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/GetFactHandlesInEntryPointCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/InsertObjectInEntryPointCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/GetFactHandleCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/GetObjectsCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/ModifyCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/GetObjectInEntryPointCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/GetEntryPointCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/ClearActivationGroupCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/HaltCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/ClearAgendaCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/GetRuleRuntimeEventListenersCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/FromExternalFactHandleCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/rule/GetObjectsInEntryPointCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/pmml/PmmlConstants.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/pmml/ApplyPmmlModelCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/GetFactCountCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/BatchExecutionCommandImpl.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/AddEventListenerCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/GetGlobalCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/GetEnvironmentCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/SetGlobalCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/process/RegisterWorkItemHandlerCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/process/AbortWorkItemCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/process/GetWorkItemCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/process/GetProcessInstancesCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/process/GetProcessInstanceCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/process/StartCorrelatedProcessCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/process/GetWorkItemIdsCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/process/SignalEventCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/process/ObjectFactory.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/process/SetProcessInstanceVariablesCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/process/GetProcessEventListenersCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/process/GetProcessIdsCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/process/GetProcessInstanceByCorrelationKeyCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/process/ReTryWorkItemCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/process/StartProcessCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/process/AbortProcessInstanceCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/process/CompleteWorkItemCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/process/CreateProcessInstanceCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/process/CreateCorrelatedProcessInstanceCommand.java",
    "drools-core/src/main/java/org/drools/core/command/runtime/process/StartProcessInstanceCommand.java",
    "drools-core/src/main/java/org/drools/core/command/assertion/AssertEquals.java",
    "drools-core/src/main/java/org/drools/core/command/SetActiveAgendaGroup.java",
    "drools-core/src/main/java/org/drools/core/command/EntryPointCreator.java",
    "drools-core/src/main/java/org/drools/core/command/StartConversationCommand.java",
    "drools-core/src/main/java/org/drools/core/command/NewKnowledgeBuilderConfigurationCommand.java",
    "drools-core/src/main/java/org/drools/core/command/GetDefaultValue.java",
    "drools-core/src/main/java/org/drools/core/command/AddDataSourceCommand.java",
    "drools-core/src/main/java/org/drools/core/command/SingleSessionCommandService.java",
    "drools-core/src/main/java/org/drools/core/command/FinishedCommand.java",
    "drools-core/src/main/java/org/drools/core/command/SetKieContainerCommand.java",
    "drools-core/src/main/java/org/drools/core/command/ConversationContextManager.java",
    "drools-core/src/main/java/org/drools/core/command/RunUnitCommand.java",
    "drools-core/src/main/java/org/drools/core/command/AbstractNewKieContainerCommand.java",
    "drools-core/src/main/java/org/drools/core/command/SetVariableCommandFromCommand.java",
    "drools-core/src/main/java/org/drools/core/command/JoinConversationCommand.java",
    "drools-core/src/main/java/org/drools/core/command/ExecuteCommand.java",
    "drools-core/src/main/java/org/drools/core/command/SetVariableCommandFromLastReturn.java",
    "drools-core/src/main/java/org/drools/core/command/OutCommand.java",
    "drools-core/src/main/java/org/drools/core/command/GetKieContainerCommand.java",
    "drools-core/src/main/java/org/drools/core/command/RequestContextImpl.java",
    "drools-core/src/main/java/org/drools/core/command/GetSessionClockCommand.java",
    "drools-core/src/main/java/org/drools/core/command/GetVariableCommand.java",
    "drools-core/src/main/java/org/drools/core/QueryResultsRowImpl.java",
    "drools-core/src/main/java/org/drools/core/BeliefSystemType.java",
    "drools-core/src/main/java/org/drools/core/ActivationListenerFactory.java",
    "drools-core/src/main/java/org/drools/core/definitions/impl/KnowledgePackageImpl.java",
    "drools-core/src/main/java/org/drools/core/definitions/ProcessPackage.java",
    "drools-core/src/main/java/org/drools/core/definitions/InternalKnowledgePackage.java",
    "drools-core/src/main/java/org/drools/core/definitions/ResourceTypePackageRegistry.java",
    "drools-core/src/main/java/org/drools/core/definitions/rule/impl/RuleImpl.java",
    "drools-core/src/main/java/org/drools/core/definitions/rule/impl/GlobalImpl.java",
    "drools-core/src/main/java/org/drools/core/builder/conf/impl/JaxbConfigurationImpl.java",
    "drools-core/src/main/java/org/drools/core/builder/conf/impl/ScoreCardConfigurationImpl.java",
    "drools-core/src/main/java/org/drools/core/builder/conf/impl/ResourceConfigurationImpl.java",
    "drools-core/src/main/java/org/drools/core/builder/conf/impl/DecisionTableConfigurationImpl.java",
    "drools-core/src/main/java/org/drools/core/kie/impl/MessageImpl.java",
    "drools-core/src/main/java/org/drools/core/event/DefaultRuleRuntimeEventListener.java",
    "drools-core/src/main/java/org/drools/core/event/AgendaGroupPushedEvent.java",
    "drools-core/src/main/java/org/drools/core/event/AgendaEventSupport.java",
    "drools-core/src/main/java/org/drools/core/event/ProcessEvent.java",
    "drools-core/src/main/java/org/drools/core/event/ProcessNodeLeftEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/SLAViolatedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/ProcessStartedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/ProcessNodeTriggeredEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/AgendaGroupEvent.java",
    "drools-core/src/main/java/org/drools/core/event/ProcessCompletedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/ProcessVariableChangedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/AbstractEventSupport.java",
    "drools-core/src/main/java/org/drools/core/event/KieBaseEventSupport.java",
    "drools-core/src/main/java/org/drools/core/event/rule/impl/ActivationCancelledEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/rule/impl/SerializableAgendaGroup.java",
    "drools-core/src/main/java/org/drools/core/event/rule/impl/ActivationCreatedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/rule/impl/SerializableRuleFlowGroup.java",
    "drools-core/src/main/java/org/drools/core/event/rule/impl/ActivationEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/rule/impl/AfterActivationFiredEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/rule/impl/AgendaGroupPushedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/rule/impl/RuleFlowGroupEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/rule/impl/RuleFlowGroupDeactivatedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/rule/impl/AgendaGroupPoppedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/rule/impl/RuleRuntimeEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/rule/impl/ObjectUpdatedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/rule/impl/SerializableActivation.java",
    "drools-core/src/main/java/org/drools/core/event/rule/impl/RuleFlowGroupActivatedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/rule/impl/ObjectDeletedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/rule/impl/ObjectInsertedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/rule/impl/BeforeActivationFiredEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/rule/impl/AgendaGroupEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/RuleFlowGroupActivatedEvent.java",
    "drools-core/src/main/java/org/drools/core/event/RuleFlowGroupDeactivatedEvent.java",
    "drools-core/src/main/java/org/drools/core/event/RuleRuntimeEventSupport.java",
    "drools-core/src/main/java/org/drools/core/event/RuleEventListenerSupport.java",
    "drools-core/src/main/java/org/drools/core/event/DebugProcessEventListener.java",
    "drools-core/src/main/java/org/drools/core/event/ProcessEventSupport.java",
    "drools-core/src/main/java/org/drools/core/event/BeforeActivationFiredEvent.java",
    "drools-core/src/main/java/org/drools/core/event/knowlegebase/impl/AfterProcessAddedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/knowlegebase/impl/KnowledgeBaseEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/knowlegebase/impl/BeforeKiePackageRemovedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/knowlegebase/impl/AfterFunctionRemovedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/knowlegebase/impl/AfterKiePackageAddedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/knowlegebase/impl/BeforeKnowledgeBaseUnlockedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/knowlegebase/impl/BeforeProcessAddedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/knowlegebase/impl/AfterProcessRemovedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/knowlegebase/impl/AfterKiePackageRemovedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/knowlegebase/impl/BeforeFunctionRemovedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/knowlegebase/impl/BeforeKiePackageAddedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/knowlegebase/impl/BeforeRuleRemovedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/knowlegebase/impl/AfterKnowledgeBaseUnlockedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/knowlegebase/impl/BeforeProcessRemovedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/knowlegebase/impl/AfterKnowledgeBaseLockedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/knowlegebase/impl/BeforeRuleAddedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/knowlegebase/impl/AfterRuleRemovedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/knowlegebase/impl/AfterRuleAddedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/knowlegebase/impl/BeforeKnowledgeBaseLockedEventImpl.java",
    "drools-core/src/main/java/org/drools/core/event/ActivationCreatedEvent.java",
    "drools-core/src/main/java/org/drools/core/event/ActivationEvent.java",
    "drools-core/src/main/java/org/drools/core/event/AgendaGroupPoppedEvent.java",
    "drools-core/src/main/java/org/drools/core/event/DebugRuleRuntimeEventListener.java",
    "drools-core/src/main/java/org/drools/core/event/DefaultAgendaEventListener.java",
    "drools-core/src/main/java/org/drools/core/event/ActivationCancelledEvent.java",
    "drools-core/src/main/java/org/drools/core/event/KnowledgeBaseEvent.java",
    "drools-core/src/main/java/org/drools/core/event/DefaultProcessEventListener.java",
    "drools-core/src/main/java/org/drools/core/event/AfterActivationFiredEvent.java",
    "drools-core/src/main/java/org/drools/core/event/WorkingMemoryEvent.java",
    "drools-core/src/main/java/org/drools/core/event/package-info.java",
    "drools-core/src/main/java/org/drools/core/event/DebugAgendaEventListener.java",
    "drools-core/src/main/java/org/drools/core/event/RuleFlowGroupEvent.java",
    "drools-core/src/main/java/org/drools/core/metadata/ManyValuedMetaProperty.java",
    "drools-core/src/main/java/org/drools/core/metadata/NewInstanceLiteral.java",
    "drools-core/src/main/java/org/drools/core/metadata/Identifiable.java",
    "drools-core/src/main/java/org/drools/core/metadata/OneToOneValuedMetaProperty.java",
    "drools-core/src/main/java/org/drools/core/metadata/AbstractWMTask.java",
    "drools-core/src/main/java/org/drools/core/metadata/OneToManyValuedMetaProperty.java",
    "drools-core/src/main/java/org/drools/core/metadata/With.java",
    "drools-core/src/main/java/org/drools/core/metadata/WorkingMemoryTask.java",
    "drools-core/src/main/java/org/drools/core/metadata/InvertiblePropertyLiteral.java",
    "drools-core/src/main/java/org/drools/core/metadata/MetaProperty.java",
    "drools-core/src/main/java/org/drools/core/metadata/ManyToOneValuedMetaProperty.java",
    "drools-core/src/main/java/org/drools/core/metadata/ManyToManyPropertyLiteral.java",
    "drools-core/src/main/java/org/drools/core/metadata/MetadataContainer.java",
    "drools-core/src/main/java/org/drools/core/metadata/ModifyLiteral.java",
    "drools-core/src/main/java/org/drools/core/metadata/PropertyLiteral.java",
    "drools-core/src/main/java/org/drools/core/metadata/OneToOnePropertyLiteral.java",
    "drools-core/src/main/java/org/drools/core/metadata/MetaClass.java",
    "drools-core/src/main/java/org/drools/core/metadata/Modify.java",
    "drools-core/src/main/java/org/drools/core/metadata/DonLiteral.java",
    "drools-core/src/main/java/org/drools/core/metadata/ModifyTask.java",
    "drools-core/src/main/java/org/drools/core/metadata/MetaCallableTask.java",
    "drools-core/src/main/java/org/drools/core/metadata/Don.java",
    "drools-core/src/main/java/org/drools/core/metadata/Metadatable.java",
    "drools-core/src/main/java/org/drools/core/metadata/ClassLiteral.java",
    "drools-core/src/main/java/org/drools/core/metadata/ToOnePropertyLiteral.java",
    "drools-core/src/main/java/org/drools/core/metadata/ManyToOnePropertyLiteral.java",
    "drools-core/src/main/java/org/drools/core/metadata/ToManyPropertyLiteral.java",
    "drools-core/src/main/java/org/drools/core/metadata/OneValuedMetaProperty.java",
    "drools-core/src/main/java/org/drools/core/metadata/InvertibleMetaProperty.java",
    "drools-core/src/main/java/org/drools/core/metadata/Shed.java",
    "drools-core/src/main/java/org/drools/core/metadata/OneToManyPropertyLiteral.java",
    "drools-core/src/main/java/org/drools/core/metadata/ManyToManyValuedMetaProperty.java",
    "drools-core/src/main/java/org/drools/core/metadata/InverseOneValuedMetaProperty.java",
    "drools-core/src/main/java/org/drools/core/metadata/InverseManyValuedMetaProperty.java",
    "drools-core/src/main/java/org/drools/core/metadata/Lit.java",
    "drools-core/src/main/java/org/drools/core/metadata/NewInstance.java",
    "drools-core/src/main/java/org/drools/core/metadata/MetadataHolder.java",
    "drools-core/src/main/java/org/drools/core/base/RuleNameStartsWithAgendaFilter.java",
    "drools-core/src/main/java/org/drools/core/base/ClassObjectType.java",
    "drools-core/src/main/java/org/drools/core/base/FieldDataFactory.java",
    "drools-core/src/main/java/org/drools/core/base/DroolsQuery.java",
    "drools-core/src/main/java/org/drools/core/base/DefaultKnowledgeHelper.java",
    "drools-core/src/main/java/org/drools/core/base/KnowledgeHelperFactory.java",
    "drools-core/src/main/java/org/drools/core/base/RuleNameEndsWithAgendaFilter.java",
    "drools-core/src/main/java/org/drools/core/base/InternalViewChangedEventListener.java",
    "drools-core/src/main/java/org/drools/core/base/BaseEvaluator.java",
    "drools-core/src/main/java/org/drools/core/base/ClassFieldWriter.java",
    "drools-core/src/main/java/org/drools/core/base/ClassFieldReader.java",
    "drools-core/src/main/java/org/drools/core/base/ClassFieldAccessorCache.java",
    "drools-core/src/main/java/org/drools/core/base/mvel/MVELEvalExpression.java",
    "drools-core/src/main/java/org/drools/core/base/mvel/MVELDateCoercion.java",
    "drools-core/src/main/java/org/drools/core/base/mvel/MVELEnabledExpression.java",
    "drools-core/src/main/java/org/drools/core/base/mvel/MVELDebugHandler.java",
    "drools-core/src/main/java/org/drools/core/base/mvel/MVELSalienceExpression.java",
    "drools-core/src/main/java/org/drools/core/base/mvel/MVELAccumulator.java",
    "drools-core/src/main/java/org/drools/core/base/mvel/MVELCompilationUnit.java",
    "drools-core/src/main/java/org/drools/core/base/mvel/MVELCalendarCoercion.java",
    "drools-core/src/main/java/org/drools/core/base/mvel/MVELObjectExpression.java",
    "drools-core/src/main/java/org/drools/core/base/mvel/ActivationPropertyHandler.java",
    "drools-core/src/main/java/org/drools/core/base/mvel/MVELReturnValueExpression.java",
    "drools-core/src/main/java/org/drools/core/base/mvel/MVELConsequence.java",
    "drools-core/src/main/java/org/drools/core/base/mvel/MVELCompileable.java",
    "drools-core/src/main/java/org/drools/core/base/dataproviders/MVELDataProvider.java",
    "drools-core/src/main/java/org/drools/core/base/dataproviders/ReactiveMVELDataProvider.java",
    "drools-core/src/main/java/org/drools/core/base/SimpleValueType.java",
    "drools-core/src/main/java/org/drools/core/base/ClassFieldAccessorFactory.java",
    "drools-core/src/main/java/org/drools/core/base/FieldAccessor.java",
    "drools-core/src/main/java/org/drools/core/base/MapGlobalResolver.java",
    "drools-core/src/main/java/org/drools/core/base/EvaluatorWrapper.java",
    "drools-core/src/main/java/org/drools/core/base/QueryRowWithSubruleIndex.java",
    "drools-core/src/main/java/org/drools/core/base/RuleNameSerializationAgendaFilter.java",
    "drools-core/src/main/java/org/drools/core/base/ArrayElements.java",
    "drools-core/src/main/java/org/drools/core/base/UndefinedCalendarExcption.java",
    "drools-core/src/main/java/org/drools/core/base/field/BooleanFieldImpl.java",
    "drools-core/src/main/java/org/drools/core/base/field/LongFieldImpl.java",
    "drools-core/src/main/java/org/drools/core/base/field/ObjectFieldImpl.java",
    "drools-core/src/main/java/org/drools/core/base/field/ClassFieldImpl.java",
    "drools-core/src/main/java/org/drools/core/base/field/DoubleFieldImpl.java",
    "drools-core/src/main/java/org/drools/core/base/field/IntegerFieldImpl.java",
    "drools-core/src/main/java/org/drools/core/base/NonCloningQueryViewListener.java",
    "drools-core/src/main/java/org/drools/core/base/ClassFieldAccessor.java",
    "drools-core/src/main/java/org/drools/core/base/DefaultKnowledgeHelperFactory.java",
    "drools-core/src/main/java/org/drools/core/base/ClassFieldAccessorStore.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/MetByEvaluatorDefinition.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/TimeIntervalParser.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/OverlapsEvaluatorDefinition.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/MeetsEvaluatorDefinition.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/Operator.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/IsAEvaluatorDefinition.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/StartsEvaluatorDefinition.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/EvaluatorDefinition.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/IncludesEvaluatorDefinition.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/FinishesEvaluatorDefinition.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/DuringEvaluatorDefinition.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/EvaluatorRegistry.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/SetEvaluatorsDefinition.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/OverlappedByEvaluatorDefinition.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/EvaluatorCache.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/SoundslikeEvaluatorsDefinition.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/StrEvaluatorDefinition.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/BeforeEvaluatorDefinition.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/MatchesEvaluatorsDefinition.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/FinishedByEvaluatorDefinition.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/BuiltInEvaluatorDefinitions.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/AfterEvaluatorDefinition.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/CoincidesEvaluatorDefinition.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/StartedByEvaluatorDefinition.java",
    "drools-core/src/main/java/org/drools/core/base/evaluators/PointInTimeEvaluator.java",
    "drools-core/src/main/java/org/drools/core/base/AccessorKey.java",
    "drools-core/src/main/java/org/drools/core/base/ValueType.java",
    "drools-core/src/main/java/org/drools/core/base/TraitHelper.java",
    "drools-core/src/main/java/org/drools/core/base/CalendarsImpl.java",
    "drools-core/src/main/java/org/drools/core/base/AbstractQueryViewListener.java",
    "drools-core/src/main/java/org/drools/core/base/WrappedStatefulKnowledgeSessionForRHS.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/CountAccumulateFunction.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/CollectSetAccumulateFunction.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/CollectAccumulator.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/LongSumAccumulateFunction.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/LongMinAccumulateFunction.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/IntegerMaxAccumulateFunction.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/NumericMinAccumulateFunction.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/VarianceAccumulateFunction.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/JavaAccumulatorFunctionExecutor.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/SumAccumulateFunction.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/MinAccumulateFunction.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/AverageAccumulateFunction.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/BigDecimalSumAccumulateFunction.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/BigDecimalAverageAccumulateFunction.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/IntegerMinAccumulateFunction.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/MVELAccumulatorFunctionExecutor.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/IntegerSumAccumulateFunction.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/CollectListAccumulateFunction.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/NumericMaxAccumulateFunction.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/StandardDeviationAccumulateFunction.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/LongMaxAccumulateFunction.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/AbstractAccumulateFunction.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/BigIntegerSumAccumulateFunction.java",
    "drools-core/src/main/java/org/drools/core/base/accumulators/MaxAccumulateFunction.java",
    "drools-core/src/main/java/org/drools/core/base/FieldFactory.java",
    "drools-core/src/main/java/org/drools/core/base/RuleNameEqualsAgendaFilter.java",
    "drools-core/src/main/java/org/drools/core/base/ReferenceOriginalGlobalExporter.java",
    "drools-core/src/main/java/org/drools/core/base/EnabledBoolean.java",
    "drools-core/src/main/java/org/drools/core/base/SequentialKnowledgeHelper.java",
    "drools-core/src/main/java/org/drools/core/base/BaseClassFieldReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/MVELObjectClassFieldReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseDateClassFieldReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseByteClassFieldWriter.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseLocalDateTimeClassFieldReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseByteClassFieldReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/ArrayElementReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/MVELDateClassFieldReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseLocalDateClassFieldReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/ConstantValueReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseNumberClassFieldReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/MVELClassFieldReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseDoubleClassFieldReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseBooleanClassFieldWriter.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseLongClassFieldWriter.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseBooleanClassFieldReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseZonedDateTimeClassFieldReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseLongClassFieldReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseDoubleClassFieldWriter.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseShortClassFieldReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseShortClassFieldWriter.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/MVELNumberClassFieldReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseFloatClassFieldReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseCharClassFieldWriter.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseIntClassFieldReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseObjectClassFieldWriter.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseObjectClassFieldReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseIntClassFieldWriter.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseCharClassFieldReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/SelfReferenceClassFieldReader.java",
    "drools-core/src/main/java/org/drools/core/base/extractors/BaseFloatClassFieldWriter.java",
    "drools-core/src/main/java/org/drools/core/base/ModifyInterceptor.java",
    "drools-core/src/main/java/org/drools/core/base/BaseClassFieldWriter.java",
    "drools-core/src/main/java/org/drools/core/base/RuleNameMatchesAgendaFilter.java",
    "drools-core/src/main/java/org/drools/core/base/JavaFactRegistryEntry.java",
    "drools-core/src/main/java/org/drools/core/base/SalienceInteger.java",
    "drools-core/src/main/java/org/drools/core/base/StandardQueryViewChangedEventListener.java",
    "drools-core/src/main/java/org/drools/core/package-info.java",
    "drools-core/src/main/java/org/drools/core/QueryResultsImpl.java",
    "drools-core/src/main/java/org/drools/core/process/instance/impl/DefaultWorkItemManager.java",
    "drools-core/src/main/java/org/drools/core/process/instance/impl/DefaultWorkItemManagerFactory.java",
    "drools-core/src/main/java/org/drools/core/process/instance/impl/WorkItemImpl.java",
    "drools-core/src/main/java/org/drools/core/process/instance/WorkItemHandler.java",
    "drools-core/src/main/java/org/drools/core/process/instance/WorkItemManager.java",
    "drools-core/src/main/java/org/drools/core/process/instance/WorkItem.java",
    "drools-core/src/main/java/org/drools/core/process/instance/WorkItemListener.java",
    "drools-core/src/main/java/org/drools/core/process/instance/WorkItemManagerFactory.java",
    "drools-workbench-models/drools-workbench-models-guided-template/src/test/java/org/drools/workbench/models/guided/template/backend/Applicant.java",
    "drools-workbench-models/drools-workbench-models-guided-template/src/test/java/org/drools/workbench/models/guided/template/backend/TemplateIntegrationTest.java",
    "drools-workbench-models/drools-workbench-models-guided-template/src/test/java/org/drools/workbench/models/guided/template/backend/RuleTemplateModelDRLPersistenceTest.java",
    "drools-workbench-models/drools-workbench-models-guided-template/src/test/java/org/drools/workbench/models/guided/template/backend/TemplateWithDSLIntegrationTest.java",
    "drools-workbench-models/drools-workbench-models-guided-template/src/test/java/org/drools/workbench/models/guided/template/backend/RuleTemplateModelXMLLegacyPersistenceTest.java",
    "drools-workbench-models/drools-workbench-models-guided-template/src/test/java/org/drools/workbench/models/guided/template/backend/RuleTemplateModelIncrementalCompilationTest.java",
    "drools-workbench-models/drools-workbench-models-guided-template/src/test/java/org/drools/workbench/models/guided/template/backend/RuleTemplateModelXMLPersistenceTest.java",
    "drools-workbench-models/drools-workbench-models-guided-template/src/test/java/org/drools/workbench/models/guided/template/shared/TemplateModelTest.java",
    "drools-workbench-models/drools-workbench-models-guided-template/src/main/java/org/drools/workbench/models/guided/template/backend/upgrade/RuleModelUpgradeHelper2.java",
    "drools-workbench-models/drools-workbench-models-guided-template/src/main/java/org/drools/workbench/models/guided/template/backend/upgrade/RuleModelUpgradeHelper3.java",
    "drools-workbench-models/drools-workbench-models-guided-template/src/main/java/org/drools/workbench/models/guided/template/backend/upgrade/TemplateModelUpgradeHelper1.java",
    "drools-workbench-models/drools-workbench-models-guided-template/src/main/java/org/drools/workbench/models/guided/template/backend/upgrade/RuleModelUpgradeHelper1.java",
    "drools-workbench-models/drools-workbench-models-guided-template/src/main/java/org/drools/workbench/models/guided/template/backend/RuleTemplateModelDRLPersistenceImpl.java",
    "drools-workbench-models/drools-workbench-models-guided-template/src/main/java/org/drools/workbench/models/guided/template/backend/RuleTemplateModelPersistence.java",
    "drools-workbench-models/drools-workbench-models-guided-template/src/main/java/org/drools/workbench/models/guided/template/backend/GuidedRuleTemplateProviderImpl.java",
    "drools-workbench-models/drools-workbench-models-guided-template/src/main/java/org/drools/workbench/models/guided/template/backend/RuleTemplateModelXMLPersistenceImpl.java",
    "drools-workbench-models/drools-workbench-models-guided-template/src/main/java/org/drools/workbench/models/guided/template/shared/TemplateModel.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/test/java/org/drools/workbench/models/guided/dtree/backend/AbstractGuidedDecisionTreeDRLPersistenceUnmarshallingTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/test/java/org/drools/workbench/models/guided/dtree/backend/GuidedDecisionTreeDRLPersistenceUnmarshallingMessagesTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/test/java/org/drools/workbench/models/guided/dtree/backend/GuidedDecisionTreeDRLPersistenceMarshallingTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/test/java/org/drools/workbench/models/guided/dtree/backend/GuidedDecisionTreeDRLPersistenceUnmarshallingTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/test/java/org/drools/workbench/models/guided/dtree/backend/GuidedDecisionTreeValuesTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/test/java/org/drools/workbench/models/guided/dtree/backend/GuidedDecisionTreeDRLPersistenceUnmarshallingLineSeparatorsTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/test/java/org/drools/workbench/models/guided/dtree/backend/GuidedDecisionTreeDRLPersistenceUnmarshallingOneLineRulesTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/backend/GuidedDecisionTreeModelMarshallingVisitor.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/backend/GuidedDecisionTreeModelUnmarshallingVisitor.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/backend/GuidedDecisionTreeDRLPersistence.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/nodes/impl/ActionInsertNodeImpl.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/nodes/impl/ActionFieldValueImpl.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/nodes/impl/ConstraintNodeImpl.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/nodes/impl/ActionRetractNodeImpl.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/nodes/impl/BaseNodeImpl.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/nodes/impl/BaseBoundNodeImpl.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/nodes/impl/TypeNodeImpl.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/nodes/impl/ActionUpdateNodeImpl.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/nodes/ActionUpdateNode.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/nodes/Node.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/nodes/ActionFieldValue.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/nodes/ActionRetractNode.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/nodes/HasValue.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/nodes/TypeNode.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/nodes/ActionInsertNode.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/nodes/HasFieldValues.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/nodes/BoundNode.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/nodes/ConstraintNode.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/values/impl/LongValue.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/values/impl/FloatValue.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/values/impl/EnumValue.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/values/impl/BigDecimalValue.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/values/impl/DateValue.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/values/impl/DoubleValue.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/values/impl/BooleanValue.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/values/impl/BigIntegerValue.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/values/impl/StringValue.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/values/impl/ByteValue.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/values/impl/ShortValue.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/values/impl/IntegerValue.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/values/Value.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/parser/messages/InvalidRootParserMessage.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/parser/messages/AmbiguousRootParserMessage.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/parser/messages/ParserMessage.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/parser/messages/UnsupportedIActionParserMessage.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/parser/messages/UnsupportedFieldNatureTypeParserMessage.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/parser/messages/UnsupportedFieldConstraintTypeParserMessage.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/parser/messages/DefaultParserMessage.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/parser/messages/UnsupportedFieldConstraintParserMessage.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/parser/messages/UnsupportedIPatternParserMessage.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/parser/messages/BindingNotFoundParserMessage.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/parser/messages/DataTypeConversionErrorParserMessage.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/parser/messages/DataTypeNotFoundParserMessage.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/parser/GuidedDecisionTreeParserError.java",
    "drools-workbench-models/drools-workbench-models-guided-dtree/src/main/java/org/drools/workbench/models/guided/dtree/shared/model/GuidedDecisionTree.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/test/java/org/drools/workbench/models/datamodel/workitems/PortableParameterDefinitionTest.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/test/java/org/drools/workbench/models/datamodel/rule/visitors/RuleModelVisitorTest.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/test/java/org/drools/workbench/models/datamodel/rule/visitors/CopyExpressionVisitorTest.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/test/java/org/drools/workbench/models/datamodel/rule/DSLSentenceTest.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/test/java/org/drools/workbench/models/datamodel/rule/RuleModelTest.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/test/java/org/drools/workbench/models/datamodel/rule/util/InterpolationVariableCollectorTest.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/test/java/org/drools/workbench/models/datamodel/rule/SingleFieldConstraintEBLeftSideTest.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/test/java/org/drools/workbench/models/datamodel/rule/DSLVariableValueTest.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/test/java/org/drools/workbench/models/datamodel/rule/DSLComplexVariableValueTest.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/test/java/org/drools/workbench/models/datamodel/rule/ActionCallMethodTest.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/oracle/DSLActionSentence.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/oracle/DSLConditionSentence.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/workitems/PortableStringParameterDefinition.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/workitems/PortableParameterDefinition.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/workitems/PortableIntegerParameterDefinition.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/workitems/PortableWorkDefinition.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/workitems/HasValue.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/workitems/PortableEnumParameterDefinition.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/workitems/PortableFloatParameterDefinition.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/workitems/PortableBooleanParameterDefinition.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/workitems/HasBinding.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/workitems/PortableObjectParameterDefinition.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/workitems/PortableListParameterDefinition.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/imports/Import.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/FieldNatureType.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ExpressionFormLine.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ActionUpdateField.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/visitors/ToStringExpressionVisitor.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/visitors/RuleModelVisitor.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/visitors/CopyExpressionVisitor.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/FreeFormLine.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/BaseSingleFieldConstraint.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ExpressionMethod.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ExpressionFieldVariable.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ActionFieldValue.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ExpressionUnboundFact.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/util/InterpolationVariableCollector.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ExpressionVisitor.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/FieldConstraint.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/SingleFieldConstraint.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/PluggableIAction.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/IFactPattern.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/DSLComplexVariableValue.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/FromCompositeFactPattern.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/RuleMetadata.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/InterpolationVariable.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ActionGlobalCollectionAdd.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ActionFieldFunction.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/FromEntryPointFactPattern.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ActionInsertFact.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/FactPattern.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ExpressionCollectionIndex.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/SingleFieldConstraintEBLeftSide.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/HasExpressionConstraint.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/FromAccumulateCompositeFactPattern.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/FromCollectCompositeFactPattern.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/CompositeFactPattern.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ConnectiveConstraint.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ExpressionVariable.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ExpressionMethodParameter.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/RuleAttribute.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ExpressionGlobalVariable.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/IAction.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ExpressionMethodParameterDefinition.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/IPattern.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ActionFieldList.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ExpressionVisitable.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ActionExecuteWorkItem.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/HasConstraints.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/HasCEPWindow.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/DSLSentence.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ActionInsertLogicalFact.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ExpressionPart.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ActionCallMethod.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ExpressionField.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ExpressionText.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ActionWorkItemFieldValue.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ActionRetractFact.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/DSLVariableValue.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/CEPWindow.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ExpressionCollection.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/ActionSetField.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/FieldNature.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/builder/JavaDRLConstraintValueBuilder.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/builder/MvelDRLConstraintValueBuilder.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/builder/DRLConstraintValueBuilder.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/HasParameterizedOperator.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/HasOperator.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/TemplateAware.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/RuleModel.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/rule/CompositeFieldConstraint.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/auditlog/AuditLog.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/auditlog/DefaultAuditLogFilter.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/auditlog/AuditLogFilter.java",
    "drools-workbench-models/drools-workbench-models-datamodel-api/src/main/java/org/drools/workbench/models/datamodel/auditlog/AuditLogEntry.java",
    "drools-workbench-models/drools-workbench-models-commons/src/test/java/org/drools/workbench/models/commons/backend/rule/RuleModelDRLPersistenceExtensionsTest.java",
    "drools-workbench-models/drools-workbench-models-commons/src/test/java/org/drools/workbench/models/commons/backend/rule/RuleModelTest.java",
    "drools-workbench-models/drools-workbench-models-commons/src/test/java/org/drools/workbench/models/commons/backend/rule/RuleModelDRLPersistenceTest.java",
    "drools-workbench-models/drools-workbench-models-commons/src/test/java/org/drools/workbench/models/commons/backend/rule/classes/RuleFactor.java",
    "drools-workbench-models/drools-workbench-models-commons/src/test/java/org/drools/workbench/models/commons/backend/rule/classes/SearchContext.java",
    "drools-workbench-models/drools-workbench-models-commons/src/test/java/org/drools/workbench/models/commons/backend/rule/classes/MyStringContainerClass.java",
    "drools-workbench-models/drools-workbench-models-commons/src/test/java/org/drools/workbench/models/commons/backend/rule/classes/MyListContainerClass.java",
    "drools-workbench-models/drools-workbench-models-commons/src/test/java/org/drools/workbench/models/commons/backend/rule/classes/ProducerMasterForRules.java",
    "drools-workbench-models/drools-workbench-models-commons/src/test/java/org/drools/workbench/models/commons/backend/rule/TestEnum.java",
    "drools-workbench-models/drools-workbench-models-commons/src/test/java/org/drools/workbench/models/commons/backend/rule/RHSClassDependencyVisitorTest.java",
    "drools-workbench-models/drools-workbench-models-commons/src/test/java/org/drools/workbench/models/commons/backend/rule/PluggableIActionTest.java",
    "drools-workbench-models/drools-workbench-models-commons/src/test/java/org/drools/workbench/models/commons/backend/rule/extensions/TestIActionPersistenceExtensionCopy.java",
    "drools-workbench-models/drools-workbench-models-commons/src/test/java/org/drools/workbench/models/commons/backend/rule/extensions/TestIActionPersistenceExtension.java",
    "drools-workbench-models/drools-workbench-models-commons/src/test/java/org/drools/workbench/models/commons/backend/rule/actions/TestIAction.java",
    "drools-workbench-models/drools-workbench-models-commons/src/test/java/org/drools/workbench/models/commons/backend/rule/RuleModelDRLPersistenceUnmarshallingTest.java",
    "drools-workbench-models/drools-workbench-models-commons/src/test/java/org/drools/workbench/models/commons/backend/rule/BaseRuleModelTest.java",
    "drools-workbench-models/drools-workbench-models-commons/src/test/java/org/drools/workbench/models/commons/backend/rule/RuleModelDRLPersistenceUnmarshallingI18NTest.java",
    "drools-workbench-models/drools-workbench-models-commons/src/main/java/org/drools/workbench/models/commons/backend/rule/RuleModelIActionPersistenceExtension.java",
    "drools-workbench-models/drools-workbench-models-commons/src/main/java/org/drools/workbench/models/commons/backend/rule/CEPOperatorParameterDRLBuilder.java",
    "drools-workbench-models/drools-workbench-models-commons/src/main/java/org/drools/workbench/models/commons/backend/rule/RuleModelDRLPersistenceImpl.java",
    "drools-workbench-models/drools-workbench-models-commons/src/main/java/org/drools/workbench/models/commons/backend/rule/context/RHSGeneratorContext.java",
    "drools-workbench-models/drools-workbench-models-commons/src/main/java/org/drools/workbench/models/commons/backend/rule/context/LHSGeneratorContextFactory.java",
    "drools-workbench-models/drools-workbench-models-commons/src/main/java/org/drools/workbench/models/commons/backend/rule/context/LHSGeneratorContext.java",
    "drools-workbench-models/drools-workbench-models-commons/src/main/java/org/drools/workbench/models/commons/backend/rule/context/GeneratorContextRuleModelVisitor.java",
    "drools-workbench-models/drools-workbench-models-commons/src/main/java/org/drools/workbench/models/commons/backend/rule/context/RHSGeneratorContextFactory.java",
    "drools-workbench-models/drools-workbench-models-commons/src/main/java/org/drools/workbench/models/commons/backend/rule/OperatorParameterDRLBuilder.java",
    "drools-workbench-models/drools-workbench-models-commons/src/main/java/org/drools/workbench/models/commons/backend/rule/CEPWindowOperatorParameterDRLBuilder.java",
    "drools-workbench-models/drools-workbench-models-commons/src/main/java/org/drools/workbench/models/commons/backend/rule/RuleModelPersistenceHelper.java",
    "drools-workbench-models/drools-workbench-models-commons/src/main/java/org/drools/workbench/models/commons/backend/rule/SharedConstants.java",
    "drools-workbench-models/drools-workbench-models-commons/src/main/java/org/drools/workbench/models/commons/backend/rule/DSLVariableValuesConverter.java",
    "drools-workbench-models/drools-workbench-models-commons/src/main/java/org/drools/workbench/models/commons/backend/rule/ActionCallMethodBuilder.java",
    "drools-workbench-models/drools-workbench-models-commons/src/main/java/org/drools/workbench/models/commons/backend/rule/exception/RuleModelDRLPersistenceException.java",
    "drools-workbench-models/drools-workbench-models-commons/src/main/java/org/drools/workbench/models/commons/backend/rule/RuleModelPersistence.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/backend/GuidedDTBRDRLPersistenceTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/backend/GuidedDTDRLPersistenceRuleOrderHitPolicyTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/backend/GuidedDTableParsingIntegrationTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/backend/BRLRuleModelTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/backend/GuidedDTXMLPersistenceTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/backend/GuidedDTDRLPersistenceUniqueHitPolicyTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/backend/HitPolicyPersistenceTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/backend/GuidedDTDRLPersistenceResolvedHitPolicyTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/backend/GuidedDTDRLPersistenceTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/backend/TestUtil.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/backend/GuidedDTDRLPersistenceFirstHitPolicyTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/backend/GuidedDTModelConversionTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/shared/model/ActionSetFieldCol52Test.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/shared/model/GuidedDecisionTable52Test.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/shared/model/Pattern52Test.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/shared/model/BaseBRLTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/shared/model/BRLRuleModelTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/shared/model/ActionWorkItemCol52Test.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/shared/model/ColumnTestBase.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/shared/model/DTCellValue52Test.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/shared/model/ActionWorkItemSetFieldCol52Test.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/shared/model/BaseColumnFieldDiffImplTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/shared/model/BRLActionColumnTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/shared/model/ActionInsertFactCol52Test.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/shared/model/BRLConditionColumnTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/shared/model/DTColumnConfig52Test.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/shared/model/AttributeCol52Test.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/shared/model/ConditionCol52Test.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/shared/model/ActionWorkItemInsertFactCol52Test.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/shared/model/MetadataCol52Test.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/shared/validation/DecisionTableValidatorHitPolicyAttributeLimitationsTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/shared/validation/DecisionTableValidatorAttributesTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/test/java/org/drools/workbench/models/guided/dtable/shared/hitpolicy/RowPriorityResolverTest.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/osgi/Activator.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/backend/util/GuidedDTBRDRLPersistence.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/backend/util/TemplateDataProvider.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/backend/util/GuidedDTTemplateDataProvider.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/backend/util/GuidedDecisionTableUpgradeHelper2.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/backend/util/DataUtilities.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/backend/util/GuidedDecisionTableUpgradeHelper3.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/backend/util/GuidedDTDRLOtherwiseHelper.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/backend/util/GuidedDecisionTableUpgradeHelper1.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/backend/util/GuidedDTDRLUtilities.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/backend/GuidedDTXMLPersistence.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/backend/GuidedDTDRLPersistence.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/backend/GuidedDecisionTableProviderImpl.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/BaseColumnFieldDiffImpl.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/BaseColumn.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/ActionCol52.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/CompositeColumn.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/BRLVariableColumn.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/DTCellValue52.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/LimitedEntryActionSetFieldCol52.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/ActionInsertFactCol52.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/WorkItemColumnParameterValueDiffImpl.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/ActionSetFieldCol52.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/ActionWorkItemInsertFactCol52.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/MetadataCol52.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/RowNumberCol52.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/LimitedEntryActionRetractFactCol52.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/ActionWorkItemCol52.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/ActionWorkItemSetFieldCol52.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/AttributeCol52.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/legacy/MetadataCol.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/legacy/AttributeCol.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/legacy/ConditionCol.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/legacy/GuidedDecisionTable.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/legacy/ActionInsertFactCol.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/legacy/ActionCol.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/legacy/ActionRetractFactCol.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/legacy/DTColumnConfig.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/legacy/ActionSetFieldCol.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/BRLActionColumn.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/LimitedEntryBRLConditionColumn.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/DTColumnConfig52.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/BRLActionVariableColumn.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/ConditionCol52.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/Pattern52.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/LimitedEntryCol.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/ActionRetractFactCol52.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/LimitedEntryActionInsertFactCol52.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/adaptors/ActionInsertFactCol52ActionInsertFactAdaptor.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/adaptors/ActionInsertFactCol52ActionInsertLogicalFactAdaptor.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/adaptors/Pattern52FactPatternAdaptor.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/adaptors/FactPatternPattern52Adaptor.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/adaptors/ConditionCol52FieldConstraintAdaptor.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/DescriptionCol52.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/BRLColumn.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/BRLConditionColumn.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/GuidedDecisionTable52.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/LimitedEntryConditionCol52.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/BRLConditionVariableColumn.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/DiffColumn.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/BaseColumnFieldDiff.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/LimitedEntryBRLActionColumn.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/BRLRuleModel.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/model/ActionInsertFactFieldsPattern.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/conversion/ConversionMessageType.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/conversion/ConversionMessage.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/conversion/ConversionAsset.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/conversion/ConversionResult.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/validation/InvalidAttributeColumnForHitPolicyException.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/validation/DecisionTableValidator.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/validation/DuplicateAttributeException.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/validation/HitPolicyValidation.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/auditlog/ActionInsertFactColumnDetails.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/auditlog/ColumnDetails.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/auditlog/InsertRowAuditLogEntry.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/auditlog/ActionWorkItemSetFieldColumnDetails.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/auditlog/DeleteRowAuditLogEntry.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/auditlog/DecisionTableAuditLogFilter.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/auditlog/DeleteColumnAuditLogEntry.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/auditlog/AttributeColumnDetails.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/auditlog/InsertColumnAuditLogEntry.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/auditlog/LimitedEntryActionSetFieldColumnDetails.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/auditlog/ActionWorkItemColumnDetails.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/auditlog/MetadataColumnDetails.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/auditlog/UpdateColumnAuditLogEntry.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/auditlog/ActionSetFieldColumnDetails.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/auditlog/LimitedEntryConditionColumnDetails.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/auditlog/DecisionTableAuditEvents.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/auditlog/LimitedEntryActionInsertFactColumnDetails.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/auditlog/ActionWorkItemInsertFactColumnDetails.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/auditlog/ConditionColumnDetails.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/hitpolicy/RowPriorityResolver.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/hitpolicy/Over.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/hitpolicy/DTableValidationException.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/hitpolicy/RowPriorities.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/hitpolicy/RowNumber.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/hitpolicy/DecisionTableHitPolicyEnhancer.java",
    "drools-workbench-models/drools-workbench-models-guided-dtable/src/main/java/org/drools/workbench/models/guided/dtable/shared/hitpolicy/Salience.java",
    "drools-workbench-models/drools-workbench-models-guided-scorecard/src/test/java/org/drools/workbench/models/guided/scorecard/backend/ImportsToFQCNTest.java",
    "drools-workbench-models/drools-workbench-models-guided-scorecard/src/test/java/org/drools/workbench/models/guided/scorecard/backend/test1/Applicant.java",
    "drools-workbench-models/drools-workbench-models-guided-scorecard/src/test/java/org/drools/workbench/models/guided/scorecard/backend/test1/GuidedScoreCardIntegrationJavaClassesOnClassPathTest.java",
    "drools-workbench-models/drools-workbench-models-guided-scorecard/src/test/java/org/drools/workbench/models/guided/scorecard/backend/test1/ApplicantAttribute.java",
    "drools-workbench-models/drools-workbench-models-guided-scorecard/src/test/java/org/drools/workbench/models/guided/scorecard/backend/test2/GuidedScoreCardIntegrationJavaClassesAddedToKieFileSystemTest.java",
    "drools-workbench-models/drools-workbench-models-guided-scorecard/src/test/java/org/drools/workbench/models/guided/scorecard/backend/base/Helper.java",
    "drools-workbench-models/drools-workbench-models-guided-scorecard/src/test/java/org/drools/workbench/models/guided/scorecard/backend/base/GuidedScoreCardDRLPersistenceTest.java",
    "drools-workbench-models/drools-workbench-models-guided-scorecard/src/main/java/org/drools/workbench/models/guided/scorecard/backend/ImportsToFQCN.java",
    "drools-workbench-models/drools-workbench-models-guided-scorecard/src/main/java/org/drools/workbench/models/guided/scorecard/backend/GuidedScoreCardDRLPersistence.java",
    "drools-workbench-models/drools-workbench-models-guided-scorecard/src/main/java/org/drools/workbench/models/guided/scorecard/backend/GuidedScoreCardModelVisitor.java",
    "drools-workbench-models/drools-workbench-models-guided-scorecard/src/main/java/org/drools/workbench/models/guided/scorecard/backend/GuidedScoreCardXMLPersistence.java",
    "drools-workbench-models/drools-workbench-models-guided-scorecard/src/main/java/org/drools/workbench/models/guided/scorecard/backend/GuidedScoreCardProviderImpl.java",
    "drools-workbench-models/drools-workbench-models-guided-scorecard/src/main/java/org/drools/workbench/models/guided/scorecard/shared/Characteristic.java",
    "drools-workbench-models/drools-workbench-models-guided-scorecard/src/main/java/org/drools/workbench/models/guided/scorecard/shared/ScoreCardModel.java",
    "drools-workbench-models/drools-workbench-models-guided-scorecard/src/main/java/org/drools/workbench/models/guided/scorecard/shared/Attribute.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/DumbFact.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/TestingEventListenerTest.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/OuterFact.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/Mouse.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/Cheesery.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/CheeseType.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/PersonInterface.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/MatryoshkaDoll.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/SqlDateWrapper.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/verifiers/FactVerifierTest.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/verifiers/FactFieldValueVerifierTest.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/verifiers/RuleFiredVerifierTest.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/ScenarioRunnerTest.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/Address.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/FactDataTest.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/Cheese.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/Person.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/executors/MethodExecutorTest.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/populators/FieldPopulatorFactoryTest.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/populators/FactPopulatorTest.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/populators/FactAssignmentFieldPopulatorTest.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/populators/GlobalFactPopulatorTest.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/populators/DummyFactPopulatorTest.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/populators/NewFactPopulatorTest.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/MyCollectionWrapper.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/ScenarioTest.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/RuleUnit.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/PopulatingWithMVELTest.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/ScenarioRunner4JUnitTest.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/test/java/org/drools/workbench/models/testscenarios/backend/RuleCoverageListenerTest.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/ScenarioRunner.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/TestServiceImpl.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/util/FieldConverter.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/util/FieldTypeResolver.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/util/DateObjectFactory.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/util/ScenarioXMLPersistence.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/verifiers/FactFieldValueVerifier.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/verifiers/RuleFiredVerifier.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/verifiers/FactVerifier.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/executors/MethodExecutor.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/NullKieSessionException.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/populators/FieldPopulator.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/populators/FieldPopulatorFactory.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/populators/DateFieldPopulator.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/populators/ExpressionFieldPopulator.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/populators/ExistingFactPopulator.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/populators/FactAssignmentFieldPopulator.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/populators/DummyFactPopulator.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/populators/CollectionFieldPopulator.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/populators/SimpleFieldPopulator.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/populators/NewFactPopulator.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/populators/FactPopulatorFactory.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/populators/GlobalFactPopulator.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/populators/Populator.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/populators/FactPopulator.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/populators/EnumFieldPopulator.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/populators/FactPopulatorBase.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/TestScenarioKSessionWrapper.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/ScenarioPMMLRunner4JUnit.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/TestService.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/ScenarioSettings.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/ScenarioRunner4JUnit.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/RuleCoverageListener.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/TestingEventListener.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/backend/InvalidClockTypeException.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/CallFixtureMap.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/VerifyFact.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/FieldData.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/Expectation.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/BuilderResultLine.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/CollectionFieldData.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/RetractFact.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/ActivateRuleFlowGroup.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/Scenario.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/VerifyRuleFired.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/FactData.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/CallFieldValue.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/FixtureList.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/FieldPlaceHolder.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/SingleScenarioResult.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/FixturesMap.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/ExecutionTrace.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/CallMethod.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/Field.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/VerifyField.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/FactAssignmentField.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/ScenarioRunResult.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/Fact.java",
    "drools-workbench-models/drools-workbench-models-test-scenarios/src/main/java/org/drools/workbench/models/testscenarios/shared/Fixture.java",
    "kie-ci/src/test/java/org/kie/api/builder/helper/KieModuleDeploymentHelperLoadResourcesTest.java",
    "kie-ci/src/test/java/org/kie/api/builder/helper/KieModuleDeploymentHelperTest.java",
    "kie-ci/src/test/java/org/kie/declarativetypes/JavaBeansEventRoleTest.java",
    "kie-ci/src/test/java/org/kie/scanner/KieModuleBuilderTest.java",
    "kie-ci/src/test/java/org/kie/scanner/KieModuleMavenTest.java",
    "kie-ci/src/test/java/org/kie/scanner/KieRepositoryScannerNexusTest.java",
    "kie-ci/src/test/java/org/kie/scanner/DependentScopeBean.java",
    "kie-ci/src/test/java/org/kie/scanner/management/KieScannerMBeanTest.java",
    "kie-ci/src/test/java/org/kie/scanner/embedder/MavenDeployTest.java",
    "kie-ci/src/test/java/org/kie/scanner/KieModuleMetaDataImplTest.java",
    "kie-ci/src/test/java/org/kie/scanner/KieRepositoryScannerTest.java",
    "kie-ci/src/test/java/org/kie/scanner/KieModuleMetaDataTest.java",
    "kie-ci/src/test/java/org/kie/scanner/DependentScopeNamedBeanTest.java",
    "kie-ci/src/test/java/org/kie/scanner/AbstractKieCiTest.java",
    "kie-ci/src/test/java/org/kie/scanner/KieScannerIncrementalCompilationTest.java",
    "kie-ci/src/test/java/org/kie/scanner/KieModuleIncrementalCompilationTest.java",
    "kie-ci/src/main/java/org/kie/api/builder/helper/FluentKieModuleDeploymentHelper.java",
    "kie-ci/src/main/java/org/kie/api/builder/helper/KieModuleDeploymentHelper.java",
    "kie-ci/src/main/java/org/kie/api/builder/helper/SingleKieModuleDeploymentHelper.java",
    "kie-ci/src/main/java/org/kie/api/builder/helper/KieModuleDeploymentHelperImpl.java",
    "kie-ci/src/main/java/org/kie/api/builder/helper/KieModuleDeploymentConfig.java",
    "kie-ci/src/main/java/org/kie/scanner/KieScannerFactoryServiceImpl.java",
    "kie-ci/src/main/java/org/kie/scanner/KieURLClassLoader.java",
    "kie-ci/src/main/java/org/kie/scanner/KieRepositoryScannerImpl.java",
    "kie-ci/src/main/java/org/kie/scanner/KieModuleMetaData.java",
    "kie-ci/src/main/java/org/kie/scanner/management/KieScannerMBean.java",
    "kie-ci/src/main/java/org/kie/scanner/management/MBeanUtils.java",
    "kie-ci/src/main/java/org/kie/scanner/management/KieScannerMBeanImpl.java",
    "kie-ci/src/main/java/org/kie/scanner/KieScannersRegistry.java",
    "kie-ci/src/main/java/org/kie/scanner/MavenClassLoaderResolver.java",
    "kie-ci/src/main/java/org/kie/scanner/KieModuleMetaDataImpl.java",
    "kie-ci/src/main/java/org/kie/scanner/KieMavenRepository.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/util/EvalHelperTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/util/DynamicTypeUtils.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/impl/RangeImplTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/FEELValuesConstantsTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/FEELNumberCoercionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/FEELDateTimeDurationTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/FEELConditionsAndLoopsTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/FEELRangesTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/FEELContextsTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/FEEL12ExtendedForLoopTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/FEELErrorMessagesTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/FEELStaticTypeTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/FEELFunctionDefinitionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/FEELFunctionsTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/FEELOperatorsTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/FEELValuesComparisonTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/KieFEELExtendedFunctionsTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/BaseFEELCompilerTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/FEELMathOperationsTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/RemoveFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/CountFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/CodeFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/StartsWithFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/NowFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/YearsAndMonthsFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/FunctionTestUtil.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/ListContainsFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/SubstringFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/MatchesFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/FlattenFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/interval/AfterFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/interval/FinishesFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/interval/FinishedByFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/interval/CoincidesFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/interval/IncludesFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/interval/DuringFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/interval/StartsFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/interval/StartedByFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/interval/OverlappedByFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/interval/OverlapsFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/interval/BeforeFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/StringFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/EndsWithFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/DateTimeFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/SublistFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/ReverseFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/StringLowerCaseFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/InsertBeforeFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/ContainsFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/SubstringAfterFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/AnyFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/StringUpperCaseFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/AllFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/SubstringBeforeFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/AppendFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/FloorFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/TodayFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/DurationFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/MaxFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/CeilingFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/StringLengthFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/SortFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/DateFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/NumberFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/DecimalFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/UnionFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/TimeFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/DistinctValuesFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/NotFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/ConcatenateFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/ReplaceFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/SumFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/ComposingDifferentFunctionsTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/twovaluelogic/CountFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/twovaluelogic/NNAnyFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/twovaluelogic/NNAllFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/twovaluelogic/ModeFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/twovaluelogic/MaxFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/twovaluelogic/MedianFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/twovaluelogic/StddevFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/twovaluelogic/SumFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/twovaluelogic/MinFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/twovaluelogic/MeanFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/MinFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/MeanFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/functions/IndexOfFunctionTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/BaseFEELTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/FEELEventListenerTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/FEELTernaryLogicTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/FEELExpressionsTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/FEELListsTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/FEEL12ExtendedFunctionsTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/runtime/FEELStringOperationsTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/parser/feel11/FEELParserTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/parser/feel11/FEELTestRig.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/parser/feel11/FEELTestRigExample.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/codegen/feel11/ManualQuantTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/codegen/feel11/ManualUnaryTestsTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/codegen/feel11/CodegenTestUtil.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/codegen/feel11/DirectCompilerTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/codegen/feel11/ManualFilterTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/codegen/feel11/ManualNamedFunctionInvocationTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/codegen/feel11/ManualBasicFunctionInvocationTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/codegen/feel11/ManualContextTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/codegen/feel11/DirectCompilerUnaryTestsTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/codegen/feel11/ManualForTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/lang/impl/JavaBackedTypeTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/lang/impl/MapBackedTypeTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/lang/examples/ExamplesBaseTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/lang/examples/ExamplesTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/lang/examples/CompileEvaluateTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/model/Address.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/model/Person.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/marshaller/FEELCodeMarshallerUnmarshallTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/marshaller/FEELStringMarshallerUnmarshallTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/marshaller/FEELCodeMarshallerTest.java",
    "kie-dmn/kie-dmn-feel/src/test/java/org/kie/dmn/feel/marshaller/FEELStringMarshallerTest.java",
    "kie-dmn/kie-dmn-feel/src/main/resources/TemplateCompiledFEELExpression.java",
    "kie-dmn/kie-dmn-feel/src/main/resources/TemplateCompiledFEELUnaryTests.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/util/EvalHelper.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/util/TokenTree.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/util/Pair.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/util/Msg.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/util/ClassLoaderUtil.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/util/Either.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/util/TypeUtil.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/FEELFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/impl/RangeImpl.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/decisiontables/DTOutputClause.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/decisiontables/DTDecisionRule.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/decisiontables/DecisionTable.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/decisiontables/SingleValueOrContextCollector.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/decisiontables/DecisionTableImpl.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/decisiontables/DTInputClause.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/decisiontables/Indexed.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/decisiontables/HitPolicy.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/UnaryTest.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/Range.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/MatchesFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/NotFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/ReplaceFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/StringFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/BaseFEELFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/AbstractCustomFEELFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/LogFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/ModuloFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/SplitFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/AllFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/FEELConversionFunctionNames.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/BuiltInFunctions.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/SqrtFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/DateFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/RemoveFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/OddFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/FlattenFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/DateAndTimeFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/UnionFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/StartsWithFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/AbsFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/interval/OverlappedByFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/interval/AfterFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/interval/BeforeFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/interval/CoincidesFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/interval/StartedByFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/interval/StartsFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/interval/FinishesFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/interval/DuringFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/interval/IncludesFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/interval/OverlapsFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/interval/FinishedByFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/CountFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/ExpFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/ProductFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/JavaFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/GetValueFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/MeanFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/GetEntriesFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/NumberFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/SumFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/TimeFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/SubstringFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/MinFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/CeilingFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/MaxFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/DecisionTableFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/DTInvokerFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/EndsWithFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/StringLowerCaseFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/AppendFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/AnyFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/SubstringBeforeFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/FloorFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/SublistFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/SortFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/ModeFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/EvenFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/DistinctValuesFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/CustomFEELFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/extended/DateFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/extended/KieExtendedDMNFunctions.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/extended/TimeFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/extended/CodeFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/extended/NowFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/extended/TodayFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/extended/InvokeFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/extended/DurationFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/FEELFnResult.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/ConcatenateFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/InsertBeforeFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/ParameterName.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/DecimalFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/ContainsFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/MedianFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/SubstringAfterFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/ReverseFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/ListContainsFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/twovaluelogic/NNAnyFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/twovaluelogic/TwoValueLogicFunctions.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/twovaluelogic/NNModeFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/twovaluelogic/NNMeanFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/twovaluelogic/NNCountFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/twovaluelogic/NNAllFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/twovaluelogic/NNMedianFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/twovaluelogic/NNStddevFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/twovaluelogic/NNMinFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/twovaluelogic/NNMaxFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/twovaluelogic/NNSumFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/StddevFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/StringLengthFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/IndexOfFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/YearsAndMonthsFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/DurationFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/functions/StringUpperCaseFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/UnaryTestImpl.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/events/ASTEventBase.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/events/FEELEventBase.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/events/SyntaxErrorEvent.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/events/DecisionTableRulesSelectedEvent.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/events/DecisionTableRulesMatchedEvent.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/events/HitPolicyViolationEvent.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/events/UnknownVariableErrorEvent.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/events/InvalidInputEvent.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/runtime/events/InvalidParametersEvent.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/parser/feel11/Keywords.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/parser/feel11/ParserHelper.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/parser/feel11/profiles/FEELv12Profile.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/parser/feel11/profiles/DoCompileFEELProfile.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/parser/feel11/profiles/KieExtendedFEELProfile.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/parser/feel11/ASTBuilderVisitor.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/parser/feel11/FEELParser.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/codegen/feel11/DefaultedVisitor.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/codegen/feel11/Functions.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/codegen/feel11/DirectCompilerVisitor.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/codegen/feel11/CompiledFEELSemanticMappings.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/codegen/feel11/CodegenStringUtil.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/codegen/feel11/ProcessedUnaryTest.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/codegen/feel11/CompiledFEELExpression.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/codegen/feel11/ProcessedExpression.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/codegen/feel11/FeelCtx.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/codegen/feel11/Contexts.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/codegen/feel11/DirectCompilerResult.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/codegen/feel11/ASTCompilerVisitor.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/codegen/feel11/FEELCompilationError.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/codegen/feel11/ASTUnaryTestTransform.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/codegen/feel11/CompilerBytecodeLoader.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/codegen/feel11/ProcessedFEELUnit.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/codegen/feel11/CompiledFEELUnaryTests.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/codegen/feel11/Expressions.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/codegen/feel11/CompiledCustomFEELFunction.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/codegen/feel11/CompiledFEELSupport.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/codegen/feel11/Constants.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/FEEL.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/impl/ExecutionFrame.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/impl/EvaluationContextImpl.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/impl/FEELImpl.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/impl/JavaBackedType.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/impl/FEELEventListenersManager.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/impl/InterpretedExecutableExpression.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/impl/CompiledExecutableExpression.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/impl/MapBackedType.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/impl/RootExecutionFrame.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/impl/UnaryTestCompiledExecutableExpression.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/impl/UnaryTestInterpretedExecutableExpression.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/impl/ExecutionFrameImpl.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/impl/CompilerContextImpl.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/impl/NamedParameter.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/impl/SilentWrappingEvaluationContextImpl.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/impl/CompiledExpressionImpl.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/types/impl/InterceptNotComparableComparator.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/types/impl/ComparablePeriod.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/types/BaseSymbol.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/types/AliasFEELType.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/types/SymbolTable.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/types/ScopeImpl.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/types/FunctionSymbol.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/types/VariableSymbol.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/types/BuiltInType.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/types/BuiltInTypeSymbol.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/EvaluationContext.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/Type.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/CompositeType.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/CompilerContext.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/Symbol.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/FunctionDefs.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/Scope.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/QualifiedNameNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/ForExpressionNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/FunctionDefNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/QuantifiedExpressionNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/NullNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/FilterExpressionNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/NumberNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/FunctionInvocationNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/PathExpressionNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/IterationContextNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/Visitor.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/ASTNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/FormalParameterNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/RangeNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/InNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/StringNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/UnaryTestNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/SignedUnaryNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/BetweenNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/InstanceOfNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/BaseNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/TypeNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/NameDefNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/IfExpressionNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/NameRefNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/ContextNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/ListNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/ContextEntryNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/DashNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/UnaryTestListNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/NamedParameterNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/ASTBuilderFactory.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/InfixOpNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/ast/BooleanNode.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/FEELProperty.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/FEELType.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/CompiledExpression.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/SimpleType.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/lang/FEELProfile.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/marshaller/FEELCodeMarshaller.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/marshaller/FEELStringMarshaller.java",
    "kie-dmn/kie-dmn-feel/src/main/java/org/kie/dmn/feel/marshaller/FEELMarshaller.java",
    "kie-dmn/kie-dmn-backend/src/test/java/org/kie/dmn/backend/marshalling/v1_1/UnmarshalMarshalTest.java",
    "kie-dmn/kie-dmn-backend/src/test/java/org/kie/dmn/backend/marshalling/v1_1/extensions/MyKieExt.java",
    "kie-dmn/kie-dmn-backend/src/test/java/org/kie/dmn/backend/marshalling/v1_1/extensions/MyDroolsExt.java",
    "kie-dmn/kie-dmn-backend/src/test/java/org/kie/dmn/backend/marshalling/v1_1/extensions/MyTestRegister.java",
    "kie-dmn/kie-dmn-backend/src/test/java/org/kie/dmn/backend/marshalling/v1_1/MarshallingUtilsTest.java",
    "kie-dmn/kie-dmn-backend/src/test/java/org/kie/dmn/backend/marshalling/v1_1/DMNXMLLoaderTest.java",
    "kie-dmn/kie-dmn-backend/src/test/java/org/kie/dmn/backend/marshalling/v1_2/UnmarshalMarshalTest.java",
    "kie-dmn/kie-dmn-backend/src/test/java/org/kie/dmn/backend/marshalling/v1_2/extensions/MyKieExt.java",
    "kie-dmn/kie-dmn-backend/src/test/java/org/kie/dmn/backend/marshalling/v1_2/extensions/MyDroolsExt.java",
    "kie-dmn/kie-dmn-backend/src/test/java/org/kie/dmn/backend/marshalling/v1_2/extensions/MyTestRegister.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1x/XStreamMarshaller.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1x/DMNMarshallerFactory.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/RelationConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/QNameConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/BindingConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/DMNBaseConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/DMNModelInstrumentedBaseConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/BusinessKnowledgeModelConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/ItemDefinitionConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/MarshallingUtils.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/ExpressionConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/DMNElementConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/InformationItemConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/PerformanceIndicatorConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/NamedElementConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/OrganizationUnitConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/DMNListConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/InvocationConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/DecisionRuleConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/DecisionConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/XStreamMarshaller.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/KnowledgeSourceConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/InputDataConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/DecisionServiceConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/extensions/DecisionServicesExtensionRegister.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/extensions/DecisionServicesConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/UnaryTestsConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/OutputClauseConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/ExtensionElementsConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/AssociationConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/InputClauseConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/LiteralExpressionConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/DMNElementReferenceConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/DRGElementConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/DecisionTableConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/ElementCollectionConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/TextAnnotationConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/InformationRequirementConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/ContextConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/ContextEntryConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/ImportedValuesConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/DefinitionsConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/BusinessContextElementConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/FunctionDefinitionConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/AuthorityRequirementConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/KnowledgeRequirementConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/ImportConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_1/xstream/ArtifactConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/CustomStaxWriter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/RelationConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/QNameConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/BindingConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DMNBaseConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/PointConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DMNModelInstrumentedBaseConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/BusinessKnowledgeModelConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/ItemDefinitionConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DMNShapeConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/MarshallingUtils.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DiagramElementConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/ShapeConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/ExpressionConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DMNElementConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/InformationItemConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/InvocableConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/PerformanceIndicatorConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/FormatUtils.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DMNDecisionServiceDividerLineConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/NamedElementConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/RuleAnnotationClauseConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/OrganizationUnitConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DMNListConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/InvocationConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DMNDiagramConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DecisionRuleConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DecisionConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DiagramConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/RuleAnnotationConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/BoundsConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/XStreamMarshaller.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/KnowledgeSourceConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/InputDataConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DecisionServiceConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/UnaryTestsConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/OutputClauseConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/ExtensionElementsConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/AssociationConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/InputClauseConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/LiteralExpressionConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DMNElementReferenceConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DRGElementConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DecisionTableConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/ElementCollectionConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DimensionConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DMNLabelConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/TextAnnotationConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/InformationRequirementConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/ContextConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/ContextEntryConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DMNStyleConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/ColorConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/StyleConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/ImportedValuesConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DiagramElementExtensionConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DefinitionsConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/EdgeConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DMNEdgeConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/BusinessContextElementConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/FunctionDefinitionConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/AuthorityRequirementConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/KnowledgeRequirementConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/ImportConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/ArtifactConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/v1_2/xstream/DMNDIConverter.java",
    "kie-dmn/kie-dmn-backend/src/main/java/org/kie/dmn/backend/marshalling/CustomStaxReader.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/DMNMessageContainer.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/DMNCompilerConfiguration.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/DMNMessage.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/DMNModel.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/DMNPackage.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/DMNContext.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/DMNUnaryTest.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/DMNMessageType.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/DMNType.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/DMNResult.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/DMNDecisionResult.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/ast/DecisionServiceNode.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/ast/DMNNode.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/ast/ItemDefNode.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/ast/BusinessKnowledgeModelNode.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/ast/InputDataNode.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/ast/DecisionNode.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/AfterGeneratingSourcesListener.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/DMNRuntime.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/DMNCompiler.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/event/AfterEvaluateDecisionTableEvent.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/event/AfterEvaluateDecisionEvent.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/event/DMNEvent.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/event/DMNRuntimeEventListener.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/event/BeforeEvaluateDecisionEvent.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/event/BeforeEvaluateBKMEvent.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/event/BeforeEvaluateContextEntryEvent.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/event/BeforeEvaluateDecisionServiceEvent.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/event/AfterEvaluateBKMEvent.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/event/BeforeEvaluateDecisionTableEvent.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/event/AfterEvaluateDecisionServiceEvent.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/event/AfterEvaluateContextEntryEvent.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/event/DMNRuntimeEventManager.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/GeneratedSource.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/marshalling/DMNMarshaller.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/marshalling/DMNExtensionRegister.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/marshalling/v1_1/DMNMarshaller.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/marshalling/v1_1/DMNExtensionRegister.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/feel/runtime/events/FEELEventListener.java",
    "kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/feel/runtime/events/FEELEvent.java",
    "kie-dmn/kie-dmn-core/src/test/resources/org/kie/dmn/core/incrementalcompilation/v1/Person.java",
    "kie-dmn/kie-dmn-core/src/test/resources/org/kie/dmn/core/incrementalcompilation/v2/Person.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/DMNDecisionTableRuntimeTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/incrementalcompilation/DMNIncrementalCompilationTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/incrementalcompilation/WBCompilationTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/VacationDaysTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/DMNCompilerTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/DMNDecisionTableWithSymbolsTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/util/DMNTestUtil.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/util/DMNRuntimeUtil.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/util/DynamicTypeUtils.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/DMNTwoValueLogicTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/WBCommonServicesBackendTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/OnlineDatingTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/fluent/GetAllDMNContextCommandTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/fluent/ExecuteDMNCommandTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/fluent/GetDMNModelCommandTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/fluent/GetDMNMessagesCommandTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/fluent/SetDMNActiveModelCommandTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/fluent/DMNRuntimeFluentTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/fluent/SetDMNInputCommandTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/fluent/GetDMNDecisionResultsCommandTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/fluent/NewDMNRuntimeCommandTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/imports/ImportsTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/classloader/DMNClassloaderTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/pmml/DMNRuntimeKiePMMLTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/pmml/DMNRuntimePMMLTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/pmml/PMMLInfoTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/BaseInterpretedVsCompiledTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/DMNAssemblerTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/DMNMessagesAPITest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/decisionservices/DMNDecisionServicesTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/DMNTypeTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/model/Person.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/DMNInputRuntimeTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/DMNRuntimeTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/v1_2/DMN12specificTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/v1_2/DMNDecisionServicesTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/DMNRuntimeTypeCheckTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/FlightRebookingTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/BaseInterpretedVsCompiledTestCanonicalKieModule.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/compiler/ImportDMNResolverUtilTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/compiler/ItemDefinitionDependenciesGeneratedTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/compiler/extensions/FirstNameDescriptionRegister.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/compiler/extensions/DMNExtensionRegisterTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/compiler/extensions/LastNameDescriptionRegister.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/compiler/extensions/FirstNameDescription.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/compiler/extensions/FirstNameLastNameProfile.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/compiler/extensions/LastNameDescription.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/compiler/profiles/Just47Function.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/compiler/profiles/ExtendedDMNProfileTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/compiler/profiles/DMNProfilesTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/compiler/profiles/Just47DMNProfile.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/compiler/ItemDefinitionDependenciesTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/DMNDecisionTableHitPolicyTest.java",
    "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/DMNUpdateTest.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/DMNContextFEELCtxWrapper.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/SimpleTypeImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/AfterEvaluateDecisionEventImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/DMNKnowledgeBuilderError.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/CompositeTypeImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/DMNDecisionResultImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/DMNPackageImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/AfterEvaluateDecisionTableEventImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/BeforeEvaluateDecisionEventImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/DMNModelImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/DMNRuntimeEventManagerImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/AfterEvaluateContextEntryEventImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/AfterEvaluateDecisionServiceEventImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/DMNResultImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/BaseDMNTypeImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/AfterEvaluateBKMEventImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/BeforeEvaluateDecisionTableEventImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/DMNContextImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/BeforeEvaluateDecisionServiceEventImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/BeforeEvaluateContextEntryEventImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/DMNRuntimeImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/BeforeEvaluateBKMEventImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/DMNMessageImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/impl/DMNRuntimeEventManagerUtils.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/assembler/DMNResourceDependenciesSorter.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/assembler/DMNAssemblerService.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/assembler/DMNResource.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/util/DefaultDMNMessagesManager.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/util/Msg.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/util/MsgUtil.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/util/KieHelper.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/fluent/GetDMNDecisionResultsCommand.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/fluent/GetAllDMNContextCommand.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/fluent/AbstractDMNResultCommand.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/fluent/GetDMNModelCommand.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/fluent/GetDMNMessagesCommand.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/fluent/ExecuteDMNCommand.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/fluent/NewDMNRuntimeCommand.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/fluent/SetDMNActiveModelCommand.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/fluent/AbstractDMNModelCommand.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/fluent/SetDMNInputCommand.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/fluent/DMNRuntimeFluentImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/runtime/DMNRuntimeService.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/internal/utils/MarshallingStubUtils.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/internal/utils/MapBackedDMNContext.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/internal/utils/DMNEvaluationUtils.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNKiePMMLInvocationEvaluator.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/PMMLInfo.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/PMMLModelInfo.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNImportPMMLInfo.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/AbstractPMMLInvocationEvaluator.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNPMMLModelInfo.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/weaver/DMNWeaverService.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/ast/DMNFunctionDefinitionEvaluator.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/ast/DMNBaseNode.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/ast/DMNFunctionWithReturnType.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/ast/DecisionServiceNodeImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/ast/DMNDecisionServiceEvaluator.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/ast/DMNRelationEvaluator.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/ast/DMNListEvaluator.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/ast/DMNContextEvaluator.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/ast/DecisionNodeImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/ast/DMNDecisionServiceFunctionDefinitionEvaluator.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/ast/ItemDefNodeImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/ast/BusinessKnowledgeModelNodeImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/ast/DMNInvocationEvaluator.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/ast/EvaluatorResultImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/ast/DMNDTExpressionEvaluator.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/ast/DMNLiteralExpressionEvaluator.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/ast/InputDataNodeImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/api/DMNMessageManager.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/api/DMNFactory.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/api/DMNExpressionEvaluator.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/api/EvaluatorResult.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/api/event/DefaultDMNRuntimeEventListener.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/DMNCompilerImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/ImportDMNResolverUtil.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/DMNOption.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/DMNCompilerConfigurationImpl.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/DMNCompilerContext.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/DMNTypeRegistryV12.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/DMNProfile.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/KnowledgeSourceCompiler.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/DecisionServiceCompiler.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/ItemDefinitionDependenciesSorter.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/ExecModelCompilerOption.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/DMNScope.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/DMNEvaluatorCompiler.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/DecisionCompiler.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/DRGElementCompiler.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/RuntimeTypeCheckOption.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/execmodelbased/ExecModelDMNMavenSourceCompiler.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/execmodelbased/ExecModelDTableModel.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/execmodelbased/ExecModelDMNClassLoaderCompiler.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/execmodelbased/AbstractModelEvaluator.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/execmodelbased/JavaParserSourceGenerator.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/execmodelbased/DMNRuleClassFile.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/execmodelbased/FeelExpressionSourceGenerator.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/execmodelbased/DTableModel.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/execmodelbased/ExecModelDMNEvaluatorCompiler.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/execmodelbased/DecisionTableEvaluator.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/execmodelbased/DMNUnit.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/execmodelbased/CompiledDTTest.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/execmodelbased/FeelValue.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/BusinessKnowledgeModelCompiler.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/DMNTypeRegistryV11.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/DMNTypeRegistry.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/profiles/ExtendedDMNProfile.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/DMNCompilerHelper.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/CoerceDecisionServiceSingletonOutputOption.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/DMNFEELHelper.java",
    "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/compiler/InputDataCompiler.java",
    "kie-dmn/kie-dmn-signavio/src/test/java/org/kie/dmn/signavio/util/DynamicTypeUtils.java",
    "kie-dmn/kie-dmn-signavio/src/test/java/org/kie/dmn/signavio/feel/runtime/ExtendedFunctionsBaseFEELTest.java",
    "kie-dmn/kie-dmn-signavio/src/test/java/org/kie/dmn/signavio/feel/runtime/FEELExtendedFunctionsTest.java",
    "kie-dmn/kie-dmn-signavio/src/test/java/org/kie/dmn/signavio/SignavioTest.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/MultiInstanceDecisionLogicRegister.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/MultiInstanceDecisionLogic.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/MonthAddFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/MidFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/DateTimeFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/TrimFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/MinutesDiffFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/YearDiffFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/SignavioEndsWithFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/RoundUpFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/SecondFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/HourDiffFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/ModuloFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/SecondsDiffFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/MinuteFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/AreElementsOfFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/IntegerFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/DayDiffFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/WeekdayFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/AbsFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/MonthDiffFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/AppendAllFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/IsSpacesFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/ProductFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/DayFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/RemoveAllFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/TextOccurrencesFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/RightFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/PowerFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/SignavioStartsWithFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/YearAddFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/NotContainsAnyFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/SignavioRemoveFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/MonthFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/ContainsOnlyFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/DayAddFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/IsAlphanumericFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/IsAlphaFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/TextFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/ModeFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/RoundFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/LowerFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/RoundDownFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/HourFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/LeftFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/YearFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/IsNumericFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/NowFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/SignavioNumberFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/MedianFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/LenFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/TodayFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/UpperFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/PercentFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/ZipFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/feel/runtime/functions/AvgFunction.java",
    "kie-dmn/kie-dmn-signavio/src/main/java/org/kie/dmn/signavio/KieDMNSignavioProfile.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TFunctionDefinition.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TNamedElement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TBusinessContextElement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TImport.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TDecisionTable.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TInputClause.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TKnowledgeRequirement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TDefinitions.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TInputData.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TUnaryTests.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TBusinessKnowledgeModel.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TKnowledgeSource.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TAuthorityRequirement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TRelation.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/KieDMNModelInstrumentedBase.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TContext.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/extensions/DecisionServices.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TDRGElement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TDMNElement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TInvocation.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TDMNElementReference.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TArtifact.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TOrganizationUnit.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TTextAnnotation.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TElementCollection.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TAssociation.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TImportedValues.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TInformationRequirement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TDecisionService.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TItemDefinition.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/NotADMNElementInV11.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TDecision.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TExpression.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TContextEntry.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TPerformanceIndicator.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TInformationItem.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TLiteralExpression.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TList.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TBinding.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TDecisionRule.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_1/TOutputClause.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/Artifact.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/ImportedValues.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/PerformanceIndicator.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/OutputClause.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/DecisionRule.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/FunctionKind.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/InputClause.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/BusinessKnowledgeModel.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/DRGElement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/DMNElement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/FunctionDefinition.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/TextAnnotation.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/Invocation.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/InputData.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/ElementCollection.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/InformationItem.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/ContextEntry.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/DecisionTable.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/Decision.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/Definitions.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/BusinessContextElement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/List.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/Context.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/DecisionService.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/RuleAnnotationClause.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/RowLocation.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/LiteralExpression.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/ItemDefinition.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/Expression.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/Invocable.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/DecisionTableOrientation.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/RuleAnnotation.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/BuiltinAggregator.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/Import.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/AuthorityRequirement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/KnowledgeSource.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/Association.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/DMNElementReference.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/DMNModelInstrumentedBase.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/Binding.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/dmndi/KnownColor.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/dmndi/DMNShape.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/dmndi/Point.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/dmndi/DMNDecisionServiceDividerLine.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/dmndi/DMNStyle.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/dmndi/DMNEdge.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/dmndi/Bounds.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/dmndi/DMNDI.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/dmndi/Style.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/dmndi/Dimension.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/dmndi/AlignmentKind.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/dmndi/Diagram.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/dmndi/Edge.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/dmndi/DMNLabel.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/dmndi/DiagramElement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/dmndi/Shape.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/dmndi/Color.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/dmndi/DMNDiagram.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/OrganizationUnit.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/NamedElement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/NamespaceConsts.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/KnowledgeRequirement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/AssociationDirection.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/InformationRequirement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/Relation.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/HitPolicy.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/api/UnaryTests.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TFunctionDefinition.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TInvocable.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TNamedElement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TBusinessContextElement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TImport.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TDecisionTable.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TInputClause.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TDecisionTableOrientation.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TRuleAnnotation.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TKnowledgeRequirement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TDefinitions.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TInputData.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TUnaryTests.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TBusinessKnowledgeModel.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TKnowledgeSource.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TAuthorityRequirement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TRelation.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/KieDMNModelInstrumentedBase.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TContext.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TDRGElement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TDMNElement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TInvocation.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TDMNElementReference.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TArtifact.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TOrganizationUnit.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TTextAnnotation.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TRuleAnnotationClause.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TElementCollection.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TAssociation.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TImportedValues.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TInformationRequirement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TDecisionService.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TItemDefinition.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TDecision.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TExpression.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/dmndi/DMNShape.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/dmndi/Point.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/dmndi/DMNDecisionServiceDividerLine.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/dmndi/DMNStyle.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/dmndi/DMNEdge.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/dmndi/Bounds.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/dmndi/DMNDI.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/dmndi/Style.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/dmndi/Dimension.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/dmndi/Diagram.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/dmndi/Edge.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/dmndi/DMNLabel.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/dmndi/DiagramElement.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/dmndi/Shape.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/dmndi/Color.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/dmndi/DMNDiagram.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TContextEntry.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TPerformanceIndicator.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TInformationItem.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TLiteralExpression.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TList.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TBinding.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TDecisionRule.java",
    "kie-dmn/kie-dmn-model/src/main/java/org/kie/dmn/model/v1_2/TOutputClause.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/ValidatorBusinessKnowledgeModelTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/ValidatorDMNElementReferenceTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/ValidatorAuthorityRequirementTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/ValidatorArtifactTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/ValidatorTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/ValidatorBusinessContextTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/ValidatorDecisionTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/ValidatorKnowledgeRequirementTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/AbstractDTAnalysisTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/IntervalTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/Check1stNFViolationTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/SRGapsOverlapsSubsumption2Test.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/ContractionRulesTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/AK0100domainOnTableTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/MultipleModelsTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/NotTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/OverlapHitPolicyTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/DTNestingTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/Gaps0100domainOnTableTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/PosDoubleNegHalfTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/utils/DTAnalysisMeta.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/Check2ndNFViolationTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/MisleadingRulesTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/NoGapsDomainOnTypeRefTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/HitPolicyFirstTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/MaskTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/BuiltinAndOtherValuesTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/GapsCube3Test.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/GapsAndOverlaps1domainOnTableTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/AgeKittenTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/AK0100v2domainOnTableTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/GapsAndOverlaps1Test.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/SomeProblemTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/GapsOverlapsBooleanTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/GapsXYTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/SubsumptionRulesTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/SomeProblemruleOutsideDomainTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/EnumerationWithNullTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/dtanalysis/PiTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/ValidatorDecisionTableTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/ValidatorKnowledgeSourceTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/AbstractValidatorTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/ValidatorContextTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/ValidatorTypeRefTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/ValidatorInformationRequirementTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/ValidatorInputDataTest.java",
    "kie-dmn/kie-dmn-validation/src/test/java/org/kie/dmn/validation/ValidatorImportTest.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/DMNValidatorImpl.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/MessageReporter.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/DMNValidatorFactory.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/DMNValidator.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/ValidatorUtil.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/dtanalysis/DMNDTAnalysisException.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/dtanalysis/model/DDTAOutputClause.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/dtanalysis/model/Subsumption.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/dtanalysis/model/MaskedRule.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/dtanalysis/model/DDTAInputClause.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/dtanalysis/model/DTAnalysis.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/dtanalysis/model/Interval.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/dtanalysis/model/BoundValueComparator.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/dtanalysis/model/DDTAInputEntry.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/dtanalysis/model/DDTATable.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/dtanalysis/model/Overlap.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/dtanalysis/model/MisleadingRule.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/dtanalysis/model/OverlapSorter.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/dtanalysis/model/DDTARule.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/dtanalysis/model/Bound.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/dtanalysis/model/Hyperrectangle.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/dtanalysis/model/Contraction.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/dtanalysis/model/Domain.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/dtanalysis/DMNDTAnalyserValueFromNodeVisitor.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/dtanalysis/DMNDTAnalysisMessage.java",
    "kie-dmn/kie-dmn-validation/src/main/java/org/kie/dmn/validation/dtanalysis/DMNDTAnalyser.java",
    "kie-dmn/kie-dmn-core-osgi/src/main/java/org/kie/dmn/core/osgi/Activator.java",
    "drools-scenario-simulation/drools-scenario-simulation-api/src/test/java/org/drools/scenariosimulation/api/utils/ScenarioSimulationSharedUtilsTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-api/src/test/java/org/drools/scenariosimulation/api/model/SimulationTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-api/src/test/java/org/drools/scenariosimulation/api/model/SimulationDescriptorTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-api/src/test/java/org/drools/scenariosimulation/api/model/FactIdentifierTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-api/src/test/java/org/drools/scenariosimulation/api/model/ScenarioTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-api/src/test/java/org/drools/scenariosimulation/api/model/FactMappingTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-api/src/test/java/org/drools/scenariosimulation/api/model/FactMappingValueTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-api/src/main/java/org/drools/scenariosimulation/api/utils/ScenarioSimulationSharedUtils.java",
    "drools-scenario-simulation/drools-scenario-simulation-api/src/main/java/org/drools/scenariosimulation/api/model/SimulationRunMetadata.java",
    "drools-scenario-simulation/drools-scenario-simulation-api/src/main/java/org/drools/scenariosimulation/api/model/Simulation.java",
    "drools-scenario-simulation/drools-scenario-simulation-api/src/main/java/org/drools/scenariosimulation/api/model/Scenario.java",
    "drools-scenario-simulation/drools-scenario-simulation-api/src/main/java/org/drools/scenariosimulation/api/model/ScenarioWithIndex.java",
    "drools-scenario-simulation/drools-scenario-simulation-api/src/main/java/org/drools/scenariosimulation/api/model/FactMapping.java",
    "drools-scenario-simulation/drools-scenario-simulation-api/src/main/java/org/drools/scenariosimulation/api/model/FactMappingType.java",
    "drools-scenario-simulation/drools-scenario-simulation-api/src/main/java/org/drools/scenariosimulation/api/model/ExpressionElement.java",
    "drools-scenario-simulation/drools-scenario-simulation-api/src/main/java/org/drools/scenariosimulation/api/model/FactIdentifier.java",
    "drools-scenario-simulation/drools-scenario-simulation-api/src/main/java/org/drools/scenariosimulation/api/model/SimulationDescriptor.java",
    "drools-scenario-simulation/drools-scenario-simulation-api/src/main/java/org/drools/scenariosimulation/api/model/FactMappingValue.java",
    "drools-scenario-simulation/drools-scenario-simulation-api/src/main/java/org/drools/scenariosimulation/api/model/ScenarioSimulationModel.java",
    "drools-scenario-simulation/drools-scenario-simulation-api/src/main/java/org/drools/scenariosimulation/api/model/ExpressionIdentifier.java",
    "drools-scenario-simulation/drools-scenario-simulation-api/src/main/java/org/drools/scenariosimulation/api/model/FactMappingValueStatus.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/TestUtils.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/util/ResourceHelperTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/util/ScenarioBeanUtilTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/util/ScenarioSimulationXMLPersistenceTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/util/DMNSimulationUtilsTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/runner/RuleScenarioRunnerHelperTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/runner/ScenarioJunitActivatorTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/runner/model/ResultWrapperTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/runner/AbstractScenarioRunnerTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/runner/DMNScenarioRunnerHelperTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/runner/SimulationRunMetadataBuilderTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/fluent/RuleStatefulScenarioExecutableBuilderTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/fluent/RuleScenarioExecutableBuilderTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/fluent/RuleStatelessScenarioExecutableBuilderTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/fluent/ConditionFilterTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/fluent/ValidateFactCommandTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/model/NotEmptyConstructor.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/model/ListMapClass.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/model/Dispute.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/model/Person.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/expression/ParameterizedBaseExpressionEvaluatorTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/expression/AbstractExpressionEvaluatorTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/expression/DMNFeelExpressionEvaluatorTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/expression/BaseExpressionEvaluatorTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/test/java/org/drools/scenariosimulation/backend/expression/BaseExpressionOperatorTest.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/util/ImpossibleToFindDMNException.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/util/InMemoryMigrationStrategy.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/util/ScenarioBeanUtil.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/util/ResourceHelper.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/util/ScenarioSimulationXMLPersistence.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/util/MigrationStrategy.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/util/DMNSimulationUtils.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/util/ScenarioBeanWrapper.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/runner/ScenarioException.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/runner/DMNScenarioRunner.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/runner/ScenarioAssumptionViolatedException.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/runner/RuleScenarioRunnerHelper.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/runner/IndexedScenarioException.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/runner/AbstractRunnerHelper.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/runner/ScenarioJunitActivator.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/runner/AbstractScenarioRunner.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/runner/RuleScenarioRunner.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/runner/model/SimulationWithFileName.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/runner/model/ScenarioGiven.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/runner/model/ScenarioExpect.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/runner/model/ResultWrapper.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/runner/model/ScenarioRunnerData.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/runner/model/ScenarioResult.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/runner/model/ScenarioResultMetadata.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/runner/SimulationRunMetadataBuilder.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/runner/DMNScenarioRunnerHelper.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/runner/ScenarioRunnerProvider.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/fluent/ValidateFactCommand.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/fluent/RuleStatelessScenarioExecutableBuilder.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/fluent/FactCheckerHandle.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/fluent/ConditionFilter.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/fluent/RuleStatefulScenarioExecutableBuilder.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/fluent/RuleScenarioExecutableBuilder.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/fluent/DMNScenarioExecutableBuilder.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/expression/ExpressionEvaluator.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/expression/BaseExpressionEvaluator.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/expression/BaseExpressionOperator.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/expression/DMNFeelExpressionEvaluator.java",
    "drools-scenario-simulation/drools-scenario-simulation-backend/src/main/java/org/drools/scenariosimulation/backend/expression/AbstractExpressionEvaluator.java",
    "drools-templates/src/test/java/org/drools/template/parser/DefaultTemplateRuleBaseTest.java",
    "drools-templates/src/test/java/org/drools/template/parser/RuleTemplateTest.java",
    "drools-templates/src/test/java/org/drools/template/parser/ExternalSheetListenerTest.java",
    "drools-templates/src/test/java/org/drools/template/parser/DefaultGeneratorTest.java",
    "drools-templates/src/test/java/org/drools/template/parser/ColumnFactoryTest.java",
    "drools-templates/src/test/java/org/drools/template/parser/DefaultTemplateContainerTest.java",
    "drools-templates/src/test/java/org/drools/template/jdbc/ResultSetGeneratorTest.java",
    "drools-templates/src/test/java/org/drools/template/jdbc/Cheese.java",
    "drools-templates/src/test/java/org/drools/template/jdbc/Person.java",
    "drools-templates/src/test/java/org/drools/template/model/FunctionsRenderTest.java",
    "drools-templates/src/test/java/org/drools/template/model/PackageRenderTest.java",
    "drools-templates/src/test/java/org/drools/template/model/SnippetBuilderTest.java",
    "drools-templates/src/test/java/org/drools/template/model/RuleRenderTest.java",
    "drools-templates/src/test/java/org/drools/template/model/QueriesRenderTest.java",
    "drools-templates/src/test/java/org/drools/template/DataProviderCompilerTest.java",
    "drools-templates/src/main/java/org/drools/template/DataProvider.java",
    "drools-templates/src/main/java/org/drools/template/DataProviderCompiler.java",
    "drools-templates/src/main/java/org/drools/template/ObjectDataCompiler.java",
    "drools-templates/src/main/java/org/drools/template/objects/ObjectDataProvider.java",
    "drools-templates/src/main/java/org/drools/template/objects/ArrayDataProvider.java",
    "drools-templates/src/main/java/org/drools/template/parser/BooleanCell.java",
    "drools-templates/src/main/java/org/drools/template/parser/ColumnFactory.java",
    "drools-templates/src/main/java/org/drools/template/parser/RuleTemplate.java",
    "drools-templates/src/main/java/org/drools/template/parser/ArrayColumn.java",
    "drools-templates/src/main/java/org/drools/template/parser/TemplateColumn.java",
    "drools-templates/src/main/java/org/drools/template/parser/DefaultTemplateContainer.java",
    "drools-templates/src/main/java/org/drools/template/parser/ArrayCell.java",
    "drools-templates/src/main/java/org/drools/template/parser/LongCell.java",
    "drools-templates/src/main/java/org/drools/template/parser/DefaultTemplateRuleBase.java",
    "drools-templates/src/main/java/org/drools/template/parser/LongColumn.java",
    "drools-templates/src/main/java/org/drools/template/parser/Row.java",
    "drools-templates/src/main/java/org/drools/template/parser/StringColumn.java",
    "drools-templates/src/main/java/org/drools/template/parser/Column.java",
    "drools-templates/src/main/java/org/drools/template/parser/StringCell.java",
    "drools-templates/src/main/java/org/drools/template/parser/BooleanColumn.java",
    "drools-templates/src/main/java/org/drools/template/parser/DefaultTemplateColumn.java",
    "drools-templates/src/main/java/org/drools/template/parser/TemplateRuleBase.java",
    "drools-templates/src/main/java/org/drools/template/parser/TemplateContainer.java",
    "drools-templates/src/main/java/org/drools/template/parser/DataListener.java",
    "drools-templates/src/main/java/org/drools/template/parser/DefaultGenerator.java",
    "drools-templates/src/main/java/org/drools/template/parser/AbstractColumn.java",
    "drools-templates/src/main/java/org/drools/template/parser/Cell.java",
    "drools-templates/src/main/java/org/drools/template/parser/DecisionTableParseException.java",
    "drools-templates/src/main/java/org/drools/template/parser/TemplateDataListener.java",
    "drools-templates/src/main/java/org/drools/template/parser/Generator.java",
    "drools-templates/src/main/java/org/drools/template/jdbc/ResultSetGenerator.java",
    "drools-templates/src/main/java/org/drools/template/model/SnippetBuilder.java",
    "drools-templates/src/main/java/org/drools/template/model/Functions.java",
    "drools-templates/src/main/java/org/drools/template/model/Global.java",
    "drools-templates/src/main/java/org/drools/template/model/Package.java",
    "drools-templates/src/main/java/org/drools/template/model/AttributedDRLElement.java",
    "drools-templates/src/main/java/org/drools/template/model/Consequence.java",
    "drools-templates/src/main/java/org/drools/template/model/Queries.java",
    "drools-templates/src/main/java/org/drools/template/model/Import.java",
    "drools-templates/src/main/java/org/drools/template/model/DRLOutput.java",
    "drools-templates/src/main/java/org/drools/template/model/Condition.java",
    "drools-templates/src/main/java/org/drools/template/model/DeclaredType.java",
    "drools-templates/src/main/java/org/drools/template/model/Rule.java",
    "drools-templates/src/main/java/org/drools/template/model/DRLElement.java",
    "drools-templates/src/main/java/org/drools/template/model/DRLJavaEmitter.java",
    "drools-scorecards/src/test/java/org/drools/scorecards/ScorecardsKModuleTest.java",
    "drools-scorecards/src/test/java/org/drools/scorecards/ScorecardParseErrorsTest.java",
    "drools-scorecards/src/test/java/org/drools/scorecards/PMMLDocumentTest.java",
    "drools-scorecards/src/test/java/org/drools/scorecards/ScoringStrategiesTest.java",
    "drools-scorecards/src/test/java/org/drools/scorecards/ScorecardProviderTest.java",
    "drools-scorecards/src/test/java/org/drools/scorecards/example/Applicant.java",
    "drools-scorecards/src/test/java/org/drools/scorecards/example/Customer.java",
    "drools-scorecards/src/test/java/org/drools/scorecards/ScorecardProviderPMMLTest.java",
    "drools-scorecards/src/test/java/org/drools/scorecards/ScorecardReasonCodeTest.java",
    "drools-scorecards/src/test/java/org/drools/scorecards/DrlFromPMMLTest.java",
    "drools-scorecards/src/test/java/org/drools/scorecards/ExternalObjectModelTest.java",
    "drools-scorecards/src/test/java/org/drools/scorecards/TestUtil.java",
    "drools-scorecards/src/main/java/org/drools/scorecards/ScoreCardProviderImpl.java",
    "drools-scorecards/src/main/java/org/drools/scorecards/ScorecardFormat.java",
    "drools-scorecards/src/main/java/org/drools/scorecards/StringUtil.java",
    "drools-scorecards/src/main/java/org/drools/scorecards/parser/xls/MergedCellRange.java",
    "drools-scorecards/src/main/java/org/drools/scorecards/parser/xls/XLSKeywords.java",
    "drools-scorecards/src/main/java/org/drools/scorecards/parser/xls/XLSEventDataCollector.java",
    "drools-scorecards/src/main/java/org/drools/scorecards/parser/xls/ExcelScorecardValidator.java",
    "drools-scorecards/src/main/java/org/drools/scorecards/parser/xls/XLSScorecardParser.java",
    "drools-scorecards/src/main/java/org/drools/scorecards/parser/ScorecardParseException.java",
    "drools-scorecards/src/main/java/org/drools/scorecards/parser/AbstractScorecardParser.java",
    "drools-scorecards/src/main/java/org/drools/scorecards/ScorecardError.java",
    "drools-scorecards/src/main/java/org/drools/scorecards/pmml/ScorecardPMMLUtils.java",
    "drools-scorecards/src/main/java/org/drools/scorecards/pmml/ScorecardPMMLGenerator.java",
    "drools-scorecards/src/main/java/org/drools/scorecards/pmml/ScorecardPMMLExtensionNames.java",
    "drools-scorecards/src/main/java/org/drools/scorecards/pmml/PMMLOperators.java",
    "drools-scorecards/src/main/java/org/drools/scorecards/ScorecardCompiler.java",
    "drools-examples-cdi/cdi-example/src/test/java/org/drools/example/cdi/cdiexample/CDIExampleTest.java",
    "drools-examples-cdi/cdi-example/src/test/java/org/drools/example/cdi/cdiexample/CDIInstanceExampleTest.java",
    "drools-examples-cdi/cdi-example/src/main/java/org/drools/example/cdi/cdiexample/Message.java",
    "drools-examples-cdi/cdi-example/src/main/java/org/drools/example/cdi/cdiexample/CDIExample.java",
    "drools-examples-cdi/cdi-example/src/main/java/org/drools/example/cdi/cdiexample/CDIInstanceExample.java",
    "drools-examples-cdi/cdi-example-with-inclusion/src/test/java/org/drools/example/cdi/cdiexamplewithinclusion/CDIExampleWithInclusionTest.java",
    "drools-examples-cdi/cdi-example-with-inclusion/src/main/java/org/drools/example/cdi/cdiexamplewithinclusion/CDIExampleWithInclusion.java",
    "drools-examples-cdi/cdi-example-scopes/src/test/java/org/drools/example/cdi/scopes/RequestScopedRulesJUnitTest.java",
    "drools-examples-cdi/cdi-example-scopes/src/test/java/org/drools/example/cdi/scopes/MyRequestScopedBean.java",
    "drools-examples-cdi/cdi-example-scopes/src/test/java/org/drools/example/cdi/scopes/SimpleConversationScopedRulesJUnitTest.java",
    "drools-examples-cdi/cdi-example-scopes/src/test/java/org/drools/example/cdi/scopes/MyApplicationScopedBean.java",
    "drools-examples-cdi/cdi-example-scopes/src/test/java/org/drools/example/cdi/scopes/SessionScopedRulesJUnitTest.java",
    "drools-examples-cdi/cdi-example-scopes/src/test/java/org/drools/example/cdi/scopes/MyBean.java",
    "drools-examples-cdi/cdi-example-scopes/src/test/java/org/drools/example/cdi/scopes/MySessionScopedBean.java",
    "drools-examples-cdi/cdi-example-scopes/src/test/java/org/drools/example/cdi/scopes/ApplicationScopedRulesJUnitTest.java",
    "drools-examples-cdi/cdi-example-scopes/src/test/java/org/drools/example/cdi/scopes/MySimpleConversationScopedBean.java",
    "drools-examples-cdi/cdi-example-scopes/src/test/java/org/drools/example/cdi/scopes/MyConversationScopedBean.java",
    "drools-examples-cdi/cdi-example-scopes/src/test/java/org/drools/example/cdi/scopes/ConversationScopedRulesJUnitTest.java",
    "drools-examples-cdi/cdi-example-scopes/src/main/java/org/drools/example/cdi/scopes/KieBusinessScopeExtension.java",
    "drools-examples-cdi/cdi-example-scopes/src/main/java/org/drools/example/cdi/scopes/KieBusinessScopedRules.java",
    "drools-examples-cdi/cdi-example-scopes/src/main/java/org/drools/example/cdi/scopes/KieBusinessScopeContext.java",
    "drools-examples-cdi/cdi-example-scopes/src/main/java/org/drools/example/cdi/scopes/KieBusinessScoped.java",
    "drools-examples-api/default-kiesession-from-file/src/test/java/org/drools/example/api/defaultkiesessionfromfile/DefaultKieSessionFromByteArrayExampleTest.java",
    "drools-examples-api/default-kiesession-from-file/src/test/java/org/drools/example/api/defaultkiesessionfromfile/DefaultKieSessionFromFileExampleTest.java",
    "drools-examples-api/default-kiesession-from-file/src/main/java/org/drools/example/api/defaultkiesessionfromfile/DefaultKieSessionFromFileExample.java",
    "drools-examples-api/named-kiesession/src/test/java/org/drools/example/api/namedkiesession/NamedKieSessionExampleTest.java",
    "drools-examples-api/named-kiesession/src/main/java/org/drools/example/api/namedkiesession/Message.java",
    "drools-examples-api/named-kiesession/src/main/java/org/drools/example/api/namedkiesession/NamedKieSessionExample.java",
    "drools-examples-api/multiple-kbases/src/test/java/org/drools/example/api/multiplekbases/MultipleKbasesExampleTest.java",
    "drools-examples-api/ruleunit/src/test/java/org/drools/example/api/reactivekiesession/RuleUnitExampleTest.java",
    "drools-examples-api/ruleunit/src/main/java/org/drools/example/api/ruleunit/PersonRuleUnit.java",
    "drools-examples-api/ruleunit/src/main/java/org/drools/example/api/ruleunit/RuleUnitExample.java",
    "drools-examples-api/ruleunit/src/main/java/org/drools/example/api/ruleunit/Person.java",
    "drools-examples-api/default-kiesession/src/test/java/org/drools/example/api/defaultkiesession/DefaultKieSessionExampleTest.java",
    "drools-examples-api/default-kiesession/src/test/java/org/drools/example/api/defaultkiesession/DefaultKieSessionFromFSExampleTest.java",
    "drools-examples-api/default-kiesession/src/main/java/org/drools/example/api/defaultkiesession/Message.java",
    "drools-examples-api/default-kiesession/src/main/java/org/drools/example/api/defaultkiesession/DefaultKieSessionExample.java",
    "drools-examples-api/kiebase-inclusion/src/test/java/org/drools/example/api/kiebaseinclusion/KieBaseInclusionExampleTest.java",
    "drools-examples-api/kiebase-inclusion/src/main/java/org/drools/example/api/kiebaseinclusion/KieBaseInclusionExample.java",
    "drools-examples-api/kie-module-from-multiple-files/src/test/java/org/drools/example/api/kiemodulefrommultiplefiles/KieModuleFromMultipleFilesExampleTest.java",
    "drools-examples-api/kie-module-from-multiple-files/src/main/java/org/drools/example/api/kiemodulefrommultiplefiles/KieModuleFromMultipleFilesExample.java",
    "drools-examples-api/reactive-kiesession/src/test/java/org/drools/example/api/reactivekiesession/ReactiveKieSessionExampleTest.java",
    "drools-examples-api/reactive-kiesession/src/main/java/org/drools/example/api/reactivekiesession/ReactiveKieSessionExample.java",
    "drools-examples-api/kiemodulemodel-example/src/test/java/org/drools/example/api/kiemodulemodel/KieModuleModelExampleTest.java",
    "drools-examples-api/kiemodulemodel-example/src/main/java/org/drools/example/api/kiemodulemodel/KieModuleModelExample.java",
    "drools-examples-api/kiefilesystem-example/src/test/java/org/drools/example/api/kiefilesystem/KieFileSystemExampleTest.java",
    "drools-examples-api/kiefilesystem-example/src/main/java/org/drools/example/api/kiefilesystem/Message.java",
    "drools-examples-api/kiefilesystem-example/src/main/java/org/drools/example/api/kiefilesystem/KieFileSystemExample.java",
    "drools-examples-api/kiecontainer-from-kierepo/src/test/java/org/drools/example/api/kiecontainerfromkierepo/KieContainerFromKieRepoExampleTest.java",
    "drools-examples-api/kiecontainer-from-kierepo/src/main/java/org/drools/example/api/kiecontainerfromkierepo/KieContainerFromKieRepoExample.java",
    "drools-examples-api/named-kiesession-from-file/src/test/java/org/drools/example/api/namedkiesessionfromfile/NamedKieSessionFromFileExampleTest.java",
    "drools-examples-api/named-kiesession-from-file/src/main/java/org/drools/example/api/namedkiesessionfromfile/NamedKieSessionFromFileExample.java",
    "kie-ci-osgi/src/main/java/org/kie/scanner/Activator.java",
    "drools-persistence/drools-persistence-api/src/main/java/org/drools/persistence/processinstance/InternalWorkItemManager.java",
    "drools-persistence/drools-persistence-api/src/main/java/org/drools/persistence/jta/JtaTransactionManagerFactory.java",
    "drools-persistence/drools-persistence-api/src/main/java/org/drools/persistence/jta/TransactionLockInterceptor.java",
    "drools-persistence/drools-persistence-api/src/main/java/org/drools/persistence/jta/JtaTransactionSynchronizationAdapter.java",
    "drools-persistence/drools-persistence-api/src/main/java/org/drools/persistence/jta/JtaTransactionManager.java",
    "drools-persistence/drools-persistence-api/src/main/java/org/drools/persistence/api/TransactionManager.java",
    "drools-persistence/drools-persistence-api/src/main/java/org/drools/persistence/api/PersistentSession.java",
    "drools-persistence/drools-persistence-api/src/main/java/org/drools/persistence/api/TransactionSynchronization.java",
    "drools-persistence/drools-persistence-api/src/main/java/org/drools/persistence/api/PersistenceContext.java",
    "drools-persistence/drools-persistence-api/src/main/java/org/drools/persistence/api/PersistenceContextManager.java",
    "drools-persistence/drools-persistence-api/src/main/java/org/drools/persistence/api/Transformable.java",
    "drools-persistence/drools-persistence-api/src/main/java/org/drools/persistence/api/TransactionManagerFactory.java",
    "drools-persistence/drools-persistence-api/src/main/java/org/drools/persistence/api/SessionNotFoundException.java",
    "drools-persistence/drools-persistence-api/src/main/java/org/drools/persistence/api/TransactionSynchronizationContainer.java",
    "drools-persistence/drools-persistence-api/src/main/java/org/drools/persistence/api/PersistentWorkItem.java",
    "drools-persistence/drools-persistence-api/src/main/java/org/drools/persistence/api/SessionMarshallingHelper.java",
    "drools-persistence/drools-persistence-api/src/main/java/org/drools/persistence/api/TransactionManagerHelper.java",
    "drools-persistence/drools-persistence-api/src/main/java/org/drools/persistence/api/OrderedTransactionSynchronization.java",
    "drools-persistence/drools-persistence-api/src/main/java/org/drools/persistence/api/TransactionSynchronizationRegistryHelper.java",
    "drools-persistence/drools-persistence-api/src/main/java/org/drools/persistence/api/TransactionAware.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/jta/TransactionTestObject.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/jta/JtaTransactionManagerTest.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/jta/JtaTransactionManagerFactoryTest.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/jta/TransactionTestCommand.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/util/DroolsPersistenceUtil.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/timer/integrationtests/TimerAndCalendarTest.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/TransactionManagerFactoryTest.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/map/impl/MapBasedPersistenceTest.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/map/impl/MapPersistenceTest.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/map/impl/JpaBasedPersistenceTest.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/map/impl/Buddy.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/command/SimpleBatchExecutionPersistenceTest.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/command/MoreBatchExecutionPersistenceTest.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/monitoring/MonitoringWithJPAKnowledgeServiceTest.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/kie/persistence/cdi/CDITest.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/kie/persistence/session/PersistentSessionForallTest.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/kie/persistence/session/JpaPersistentStatefulSessionTest.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/session/ReloadSessionTest.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/session/JpaPersistenceTraitTest.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/session/AgendaRuleFlowGroupsTest.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/session/JpaOptLockPersistentStatefulSessionTest.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/session/RuleFlowGroupRollbackTest.java",
    "drools-persistence/drools-persistence-jpa/src/test/java/org/drools/persistence/session/JpaPersistentStatefulSessionTest.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/TriggerUpdateTransactionSynchronization.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/osgi/Activator.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/jpa/KnowledgeStoreServiceImpl.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/jpa/processinstance/JPAWorkItemManagerFactory.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/jpa/processinstance/JPAWorkItemManager.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/jpa/AbstractPersistenceContextManager.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/jpa/JpaTimeJobFactoryManager.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/jpa/JDKCallableJobCommand.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/jpa/OptimisticLockRetryInterceptor.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/jpa/JpaPersistenceContext.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/jpa/JpaJDKTimerService.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/jpa/marshaller/VariableEntity.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/jpa/marshaller/MappedVariable.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/jpa/marshaller/EntityPersister.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/jpa/marshaller/JPAPlaceholderResolverStrategy.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/jpa/JpaTimerJobInstance.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/jpa/JpaPersistenceContextManager.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/info/WorkItemInfo.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/info/SessionInfo.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/map/MapBasedPersistenceContext.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/map/KnowledgeSessionStorage.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/map/ManualTransactionManager.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/map/EnvironmentBuilder.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/map/NonTransactionalPersistentSession.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/map/MapPersistenceContextManager.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/map/KnowledgeSessionStorageEnvironmentBuilder.java",
    "drools-persistence/drools-persistence-jpa/src/main/java/org/drools/persistence/PersistableRunner.java"
  ],
  "file": "drools-compiler/src/main/java/org/drools/compiler/rule/builder/PatternBuilder.java",
  "methods": [
    {
      "longName": "PatternBuilder::build(RuleBuildContext context, PatternDescr descr)",
      "startLine": 150,
      "methodName": "build",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "public"
    },
    {
      "longName": "PatternBuilder::build(RuleBuildContext context, PatternDescr patternDescr, Pattern prefixPattern)",
      "startLine": 166,
      "methodName": "build",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "public"
    },
    {
      "longName": "PatternBuilder::lookupObjectType(RuleBuildContext context, PatternDescr patternDescr)",
      "startLine": 201,
      "methodName": "lookupObjectType",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::findObjectType(RuleBuildContext context, XpathPart firstXpathChunk, String identifier)",
      "startLine": 246,
      "methodName": "findObjectType",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::buildPattern(RuleBuildContext context, PatternDescr patternDescr, ObjectType objectType)",
      "startLine": 257,
      "methodName": "buildPattern",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::processClassObjectType(RuleBuildContext context, ObjectType objectType, Pattern pattern)",
      "startLine": 301,
      "methodName": "processClassObjectType",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::getObjectType(RuleBuildContext context, PatternDescr patternDescr)",
      "startLine": 316,
      "methodName": "getObjectType",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::getObjectType(RuleBuildContext context, PatternDescr patternDescr, String objectType)",
      "startLine": 320,
      "methodName": "getObjectType",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::isEvent(RuleBuildContext context, Class<?> userProvidedClass)",
      "startLine": 340,
      "methodName": "isEvent",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::getTypeDeclaration(RuleBuildContext context, Class<?> userProvidedClass)",
      "startLine": 350,
      "methodName": "getTypeDeclaration",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::processSource(RuleBuildContext context, PatternDescr patternDescr, Pattern pattern)",
      "startLine": 366,
      "methodName": "processSource",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::processBehaviors(RuleBuildContext context, PatternDescr patternDescr, Pattern pattern)",
      "startLine": 374,
      "methodName": "processBehaviors",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::createWindow(BehaviorDescr behaviorDescr)",
      "startLine": 394,
      "methodName": "createWindow",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::buildQuery(RuleBuildContext context, PatternDescr descr, PatternDescr patternDescr)",
      "startLine": 404,
      "methodName": "buildQuery",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::buildQueryElement(RuleBuildContext context, BaseDescr descr, QueryImpl rule)",
      "startLine": 450,
      "methodName": "buildQueryElement",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::processDuplicateBindings(boolean isUnification, PatternDescr patternDescr, Pattern pattern, BaseDescr original, String leftExpression, String rightIdentifier, RuleBuildContext context)",
      "startLine": 457,
      "methodName": "processDuplicateBindings",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::processAnnotations(RuleBuildContext context, PatternDescr patternDescr, Pattern pattern)",
      "startLine": 479,
      "methodName": "processAnnotations",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::processMetadataAnnotations(PatternDescr patternDescr, Pattern pattern, TypeResolver typeResolver)",
      "startLine": 486,
      "methodName": "processMetadataAnnotations",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::buildAnnotationDef(AnnotationDescr annotationDescr, TypeResolver resolver)",
      "startLine": 496,
      "methodName": "buildAnnotationDef",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::processListenedPropertiesAnnotation(RuleBuildContext context, PatternDescr patternDescr, Pattern pattern)",
      "startLine": 515,
      "methodName": "processListenedPropertiesAnnotation",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::getSettableProperties(RuleBuildContext context, PatternDescr patternDescr, Pattern pattern)",
      "startLine": 566,
      "methodName": "getSettableProperties",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::processConstraintsAndBinds(RuleBuildContext context, PatternDescr patternDescr, Pattern pattern)",
      "startLine": 584,
      "methodName": "processConstraintsAndBinds",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::combineConstraints(RuleBuildContext context, Pattern pattern, MVELDumper.MVELDumperContext mvelCtx)",
      "startLine": 635,
      "methodName": "combineConstraints",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::processPositional(RuleBuildContext context, PatternDescr patternDescr, Pattern pattern, ExprConstraintDescr descr)",
      "startLine": 687,
      "methodName": "processPositional",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::build(RuleBuildContext context, PatternDescr patternDescr, Pattern pattern, BaseDescr original, String expr)",
      "startLine": 732,
      "methodName": "build",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::build(RuleBuildContext context, PatternDescr patternDescr, Pattern pattern, ConstraintConnectiveDescr descr, MVELDumper.MVELDumperContext mvelCtx)",
      "startLine": 749,
      "methodName": "build",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::getDeclarationCorrespondingToXpath(Pattern pattern, boolean isXPath, Constraint constraint)",
      "startLine": 808,
      "methodName": "getDeclarationCorrespondingToXpath",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::isXPathDescr(BaseDescr descr)",
      "startLine": 822,
      "methodName": "isXPathDescr",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::buildXPathDescr(RuleBuildContext context, PatternDescr patternDescr, Pattern pattern, BaseDescr descr, MVELDumper.MVELDumperContext mvelCtx)",
      "startLine": 828,
      "methodName": "buildXPathDescr",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::buildCcdDescr(RuleBuildContext context, PatternDescr patternDescr, Pattern pattern, BaseDescr d, ConstraintConnectiveDescr ccd, MVELDumper.MVELDumperContext mvelCtx)",
      "startLine": 915,
      "methodName": "buildCcdDescr",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::buildExpression(RuleBuildContext context, Pattern pattern, BaseDescr d, String expr, Map<String, OperatorDescr> aliases)",
      "startLine": 943,
      "methodName": "buildExpression",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::rewriteOrExpressions(RuleBuildContext context, Pattern pattern, BaseDescr d, String expr)",
      "startLine": 971,
      "methodName": "rewriteOrExpressions",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::rewriteCompositeExpressions(RuleBuildContext context, Pattern pattern, ConstraintConnectiveDescr d)",
      "startLine": 981,
      "methodName": "rewriteCompositeExpressions",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::normalizeExpression(RuleBuildContext context, Pattern pattern, RelationalExprDescr subDescr, String subExpr)",
      "startLine": 1018,
      "methodName": "normalizeExpression",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::getValueType(RuleBuildContext context, Pattern pattern, String leftValue)",
      "startLine": 1045,
      "methodName": "getValueType",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::buildRelationalExpression(RuleBuildContext context, Pattern pattern, RelationalExprDescr relDescr, String expr, Map<String, OperatorDescr> aliases)",
      "startLine": 1060,
      "methodName": "buildRelationalExpression",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::getExprBindings(RuleBuildContext context, Pattern pattern, String value)",
      "startLine": 1081,
      "methodName": "getExprBindings",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::findExpressionValues(RelationalExprDescr relDescr, String[] values)",
      "startLine": 1090,
      "methodName": "findExpressionValues",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::findLeftExpressionValue(RelationalExprDescr relDescr)",
      "startLine": 1098,
      "methodName": "findLeftExpressionValue",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::findRightExpressionValue(RelationalExprDescr relDescr)",
      "startLine": 1104,
      "methodName": "findRightExpressionValue",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::buildConstraintForPattern(RuleBuildContext context, Pattern pattern, RelationalExprDescr relDescr, String expr, String value1, String value2, boolean isConstant, Map<String, OperatorDescr> aliases)",
      "startLine": 1110,
      "methodName": "buildConstraintForPattern",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::getDeclarationsForReturnValue(RuleBuildContext context, RelationalExprDescr relDescr, String operator, String value2)",
      "startLine": 1201,
      "methodName": "getDeclarationsForReturnValue",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::buildLiteralRestrictionDescr(RuleBuildContext context, RelationalExprDescr exprDescr, String rightValue, String operator, boolean isRightLiteral)",
      "startLine": 1258,
      "methodName": "buildLiteralRestrictionDescr",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::processAtomicExpression(RuleBuildContext context, Pattern pattern, BaseDescr d, String expr, Map<String, OperatorDescr> aliases)",
      "startLine": 1289,
      "methodName": "processAtomicExpression",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::isSimpleExpr(RelationalExprDescr relDescr)",
      "startLine": 1307,
      "methodName": "isSimpleExpr",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::createAndBuildPredicate(RuleBuildContext context, Pattern pattern, BaseDescr base, String expr, Map<String, OperatorDescr> aliases)",
      "startLine": 1318,
      "methodName": "createAndBuildPredicate",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::setInputs(RuleBuildContext context, ExprBindings descrBranch, Class<?> thisClass, String expr)",
      "startLine": 1337,
      "methodName": "setInputs",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder$ExprBindings::getGlobalBindings()",
      "startLine": 1394,
      "methodName": "getGlobalBindings",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "public"
    },
    {
      "longName": "PatternBuilder$ExprBindings::getRuleBindings()",
      "startLine": 1398,
      "methodName": "getRuleBindings",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "public"
    },
    {
      "longName": "PatternBuilder$ExprBindings::getFieldAccessors()",
      "startLine": 1402,
      "methodName": "getFieldAccessors",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "public"
    },
    {
      "longName": "PatternBuilder$ExprBindings::isConstant()",
      "startLine": 1406,
      "methodName": "isConstant",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "public"
    },
    {
      "longName": "PatternBuilder::buildRuleBindings(RuleBuildContext context, PatternDescr patternDescr, Pattern pattern, BindingDescr fieldBindingDescr)",
      "startLine": 1411,
      "methodName": "buildRuleBindings",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::buildRuleBindings(RuleBuildContext context, PatternDescr patternDescr, Pattern pattern, BindingDescr fieldBindingDescr, TypeDeclaration typeDeclaration)",
      "startLine": 1418,
      "methodName": "buildRuleBindings",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::addFieldToPatternWatchlist(Pattern pattern, TypeDeclaration typeDeclaration, String fieldName)",
      "startLine": 1461,
      "methodName": "addFieldToPatternWatchlist",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::getTypeDeclaration(Pattern pattern, RuleBuildContext context)",
      "startLine": 1472,
      "methodName": "getTypeDeclaration",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::buildEval(RuleBuildContext context, Pattern pattern, PredicateDescr predicateDescr, Map<String, OperatorDescr> aliases, String expr, boolean isEvalExpression)",
      "startLine": 1476,
      "methodName": "buildEval",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::getOperators(Map<String, EvaluatorWrapper> operatorMap)",
      "startLine": 1546,
      "methodName": "getOperators",
      "isStatic": true,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::getUsedDeclarations(RuleBuildContext context, Pattern pattern, AnalysisResult analysis)",
      "startLine": 1557,
      "methodName": "getUsedDeclarations",
      "isStatic": true,
      "isAbstract": false,
      "visibility": "public"
    },
    {
      "longName": "PatternBuilder::buildAnalysis(RuleBuildContext context, Pattern pattern, PredicateDescr predicateDescr, Map<String, OperatorDescr> aliases)",
      "startLine": 1583,
      "methodName": "buildAnalysis",
      "isStatic": true,
      "isAbstract": false,
      "visibility": "public"
    },
    {
      "longName": "PatternBuilder::buildOperators(RuleBuildContext context, Pattern pattern, BaseDescr predicateDescr, Map<String, OperatorDescr> aliases)",
      "startLine": 1595,
      "methodName": "buildOperators",
      "isStatic": true,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::createDeclarationForOperator(RuleBuildContext context, Pattern pattern, String expr)",
      "startLine": 1631,
      "methodName": "createDeclarationForOperator",
      "isStatic": true,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::getConstraintBuilder(RuleBuildContext context)",
      "startLine": 1663,
      "methodName": "getConstraintBuilder",
      "isStatic": true,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::createImplicitBindings(RuleBuildContext context, Pattern pattern, Set<String> unboundIdentifiers, BoundIdentifiers boundIdentifiers, List<Declaration> factDeclarations)",
      "startLine": 1667,
      "methodName": "createImplicitBindings",
      "isStatic": true,
      "isAbstract": false,
      "visibility": "public"
    },
    {
      "longName": "PatternBuilder::createDeclarationObject(RuleBuildContext context, String identifier, Pattern pattern)",
      "startLine": 1694,
      "methodName": "createDeclarationObject",
      "isStatic": true,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::createDeclarationObject(RuleBuildContext context, String identifier, String expr, Pattern pattern)",
      "startLine": 1700,
      "methodName": "createDeclarationObject",
      "isStatic": true,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::getFieldValue(RuleBuildContext context, ValueType vtype, String value)",
      "startLine": 1727,
      "methodName": "getFieldValue",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::registerReadAccessor(RuleBuildContext context, ObjectType objectType, String fieldName, AcceptsReadAccessor target)",
      "startLine": 1753,
      "methodName": "registerReadAccessor",
      "isStatic": true,
      "isAbstract": false,
      "visibility": "public"
    },
    {
      "longName": "PatternBuilder::getFieldReadAccessor(RuleBuildContext context, BaseDescr descr, Pattern pattern, String fieldName, AcceptsReadAccessor target, boolean reportError)",
      "startLine": 1762,
      "methodName": "getFieldReadAccessor",
      "isStatic": true,
      "isAbstract": false,
      "visibility": "public"
    },
    {
      "longName": "PatternBuilder::getFieldReadAccessor(RuleBuildContext context, BaseDescr descr, Pattern pattern, ObjectType objectType, String fieldName, AcceptsReadAccessor target, boolean reportError)",
      "startLine": 1771,
      "methodName": "getFieldReadAccessor",
      "isStatic": true,
      "isAbstract": false,
      "visibility": "public"
    },
    {
      "longName": "PatternBuilder::parseExpression(RuleBuildContext context, PatternDescr patternDescr, BaseDescr original, String expression)",
      "startLine": 1894,
      "methodName": "parseExpression",
      "isStatic": false,
      "isAbstract": false,
      "visibility": "protected"
    },
    {
      "longName": "PatternBuilder::registerDescrBuildError(RuleBuildContext context, BaseDescr patternDescr, String error)",
      "startLine": 1912,
      "methodName": "registerDescrBuildError",
      "isStatic": true,
      "isAbstract": false,
      "visibility": "private"
    },
    {
      "longName": "PatternBuilder::registerDescrBuildError(RuleBuildContext context, BaseDescr patternDescr, Object object, String error)",
      "startLine": 1916,
      "methodName": "registerDescrBuildError",
      "isStatic": true,
      "isAbstract": false,
      "visibility": "private"
    }
  ],
  "method": {
    "longName": "PatternBuilder::build(RuleBuildContext context, PatternDescr patternDescr, Pattern prefixPattern)",
    "startLine": 166,
    "methodName": "build",
    "isStatic": false,
    "isAbstract": false,
    "visibility": "public"
  },
  "history": {
    "5b1a928b81875c20d7859a15985491e8b5604b55":
    {
      "type": "Ybodychange",
      "commitMessage": "[DROOLS-1723] throw compile time error for misspelled sliding window predicate (#1449)\n\n",
      "commitDate": "2017-09-06, 1:37 AM",
      "commitName": "5b1a928b81875c20d7859a15985491e8b5604b55",
      "commitAuthor": "Mario Fusco",
      "commitDateOld": "2017-07-04, 12:40 AM",
      "commitNameOld": "def1b5dda56d85df6ff061e17a5fb738a1247246",
      "commitAuthorOld": "Mario Fusco",
      "daysBetweenCommits": 64.04,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,34 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        PatternDescr patternDescr,\n                                        Pattern prefixPattern ) {\n         if ( patternDescr.getObjectType() == null ) {\n             lookupObjectType( context, patternDescr );\n         }\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n-            context.addError(new DescrBuildError(context.getParentDescr(),\n-                                                 patternDescr,\n-                                                 null,\n-                                                 \"ObjectType not correctly defined\"));\n+            registerDescrBuildError( context, patternDescr, \"ObjectType not correctly defined\" );\n             return null;\n         }\n \n         ObjectType objectType = getObjectType(context, patternDescr);\n         if ( objectType == null ) { // if the objectType doesn't exist it has to be query\n             return buildQuery( context, patternDescr, patternDescr );\n         }\n \n         Pattern pattern = buildPattern( context, patternDescr, objectType );\n         processClassObjectType( context, objectType, pattern );\n         processAnnotations( context, patternDescr, pattern );\n         processSource( context, patternDescr, pattern );\n         processConstraintsAndBinds( context, patternDescr, pattern );\n         processBehaviors( context, patternDescr, pattern );\n \n         if ( !pattern.hasNegativeConstraint() && \"on\".equals( System.getProperty(\"drools.negatable\") ) ) {\n             // this is a non-negative pattern, so we must inject the constraint\n             pattern.addConstraint( new NegConstraint(false) );\n         }\n \n         // poping the pattern\n         context.getDeclarationResolver().popBuildStack();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "987d68ab386923edda23002a1c64526812aa4764":
    {
      "type": "Ybodychange",
      "commitMessage": "[DROOLS-414] allow any kind of expression to be used as input for a query\n",
      "commitDate": "2016-08-05, 8:31 AM",
      "commitName": "987d68ab386923edda23002a1c64526812aa4764",
      "commitAuthor": "Mario Fusco",
      "commitDateOld": "2016-08-02, 5:33 AM",
      "commitNameOld": "29a1a5015575f3fd6f21b11f6c7e956f2a1c5801",
      "commitAuthorOld": "Mario Fusco",
      "daysBetweenCommits": 3.12,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        PatternDescr patternDescr,\n                                        Pattern prefixPattern ) {\n         if ( patternDescr.getObjectType() == null ) {\n             lookupObjectType( context, patternDescr );\n         }\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                                                  patternDescr,\n                                                  null,\n                                                  \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = getObjectType(context, patternDescr);\n         if ( objectType == null ) { // if the objectType doesn't exist it has to be query\n-            return buildQuery( context, patternDescr, prefixPattern, patternDescr );\n+            return buildQuery( context, patternDescr, patternDescr );\n         }\n \n         Pattern pattern = buildPattern( context, patternDescr, objectType );\n         processClassObjectType( context, objectType, pattern );\n         processAnnotations( context, patternDescr, pattern );\n         processSource( context, patternDescr, pattern );\n         processConstraintsAndBinds( context, patternDescr, pattern );\n         processBehaviors( context, patternDescr, pattern );\n \n         if ( !pattern.hasNegativeConstraint() && \"on\".equals( System.getProperty(\"drools.negatable\") ) ) {\n             // this is a non-negative pattern, so we must inject the constraint\n             pattern.addConstraint( new NegConstraint(false) );\n         }\n \n         // poping the pattern\n         context.getDeclarationResolver().popBuildStack();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "137d933267f9378b6ae49f477673a29c9501ca6a":
    {
      "type": "Ybodychange",
      "commitMessage": "[DROOLS-897] make same variable bound to different classes in or condition to be actually bound to the common superclass\n",
      "commitDate": "2015-08-28, 8:09 AM",
      "commitName": "137d933267f9378b6ae49f477673a29c9501ca6a",
      "commitAuthor": "Mario Fusco",
      "commitDateOld": "2015-08-18, 2:36 AM",
      "commitNameOld": "dc81e1f1ca7f56a29b4fb6c0ad0e14bb3c49551c",
      "commitAuthorOld": "Mario Fusco",
      "daysBetweenCommits": 10.23,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        PatternDescr patternDescr,\n                                        Pattern prefixPattern ) {\n         if ( patternDescr.getObjectType() == null ) {\n             lookupObjectType( context, patternDescr );\n         }\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                                                  patternDescr,\n                                                  null,\n                                                  \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = getObjectType(context, patternDescr);\n         if ( objectType == null ) { // if the objectType doesn't exist it has to be query\n             return buildQuery( context, patternDescr, prefixPattern, patternDescr );\n         }\n \n         Pattern pattern = buildPattern( context, patternDescr, objectType );\n         processClassObjectType( context, objectType, pattern );\n         processAnnotations( context, patternDescr, pattern );\n         processSource( context, patternDescr, pattern );\n         processConstraintsAndBinds( context, patternDescr, pattern );\n         processBehaviors( context, patternDescr, pattern );\n \n         if ( !pattern.hasNegativeConstraint() && \"on\".equals( System.getProperty(\"drools.negatable\") ) ) {\n             // this is a non-negative pattern, so we must inject the constraint\n             pattern.addConstraint( new NegConstraint(false) );\n         }\n \n         // poping the pattern\n-        context.getBuildStack().pop();\n+        context.getDeclarationResolver().popBuildStack();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "9acd02bacd77c19d5393a164dcfda91cd597c3c4":
    {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "[DROOLS-664] allow out of pattern oopath\n",
      "commitDate": "2015-07-24, 9:38 AM",
      "commitName": "9acd02bacd77c19d5393a164dcfda91cd597c3c4",
      "commitAuthor": "Mario Fusco",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "[DROOLS-664] allow out of pattern oopath\n",
          "commitDate": "2015-07-24, 9:38 AM",
          "commitName": "9acd02bacd77c19d5393a164dcfda91cd597c3c4",
          "commitAuthor": "Mario Fusco",
          "commitDateOld": "2015-07-21, 10:53 AM",
          "commitNameOld": "57cb56675766fc016309a30860131f1ac38fa9e1",
          "commitAuthorOld": "Mario Fusco",
          "daysBetweenCommits": 2.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,195 +1,37 @@\n     public RuleConditionElement build( RuleBuildContext context,\n-                                       BaseDescr descr,\n+                                       PatternDescr patternDescr,\n                                        Pattern prefixPattern ) {\n-\n-        final PatternDescr patternDescr = (PatternDescr) descr;\n+        if ( patternDescr.getObjectType() == null ) {\n+            lookupObjectType( context, patternDescr );\n+        }\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n-                    patternDescr,\n-                    null,\n-                    \"ObjectType not correctly defined\"));\n+                                                 patternDescr,\n+                                                 null,\n+                                                 \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n-        ObjectType objectType = null;\n-\n-        final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n-\n-        if ( factTemplate != null ) {\n-            objectType = new FactTemplateObjectType( factTemplate );\n-        } else {\n-            try {\n-                final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n-                if ( !Modifier.isPublic(userProvidedClass.getModifiers()) ) {\n-                    context.addError(new DescrBuildError(context.getParentDescr(),\n-                                                         patternDescr,\n-                                                         null,\n-                                                         \"The class '\" + patternDescr.getObjectType() + \"' is not public\"));\n-                    return null;\n-                }\n-                PackageRegistry pkgr = context.getKnowledgeBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n-                InternalKnowledgePackage pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n-                final boolean isEvent = pkg.isEvent( userProvidedClass );\n-                objectType = new ClassObjectType( userProvidedClass,\n-                                                  isEvent );\n-            } catch ( final ClassNotFoundException e ) {\n-                // swallow as we'll do another check in a moment and then record the problem\n-            }\n+        ObjectType objectType = getObjectType(context, patternDescr);\n+        if ( objectType == null ) { // if the objectType doesn't exist it has to be query\n+            return buildQuery( context, patternDescr, prefixPattern, patternDescr );\n         }\n \n-        // lets see if it maps to a query\n-        if ( objectType == null ) {\n-            RuleConditionElement rce = null;\n-            // it might be a recursive query, so check for same names\n-            if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n-                // it's a query so delegate to the QueryElementBuilder\n-                rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) context.getRule());\n-            }\n-\n-            if ( rce == null ) {\n-                // look up the query in the current package\n-                RuleImpl rule = context.getPkg().getRule( patternDescr.getObjectType() );\n-                if ( rule instanceof QueryImpl ) {\n-                    // it's a query so delegate to the QueryElementBuilder\n-                    rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) rule);\n-                }\n-            }\n-\n-            if ( rce == null ) {\n-                // the query may have been imported, so try package imports\n-                for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n-                    importName = importName.trim();\n-                    int pos = importName.indexOf( '*' );\n-                    if ( pos >= 0 ) {\n-                        String pkgName = importName.substring( 0,\n-                                                               pos - 1 );\n-                        PackageRegistry pkgReg = context.getKnowledgeBuilder().getPackageRegistry( pkgName );\n-                        if ( pkgReg != null ) {\n-                            RuleImpl rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n-                            if ( rule instanceof QueryImpl) {\n-                                // it's a query so delegate to the QueryElementBuilder\n-                                rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) rule);\n-                                break;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-\n-            if ( rce == null ) {\n-                // this isn't a query either, so log an error\n-                context.addError(new DescrBuildError(context.getParentDescr(),\n-                                                     patternDescr,\n-                                                     null,\n-                                                     \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n-            }\n-            return rce;\n-        }\n-\n-        String patternIdentifier = patternDescr.getIdentifier();\n-        boolean duplicateBindings = patternIdentifier != null && objectType instanceof ClassObjectType &&\n-                                    context.getDeclarationResolver().isDuplicated( context.getRule(),\n-                                                                                   patternIdentifier,\n-                                                                                   ((ClassObjectType) objectType).getClassName() );\n-\n-        Pattern pattern;\n-        if ( !StringUtils.isEmpty( patternIdentifier ) && !duplicateBindings ) {\n-\n-            pattern = new Pattern( context.getNextPatternId(),\n-                                   0, // offset is 0 by default\n-                                   objectType,\n-                                   patternIdentifier,\n-                                   patternDescr.isInternalFact() );\n-            if ( objectType instanceof ClassObjectType ) {\n-                // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n-                context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n-                                                                                  (AcceptsClassObjectType) pattern.getDeclaration().getExtractor() );\n-            }\n-        } else {\n-            pattern = new Pattern( context.getNextPatternId(),\n-                                   0, // offset is 0 by default\n-                                   objectType,\n-                                   null );\n-        }\n-        pattern.setPassive(patternDescr.isPassive());\n-\n-        if ( ClassObjectType.Match_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n-            PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( RuleTerminalNodeLeftTuple.class );\n-            if ( handler == null ) {\n-                PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( RuleTerminalNodeLeftTuple.class,\n-                                                                           new ActivationPropertyHandler() );\n-            }\n-        }\n-\n-        // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n-        context.getBuildStack().push( pattern );\n-\n-        if ( duplicateBindings ) {\n-            processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n-        }\n-\n-        if ( objectType instanceof ClassObjectType ) {\n-            // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n-            context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n-                                                                              pattern );\n-        }\n-\n-        if ( pattern.getObjectType() instanceof ClassObjectType ) {\n-            Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n-            if ( cls.getPackage() != null && !cls.getPackage().getName().equals( \"java.lang\" ) ) {\n-                // register the class in its own package unless it is primitive or belongs to java.lang\n-                TypeDeclaration typeDeclr = context.getKnowledgeBuilder().getAndRegisterTypeDeclaration( cls,\n-                                                                                                       cls.getPackage().getName() );\n-                context.setTypesafe( typeDeclr == null || typeDeclr.isTypesafe() );\n-            } else {\n-                context.setTypesafe( true );\n-            }\n-        }\n-\n+        Pattern pattern = buildPattern( context, patternDescr, objectType );\n+        processClassObjectType( context, objectType, pattern );\n         processAnnotations( context, patternDescr, pattern );\n-        \n-        if ( patternDescr.getSource() != null ) {\n-            // we have a pattern source, so build it\n-            RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n-\n-            PatternSource source = (PatternSource) builder.build( context, patternDescr.getSource() );\n-            if ( source instanceof From ) {\n-                ((From) source).setResultPattern( pattern );\n-            }\n-            pattern.setSource( source );\n-        }\n-\n-        // Process all constraints\n+        processSource( context, patternDescr, pattern );\n         processConstraintsAndBinds( context, patternDescr, pattern );\n-\n-        for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n-            if ( pattern.getObjectType().isEvent() ) {\n-                if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n-                    SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n-                    pattern.addBehavior( window );\n-                } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n-                    SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n-                    pattern.addBehavior( window );\n-                }\n-                context.setNeedStreamMode();\n-            } else {\n-                // Some behaviors can only be assigned to patterns declared as events\n-                context.addError(new DescrBuildError(context.getParentDescr(),\n-                                                     patternDescr,\n-                                                     null,\n-                                                     \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n-                                                     + \"' is not declared as an Event.\"));\n-            }\n-        }\n+        processBehaviors( context, patternDescr, pattern );\n \n         if ( !pattern.hasNegativeConstraint() && \"on\".equals( System.getProperty(\"drools.negatable\") ) ) {\n             // this is a non-negative pattern, so we must inject the constraint\n             pattern.addConstraint( new NegConstraint(false) );\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
          "extendedDetails":
          {
            "oldValue": "[context-RuleBuildContext, descr-BaseDescr, prefixPattern-Pattern]",
            "newValue": "[context-RuleBuildContext, patternDescr-PatternDescr, prefixPattern-Pattern]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "[DROOLS-664] allow out of pattern oopath\n",
          "commitDate": "2015-07-24, 9:38 AM",
          "commitName": "9acd02bacd77c19d5393a164dcfda91cd597c3c4",
          "commitAuthor": "Mario Fusco",
          "commitDateOld": "2015-07-21, 10:53 AM",
          "commitNameOld": "57cb56675766fc016309a30860131f1ac38fa9e1",
          "commitAuthorOld": "Mario Fusco",
          "daysBetweenCommits": 2.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,195 +1,37 @@\n     public RuleConditionElement build( RuleBuildContext context,\n-                                       BaseDescr descr,\n+                                       PatternDescr patternDescr,\n                                        Pattern prefixPattern ) {\n-\n-        final PatternDescr patternDescr = (PatternDescr) descr;\n+        if ( patternDescr.getObjectType() == null ) {\n+            lookupObjectType( context, patternDescr );\n+        }\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n-                    patternDescr,\n-                    null,\n-                    \"ObjectType not correctly defined\"));\n+                                                 patternDescr,\n+                                                 null,\n+                                                 \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n-        ObjectType objectType = null;\n-\n-        final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n-\n-        if ( factTemplate != null ) {\n-            objectType = new FactTemplateObjectType( factTemplate );\n-        } else {\n-            try {\n-                final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n-                if ( !Modifier.isPublic(userProvidedClass.getModifiers()) ) {\n-                    context.addError(new DescrBuildError(context.getParentDescr(),\n-                                                         patternDescr,\n-                                                         null,\n-                                                         \"The class '\" + patternDescr.getObjectType() + \"' is not public\"));\n-                    return null;\n-                }\n-                PackageRegistry pkgr = context.getKnowledgeBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n-                InternalKnowledgePackage pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n-                final boolean isEvent = pkg.isEvent( userProvidedClass );\n-                objectType = new ClassObjectType( userProvidedClass,\n-                                                  isEvent );\n-            } catch ( final ClassNotFoundException e ) {\n-                // swallow as we'll do another check in a moment and then record the problem\n-            }\n+        ObjectType objectType = getObjectType(context, patternDescr);\n+        if ( objectType == null ) { // if the objectType doesn't exist it has to be query\n+            return buildQuery( context, patternDescr, prefixPattern, patternDescr );\n         }\n \n-        // lets see if it maps to a query\n-        if ( objectType == null ) {\n-            RuleConditionElement rce = null;\n-            // it might be a recursive query, so check for same names\n-            if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n-                // it's a query so delegate to the QueryElementBuilder\n-                rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) context.getRule());\n-            }\n-\n-            if ( rce == null ) {\n-                // look up the query in the current package\n-                RuleImpl rule = context.getPkg().getRule( patternDescr.getObjectType() );\n-                if ( rule instanceof QueryImpl ) {\n-                    // it's a query so delegate to the QueryElementBuilder\n-                    rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) rule);\n-                }\n-            }\n-\n-            if ( rce == null ) {\n-                // the query may have been imported, so try package imports\n-                for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n-                    importName = importName.trim();\n-                    int pos = importName.indexOf( '*' );\n-                    if ( pos >= 0 ) {\n-                        String pkgName = importName.substring( 0,\n-                                                               pos - 1 );\n-                        PackageRegistry pkgReg = context.getKnowledgeBuilder().getPackageRegistry( pkgName );\n-                        if ( pkgReg != null ) {\n-                            RuleImpl rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n-                            if ( rule instanceof QueryImpl) {\n-                                // it's a query so delegate to the QueryElementBuilder\n-                                rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) rule);\n-                                break;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-\n-            if ( rce == null ) {\n-                // this isn't a query either, so log an error\n-                context.addError(new DescrBuildError(context.getParentDescr(),\n-                                                     patternDescr,\n-                                                     null,\n-                                                     \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n-            }\n-            return rce;\n-        }\n-\n-        String patternIdentifier = patternDescr.getIdentifier();\n-        boolean duplicateBindings = patternIdentifier != null && objectType instanceof ClassObjectType &&\n-                                    context.getDeclarationResolver().isDuplicated( context.getRule(),\n-                                                                                   patternIdentifier,\n-                                                                                   ((ClassObjectType) objectType).getClassName() );\n-\n-        Pattern pattern;\n-        if ( !StringUtils.isEmpty( patternIdentifier ) && !duplicateBindings ) {\n-\n-            pattern = new Pattern( context.getNextPatternId(),\n-                                   0, // offset is 0 by default\n-                                   objectType,\n-                                   patternIdentifier,\n-                                   patternDescr.isInternalFact() );\n-            if ( objectType instanceof ClassObjectType ) {\n-                // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n-                context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n-                                                                                  (AcceptsClassObjectType) pattern.getDeclaration().getExtractor() );\n-            }\n-        } else {\n-            pattern = new Pattern( context.getNextPatternId(),\n-                                   0, // offset is 0 by default\n-                                   objectType,\n-                                   null );\n-        }\n-        pattern.setPassive(patternDescr.isPassive());\n-\n-        if ( ClassObjectType.Match_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n-            PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( RuleTerminalNodeLeftTuple.class );\n-            if ( handler == null ) {\n-                PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( RuleTerminalNodeLeftTuple.class,\n-                                                                           new ActivationPropertyHandler() );\n-            }\n-        }\n-\n-        // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n-        context.getBuildStack().push( pattern );\n-\n-        if ( duplicateBindings ) {\n-            processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n-        }\n-\n-        if ( objectType instanceof ClassObjectType ) {\n-            // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n-            context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n-                                                                              pattern );\n-        }\n-\n-        if ( pattern.getObjectType() instanceof ClassObjectType ) {\n-            Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n-            if ( cls.getPackage() != null && !cls.getPackage().getName().equals( \"java.lang\" ) ) {\n-                // register the class in its own package unless it is primitive or belongs to java.lang\n-                TypeDeclaration typeDeclr = context.getKnowledgeBuilder().getAndRegisterTypeDeclaration( cls,\n-                                                                                                       cls.getPackage().getName() );\n-                context.setTypesafe( typeDeclr == null || typeDeclr.isTypesafe() );\n-            } else {\n-                context.setTypesafe( true );\n-            }\n-        }\n-\n+        Pattern pattern = buildPattern( context, patternDescr, objectType );\n+        processClassObjectType( context, objectType, pattern );\n         processAnnotations( context, patternDescr, pattern );\n-        \n-        if ( patternDescr.getSource() != null ) {\n-            // we have a pattern source, so build it\n-            RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n-\n-            PatternSource source = (PatternSource) builder.build( context, patternDescr.getSource() );\n-            if ( source instanceof From ) {\n-                ((From) source).setResultPattern( pattern );\n-            }\n-            pattern.setSource( source );\n-        }\n-\n-        // Process all constraints\n+        processSource( context, patternDescr, pattern );\n         processConstraintsAndBinds( context, patternDescr, pattern );\n-\n-        for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n-            if ( pattern.getObjectType().isEvent() ) {\n-                if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n-                    SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n-                    pattern.addBehavior( window );\n-                } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n-                    SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n-                    pattern.addBehavior( window );\n-                }\n-                context.setNeedStreamMode();\n-            } else {\n-                // Some behaviors can only be assigned to patterns declared as events\n-                context.addError(new DescrBuildError(context.getParentDescr(),\n-                                                     patternDescr,\n-                                                     null,\n-                                                     \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n-                                                     + \"' is not declared as an Event.\"));\n-            }\n-        }\n+        processBehaviors( context, patternDescr, pattern );\n \n         if ( !pattern.hasNegativeConstraint() && \"on\".equals( System.getProperty(\"drools.negatable\") ) ) {\n             // this is a non-negative pattern, so we must inject the constraint\n             pattern.addConstraint( new NegConstraint(false) );\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
          "extendedDetails":
          {}
        }]
    },
    "a2888dade8f73802e9ef2cc346cb1f8a73ce5e85":
    {
      "type": "Ybodychange",
      "commitMessage": "[DROOLS-727] support variable unification in accumulate patterns\n",
      "commitDate": "2015-02-25, 7:06 AM",
      "commitName": "a2888dade8f73802e9ef2cc346cb1f8a73ce5e85",
      "commitAuthor": "sotty",
      "commitDateOld": "2015-01-29, 8:07 AM",
      "commitNameOld": "ed1a83fe764a3d9b7c3248777d07829d790449f5",
      "commitAuthorOld": "Mario Fusco",
      "daysBetweenCommits": 26.96,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,194 +1,195 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 if ( !Modifier.isPublic(userProvidedClass.getModifiers()) ) {\n                     context.addError(new DescrBuildError(context.getParentDescr(),\n                                                          patternDescr,\n                                                          null,\n                                                          \"The class '\" + patternDescr.getObjectType() + \"' is not public\"));\n                     return null;\n                 }\n                 PackageRegistry pkgr = context.getKnowledgeBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 InternalKnowledgePackage pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) context.getRule());\n             }\n \n             if ( rce == null ) {\n                 // look up the query in the current package\n                 RuleImpl rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule instanceof QueryImpl ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) rule);\n                 }\n             }\n \n             if ( rce == null ) {\n                 // the query may have been imported, so try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getKnowledgeBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             RuleImpl rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule instanceof QueryImpl) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) rule);\n                                 break;\n                             }\n                         }\n                     }\n                 }\n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                                                      patternDescr,\n                                                      null,\n                                                      \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n-        boolean duplicateBindings = objectType instanceof ClassObjectType &&\n+        String patternIdentifier = patternDescr.getIdentifier();\n+        boolean duplicateBindings = patternIdentifier != null && objectType instanceof ClassObjectType &&\n                                     context.getDeclarationResolver().isDuplicated( context.getRule(),\n-                                                                                   patternDescr.getIdentifier(),\n+                                                                                   patternIdentifier,\n                                                                                    ((ClassObjectType) objectType).getClassName() );\n \n         Pattern pattern;\n-        if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n+        if ( !StringUtils.isEmpty( patternIdentifier ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n-                                   patternDescr.getIdentifier(),\n+                                   patternIdentifier,\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (AcceptsClassObjectType) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n         pattern.setPassive(patternDescr.isPassive());\n \n         if ( ClassObjectType.Match_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( RuleTerminalNodeLeftTuple.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( RuleTerminalNodeLeftTuple.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( duplicateBindings ) {\n             processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             if ( cls.getPackage() != null && !cls.getPackage().getName().equals( \"java.lang\" ) ) {\n                 // register the class in its own package unless it is primitive or belongs to java.lang\n                 TypeDeclaration typeDeclr = context.getKnowledgeBuilder().getAndRegisterTypeDeclaration( cls,\n                                                                                                        cls.getPackage().getName() );\n                 context.setTypesafe( typeDeclr == null || typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context, patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n                 context.setNeedStreamMode();\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                                                      patternDescr,\n                                                      null,\n                                                      \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                                      + \"' is not declared as an Event.\"));\n             }\n         }\n \n         if ( !pattern.hasNegativeConstraint() && \"on\".equals( System.getProperty(\"drools.negatable\") ) ) {\n             // this is a non-negative pattern, so we must inject the constraint\n             pattern.addConstraint( new NegConstraint(false) );\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "ed1a83fe764a3d9b7c3248777d07829d790449f5":
    {
      "type": "Ybodychange",
      "commitMessage": "[DROOLS-699] do eager segment creation only for passive exists nodes\n",
      "commitDate": "2015-01-29, 8:07 AM",
      "commitName": "ed1a83fe764a3d9b7c3248777d07829d790449f5",
      "commitAuthor": "Mario Fusco",
      "commitDateOld": "2015-01-27, 11:54 PM",
      "commitNameOld": "2d86a327fae6fd0496ad5241191e23173a892f1a",
      "commitAuthorOld": "Mario Fusco",
      "daysBetweenCommits": 1.34,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,194 +1,194 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 if ( !Modifier.isPublic(userProvidedClass.getModifiers()) ) {\n                     context.addError(new DescrBuildError(context.getParentDescr(),\n                                                          patternDescr,\n                                                          null,\n                                                          \"The class '\" + patternDescr.getObjectType() + \"' is not public\"));\n                     return null;\n                 }\n                 PackageRegistry pkgr = context.getKnowledgeBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 InternalKnowledgePackage pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) context.getRule());\n             }\n \n             if ( rce == null ) {\n                 // look up the query in the current package\n                 RuleImpl rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule instanceof QueryImpl ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) rule);\n                 }\n             }\n \n             if ( rce == null ) {\n                 // the query may have been imported, so try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getKnowledgeBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             RuleImpl rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule instanceof QueryImpl) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) rule);\n                                 break;\n                             }\n                         }\n                     }\n                 }\n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                                                      patternDescr,\n                                                      null,\n                                                      \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         boolean duplicateBindings = objectType instanceof ClassObjectType &&\n                                     context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier(),\n                                                                                    ((ClassObjectType) objectType).getClassName() );\n \n         Pattern pattern;\n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (AcceptsClassObjectType) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n-        pattern.setPassive(patternDescr.isQuery());\n+        pattern.setPassive(patternDescr.isPassive());\n \n         if ( ClassObjectType.Match_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( RuleTerminalNodeLeftTuple.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( RuleTerminalNodeLeftTuple.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( duplicateBindings ) {\n             processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             if ( cls.getPackage() != null && !cls.getPackage().getName().equals( \"java.lang\" ) ) {\n                 // register the class in its own package unless it is primitive or belongs to java.lang\n                 TypeDeclaration typeDeclr = context.getKnowledgeBuilder().getAndRegisterTypeDeclaration( cls,\n                                                                                                        cls.getPackage().getName() );\n                 context.setTypesafe( typeDeclr == null || typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context, patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n                 context.setNeedStreamMode();\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                                                      patternDescr,\n                                                      null,\n                                                      \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                                      + \"' is not declared as an Event.\"));\n             }\n         }\n \n         if ( !pattern.hasNegativeConstraint() && \"on\".equals( System.getProperty(\"drools.negatable\") ) ) {\n             // this is a non-negative pattern, so we must inject the constraint\n             pattern.addConstraint( new NegConstraint(false) );\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "333f4f333d837862f733b72dac54f4089dea67f0":
    {
      "type": "Ybodychange",
      "commitMessage": "[DROOLS-664] implement xpath notation\n",
      "commitDate": "2014-12-10, 8:50 AM",
      "commitName": "333f4f333d837862f733b72dac54f4089dea67f0",
      "commitAuthor": "Mario Fusco",
      "commitDateOld": "2014-11-26, 4:29 PM",
      "commitNameOld": "8376ed4d69206b0320210c4a37e4555be682e602",
      "commitAuthorOld": "sotty",
      "daysBetweenCommits": 13.68,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,196 +1,195 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 if ( !Modifier.isPublic(userProvidedClass.getModifiers()) ) {\n                     context.addError(new DescrBuildError(context.getParentDescr(),\n                                                          patternDescr,\n                                                          null,\n                                                          \"The class '\" + patternDescr.getObjectType() + \"' is not public\"));\n                     return null;\n                 }\n                 PackageRegistry pkgr = context.getKnowledgeBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 InternalKnowledgePackage pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) context.getRule());\n             }\n \n             if ( rce == null ) {\n                 // look up the query in the current package\n                 RuleImpl rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule instanceof QueryImpl ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) rule);\n                 }\n             }\n \n             if ( rce == null ) {\n                 // the query may have been imported, so try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getKnowledgeBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             RuleImpl rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule instanceof QueryImpl) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) rule);\n                                 break;\n                             }\n                         }\n                     }\n                 }\n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                                                      patternDescr,\n                                                      null,\n                                                      \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n-        Pattern pattern;\n-\n         boolean duplicateBindings = objectType instanceof ClassObjectType &&\n                                     context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier(),\n                                                                                    ((ClassObjectType) objectType).getClassName() );\n \n+        Pattern pattern;\n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (AcceptsClassObjectType) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n         pattern.setPassive(patternDescr.isQuery());\n \n         if ( ClassObjectType.Match_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( RuleTerminalNodeLeftTuple.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( RuleTerminalNodeLeftTuple.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( duplicateBindings ) {\n             processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             if ( cls.getPackage() != null && !cls.getPackage().getName().equals( \"java.lang\" ) ) {\n                 // register the class in its own package unless it is primitive or belongs to java.lang\n                 TypeDeclaration typeDeclr = context.getKnowledgeBuilder().getAndRegisterTypeDeclaration( cls,\n                                                                                                        cls.getPackage().getName() );\n                 context.setTypesafe( typeDeclr == null || typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n                 context.setNeedStreamMode();\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                 + \"' is not declared as an Event.\"));\n             }\n         }\n \n         if ( !pattern.hasNegativeConstraint() && \"on\".equals( System.getProperty(\"drools.negatable\") ) ) {\n             // this is a non-negative pattern, so we must inject the constraint\n             pattern.addConstraint( new NegConstraint(false) );\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "3132b8febc5c316d5cc1b366df7af68db10c80c4":
    {
      "type": "Ybodychange",
      "commitMessage": "DROOLS-488 \"Pluggable and Encapsulated Knowledge Types\"\n-Refactored Undecided to Decided.\n\nDROOLS-488 \"Pluggable and Encapsulated Knowledge Types\"\n-introduced _.neg and removed the DFL, JTMS pos/neg fact handle and neg entry point\n\nDROOLS-488 \"Pluggable and Encapsulated Knowledge Types\"\n-Added correct handling of NegConstraint for declared masks\n-Fixed FH cloning and NegConstraint cloning\n\nDROOLS-488 \"Pluggable and Encapsulated Knowledge Types\"\n-Negatable support must be turned on for !_.neg constraint injection\n\nDROOLS-488 \"Pluggable and Encapsulated Knowledge Types\"\n-Better WM and TMS separation, as a pipeline\n\nDROOLS-488 \"Pluggable and Encapsulated Knowledge Types\"\n-Better WM and TMS separation, as a pipeline\n-Neg is now separate map in the ObjectStore\n",
      "commitDate": "2014-11-26, 4:29 PM",
      "commitName": "3132b8febc5c316d5cc1b366df7af68db10c80c4",
      "commitAuthor": "Mark Proctor",
      "commitDateOld": "2014-10-13, 10:07 AM",
      "commitNameOld": "deb53717adb736efcf006e1f9197b2345d74c899",
      "commitAuthorOld": "sotty",
      "daysBetweenCommits": 44.31,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,191 +1,196 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 if ( !Modifier.isPublic(userProvidedClass.getModifiers()) ) {\n                     context.addError(new DescrBuildError(context.getParentDescr(),\n                                                          patternDescr,\n                                                          null,\n                                                          \"The class '\" + patternDescr.getObjectType() + \"' is not public\"));\n                     return null;\n                 }\n                 PackageRegistry pkgr = context.getKnowledgeBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 InternalKnowledgePackage pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) context.getRule());\n             }\n \n             if ( rce == null ) {\n                 // look up the query in the current package\n                 RuleImpl rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule instanceof QueryImpl ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) rule);\n                 }\n             }\n \n             if ( rce == null ) {\n                 // the query may have been imported, so try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getKnowledgeBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             RuleImpl rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule instanceof QueryImpl) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) rule);\n                                 break;\n                             }\n                         }\n                     }\n                 }\n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                                                      patternDescr,\n                                                      null,\n                                                      \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = objectType instanceof ClassObjectType &&\n                                     context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier(),\n                                                                                    ((ClassObjectType) objectType).getClassName() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (AcceptsClassObjectType) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n         pattern.setPassive(patternDescr.isQuery());\n \n         if ( ClassObjectType.Match_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( RuleTerminalNodeLeftTuple.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( RuleTerminalNodeLeftTuple.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( duplicateBindings ) {\n             processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             if ( cls.getPackage() != null && !cls.getPackage().getName().equals( \"java.lang\" ) ) {\n                 // register the class in its own package unless it is primitive or belongs to java.lang\n                 TypeDeclaration typeDeclr = context.getKnowledgeBuilder().getAndRegisterTypeDeclaration( cls,\n                                                                                                        cls.getPackage().getName() );\n                 context.setTypesafe( typeDeclr == null || typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n                 context.setNeedStreamMode();\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                 + \"' is not declared as an Event.\"));\n             }\n         }\n \n+        if ( !pattern.hasNegativeConstraint() && \"on\".equals( System.getProperty(\"drools.negatable\") ) ) {\n+            // this is a non-negative pattern, so we must inject the constraint\n+            pattern.addConstraint( new NegConstraint(false) );\n+        }\n+\n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "9028f2db4dbfb3a91f41d0c96770c158c4904fdf":
    {
      "type": "Ybodychange",
      "commitMessage": "[DROOLS-625] parse and register passive patterns\n",
      "commitDate": "2014-10-03, 10:37 AM",
      "commitName": "9028f2db4dbfb3a91f41d0c96770c158c4904fdf",
      "commitAuthor": "mariofusco",
      "commitDateOld": "2014-10-01, 9:43 AM",
      "commitNameOld": "ee811d16f3723bb7ce9ed7f3dd0970bf892502c9",
      "commitAuthorOld": "mariofusco",
      "daysBetweenCommits": 2.04,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,190 +1,191 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 if ( !Modifier.isPublic(userProvidedClass.getModifiers()) ) {\n                     context.addError(new DescrBuildError(context.getParentDescr(),\n                                                          patternDescr,\n                                                          null,\n                                                          \"The class '\" + patternDescr.getObjectType() + \"' is not public\"));\n                     return null;\n                 }\n                 PackageRegistry pkgr = context.getKnowledgeBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 InternalKnowledgePackage pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) context.getRule());\n             }\n \n             if ( rce == null ) {\n                 // look up the query in the current package\n                 RuleImpl rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule instanceof QueryImpl ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) rule);\n                 }\n             }\n \n             if ( rce == null ) {\n                 // the query may have been imported, so try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getKnowledgeBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             RuleImpl rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule instanceof QueryImpl) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) rule);\n                                 break;\n                             }\n                         }\n                     }\n                 }\n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                                                      patternDescr,\n                                                      null,\n                                                      \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = objectType instanceof ClassObjectType &&\n                                     context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier(),\n                                                                                    ((ClassObjectType) objectType).getClassName() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (AcceptsClassObjectType) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n+        pattern.setPassive(patternDescr.isQuery());\n \n         if ( ClassObjectType.Match_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( RuleTerminalNodeLeftTuple.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( RuleTerminalNodeLeftTuple.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( duplicateBindings ) {\n             processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             if ( cls.getPackage() != null && !cls.getPackage().getName().equals( \"java.lang\" ) ) {\n                 // register the class in its own package unless it is primitive or belongs to java.lang\n                 TypeDeclaration typeDeclr = context.getKnowledgeBuilder().getAndRegisterTypeDeclaration( cls,\n                                                                                                        cls.getPackage().getName() );\n                 context.setTypesafe( typeDeclr == null || typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n                 context.setNeedStreamMode();\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                 + \"' is not declared as an Event.\"));\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "3c124bee7c9ad544a43945aea7e5762ec3183589":
    {
      "type": "Ybodychange",
      "commitMessage": "[DROOLS-600] fix ClassCastException when using FactTemplates\n",
      "commitDate": "2014-09-24, 3:16 AM",
      "commitName": "3c124bee7c9ad544a43945aea7e5762ec3183589",
      "commitAuthor": "mariofusco",
      "commitDateOld": "2014-09-18, 10:00 AM",
      "commitNameOld": "67e2a30687c80776e00b36c94b79589be95a6d06",
      "commitAuthorOld": "mariofusco",
      "daysBetweenCommits": 5.72,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,189 +1,190 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 if ( !Modifier.isPublic(userProvidedClass.getModifiers()) ) {\n                     context.addError(new DescrBuildError(context.getParentDescr(),\n                                                          patternDescr,\n                                                          null,\n                                                          \"The class '\" + patternDescr.getObjectType() + \"' is not public\"));\n                     return null;\n                 }\n                 PackageRegistry pkgr = context.getKnowledgeBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 InternalKnowledgePackage pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) context.getRule());\n             }\n \n             if ( rce == null ) {\n                 // look up the query in the current package\n                 RuleImpl rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule instanceof QueryImpl ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) rule);\n                 }\n             }\n \n             if ( rce == null ) {\n                 // the query may have been imported, so try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getKnowledgeBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             RuleImpl rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule instanceof QueryImpl) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) rule);\n                                 break;\n                             }\n                         }\n                     }\n                 }\n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                                                      patternDescr,\n                                                      null,\n                                                      \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n-        boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n+        boolean duplicateBindings = objectType instanceof ClassObjectType &&\n+                                    context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier(),\n                                                                                    ((ClassObjectType) objectType).getClassName() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (AcceptsClassObjectType) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( ClassObjectType.Match_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( RuleTerminalNodeLeftTuple.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( RuleTerminalNodeLeftTuple.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( duplicateBindings ) {\n             processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             if ( cls.getPackage() != null && !cls.getPackage().getName().equals( \"java.lang\" ) ) {\n                 // register the class in its own package unless it is primitive or belongs to java.lang\n                 TypeDeclaration typeDeclr = context.getKnowledgeBuilder().getAndRegisterTypeDeclaration( cls,\n                                                                                                        cls.getPackage().getName() );\n                 context.setTypesafe( typeDeclr == null || typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n                 context.setNeedStreamMode();\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                 + \"' is not declared as an Event.\"));\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "67e2a30687c80776e00b36c94b79589be95a6d06":
    {
      "type": "Ybodychange",
      "commitMessage": "[DROOLS-601] fix queries when used in combination with agenda-groups\n",
      "commitDate": "2014-09-18, 10:00 AM",
      "commitName": "67e2a30687c80776e00b36c94b79589be95a6d06",
      "commitAuthor": "mariofusco",
      "commitDateOld": "2014-09-01, 10:48 AM",
      "commitNameOld": "042350294cd372ef01db3a4be18797824e64c9d6",
      "commitAuthorOld": "mariofusco",
      "daysBetweenCommits": 16.97,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,201 +1,189 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 if ( !Modifier.isPublic(userProvidedClass.getModifiers()) ) {\n                     context.addError(new DescrBuildError(context.getParentDescr(),\n                                                          patternDescr,\n                                                          null,\n                                                          \"The class '\" + patternDescr.getObjectType() + \"' is not public\"));\n                     return null;\n                 }\n                 PackageRegistry pkgr = context.getKnowledgeBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 InternalKnowledgePackage pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n-                QueryElementBuilder qeBuilder = QueryElementBuilder.getInstance();\n-                rce = qeBuilder.build( context,\n-                                        descr,\n-                                        prefixPattern,\n-                                        (QueryImpl) context.getRule() );\n+                rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) context.getRule());\n             }\n \n             if ( rce == null ) {\n                 // look up the query in the current package\n                 RuleImpl rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule instanceof QueryImpl ) {\n                     // it's a query so delegate to the QueryElementBuilder\n-                    QueryElementBuilder qeBuilder = QueryElementBuilder.getInstance();\n-                    rce = qeBuilder.build( context,\n-                                           descr,\n-                                           prefixPattern,\n-                                           (QueryImpl) rule );\n+                    rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) rule);\n                 }\n             }\n \n             if ( rce == null ) {\n                 // the query may have been imported, so try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getKnowledgeBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             RuleImpl rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule instanceof QueryImpl) {\n                                 // it's a query so delegate to the QueryElementBuilder\n-                                QueryElementBuilder qeBuilder = QueryElementBuilder.getInstance();\n-                                rce = qeBuilder.build( context,\n-                                                       descr,\n-                                                       prefixPattern,\n-                                                       (QueryImpl) rule );\n+                                rce = buildQueryElement(context, descr, prefixPattern, (QueryImpl) rule);\n                                 break;\n                             }\n                         }\n                     }\n                 }\n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                                                      patternDescr,\n                                                      null,\n                                                      \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier(),\n                                                                                    ((ClassObjectType) objectType).getClassName() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (AcceptsClassObjectType) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( ClassObjectType.Match_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( RuleTerminalNodeLeftTuple.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( RuleTerminalNodeLeftTuple.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( duplicateBindings ) {\n             processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             if ( cls.getPackage() != null && !cls.getPackage().getName().equals( \"java.lang\" ) ) {\n                 // register the class in its own package unless it is primitive or belongs to java.lang\n                 TypeDeclaration typeDeclr = context.getKnowledgeBuilder().getAndRegisterTypeDeclaration( cls,\n                                                                                                        cls.getPackage().getName() );\n                 context.setTypesafe( typeDeclr == null || typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n                 context.setNeedStreamMode();\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                 + \"' is not declared as an Event.\"));\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "ebf7f1dcc85a0a98e41f6bd5ea43cf6e17e80fb7":
    {
      "type": "Ybodychange",
      "commitMessage": "[DROOLS-549] Queries in the default package are built twice\n",
      "commitDate": "2014-07-18, 7:48 AM",
      "commitName": "ebf7f1dcc85a0a98e41f6bd5ea43cf6e17e80fb7",
      "commitAuthor": "sotty",
      "commitDateOld": "2014-04-22, 12:12 AM",
      "commitNameOld": "1f8dc32725276a68456c5c4315c6a7c0b3f222ad",
      "commitAuthorOld": "mariofusco",
      "daysBetweenCommits": 87.32,
      "commitsBetweenForRepo": 104,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,199 +1,201 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 if ( !Modifier.isPublic(userProvidedClass.getModifiers()) ) {\n                     context.addError(new DescrBuildError(context.getParentDescr(),\n                                                          patternDescr,\n                                                          null,\n                                                          \"The class '\" + patternDescr.getObjectType() + \"' is not public\"));\n                     return null;\n                 }\n                 PackageRegistry pkgr = context.getKnowledgeBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 InternalKnowledgePackage pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = QueryElementBuilder.getInstance();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern,\n                                         (QueryImpl) context.getRule() );\n             }\n \n             if ( rce == null ) {\n+                // look up the query in the current package\n                 RuleImpl rule = context.getPkg().getRule( patternDescr.getObjectType() );\n-                if ( rule instanceof QueryImpl) {\n+                if ( rule instanceof QueryImpl ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = QueryElementBuilder.getInstance();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern,\n                                            (QueryImpl) rule );\n                 }\n+            }\n \n-                // try package imports\n+            if ( rce == null ) {\n+                // the query may have been imported, so try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getKnowledgeBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n-                            rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n+                            RuleImpl rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule instanceof QueryImpl) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 QueryElementBuilder qeBuilder = QueryElementBuilder.getInstance();\n                                 rce = qeBuilder.build( context,\n                                                        descr,\n                                                        prefixPattern,\n                                                        (QueryImpl) rule );\n                                 break;\n                             }\n                         }\n                     }\n                 }\n-\n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                                                      patternDescr,\n                                                      null,\n                                                      \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier(),\n                                                                                    ((ClassObjectType) objectType).getClassName() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (AcceptsClassObjectType) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( ClassObjectType.Match_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( RuleTerminalNodeLeftTuple.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( RuleTerminalNodeLeftTuple.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( duplicateBindings ) {\n             processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             if ( cls.getPackage() != null && !cls.getPackage().getName().equals( \"java.lang\" ) ) {\n                 // register the class in its own package unless it is primitive or belongs to java.lang\n                 TypeDeclaration typeDeclr = context.getKnowledgeBuilder().getAndRegisterTypeDeclaration( cls,\n                                                                                                        cls.getPackage().getName() );\n                 context.setTypesafe( typeDeclr == null || typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n                 context.setNeedStreamMode();\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                 + \"' is not declared as an Event.\"));\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "1f8dc32725276a68456c5c4315c6a7c0b3f222ad":
    {
      "type": "Ybodychange",
      "commitMessage": "major cleanup 4.x legacy API\n",
      "commitDate": "2014-04-22, 12:12 AM",
      "commitName": "1f8dc32725276a68456c5c4315c6a7c0b3f222ad",
      "commitAuthor": "mariofusco",
      "commitDateOld": "2014-02-07, 7:22 AM",
      "commitNameOld": "57708e3898bd126579d1461714d6b60c1a54c8a8",
      "commitAuthorOld": "sotty",
      "daysBetweenCommits": 73.66,
      "commitsBetweenForRepo": 141,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,199 +1,199 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 if ( !Modifier.isPublic(userProvidedClass.getModifiers()) ) {\n                     context.addError(new DescrBuildError(context.getParentDescr(),\n                                                          patternDescr,\n                                                          null,\n                                                          \"The class '\" + patternDescr.getObjectType() + \"' is not public\"));\n                     return null;\n                 }\n-                PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n-                org.drools.core.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n+                PackageRegistry pkgr = context.getKnowledgeBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n+                InternalKnowledgePackage pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = QueryElementBuilder.getInstance();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern,\n-                                        (Query) context.getRule() );\n+                                        (QueryImpl) context.getRule() );\n             }\n \n             if ( rce == null ) {\n-                Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n-                if ( rule instanceof Query ) {\n+                RuleImpl rule = context.getPkg().getRule( patternDescr.getObjectType() );\n+                if ( rule instanceof QueryImpl) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = QueryElementBuilder.getInstance();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern,\n-                                           (Query) rule );\n+                                           (QueryImpl) rule );\n                 }\n \n                 // try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n-                        PackageRegistry pkgReg = context.getPackageBuilder().getPackageRegistry( pkgName );\n+                        PackageRegistry pkgReg = context.getKnowledgeBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n-                            if ( rule instanceof Query ) {\n+                            if ( rule instanceof QueryImpl) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 QueryElementBuilder qeBuilder = QueryElementBuilder.getInstance();\n                                 rce = qeBuilder.build( context,\n                                                        descr,\n                                                        prefixPattern,\n-                                                       (Query) rule );\n+                                                       (QueryImpl) rule );\n                                 break;\n                             }\n                         }\n                     }\n                 }\n \n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                                                      patternDescr,\n                                                      null,\n                                                      \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier(),\n                                                                                    ((ClassObjectType) objectType).getClassName() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (AcceptsClassObjectType) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( ClassObjectType.Match_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( RuleTerminalNodeLeftTuple.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( RuleTerminalNodeLeftTuple.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( duplicateBindings ) {\n             processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             if ( cls.getPackage() != null && !cls.getPackage().getName().equals( \"java.lang\" ) ) {\n                 // register the class in its own package unless it is primitive or belongs to java.lang\n-                TypeDeclaration typeDeclr = context.getPackageBuilder().getAndRegisterTypeDeclaration( cls,\n+                TypeDeclaration typeDeclr = context.getKnowledgeBuilder().getAndRegisterTypeDeclaration( cls,\n                                                                                                        cls.getPackage().getName() );\n                 context.setTypesafe( typeDeclr == null || typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n                 context.setNeedStreamMode();\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                 + \"' is not declared as an Event.\"));\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "4b4f4f2fa1cc2dc68b293ac9fdf58c9a53266aae":
    {
      "type": "Ybodychange",
      "commitMessage": "DROOLS-307 Queries should be order independent within the same namespace\n",
      "commitDate": "2013-10-21, 8:28 PM",
      "commitName": "4b4f4f2fa1cc2dc68b293ac9fdf58c9a53266aae",
      "commitAuthor": "Mark Proctor",
      "commitDateOld": "2013-10-21, 3:29 AM",
      "commitNameOld": "3361ff876ca3bdd9d28cad3997c576d7211bd748",
      "commitAuthorOld": "mariofusco",
      "daysBetweenCommits": 0.71,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,199 +1,199 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 if ( !Modifier.isPublic(userProvidedClass.getModifiers()) ) {\n                     context.addError(new DescrBuildError(context.getParentDescr(),\n                                                          patternDescr,\n                                                          null,\n                                                          \"The class '\" + patternDescr.getObjectType() + \"' is not public\"));\n                     return null;\n                 }\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.core.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n-                QueryElementBuilder qeBuilder = new QueryElementBuilder();\n+                QueryElementBuilder qeBuilder = QueryElementBuilder.getInstance();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern,\n                                         (Query) context.getRule() );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n-                    QueryElementBuilder qeBuilder = new QueryElementBuilder();\n+                    QueryElementBuilder qeBuilder = QueryElementBuilder.getInstance();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern,\n                                            (Query) rule );\n                 }\n \n                 // try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getPackageBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule instanceof Query ) {\n                                 // it's a query so delegate to the QueryElementBuilder\n-                                QueryElementBuilder qeBuilder = new QueryElementBuilder();\n+                                QueryElementBuilder qeBuilder = QueryElementBuilder.getInstance();\n                                 rce = qeBuilder.build( context,\n                                                        descr,\n                                                        prefixPattern,\n                                                        (Query) rule );\n                                 break;\n                             }\n                         }\n                     }\n                 }\n \n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                                                      patternDescr,\n                                                      null,\n                                                      \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier(),\n                                                                                    ((ClassObjectType) objectType).getClassName() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (AcceptsClassObjectType) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( ClassObjectType.Match_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( RuleTerminalNodeLeftTuple.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( RuleTerminalNodeLeftTuple.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( duplicateBindings ) {\n             processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             if ( cls.getPackage() != null && !cls.getPackage().getName().equals( \"java.lang\" ) ) {\n                 // register the class in its own package unless it is primitive or belongs to java.lang\n                 TypeDeclaration typeDeclr = context.getPackageBuilder().getAndRegisterTypeDeclaration( cls,\n                                                                                                        cls.getPackage().getName() );\n                 context.setTypesafe( typeDeclr == null || typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n                 context.setNeedStreamMode();\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                 + \"' is not declared as an Event.\"));\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "69dd8626bb40cd86dd59247a908aa8f212b5eb84":
    {
      "type": "Ybodychange",
      "commitMessage": "[BZ-1005165] throw a RuntimeException when trying to create in CLOUD mode a KieBase requiring STREAM features\n",
      "commitDate": "2013-09-13, 11:23 AM",
      "commitName": "69dd8626bb40cd86dd59247a908aa8f212b5eb84",
      "commitAuthor": "mariofusco",
      "commitDateOld": "2013-07-16, 5:43 AM",
      "commitNameOld": "1145fc0034bab451d86a09978fd4f951bd8fde20",
      "commitAuthorOld": "mariofusco",
      "daysBetweenCommits": 59.24,
      "commitsBetweenForRepo": 174,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,198 +1,199 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 if ( !Modifier.isPublic(userProvidedClass.getModifiers()) ) {\n                     context.addError(new DescrBuildError(context.getParentDescr(),\n                                                          patternDescr,\n                                                          null,\n                                                          \"The class '\" + patternDescr.getObjectType() + \"' is not public\"));\n                     return null;\n                 }\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.core.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern,\n                                         (Query) context.getRule() );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern,\n                                            (Query) rule );\n                 }\n \n                 // try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getPackageBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule instanceof Query ) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                                 rce = qeBuilder.build( context,\n                                                        descr,\n                                                        prefixPattern,\n                                                        (Query) rule );\n                                 break;\n                             }\n                         }\n                     }\n                 }\n \n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                                                      patternDescr,\n                                                      null,\n                                                      \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier(),\n                                                                                    ((ClassObjectType) objectType).getClassName() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (AcceptsClassObjectType) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( ClassObjectType.Match_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( RuleTerminalNodeLeftTuple.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( RuleTerminalNodeLeftTuple.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( duplicateBindings ) {\n             processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             if ( cls.getPackage() != null && !cls.getPackage().getName().equals( \"java.lang\" ) ) {\n                 // register the class in its own package unless it is primitive or belongs to java.lang\n                 TypeDeclaration typeDeclr = context.getPackageBuilder().getAndRegisterTypeDeclaration( cls,\n                                                                                                        cls.getPackage().getName() );\n                 context.setTypesafe( typeDeclr == null || typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n+                context.setNeedStreamMode();\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                 + \"' is not declared as an Event.\"));\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "1c5ae38b15b359eea42053da1b9eda03b965d9e6":
    {
      "type": "Ybodychange",
      "commitMessage": "[DROOLS-162] Unsupported polymorphic declarations are not detected until runtime\n",
      "commitDate": "2013-07-09, 8:09 AM",
      "commitName": "1c5ae38b15b359eea42053da1b9eda03b965d9e6",
      "commitAuthor": "mariofusco",
      "commitDateOld": "2013-06-14, 8:33 AM",
      "commitNameOld": "c3aadef98727e2be7f9e544ce239fd08f4d7c669",
      "commitAuthorOld": "mariofusco",
      "daysBetweenCommits": 24.98,
      "commitsBetweenForRepo": 125,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,197 +1,198 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 if ( !Modifier.isPublic(userProvidedClass.getModifiers()) ) {\n                     context.addError(new DescrBuildError(context.getParentDescr(),\n                                                          patternDescr,\n                                                          null,\n                                                          \"The class '\" + patternDescr.getObjectType() + \"' is not public\"));\n                     return null;\n                 }\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.core.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern,\n                                         (Query) context.getRule() );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern,\n                                            (Query) rule );\n                 }\n \n                 // try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getPackageBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule instanceof Query ) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                                 rce = qeBuilder.build( context,\n                                                        descr,\n                                                        prefixPattern,\n                                                        (Query) rule );\n                                 break;\n                             }\n                         }\n                     }\n                 }\n \n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                                                      patternDescr,\n                                                      null,\n                                                      \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n-                                                                                   patternDescr.getIdentifier() );\n+                                                                                   patternDescr.getIdentifier(),\n+                                                                                   ((ClassObjectType) objectType).getClassName() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (AcceptsClassObjectType) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( ClassObjectType.Match_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( RuleTerminalNodeLeftTuple.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( RuleTerminalNodeLeftTuple.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( duplicateBindings ) {\n             processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             if ( cls.getPackage() != null && !cls.getPackage().getName().equals( \"java.lang\" ) ) {\n                 // register the class in its own package unless it is primitive or belongs to java.lang\n                 TypeDeclaration typeDeclr = context.getPackageBuilder().getAndRegisterTypeDeclaration( cls,\n                                                                                                        cls.getPackage().getName() );\n                 context.setTypesafe( typeDeclr == null || typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                 + \"' is not declared as an Event.\"));\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "b6849a106c805c97fbcaea3ec2ecd2e433225cc0":
    {
      "type": "Ybodychange",
      "commitMessage": "DROOLS-7 Phreak\n-Trying to merge RuleTerminalNodeLeftTuple and AgendaItem (+1 squashed commit)\nSquashed commits:\n[a46db5e] DROOLS-7 Phreak\n-Trying to merge RuleTerminalNodeLeftTuple and AgendaItem\n",
      "commitDate": "2013-05-12, 5:33 PM",
      "commitName": "b6849a106c805c97fbcaea3ec2ecd2e433225cc0",
      "commitAuthor": "Mark Proctor",
      "commitDateOld": "2013-04-08, 5:45 AM",
      "commitNameOld": "24c98f317c5d5316163147675abcabf6bdef93eb",
      "commitAuthorOld": "mariofusco",
      "daysBetweenCommits": 34.49,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,197 +1,197 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 if ( !Modifier.isPublic(userProvidedClass.getModifiers()) ) {\n                     context.addError(new DescrBuildError(context.getParentDescr(),\n                                                          patternDescr,\n                                                          null,\n                                                          \"The class '\" + patternDescr.getObjectType() + \"' is not public\"));\n                     return null;\n                 }\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.core.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern,\n                                         (Query) context.getRule() );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern,\n                                            (Query) rule );\n                 }\n \n                 // try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getPackageBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule instanceof Query ) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                                 rce = qeBuilder.build( context,\n                                                        descr,\n                                                        prefixPattern,\n                                                        (Query) rule );\n                                 break;\n                             }\n                         }\n                     }\n                 }\n \n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                                                      patternDescr,\n                                                      null,\n                                                      \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (AcceptsClassObjectType) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( ClassObjectType.Match_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n-            PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( AgendaItem.class );\n+            PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( RuleTerminalNodeLeftTuple.class );\n             if ( handler == null ) {\n-                PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( AgendaItem.class,\n+                PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( RuleTerminalNodeLeftTuple.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( duplicateBindings ) {\n             processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             if ( cls.getPackage() != null && !cls.getPackage().getName().equals( \"java.lang\" ) ) {\n                 // register the class in its own package unless it is primitive or belongs to java.lang\n                 TypeDeclaration typeDeclr = context.getPackageBuilder().getAndRegisterTypeDeclaration( cls,\n                                                                                                        cls.getPackage().getName() );\n                 context.setTypesafe( typeDeclr == null || typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                 + \"' is not declared as an Event.\"));\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "24c98f317c5d5316163147675abcabf6bdef93eb":
    {
      "type": "Ybodychange",
      "commitMessage": "[DROOLS-99] put type declaration for Java classes in a Package with the same name of the one of the class\n",
      "commitDate": "2013-04-08, 5:45 AM",
      "commitName": "24c98f317c5d5316163147675abcabf6bdef93eb",
      "commitAuthor": "mariofusco",
      "commitDateOld": "2013-03-16, 9:56 AM",
      "commitNameOld": "ab7f413209fd976bc3e76ce2a45d88c51f2ca028",
      "commitAuthorOld": "Geoffrey De Smet",
      "daysBetweenCommits": 22.83,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,195 +1,197 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 if ( !Modifier.isPublic(userProvidedClass.getModifiers()) ) {\n                     context.addError(new DescrBuildError(context.getParentDescr(),\n                                                          patternDescr,\n                                                          null,\n                                                          \"The class '\" + patternDescr.getObjectType() + \"' is not public\"));\n                     return null;\n                 }\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.core.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern,\n                                         (Query) context.getRule() );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern,\n                                            (Query) rule );\n                 }\n \n                 // try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getPackageBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule instanceof Query ) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                                 rce = qeBuilder.build( context,\n                                                        descr,\n                                                        prefixPattern,\n                                                        (Query) rule );\n                                 break;\n                             }\n                         }\n                     }\n                 }\n \n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                                                      patternDescr,\n                                                      null,\n                                                      \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (AcceptsClassObjectType) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( ClassObjectType.Match_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( AgendaItem.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( AgendaItem.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( duplicateBindings ) {\n             processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n-            TypeDeclaration typeDeclr = context.getPackageBuilder().getAndRegisterTypeDeclaration(cls, context.getPkg().getName());\n-            if ( typeDeclr != null ) {\n-                context.setTypesafe( typeDeclr.isTypesafe() );\n+            if ( cls.getPackage() != null && !cls.getPackage().getName().equals( \"java.lang\" ) ) {\n+                // register the class in its own package unless it is primitive or belongs to java.lang\n+                TypeDeclaration typeDeclr = context.getPackageBuilder().getAndRegisterTypeDeclaration( cls,\n+                                                                                                       cls.getPackage().getName() );\n+                context.setTypesafe( typeDeclr == null || typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                 + \"' is not declared as an Event.\"));\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "b1d63cf9c2c1b8d537c80fe0d2c7ae7b93657cba":
    {
      "type": "Ybodychange",
      "commitMessage": "Resolve split-packages: move everything from drools-core under org.drools.core: move org.drools.rule\n",
      "commitDate": "2013-03-16, 7:28 AM",
      "commitName": "b1d63cf9c2c1b8d537c80fe0d2c7ae7b93657cba",
      "commitAuthor": "Geoffrey De Smet",
      "commitDateOld": "2013-03-15, 11:47 PM",
      "commitNameOld": "6947d48a64e139cd4bd4d19514fa6f8f589ac73c",
      "commitAuthorOld": "Mark Proctor",
      "daysBetweenCommits": 0.32,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,195 +1,195 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 if ( !Modifier.isPublic(userProvidedClass.getModifiers()) ) {\n                     context.addError(new DescrBuildError(context.getParentDescr(),\n                                                          patternDescr,\n                                                          null,\n                                                          \"The class '\" + patternDescr.getObjectType() + \"' is not public\"));\n                     return null;\n                 }\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n-                org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n+                org.drools.core.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern,\n                                         (Query) context.getRule() );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern,\n                                            (Query) rule );\n                 }\n \n                 // try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getPackageBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule instanceof Query ) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                                 rce = qeBuilder.build( context,\n                                                        descr,\n                                                        prefixPattern,\n                                                        (Query) rule );\n                                 break;\n                             }\n                         }\n                     }\n                 }\n \n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                                                      patternDescr,\n                                                      null,\n                                                      \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (AcceptsClassObjectType) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( ClassObjectType.Match_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( AgendaItem.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( AgendaItem.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( duplicateBindings ) {\n             processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getAndRegisterTypeDeclaration(cls, context.getPkg().getName());\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                 + \"' is not declared as an Event.\"));\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "bb3406c940949b0cbf9fa9f9f839c8d24512a4c4":
    {
      "type": "Yfilerename",
      "commitMessage": "Resolve split-packages: move everything from drools-compiler under org.drools.compiler: move org.drools.rule\n",
      "commitDate": "2013-03-15, 7:14 AM",
      "commitName": "bb3406c940949b0cbf9fa9f9f839c8d24512a4c4",
      "commitAuthor": "Geoffrey De Smet",
      "commitDateOld": "2013-03-15, 7:10 AM",
      "commitNameOld": "e65c41aefbcd61e138406f44b57e0b83d0f4217d",
      "commitAuthorOld": "Geoffrey De Smet",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "extendedDetails":
      {
        "oldPath": "drools-compiler/src/main/java/org/drools/rule/builder/PatternBuilder.java",
        "newPath": "drools-compiler/src/main/java/org/drools/compiler/rule/builder/PatternBuilder.java"
      }
    },
    "ca31c2fb77762170f154642aefdd13d239d31b52":
    {
      "type": "Ybodychange",
      "commitMessage": "[DROOLS-61] generate a proper compilation failure when trying to use non-public classes in drl\n",
      "commitDate": "2013-02-27, 8:24 AM",
      "commitName": "ca31c2fb77762170f154642aefdd13d239d31b52",
      "commitAuthor": "mariofusco",
      "commitDateOld": "2013-02-22, 8:26 AM",
      "commitNameOld": "d2249b85cd81fba158c9070ac2afa51cce048379",
      "commitAuthorOld": "mariofusco",
      "daysBetweenCommits": 5.0,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,188 +1,195 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n+                if ( !Modifier.isPublic(userProvidedClass.getModifiers()) ) {\n+                    context.addError(new DescrBuildError(context.getParentDescr(),\n+                                                         patternDescr,\n+                                                         null,\n+                                                         \"The class '\" + patternDescr.getObjectType() + \"' is not public\"));\n+                    return null;\n+                }\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern,\n                                         (Query) context.getRule() );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern,\n                                            (Query) rule );\n                 }\n \n                 // try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getPackageBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule instanceof Query ) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                                 rce = qeBuilder.build( context,\n                                                        descr,\n                                                        prefixPattern,\n                                                        (Query) rule );\n                                 break;\n                             }\n                         }\n                     }\n                 }\n \n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n-                        patternDescr,\n-                        null,\n-                        \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n+                                                     patternDescr,\n+                                                     null,\n+                                                     \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (AcceptsClassObjectType) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( ClassObjectType.Match_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( AgendaItem.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( AgendaItem.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( duplicateBindings ) {\n             processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getAndRegisterTypeDeclaration(cls, context.getPkg().getName());\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                 + \"' is not declared as an Event.\"));\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "f4b8f5fdb0ead269501b56f880a1fe7d821b4352":
    {
      "type": "Ybodychange",
      "commitMessage": "[DROOLS-45] anticipate pushing of the compiling pattern on the build stack to fix unification compilation\n",
      "commitDate": "2013-02-19, 3:30 AM",
      "commitName": "f4b8f5fdb0ead269501b56f880a1fe7d821b4352",
      "commitAuthor": "mariofusco",
      "commitDateOld": "2013-01-30, 7:20 AM",
      "commitNameOld": "e21443fd19c344927830c5c70b6c5ab2cd01f29a",
      "commitAuthorOld": "mariofusco",
      "daysBetweenCommits": 19.84,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,188 +1,188 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern,\n                                         (Query) context.getRule() );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern,\n                                            (Query) rule );\n                 }\n \n                 // try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getPackageBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule instanceof Query ) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                                 rce = qeBuilder.build( context,\n                                                        descr,\n                                                        prefixPattern,\n                                                        (Query) rule );\n                                 break;\n                             }\n                         }\n                     }\n                 }\n \n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (AcceptsClassObjectType) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( ClassObjectType.Match_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( AgendaItem.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( AgendaItem.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n+        // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n+        context.getBuildStack().push( pattern );\n+\n         if ( duplicateBindings ) {\n             processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n-        // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n-        context.getBuildStack().push( pattern );\n-\n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getAndRegisterTypeDeclaration(cls, context.getPkg().getName());\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                 + \"' is not declared as an Event.\"));\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "12534ae521aaab197258f1e292b7e7739ae137a5":
    {
      "type": "Ybodychange",
      "commitMessage": "DROOLS-19 ClassCastException with Before and After operators\n",
      "commitDate": "2013-01-28, 8:39 AM",
      "commitName": "12534ae521aaab197258f1e292b7e7739ae137a5",
      "commitAuthor": "Mark Proctor",
      "commitDateOld": "2012-11-30, 6:51 PM",
      "commitNameOld": "12b833aabeb97cae50f73083963e78b95b1cd970",
      "commitAuthorOld": "Edson Tirelli",
      "daysBetweenCommits": 58.57,
      "commitsBetweenForRepo": 167,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,188 +1,188 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern,\n                                         (Query) context.getRule() );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern,\n                                            (Query) rule );\n                 }\n \n                 // try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getPackageBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule instanceof Query ) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                                 rce = qeBuilder.build( context,\n                                                        descr,\n                                                        prefixPattern,\n                                                        (Query) rule );\n                                 break;\n                             }\n                         }\n                     }\n                 }\n \n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n-                                                                                  (PatternExtractor) pattern.getDeclaration().getExtractor() );\n+                                                                                  (AcceptsClassObjectType) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( ClassObjectType.Match_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( AgendaItem.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( AgendaItem.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         if ( duplicateBindings ) {\n             processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getAndRegisterTypeDeclaration(cls, context.getPkg().getName());\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                 + \"' is not declared as an Event.\"));\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "12b833aabeb97cae50f73083963e78b95b1cd970":
    {
      "type": "Ybodychange",
      "commitMessage": "Implementing the API for Drools 6\n",
      "commitDate": "2012-11-30, 6:51 PM",
      "commitName": "12b833aabeb97cae50f73083963e78b95b1cd970",
      "commitAuthor": "Edson Tirelli",
      "commitDateOld": "2012-10-30, 7:22 AM",
      "commitNameOld": "d124a9cbbda79bd566075420edf3032fc256598b",
      "commitAuthorOld": "mariofusco",
      "daysBetweenCommits": 31.52,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,188 +1,188 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern,\n                                         (Query) context.getRule() );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern,\n                                            (Query) rule );\n                 }\n \n                 // try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getPackageBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule instanceof Query ) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                                 rce = qeBuilder.build( context,\n                                                        descr,\n                                                        prefixPattern,\n                                                        (Query) rule );\n                                 break;\n                             }\n                         }\n                     }\n                 }\n \n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n-        if ( ClassObjectType.Activation_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n+        if ( ClassObjectType.Match_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( AgendaItem.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( AgendaItem.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         if ( duplicateBindings ) {\n             processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getAndRegisterTypeDeclaration(cls, context.getPkg().getName());\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                 + \"' is not declared as an Event.\"));\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "c198abdad092b0651fda0034d5af148af7adce45":
    {
      "type": "Ybodychange",
      "commitMessage": "[JBRULES-3645] null-safe dereferencing operator\n",
      "commitDate": "2012-10-02, 11:07 AM",
      "commitName": "c198abdad092b0651fda0034d5af148af7adce45",
      "commitAuthor": "mariofusco",
      "commitDateOld": "2012-09-25, 5:28 AM",
      "commitNameOld": "bee56ce2bb7fa82829c399126c8de6a4eb16244b",
      "commitAuthorOld": "mariofusco",
      "daysBetweenCommits": 7.24,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,188 +1,188 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern,\n                                         (Query) context.getRule() );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n-                if ( rule != null && rule instanceof Query ) {\n+                if ( rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern,\n                                            (Query) rule );\n                 }\n \n                 // try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getPackageBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n-                            if ( rule != null && rule instanceof Query ) {\n+                            if ( rule instanceof Query ) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                                 rce = qeBuilder.build( context,\n                                                        descr,\n                                                        prefixPattern,\n                                                        (Query) rule );\n                                 break;\n                             }\n                         }\n                     }\n                 }\n \n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( ClassObjectType.Activation_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( AgendaItem.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( AgendaItem.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         if ( duplicateBindings ) {\n             processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getAndRegisterTypeDeclaration(cls, context.getPkg().getName());\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                 + \"' is not declared as an Event.\"));\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "3858161e7c5f5ab6188667241beebb5c89ab8275":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-359 Certainty Factors\n\nJBRULES-359 Certainty Factors\n\nJBRULES-359 Certainty Factors in Traits\n\nJBRULES-359 Certainty Factors in Traits\n\nJBRULES-359 Certainty Factors in Traits\n\nJBRULES-359 Certainty Factors\n\nJBRULES-359 Certainty Factors\n\nJBRULES-359 Certainty Factors\n\nJBRULES-359 Certainty Factors\n\nJBRULES-359 Certainty Factors\n\nJBRULES-359 Certainty Factors\n\nJBRULES-359 Certainty Factors\n\nJBRULES-359 Certainty Factors\n\nJBRULES-359 Certainty Factors\n\nJBRULES-359 Certainty Factors\n\nJBRULES-359 Certainty Factors\n\nJBRULES-3481 hashCode() for declared types without @key fields always yields 1\n\nJBRULES-3481 hashCode() for declared types without @key fields always yields 1\n\nFix merge upstream conflicts\n\nJBRULES-359 Certainty Factors\n\nJBRULES-359 Certainty Factors\n\nJBRULES-359 Certainty Factors\n\nJBRULES-359 Certainty Factors\n\nJBRULES-359 Certainty Factors\n\nJBRULES-359 Certainty Factors\n\nFix merge upstream conflicts\n\nJBRULES-359 Certainty Factors\n\nJBRULES-359 Certainty Factors\n",
      "commitDate": "2012-07-16, 6:37 AM",
      "commitName": "3858161e7c5f5ab6188667241beebb5c89ab8275",
      "commitAuthor": "Davide Sottara",
      "commitDateOld": "2012-07-12, 11:37 AM",
      "commitNameOld": "cd4b22f042014ddb85ebd0e71b4d0d96eb2fb609",
      "commitAuthorOld": "Edson Tirelli",
      "daysBetweenCommits": 3.79,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,201 +1,188 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern,\n                                         (Query) context.getRule() );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule != null && rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern,\n                                            (Query) rule );\n                 }\n \n                 // try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getPackageBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule != null && rule instanceof Query ) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                                 rce = qeBuilder.build( context,\n                                                        descr,\n                                                        prefixPattern,\n                                                        (Query) rule );\n                                 break;\n                             }\n                         }\n                     }\n                 }\n \n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( ClassObjectType.Activation_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( AgendaItem.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( AgendaItem.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         if ( duplicateBindings ) {\n-            if ( patternDescr.isUnification() ) {\n-                // rewrite existing bindings into == constraints, so it unifies\n-                build( context,\n-                       patternDescr,\n-                       pattern,\n-                       patternDescr,\n-                       \"this == \" + patternDescr.getIdentifier() );\n-            } else {\n-                // This declaration already exists, so throw an Exception\n-                context.addError(new DescrBuildError(context.getParentDescr(),\n-                        patternDescr,\n-                        null,\n-                        \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\"));\n-            }\n+            processDuplicateBindings( patternDescr.isUnification(), patternDescr, pattern, patternDescr, \"this\", patternDescr.getIdentifier(), context );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getAndRegisterTypeDeclaration(cls, context.getPkg().getName());\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                 + \"' is not declared as an Event.\"));\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "cd4b22f042014ddb85ebd0e71b4d0d96eb2fb609":
    {
      "type": "Ybodychange",
      "commitMessage": "Fixing error message when using window declarations with object types not declared as events\n",
      "commitDate": "2012-07-12, 11:37 AM",
      "commitName": "cd4b22f042014ddb85ebd0e71b4d0d96eb2fb609",
      "commitAuthor": "Edson Tirelli",
      "commitDateOld": "2012-05-16, 11:12 AM",
      "commitNameOld": "2b879821238e82fe812d7cde38f193d3c37b4282",
      "commitAuthorOld": "mariofusco",
      "daysBetweenCommits": 57.02,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,201 +1,201 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern,\n                                         (Query) context.getRule() );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule != null && rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern,\n                                            (Query) rule );\n                 }\n \n                 // try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getPackageBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule != null && rule instanceof Query ) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                                 rce = qeBuilder.build( context,\n                                                        descr,\n                                                        prefixPattern,\n                                                        (Query) rule );\n                                 break;\n                             }\n                         }\n                     }\n                 }\n \n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( ClassObjectType.Activation_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( AgendaItem.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( AgendaItem.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         if ( duplicateBindings ) {\n             if ( patternDescr.isUnification() ) {\n                 // rewrite existing bindings into == constraints, so it unifies\n                 build( context,\n                        patternDescr,\n                        pattern,\n                        patternDescr,\n                        \"this == \" + patternDescr.getIdentifier() );\n             } else {\n                 // This declaration already exists, so throw an Exception\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\"));\n             }\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getAndRegisterTypeDeclaration(cls, context.getPkg().getName());\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         processAnnotations( context, patternDescr, pattern );\n         \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context, patternDescr, pattern );\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n-                        \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n+                        \"A Sliding Window can only be assigned to types declared with @role( event ). The type '\" + pattern.getObjectType() + \"' in '\" + context.getRule().getName()\n                                 + \"' is not declared as an Event.\"));\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "8ada29d38ff15e7374e534a9e93a66cf465021db":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-3363: fixing bad cut&paste code\n",
      "commitDate": "2012-05-01, 4:16 PM",
      "commitName": "8ada29d38ff15e7374e534a9e93a66cf465021db",
      "commitAuthor": "Edson Tirelli",
      "commitDateOld": "2012-04-29, 3:10 AM",
      "commitNameOld": "ec5afbf186d1bf44f44765a8e6863e4d7471c949",
      "commitAuthorOld": "mariofusco",
      "daysBetweenCommits": 2.55,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,200 +1,201 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.addError(new DescrBuildError(context.getParentDescr(),\n                     patternDescr,\n                     null,\n                     \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern,\n                                         (Query) context.getRule() );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule != null && rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern,\n                                            (Query) rule );\n                 }\n \n                 // try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getPackageBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule != null && rule instanceof Query ) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                                 rce = qeBuilder.build( context,\n                                                        descr,\n                                                        prefixPattern,\n                                                        (Query) rule );\n                                 break;\n                             }\n                         }\n                     }\n                 }\n \n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( ClassObjectType.Activation_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( AgendaItem.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( AgendaItem.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         if ( duplicateBindings ) {\n             if ( patternDescr.isUnification() ) {\n                 // rewrite existing bindings into == constraints, so it unifies\n                 build( context,\n                        patternDescr,\n                        pattern,\n                        patternDescr,\n                        \"this == \" + patternDescr.getIdentifier() );\n             } else {\n                 // This declaration already exists, so throw an Exception\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\"));\n             }\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getAndRegisterTypeDeclaration(cls, context.getPkg().getName());\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n-        // Process all constraints\n-        processConstraintsAndBinds( context, patternDescr, pattern );\n         processAnnotations( context, patternDescr, pattern );\n-\n+        \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n+        // Process all constraints\n+        processConstraintsAndBinds( context, patternDescr, pattern );\n+\n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.addError(new DescrBuildError(context.getParentDescr(),\n                         patternDescr,\n                         null,\n                         \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                 + \"' is not declared as an Event.\"));\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "55ed8a0e84ba4ac1a6d62b0ec015372218726255":
    {
      "type": "Ybodychange",
      "commitMessage": "[JBRULES-3343] add slot specific annotations\n",
      "commitDate": "2012-01-18, 8:40 AM",
      "commitName": "55ed8a0e84ba4ac1a6d62b0ec015372218726255",
      "commitAuthor": "mariofusco",
      "commitDateOld": "2012-01-18, 7:53 AM",
      "commitNameOld": "3d2d855b173a5ac4cf6feab7d63c8c507554010b",
      "commitAuthorOld": "Edson Tirelli",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,201 +1,200 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n-            context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n-                                                          patternDescr,\n-                                                          null,\n-                                                          \"ObjectType not correctly defined\" ) );\n+            context.addError(new DescrBuildError(context.getParentDescr(),\n+                    patternDescr,\n+                    null,\n+                    \"ObjectType not correctly defined\"));\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern,\n                                         (Query) context.getRule() );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule != null && rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern,\n                                            (Query) rule );\n                 }\n \n                 // try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0,\n                                                                pos - 1 );\n                         PackageRegistry pkgReg = context.getPackageBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule != null && rule instanceof Query ) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                                 rce = qeBuilder.build( context,\n                                                        descr,\n                                                        prefixPattern,\n                                                        (Query) rule );\n                                 break;\n                             }\n                         }\n                     }\n                 }\n \n             }\n \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n-                context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n-                                                              patternDescr,\n-                                                              null,\n-                                                              \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n+                context.addError(new DescrBuildError(context.getParentDescr(),\n+                        patternDescr,\n+                        null,\n+                        \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\"));\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( ClassObjectType.Activation_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( AgendaItem.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( AgendaItem.class,\n                                                                            new ActivationPropertyHandler() );\n             }\n         }\n \n         if ( duplicateBindings ) {\n             if ( patternDescr.isUnification() ) {\n                 // rewrite existing bindings into == constraints, so it unifies\n                 build( context,\n                        patternDescr,\n                        pattern,\n                        patternDescr,\n                        \"this == \" + patternDescr.getIdentifier() );\n             } else {\n                 // This declaration already exists, so throw an Exception\n-                context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n-                                                              patternDescr,\n-                                                              null,\n-                                                              \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n+                context.addError(new DescrBuildError(context.getParentDescr(),\n+                        patternDescr,\n+                        null,\n+                        \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\"));\n             }\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n-            TypeDeclaration typeDeclr = context.getPackageBuilder().getTypeDeclaration( cls );\n+            TypeDeclaration typeDeclr = context.getPackageBuilder().getAndRegisterTypeDeclaration(cls, context.getPkg().getName());\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         // Process all constraints\n-        processConstraintsAndBinds( context,\n-                                    patternDescr,\n-                                    pattern );\n+        processConstraintsAndBinds( context, patternDescr, pattern );\n+        processAnnotations( context, patternDescr, pattern );\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From) source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n-                context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n-                                                              patternDescr,\n-                                                              null,\n-                                                              \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n-                                                                      + \"' is not declared as an Event.\" ) );\n+                context.addError(new DescrBuildError(context.getParentDescr(),\n+                        patternDescr,\n+                        null,\n+                        \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n+                                + \"' is not declared as an Event.\"));\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "4b74b5823d19c3e7839fba1c6e9be20fb2ab535d":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-2872: fixing line numbers on error messages\n",
      "commitDate": "2011-08-19, 9:27 AM",
      "commitName": "4b74b5823d19c3e7839fba1c6e9be20fb2ab535d",
      "commitAuthor": "Edson Tirelli",
      "commitDateOld": "2011-08-17, 4:54 PM",
      "commitNameOld": "1728d93728acb77c93c851c3849ea466ce95420e",
      "commitAuthorOld": "Mark Proctor",
      "daysBetweenCommits": 1.69,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,198 +1,199 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern,\n                                         (Query) context.getRule() );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule != null && rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern,\n                                            (Query) rule );\n                 }\n                 \n                 // try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0, pos-1 );\n                         PackageRegistry pkgReg = context.getPackageBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule != null && rule instanceof Query ) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                                 rce = qeBuilder.build( context,\n                                                        descr,\n                                                        prefixPattern,\n                                                        (Query) rule);\n                                 break;\n                             }                           \n                         }\n                     }\n                 }\n                 \n             }\n             \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( ClassObjectType.Activation_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( AgendaItem.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( AgendaItem.class, new ActivationPropertyHandler() );\n             }\n         }\n         \n         if ( duplicateBindings ) {\n             if ( patternDescr.isUnification() ) {\n                 // rewrite existing bindings into == constraints, so it unifies\n                 build( context,\n                        patternDescr,\n                        pattern,\n+                       patternDescr,\n                        \"this == \" + patternDescr.getIdentifier() );\n             } else {\n                 // This declaration already exists, so throw an Exception\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getTypeDeclaration( cls );\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context,\n                                     patternDescr,\n                                     pattern );\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n             if ( source instanceof From ) {\n                 ((From)source).setResultPattern( pattern );\n             }\n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "1728d93728acb77c93c851c3849ea466ce95420e":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-3142 Exception when using from with mixed collections\n",
      "commitDate": "2011-08-17, 4:54 PM",
      "commitName": "1728d93728acb77c93c851c3849ea466ce95420e",
      "commitAuthor": "Mark Proctor",
      "commitDateOld": "2011-08-16, 5:02 PM",
      "commitNameOld": "428af65e9bbbb49f010c0f3bf76414465814d153",
      "commitAuthorOld": "Mark Proctor",
      "daysBetweenCommits": 0.99,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,196 +1,198 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern,\n                                         (Query) context.getRule() );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule != null && rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern,\n                                            (Query) rule );\n                 }\n                 \n                 // try package imports\n                 for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n                     importName = importName.trim();\n                     int pos = importName.indexOf( '*' );\n                     if ( pos >= 0 ) {\n                         String pkgName = importName.substring( 0, pos-1 );\n                         PackageRegistry pkgReg = context.getPackageBuilder().getPackageRegistry( pkgName );\n                         if ( pkgReg != null ) {\n                             rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n                             if ( rule != null && rule instanceof Query ) {\n                                 // it's a query so delegate to the QueryElementBuilder\n                                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                                 rce = qeBuilder.build( context,\n                                                        descr,\n                                                        prefixPattern,\n                                                        (Query) rule);\n                                 break;\n                             }                           \n                         }\n                     }\n                 }\n                 \n             }\n             \n             if ( rce == null ) {\n                 // this isn't a query either, so log an error\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( ClassObjectType.Activation_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( AgendaItem.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( AgendaItem.class, new ActivationPropertyHandler() );\n             }\n         }\n         \n         if ( duplicateBindings ) {\n             if ( patternDescr.isUnification() ) {\n                 // rewrite existing bindings into == constraints, so it unifies\n                 build( context,\n                        patternDescr,\n                        pattern,\n                        \"this == \" + patternDescr.getIdentifier() );\n             } else {\n                 // This declaration already exists, so throw an Exception\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getTypeDeclaration( cls );\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context,\n                                     patternDescr,\n                                     pattern );\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n-\n+            if ( source instanceof From ) {\n+                ((From)source).setResultPattern( pattern );\n+            }\n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "737a782e6b33789ebf21b932198e766754da3ad2":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-3148 Dynamic Declarative Conflict Resolution\nJBRULES-3164 Serialization broken for Backward Chaining\nJBRULES-3165 Dynamic Rules broken for Backward Chaining\n",
      "commitDate": "2011-08-07, 10:15 PM",
      "commitName": "737a782e6b33789ebf21b932198e766754da3ad2",
      "commitAuthor": "Mark Proctor",
      "commitDateOld": "2011-08-07, 10:15 PM",
      "commitNameOld": "d2016311bdfc990efb7cc39c847df8e9abb09f13",
      "commitAuthorOld": "Mark Proctor",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,169 +1,196 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n-                                        prefixPattern );\n+                                        prefixPattern,\n+                                        (Query) context.getRule() );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule != null && rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n-                                           prefixPattern );\n-                } else {\n-                    // this isn't a query either, so log an error\n-                    context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n-                                                                  patternDescr,\n-                                                                  null,\n-                                                                  \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n+                                           prefixPattern,\n+                                           (Query) rule );\n                 }\n+                \n+                // try package imports\n+                for ( String importName : context.getDialect().getTypeResolver().getImports() ) {\n+                    importName = importName.trim();\n+                    int pos = importName.indexOf( '*' );\n+                    if ( pos >= 0 ) {\n+                        String pkgName = importName.substring( 0, pos-1 );\n+                        PackageRegistry pkgReg = context.getPackageBuilder().getPackageRegistry( pkgName );\n+                        if ( pkgReg != null ) {\n+                            rule = pkgReg.getPackage().getRule( patternDescr.getObjectType() );\n+                            if ( rule != null && rule instanceof Query ) {\n+                                // it's a query so delegate to the QueryElementBuilder\n+                                QueryElementBuilder qeBuilder = new QueryElementBuilder();\n+                                rce = qeBuilder.build( context,\n+                                                       descr,\n+                                                       prefixPattern,\n+                                                       (Query) rule);\n+                                break;\n+                            }                           \n+                        }\n+                    }\n+                }\n+                \n+            }\n+            \n+            if ( rce == null ) {\n+                // this isn't a query either, so log an error\n+                context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n+                                                              patternDescr,\n+                                                              null,\n+                                                              \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( ClassObjectType.Activation_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n             PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( AgendaItem.class );\n             if ( handler == null ) {\n                 PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( AgendaItem.class, new ActivationPropertyHandler() );\n             }\n         }\n         \n         if ( duplicateBindings ) {\n             if ( patternDescr.isUnification() ) {\n                 // rewrite existing bindings into == constraints, so it unifies\n                 build( context,\n                        patternDescr,\n                        pattern,\n                        \"this == \" + patternDescr.getIdentifier() );\n             } else {\n                 // This declaration already exists, so throw an Exception\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getTypeDeclaration( cls );\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context,\n                                     patternDescr,\n                                     pattern );\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "d2016311bdfc990efb7cc39c847df8e9abb09f13":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-3148 Dynamic Declarative Conflict Resolution\n",
      "commitDate": "2011-08-07, 10:15 PM",
      "commitName": "d2016311bdfc990efb7cc39c847df8e9abb09f13",
      "commitAuthor": "Mark Proctor",
      "commitDateOld": "2011-07-01, 6:22 PM",
      "commitNameOld": "e1495fac18c46d23945f93e3bd806420f6593596",
      "commitAuthorOld": "Edson Tirelli",
      "daysBetweenCommits": 37.16,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,162 +1,169 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule != null && rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern );\n                 } else {\n                     // this isn't a query either, so log an error\n                     context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                   patternDescr,\n                                                                   null,\n                                                                   \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 }\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n+        if ( ClassObjectType.Activation_ObjectType.isAssignableFrom( pattern.getObjectType() ) ) {\n+            PropertyHandler handler = PropertyHandlerFactory.getPropertyHandler( AgendaItem.class );\n+            if ( handler == null ) {\n+                PropertyHandlerFactoryFixer.getPropertyHandlerClass().put( AgendaItem.class, new ActivationPropertyHandler() );\n+            }\n+        }\n+        \n         if ( duplicateBindings ) {\n             if ( patternDescr.isUnification() ) {\n                 // rewrite existing bindings into == constraints, so it unifies\n                 build( context,\n                        patternDescr,\n                        pattern,\n                        \"this == \" + patternDescr.getIdentifier() );\n             } else {\n                 // This declaration already exists, so throw an Exception\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getTypeDeclaration( cls );\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n         // Process all constraints\n         processConstraintsAndBinds( context,\n                                     patternDescr,\n                                     pattern );\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "6c2f277aa88f93a960ca13ad0ab1ef13808aacc9":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-3025: fixing support for nested bindings\n",
      "commitDate": "2011-06-03, 1:15 PM",
      "commitName": "6c2f277aa88f93a960ca13ad0ab1ef13808aacc9",
      "commitAuthor": "Edson Tirelli",
      "commitDateOld": "2011-06-01, 5:03 PM",
      "commitNameOld": "1f11b6be67a3c01fdcba05e1af8085a13ab735a3",
      "commitAuthorOld": "Edson Tirelli",
      "daysBetweenCommits": 1.84,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,170 +1,162 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule != null && rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern );\n                 } else {\n                     // this isn't a query either, so log an error\n                     context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                   patternDescr,\n                                                                   null,\n                                                                   \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 }\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( duplicateBindings ) {\n             if ( patternDescr.isUnification() ) {\n                 // rewrite existing bindings into == constraints, so it unifies\n                 build( context,\n                        patternDescr,\n                        pattern,\n                        \"this == \" + patternDescr.getIdentifier() );\n             } else {\n                 // This declaration already exists, so throw an Exception\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getTypeDeclaration( cls );\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n-        List<BaseDescr> notAConstraints = processPositional( new ArrayList<BaseDescr>( patternDescr.getDescrs() ), // needs to be cloned\n-                                                             context,\n-                                                             patternDescr,\n-                                                             pattern );\n-        for ( BaseDescr nac : notAConstraints ) {\n-            patternDescr.removeConstraint( nac );\n-        }\n-\n         // Process all constraints\n         processConstraintsAndBinds( context,\n                                     patternDescr,\n                                     pattern );\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "1f11b6be67a3c01fdcba05e1af8085a13ab735a3":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-3025: adding support for nested bindings\n",
      "commitDate": "2011-06-01, 5:03 PM",
      "commitName": "1f11b6be67a3c01fdcba05e1af8085a13ab735a3",
      "commitAuthor": "Edson Tirelli",
      "commitDateOld": "2011-05-25, 9:41 PM",
      "commitNameOld": "109626f1603bb69b26c91f16e6efef3ea5d0b06a",
      "commitAuthorOld": "Mark Proctor",
      "daysBetweenCommits": 6.81,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,217 +1,170 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule != null && rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern );\n                 } else {\n                     // this isn't a query either, so log an error\n                     context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                   patternDescr,\n                                                                   null,\n                                                                   \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 }\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( duplicateBindings ) {\n             if ( patternDescr.isUnification() ) {\n                 // rewrite existing bindings into == constraints, so it unifies\n                 build( context,\n+                       patternDescr,\n                        pattern,\n-                       new ExprConstraintDescr( \"this == \" + patternDescr.getIdentifier() ) );\n+                       \"this == \" + patternDescr.getIdentifier() );\n             } else {\n                 // This declaration already exists, so throw an Exception\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n-                                                              \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );                \n+                                                              \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n-            Class cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n+            Class< ? > cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getTypeDeclaration( cls );\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n-\n-        List<BaseDescr> notAConstraints = processPositional(patternDescr.getDescrs(),context,patternDescr,pattern);\n-        for (BaseDescr nac : notAConstraints) {\n-            patternDescr.removeConstraint(nac);\n+        List<BaseDescr> notAConstraints = processPositional( new ArrayList<BaseDescr>( patternDescr.getDescrs() ), // needs to be cloned\n+                                                             context,\n+                                                             patternDescr,\n+                                                             pattern );\n+        for ( BaseDescr nac : notAConstraints ) {\n+            patternDescr.removeConstraint( nac );\n         }\n \n-\n-        for ( BindingDescr b : patternDescr.getBindings() ) {\n-            if ( true ) { // TODO: replace this by legacy mode configuration\n-                String expression = b.getExpression();\n-\n-                DrlExprParser parser = new DrlExprParser();\n-                ConstraintConnectiveDescr result = parser.parse( expression );\n-                if ( result == null || parser.hasErrors() ) {\n-                    for ( DroolsParserException error : parser.getErrors() ) {\n-                        context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n-                                                                      descr,\n-                                                                      null,\n-                                                                      \"Unable to parser pattern expression:\\n\" + error.getMessage() ) );\n-                    }\n-                    return null;\n-                }\n-                String left = parser.getLeftMostExpr();\n-                // HACK below. need to implement it properly\n-                if ( expression.equals( left ) ) {\n-                    // it is just a bind, so build it\n-                    buildRuleBindings( context,\n-                                       pattern,\n-                                       b,\n-                                       null ); // null containers get added to the pattern\n-                } else {\n-                    // it is both a binding and a constraint\n-                    b.setExpression( left );\n-                    buildRuleBindings( context,\n-                                       pattern,\n-                                       b,\n-                                       null ); // null containers get added to the pattern\n-                    b.setExpression( expression );\n-\n-                    // needs to build the actual constraints as well\n-                    build( context,\n-                           pattern,\n-                           new ExprConstraintDescr( b.getExpression() ) );\n-                }\n-\n-            } else {\n-                buildRuleBindings( context,\n-                                   pattern,\n-                                   b,\n-                                   null ); // null containers get added to the pattern\n-            }\n-        }\n-\n-\n-         for ( BaseDescr b : patternDescr.getDescrs() ) {\n-            build( context,\n-                   pattern,\n-                   (ExprConstraintDescr) b );\n-        }\n-\n+        // Process all constraints\n+        processConstraintsAndBinds( context,\n+                                    patternDescr,\n+                                    pattern );\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "3753cec5ecb606510152fe3ce46ba48e90d81c9b":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-3050 Use := for unification\n",
      "commitDate": "2011-05-24, 8:50 PM",
      "commitName": "3753cec5ecb606510152fe3ce46ba48e90d81c9b",
      "commitAuthor": "Mark Proctor",
      "commitDateOld": "2011-05-24, 2:19 PM",
      "commitNameOld": "117a421201a430869267336c912d83f649d5751b",
      "commitAuthorOld": "Mark Proctor",
      "daysBetweenCommits": 0.27,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,209 +1,217 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule != null && rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern );\n                 } else {\n                     // this isn't a query either, so log an error\n                     context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                   patternDescr,\n                                                                   null,\n                                                                   \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 }\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( duplicateBindings ) {\n-            // rewrite existing bindings into == constraints, so it unifies\n-            build( context,\n-                   pattern,\n-                   new ExprConstraintDescr( \"this == \" + patternDescr.getIdentifier() ) );\n+            if ( patternDescr.isUnification() ) {\n+                // rewrite existing bindings into == constraints, so it unifies\n+                build( context,\n+                       pattern,\n+                       new ExprConstraintDescr( \"this == \" + patternDescr.getIdentifier() ) );\n+            } else {\n+                // This declaration already exists, so throw an Exception\n+                context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n+                                                              patternDescr,\n+                                                              null,\n+                                                              \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );                \n+            }\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getTypeDeclaration( cls );\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n \n         List<BaseDescr> notAConstraints = processPositional(patternDescr.getDescrs(),context,patternDescr,pattern);\n         for (BaseDescr nac : notAConstraints) {\n             patternDescr.removeConstraint(nac);\n         }\n \n \n         for ( BindingDescr b : patternDescr.getBindings() ) {\n             if ( true ) { // TODO: replace this by legacy mode configuration\n                 String expression = b.getExpression();\n \n                 DrlExprParser parser = new DrlExprParser();\n                 ConstraintConnectiveDescr result = parser.parse( expression );\n                 if ( result == null || parser.hasErrors() ) {\n                     for ( DroolsParserException error : parser.getErrors() ) {\n                         context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                       descr,\n                                                                       null,\n                                                                       \"Unable to parser pattern expression:\\n\" + error.getMessage() ) );\n                     }\n                     return null;\n                 }\n                 String left = parser.getLeftMostExpr();\n                 // HACK below. need to implement it properly\n                 if ( expression.equals( left ) ) {\n                     // it is just a bind, so build it\n                     buildRuleBindings( context,\n                                        pattern,\n                                        b,\n                                        null ); // null containers get added to the pattern\n                 } else {\n                     // it is both a binding and a constraint\n                     b.setExpression( left );\n                     buildRuleBindings( context,\n                                        pattern,\n                                        b,\n                                        null ); // null containers get added to the pattern\n                     b.setExpression( expression );\n \n                     // needs to build the actual constraints as well\n                     build( context,\n                            pattern,\n                            new ExprConstraintDescr( b.getExpression() ) );\n                 }\n \n             } else {\n                 buildRuleBindings( context,\n                                    pattern,\n                                    b,\n                                    null ); // null containers get added to the pattern\n             }\n         }\n \n \n          for ( BaseDescr b : patternDescr.getDescrs() ) {\n             build( context,\n                    pattern,\n                    (ExprConstraintDescr) b );\n         }\n \n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "c9cd8f6e3a1d979aca593866093017286144f2ba":
    {
      "type": "Ybodychange",
      "commitMessage": "typo's: mainly bellow instead below\n",
      "commitDate": "2011-05-18, 7:09 AM",
      "commitName": "c9cd8f6e3a1d979aca593866093017286144f2ba",
      "commitAuthor": "Geoffrey De Smet",
      "commitDateOld": "2011-05-02, 9:47 PM",
      "commitNameOld": "d1cb1b264610a1a17b631fda5a1574ff9d208be9",
      "commitAuthorOld": "Mark Proctor",
      "daysBetweenCommits": 15.39,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,209 +1,209 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule != null && rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern );\n                 } else {\n                     // this isn't a query either, so log an error\n                     context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                   patternDescr,\n                                                                   null,\n                                                                   \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 }\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( duplicateBindings ) {\n             // rewrite existing bindings into == constraints, so it unifies\n             build( context,\n                    pattern,\n                    new ExprConstraintDescr( \"this == \" + patternDescr.getIdentifier() ) );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getTypeDeclaration( cls );\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             } else {\n                 context.setTypesafe( true );\n             }\n         }\n \n \n         List<BaseDescr> notAConstraints = processPositional(patternDescr.getDescrs(),context,patternDescr,pattern);\n         for (BaseDescr nac : notAConstraints) {\n             patternDescr.removeConstraint(nac);\n         }\n \n \n         for ( BindingDescr b : patternDescr.getBindings() ) {\n             if ( true ) { // TODO: replace this by legacy mode configuration\n                 String expression = b.getExpression();\n \n                 DrlExprParser parser = new DrlExprParser();\n                 ConstraintConnectiveDescr result = parser.parse( expression );\n                 if ( result == null || parser.hasErrors() ) {\n                     for ( DroolsParserException error : parser.getErrors() ) {\n                         context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                       descr,\n                                                                       null,\n                                                                       \"Unable to parser pattern expression:\\n\" + error.getMessage() ) );\n                     }\n                     return null;\n                 }\n                 String left = parser.getLeftMostExpr();\n-                // BELLOW is a hack.. need to implement it properly\n+                // HACK below. need to implement it properly\n                 if ( expression.equals( left ) ) {\n                     // it is just a bind, so build it\n                     buildRuleBindings( context,\n                                        pattern,\n                                        b,\n                                        null ); // null containers get added to the pattern\n                 } else {\n                     // it is both a binding and a constraint\n                     b.setExpression( left );\n                     buildRuleBindings( context,\n                                        pattern,\n                                        b,\n                                        null ); // null containers get added to the pattern\n                     b.setExpression( expression );\n \n                     // needs to build the actual constraints as well\n                     build( context,\n                            pattern,\n                            new ExprConstraintDescr( b.getExpression() ) );\n                 }\n \n             } else {\n                 buildRuleBindings( context,\n                                    pattern,\n                                    b,\n                                    null ); // null containers get added to the pattern\n             }\n         }\n \n \n          for ( BaseDescr b : patternDescr.getDescrs() ) {\n             build( context,\n                    pattern,\n                    (ExprConstraintDescr) b );\n         }\n \n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "1b722bdba60aac44883c35da443323988baf0957":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-2925 Support for non typesafe classes\n-further changes to support typesafe(false) in evals etc\n",
      "commitDate": "2011-04-27, 3:02 PM",
      "commitName": "1b722bdba60aac44883c35da443323988baf0957",
      "commitAuthor": "Mark Proctor",
      "commitDateOld": "2011-04-25, 1:58 PM",
      "commitNameOld": "e3dad656801004ac067cbe6e5dd2b12b8c8b4cb8",
      "commitAuthorOld": "Mark Proctor",
      "daysBetweenCommits": 2.04,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,207 +1,209 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule != null && rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern );\n                 } else {\n                     // this isn't a query either, so log an error\n                     context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                   patternDescr,\n                                                                   null,\n                                                                   \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 }\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( duplicateBindings ) {\n             // rewrite existing bindings into == constraints, so it unifies\n             build( context,\n                    pattern,\n                    new ExprConstraintDescr( \"this == \" + patternDescr.getIdentifier() ) );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getTypeDeclaration( cls );\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n+            } else {\n+                context.setTypesafe( true );\n             }\n         }\n \n \n         List<BaseDescr> notAConstraints = processPositional(patternDescr.getDescrs(),context,patternDescr,pattern);\n         for (BaseDescr nac : notAConstraints) {\n             patternDescr.removeConstraint(nac);\n         }\n \n \n         for ( BindingDescr b : patternDescr.getBindings() ) {\n             if ( true ) { // TODO: replace this by legacy mode configuration\n                 String expression = b.getExpression();\n \n                 DrlExprParser parser = new DrlExprParser();\n                 ConstraintConnectiveDescr result = parser.parse( expression );\n                 if ( result == null || parser.hasErrors() ) {\n                     for ( DroolsParserException error : parser.getErrors() ) {\n                         context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                       descr,\n                                                                       null,\n                                                                       \"Unable to parser pattern expression:\\n\" + error.getMessage() ) );\n                     }\n                     return null;\n                 }\n                 String left = parser.getLeftMostExpr();\n                 // BELLOW is a hack.. need to implement it properly\n                 if ( expression.equals( left ) ) {\n                     // it is just a bind, so build it\n                     buildRuleBindings( context,\n                                        pattern,\n                                        b,\n                                        null ); // null containers get added to the pattern\n                 } else {\n                     // it is both a binding and a constraint\n                     b.setExpression( left );\n                     buildRuleBindings( context,\n                                        pattern,\n                                        b,\n                                        null ); // null containers get added to the pattern\n                     b.setExpression( expression );\n \n                     // needs to build the actual constraints as well\n                     build( context,\n                            pattern,\n                            new ExprConstraintDescr( b.getExpression() ) );\n                 }\n \n             } else {\n                 buildRuleBindings( context,\n                                    pattern,\n                                    b,\n                                    null ); // null containers get added to the pattern\n             }\n         }\n \n \n          for ( BaseDescr b : patternDescr.getDescrs() ) {\n             build( context,\n                    pattern,\n                    (ExprConstraintDescr) b );\n         }\n \n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "d3b711cafc3d086b6b3caeab4b6eb5abe6bc79e3":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-2762 ArrayIndexOutOfBoundsException in org.drools.core.util.AbstractHashTable\n",
      "commitDate": "2011-04-20, 2:56 AM",
      "commitName": "d3b711cafc3d086b6b3caeab4b6eb5abe6bc79e3",
      "commitAuthor": "Mark Proctor",
      "commitDateOld": "2011-04-19, 12:07 AM",
      "commitNameOld": "147d70fbe76d802bdd3c933f7950c0eafac473d0",
      "commitAuthorOld": "Mark Proctor",
      "daysBetweenCommits": 1.12,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,207 +1,207 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             RuleConditionElement rce = null;\n             // it might be a recursive query, so check for same names\n             if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern );\n             }\n \n             if ( rce == null ) {\n                 Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n                 if ( rule != null && rule instanceof Query ) {\n                     // it's a query so delegate to the QueryElementBuilder\n                     QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                     rce = qeBuilder.build( context,\n                                            descr,\n                                            prefixPattern );\n                 } else {\n                     // this isn't a query either, so log an error\n                     context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                   patternDescr,\n                                                                   null,\n                                                                   \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 }\n             }\n             return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( duplicateBindings ) {\n             // rewrite existing bindings into == constraints, so it unifies\n             build( context,\n                    pattern,\n                    new ExprConstraintDescr( \"this == \" + patternDescr.getIdentifier() ) );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getTypeDeclaration( cls );\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             }\n         }\n \n \n         List<BaseDescr> notAConstraints = processPositional(patternDescr.getDescrs(),context,patternDescr,pattern);\n         for (BaseDescr nac : notAConstraints) {\n             patternDescr.removeConstraint(nac);\n         }\n \n \n         for ( BindingDescr b : patternDescr.getBindings() ) {\n             if ( true ) { // TODO: replace this by legacy mode configuration\n                 String expression = b.getExpression();\n \n                 DrlExprParser parser = new DrlExprParser();\n                 ConstraintConnectiveDescr result = parser.parse( expression );\n-                if ( parser.hasErrors() ) {\n+                if ( result == null || parser.hasErrors() ) {\n                     for ( DroolsParserException error : parser.getErrors() ) {\n                         context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                       descr,\n                                                                       null,\n                                                                       \"Unable to parser pattern expression:\\n\" + error.getMessage() ) );\n                     }\n                     return null;\n                 }\n                 String left = parser.getLeftMostExpr();\n                 // BELLOW is a hack.. need to implement it properly\n                 if ( expression.equals( left ) ) {\n                     // it is just a bind, so build it\n                     buildRuleBindings( context,\n                                        pattern,\n                                        b,\n                                        null ); // null containers get added to the pattern\n                 } else {\n                     // it is both a binding and a constraint\n                     b.setExpression( left );\n                     buildRuleBindings( context,\n                                        pattern,\n                                        b,\n                                        null ); // null containers get added to the pattern\n                     b.setExpression( expression );\n \n                     // needs to build the actual constraints as well\n                     build( context,\n                            pattern,\n                            new ExprConstraintDescr( b.getExpression() ) );\n                 }\n \n             } else {\n                 buildRuleBindings( context,\n                                    pattern,\n                                    b,\n                                    null ); // null containers get added to the pattern\n             }\n         }\n \n \n          for ( BaseDescr b : patternDescr.getDescrs() ) {\n             build( context,\n                    pattern,\n                    (ExprConstraintDescr) b );\n         }\n \n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "147d70fbe76d802bdd3c933f7950c0eafac473d0":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-47 Prolog Style Query Based Backward Chaining\n-recursion now works\n-? prefix enforced\n-; separator enforced\n",
      "commitDate": "2011-04-19, 12:07 AM",
      "commitName": "147d70fbe76d802bdd3c933f7950c0eafac473d0",
      "commitAuthor": "Mark Proctor",
      "commitDateOld": "2011-04-18, 6:07 PM",
      "commitNameOld": "0285ff4a3e12bf5bb22313f8b77641c487806d44",
      "commitAuthorOld": "Mark Proctor",
      "daysBetweenCommits": 0.25,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,195 +1,207 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n-            Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n-            if ( rule != null && rule instanceof Query ) {\n+            RuleConditionElement rce = null;\n+            // it might be a recursive query, so check for same names\n+            if ( context.getRule().getName().equals( patternDescr.getObjectType() ) ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n-                return qeBuilder.build( context,\n+                rce = qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern );\n-            } else {\n-                // this isn't a query either, so log an error\n-                context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n-                                                              patternDescr,\n-                                                              null,\n-                                                              \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n-                return null;\n             }\n+\n+            if ( rce == null ) {\n+                Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n+                if ( rule != null && rule instanceof Query ) {\n+                    // it's a query so delegate to the QueryElementBuilder\n+                    QueryElementBuilder qeBuilder = new QueryElementBuilder();\n+                    rce = qeBuilder.build( context,\n+                                           descr,\n+                                           prefixPattern );\n+                } else {\n+                    // this isn't a query either, so log an error\n+                    context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n+                                                                  patternDescr,\n+                                                                  null,\n+                                                                  \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n+                }\n+            }\n+            return rce;\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( duplicateBindings ) {\n             // rewrite existing bindings into == constraints, so it unifies\n             build( context,\n                    pattern,\n                    new ExprConstraintDescr( \"this == \" + patternDescr.getIdentifier() ) );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getTypeDeclaration( cls );\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             }\n         }\n \n \n         List<BaseDescr> notAConstraints = processPositional(patternDescr.getDescrs(),context,patternDescr,pattern);\n         for (BaseDescr nac : notAConstraints) {\n             patternDescr.removeConstraint(nac);\n         }\n \n \n         for ( BindingDescr b : patternDescr.getBindings() ) {\n             if ( true ) { // TODO: replace this by legacy mode configuration\n                 String expression = b.getExpression();\n \n                 DrlExprParser parser = new DrlExprParser();\n                 ConstraintConnectiveDescr result = parser.parse( expression );\n                 if ( parser.hasErrors() ) {\n                     for ( DroolsParserException error : parser.getErrors() ) {\n                         context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                       descr,\n                                                                       null,\n                                                                       \"Unable to parser pattern expression:\\n\" + error.getMessage() ) );\n                     }\n                     return null;\n                 }\n                 String left = parser.getLeftMostExpr();\n                 // BELLOW is a hack.. need to implement it properly\n                 if ( expression.equals( left ) ) {\n                     // it is just a bind, so build it\n                     buildRuleBindings( context,\n                                        pattern,\n                                        b,\n                                        null ); // null containers get added to the pattern\n                 } else {\n                     // it is both a binding and a constraint\n                     b.setExpression( left );\n                     buildRuleBindings( context,\n                                        pattern,\n                                        b,\n                                        null ); // null containers get added to the pattern\n                     b.setExpression( expression );\n \n                     // needs to build the actual constraints as well\n                     build( context,\n                            pattern,\n                            new ExprConstraintDescr( b.getExpression() ) );\n                 }\n \n             } else {\n                 buildRuleBindings( context,\n                                    pattern,\n                                    b,\n                                    null ); // null containers get added to the pattern\n             }\n         }\n \n \n          for ( BaseDescr b : patternDescr.getDescrs() ) {\n             build( context,\n                    pattern,\n                    (ExprConstraintDescr) b );\n         }\n \n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "0285ff4a3e12bf5bb22313f8b77641c487806d44":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-47 Prolog Style Query Based Backward Chaining\n-Refactoring nani search to use type declaration ground facts directly\n",
      "commitDate": "2011-04-18, 6:07 PM",
      "commitName": "0285ff4a3e12bf5bb22313f8b77641c487806d44",
      "commitAuthor": "Mark Proctor",
      "commitDateOld": "2011-04-17, 9:18 PM",
      "commitNameOld": "0302cab989204f6c4bac4ad99395e47563c5504b",
      "commitAuthorOld": "Davide Sottara",
      "daysBetweenCommits": 0.87,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,200 +1,195 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n             if ( rule != null && rule instanceof Query ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 return qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern );\n             } else {\n                 // this isn't a query either, so log an error\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( duplicateBindings ) {\n             // rewrite existing bindings into == constraints, so it unifies\n             build( context,\n                    pattern,\n                    new ExprConstraintDescr( \"this == \" + patternDescr.getIdentifier() ) );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getTypeDeclaration( cls );\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             }\n         }\n \n \n         List<BaseDescr> notAConstraints = processPositional(patternDescr.getDescrs(),context,patternDescr,pattern);\n-        for (BaseDescr nac : notAConstraints)\n+        for (BaseDescr nac : notAConstraints) {\n             patternDescr.removeConstraint(nac);\n+        }\n \n \n         for ( BindingDescr b : patternDescr.getBindings() ) {\n             if ( true ) { // TODO: replace this by legacy mode configuration\n                 String expression = b.getExpression();\n \n                 DrlExprParser parser = new DrlExprParser();\n                 ConstraintConnectiveDescr result = parser.parse( expression );\n                 if ( parser.hasErrors() ) {\n                     for ( DroolsParserException error : parser.getErrors() ) {\n                         context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                       descr,\n                                                                       null,\n                                                                       \"Unable to parser pattern expression:\\n\" + error.getMessage() ) );\n                     }\n                     return null;\n                 }\n                 String left = parser.getLeftMostExpr();\n                 // BELLOW is a hack.. need to implement it properly\n                 if ( expression.equals( left ) ) {\n                     // it is just a bind, so build it\n                     buildRuleBindings( context,\n                                        pattern,\n                                        b,\n                                        null ); // null containers get added to the pattern\n                 } else {\n                     // it is both a binding and a constraint\n                     b.setExpression( left );\n                     buildRuleBindings( context,\n                                        pattern,\n                                        b,\n                                        null ); // null containers get added to the pattern\n                     b.setExpression( expression );\n \n                     // needs to build the actual constraints as well\n                     build( context,\n                            pattern,\n                            new ExprConstraintDescr( b.getExpression() ) );\n                 }\n \n             } else {\n                 buildRuleBindings( context,\n                                    pattern,\n                                    b,\n                                    null ); // null containers get added to the pattern\n             }\n         }\n \n-//        BaseDescr temp = context.getParentDescr();\n-//        context.setParentDescr(patternDescr);\n-\n-\n-//        context.setParentDescr(temp);\n-\n \n          for ( BaseDescr b : patternDescr.getDescrs() ) {\n             build( context,\n                    pattern,\n                    (ExprConstraintDescr) b );\n         }\n \n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "0302cab989204f6c4bac4ad99395e47563c5504b":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES 2948 - Decouple PMML and Compiler\n",
      "commitDate": "2011-04-17, 9:18 PM",
      "commitName": "0302cab989204f6c4bac4ad99395e47563c5504b",
      "commitAuthor": "Davide Sottara",
      "commitDateOld": "2011-04-08, 2:09 PM",
      "commitNameOld": "3704c7ef54be27d10c988126a0ed01607dd72d67",
      "commitAuthorOld": "Edson Tirelli",
      "daysBetweenCommits": 9.3,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,186 +1,200 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n             if ( rule != null && rule instanceof Query ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 return qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern );\n             } else {\n                 // this isn't a query either, so log an error\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( duplicateBindings ) {\n             // rewrite existing bindings into == constraints, so it unifies\n             build( context,\n                    pattern,\n                    new ExprConstraintDescr( \"this == \" + patternDescr.getIdentifier() ) );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getTypeDeclaration( cls );\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             }\n         }\n \n+\n+        List<BaseDescr> notAConstraints = processPositional(patternDescr.getDescrs(),context,patternDescr,pattern);\n+        for (BaseDescr nac : notAConstraints)\n+            patternDescr.removeConstraint(nac);\n+\n+\n         for ( BindingDescr b : patternDescr.getBindings() ) {\n             if ( true ) { // TODO: replace this by legacy mode configuration\n                 String expression = b.getExpression();\n \n                 DrlExprParser parser = new DrlExprParser();\n                 ConstraintConnectiveDescr result = parser.parse( expression );\n                 if ( parser.hasErrors() ) {\n                     for ( DroolsParserException error : parser.getErrors() ) {\n                         context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                       descr,\n                                                                       null,\n                                                                       \"Unable to parser pattern expression:\\n\" + error.getMessage() ) );\n                     }\n                     return null;\n                 }\n                 String left = parser.getLeftMostExpr();\n                 // BELLOW is a hack.. need to implement it properly\n                 if ( expression.equals( left ) ) {\n                     // it is just a bind, so build it\n                     buildRuleBindings( context,\n                                        pattern,\n                                        b,\n                                        null ); // null containers get added to the pattern\n                 } else {\n                     // it is both a binding and a constraint\n                     b.setExpression( left );\n                     buildRuleBindings( context,\n                                        pattern,\n                                        b,\n                                        null ); // null containers get added to the pattern\n                     b.setExpression( expression );\n \n                     // needs to build the actual constraints as well\n                     build( context,\n                            pattern,\n                            new ExprConstraintDescr( b.getExpression() ) );\n                 }\n \n             } else {\n                 buildRuleBindings( context,\n                                    pattern,\n                                    b,\n                                    null ); // null containers get added to the pattern\n             }\n         }\n \n-        for ( BaseDescr b : patternDescr.getDescrs() ) {\n+//        BaseDescr temp = context.getParentDescr();\n+//        context.setParentDescr(patternDescr);\n+\n+\n+//        context.setParentDescr(temp);\n+\n+\n+         for ( BaseDescr b : patternDescr.getDescrs() ) {\n             build( context,\n                    pattern,\n                    (ExprConstraintDescr) b );\n         }\n \n+\n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "bfb05f782014ca889b0312d57afbaa1c870088b8":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-2642: Fixing behavior parsing\n",
      "commitDate": "2011-03-21, 12:54 PM",
      "commitName": "bfb05f782014ca889b0312d57afbaa1c870088b8",
      "commitAuthor": "Edson Tirelli",
      "commitDateOld": "2011-03-18, 1:34 PM",
      "commitNameOld": "34acac30b502c48871c464c9d3805ec5fd85cb05",
      "commitAuthorOld": "Edson Tirelli",
      "daysBetweenCommits": 2.97,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,186 +1,186 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n                 org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n                 final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n             if ( rule != null && rule instanceof Query ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 return qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern );\n             } else {\n                 // this isn't a query either, so log an error\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( duplicateBindings ) {\n             // rewrite existing bindings into == constraints, so it unifies\n             build( context,\n                    pattern,\n                    new ExprConstraintDescr( \"this == \" + patternDescr.getIdentifier() ) );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getTypeDeclaration( cls );\n             if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             }\n         }\n \n         for ( BindingDescr b : patternDescr.getBindings() ) {\n             if ( true ) { // TODO: replace this by legacy mode configuration\n                 String expression = b.getExpression();\n \n                 DrlExprParser parser = new DrlExprParser();\n                 ConstraintConnectiveDescr result = parser.parse( expression );\n                 if ( parser.hasErrors() ) {\n                     for ( DroolsParserException error : parser.getErrors() ) {\n                         context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                       descr,\n                                                                       null,\n                                                                       \"Unable to parser pattern expression:\\n\" + error.getMessage() ) );\n                     }\n                     return null;\n                 }\n                 String left = parser.getLeftMostExpr();\n                 // BELLOW is a hack.. need to implement it properly\n                 if ( expression.equals( left ) ) {\n                     // it is just a bind, so build it\n                     buildRuleBindings( context,\n                                        pattern,\n                                        b,\n                                        null ); // null containers get added to the pattern\n                 } else {\n                     // it is both a binding and a constraint\n                     b.setExpression( left );\n                     buildRuleBindings( context,\n                                        pattern,\n                                        b,\n                                        null ); // null containers get added to the pattern\n                     b.setExpression( expression );\n \n                     // needs to build the actual constraints as well\n                     build( context,\n                            pattern,\n                            new ExprConstraintDescr( b.getExpression() ) );\n                 }\n \n             } else {\n                 buildRuleBindings( context,\n                                    pattern,\n                                    b,\n                                    null ); // null containers get added to the pattern\n             }\n         }\n \n         for ( BaseDescr b : patternDescr.getDescrs() ) {\n             build( context,\n                    pattern,\n                    (ExprConstraintDescr) b );\n         }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n-                    SlidingTimeWindow window = new SlidingTimeWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n+                    SlidingTimeWindow window = new SlidingTimeWindow( TimeUtils.parseTimeString( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n                     SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "26d7c7cdad431e36f0276d91baa12ecf6d4cd50a":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-2642: adding support for pattern behaviors\n",
      "commitDate": "2011-03-17, 3:40 PM",
      "commitName": "26d7c7cdad431e36f0276d91baa12ecf6d4cd50a",
      "commitAuthor": "Edson Tirelli",
      "commitDateOld": "2011-03-17, 12:31 PM",
      "commitNameOld": "b4f88934d46c87d112719d9ee48a7fc8d0cc9f33",
      "commitAuthorOld": "Edson Tirelli",
      "daysBetweenCommits": 0.13,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,186 +1,186 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n-                final Class<?> userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n-                final boolean isEvent = context.getPackageBuilder().getPackageRegistry( userProvidedClass.getPackage().getName() ).getPackage().isEvent( userProvidedClass );\n+                final Class< ? > userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n+                PackageRegistry pkgr = context.getPackageBuilder().getPackageRegistry( ClassUtils.getPackage( userProvidedClass ) );\n+                org.drools.rule.Package pkg = pkgr == null ? context.getPkg() : pkgr.getPackage();\n+                final boolean isEvent = pkg.isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n             if ( rule != null && rule instanceof Query ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 return qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern );\n             } else {\n                 // this isn't a query either, so log an error\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( duplicateBindings ) {\n             // rewrite existing bindings into == constraints, so it unifies\n-            build(context, \n-                  pattern, \n-                  new ExprConstraintDescr(\"this == \" + patternDescr.getIdentifier() ));            \n+            build( context,\n+                   pattern,\n+                   new ExprConstraintDescr( \"this == \" + patternDescr.getIdentifier() ) );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n-        \n+\n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n-            Class cls = ((ClassObjectType)pattern.getObjectType()).getClassType();\n+            Class cls = ((ClassObjectType) pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getTypeDeclaration( cls );\n-            if  ( typeDeclr != null ) {\n+            if ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             }\n         }\n \n         for ( BindingDescr b : patternDescr.getBindings() ) {\n             if ( true ) { // TODO: replace this by legacy mode configuration\n                 String expression = b.getExpression();\n \n                 DrlExprParser parser = new DrlExprParser();\n                 ConstraintConnectiveDescr result = parser.parse( expression );\n                 if ( parser.hasErrors() ) {\n                     for ( DroolsParserException error : parser.getErrors() ) {\n                         context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                       descr,\n                                                                       null,\n                                                                       \"Unable to parser pattern expression:\\n\" + error.getMessage() ) );\n                     }\n                     return null;\n                 }\n                 String left = parser.getLeftMostExpr();\n                 // BELLOW is a hack.. need to implement it properly\n                 if ( expression.equals( left ) ) {\n                     // it is just a bind, so build it\n                     buildRuleBindings( context,\n-                           pattern,\n-                           b,\n-                           null ); // null containers get added to the pattern\n+                                       pattern,\n+                                       b,\n+                                       null ); // null containers get added to the pattern\n                 } else {\n                     // it is both a binding and a constraint\n                     b.setExpression( left );\n                     buildRuleBindings( context,\n                                        pattern,\n                                        b,\n                                        null ); // null containers get added to the pattern\n                     b.setExpression( expression );\n \n                     // needs to build the actual constraints as well\n-                    build(context,\n-                          pattern,\n-                          new ExprConstraintDescr( b.getExpression() ));\n+                    build( context,\n+                           pattern,\n+                           new ExprConstraintDescr( b.getExpression() ) );\n                 }\n \n             } else {\n                 buildRuleBindings( context,\n                                    pattern,\n                                    b,\n                                    null ); // null containers get added to the pattern\n             }\n         }\n \n         for ( BaseDescr b : patternDescr.getDescrs() ) {\n-            build(context,\n-                  pattern,\n-                 (ExprConstraintDescr) b);\n+            build( context,\n+                   pattern,\n+                   (ExprConstraintDescr) b );\n         }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n-                if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n-                    SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n-                    SlidingTimeWindow window = new SlidingTimeWindow( swd.getLength() );\n+                if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n+                    SlidingTimeWindow window = new SlidingTimeWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n-                } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getType() ) ) {\n-                    SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n-                    SlidingLengthWindow window = new SlidingLengthWindow( (int) swd.getLength() );\n+                } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getSubType() ) ) {\n+                    SlidingLengthWindow window = new SlidingLengthWindow( Integer.valueOf( behaviorDescr.getParameters().get( 0 ) ) );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "b4f88934d46c87d112719d9ee48a7fc8d0cc9f33":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-2642: fixing CEP tests\n",
      "commitDate": "2011-03-17, 12:31 PM",
      "commitName": "b4f88934d46c87d112719d9ee48a7fc8d0cc9f33",
      "commitAuthor": "Edson Tirelli",
      "commitDateOld": "2011-03-17, 5:33 AM",
      "commitNameOld": "9fb414148610e6c60aeff1f2fff60ba826be41d7",
      "commitAuthorOld": "Mark Proctor",
      "daysBetweenCommits": 0.29,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,186 +1,186 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n-                final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n-                final boolean isEvent = context.getPkg().isEvent( userProvidedClass );\n+                final Class<?> userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n+                final boolean isEvent = context.getPackageBuilder().getPackageRegistry( userProvidedClass.getPackage().getName() ).getPackage().isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n             if ( rule != null && rule instanceof Query ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 return qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern );\n             } else {\n                 // this isn't a query either, so log an error\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( duplicateBindings ) {\n             // rewrite existing bindings into == constraints, so it unifies\n             build(context, \n                   pattern, \n                   new ExprConstraintDescr(\"this == \" + patternDescr.getIdentifier() ));            \n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n         \n         if ( pattern.getObjectType() instanceof ClassObjectType ) {\n             Class cls = ((ClassObjectType)pattern.getObjectType()).getClassType();\n             TypeDeclaration typeDeclr = context.getPackageBuilder().getTypeDeclaration( cls );\n             if  ( typeDeclr != null ) {\n                 context.setTypesafe( typeDeclr.isTypesafe() );\n             }\n         }\n \n         for ( BindingDescr b : patternDescr.getBindings() ) {\n             if ( true ) { // TODO: replace this by legacy mode configuration\n                 String expression = b.getExpression();\n \n                 DrlExprParser parser = new DrlExprParser();\n                 ConstraintConnectiveDescr result = parser.parse( expression );\n                 if ( parser.hasErrors() ) {\n                     for ( DroolsParserException error : parser.getErrors() ) {\n                         context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                       descr,\n                                                                       null,\n                                                                       \"Unable to parser pattern expression:\\n\" + error.getMessage() ) );\n                     }\n                     return null;\n                 }\n                 String left = parser.getLeftMostExpr();\n                 // BELLOW is a hack.. need to implement it properly\n                 if ( expression.equals( left ) ) {\n                     // it is just a bind, so build it\n                     buildRuleBindings( context,\n                            pattern,\n                            b,\n                            null ); // null containers get added to the pattern\n                 } else {\n                     // it is both a binding and a constraint\n                     b.setExpression( left );\n                     buildRuleBindings( context,\n                                        pattern,\n                                        b,\n                                        null ); // null containers get added to the pattern\n                     b.setExpression( expression );\n \n                     // needs to build the actual constraints as well\n                     build(context,\n                           pattern,\n                           new ExprConstraintDescr( b.getExpression() ));\n                 }\n \n             } else {\n                 buildRuleBindings( context,\n                                    pattern,\n                                    b,\n                                    null ); // null containers get added to the pattern\n             }\n         }\n \n         for ( BaseDescr b : patternDescr.getDescrs() ) {\n             build(context,\n                   pattern,\n                  (ExprConstraintDescr) b);\n         }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingTimeWindow window = new SlidingTimeWindow( swd.getLength() );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingLengthWindow window = new SlidingLengthWindow( (int) swd.getLength() );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "0bde5484297adc1d0cd23c98d0a91e79c2124621":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-2642 Getting tests working for new updated parser.\\n removing old code\\nJBRULES-2925 Support for non typesafe classes\n",
      "commitDate": "2011-03-14, 6:39 PM",
      "commitName": "0bde5484297adc1d0cd23c98d0a91e79c2124621",
      "commitAuthor": "Mark Proctor",
      "commitDateOld": "2011-03-14, 12:28 PM",
      "commitNameOld": "f7338793da8774ff3d420cbed2bca0b02b6021d8",
      "commitAuthorOld": "Edson Tirelli",
      "daysBetweenCommits": 0.26,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,178 +1,186 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 final boolean isEvent = context.getPkg().isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n             if ( rule != null && rule instanceof Query ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 return qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern );\n             } else {\n                 // this isn't a query either, so log an error\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( duplicateBindings ) {\n             // rewrite existing bindings into == constraints, so it unifies\n             build(context, \n                   pattern, \n                   new ExprConstraintDescr(\"this == \" + patternDescr.getIdentifier() ));            \n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n+        \n+        if ( pattern.getObjectType() instanceof ClassObjectType ) {\n+            Class cls = ((ClassObjectType)pattern.getObjectType()).getClassType();\n+            TypeDeclaration typeDeclr = context.getPackageBuilder().getTypeDeclaration( cls );\n+            if  ( typeDeclr != null ) {\n+                context.setTypesafe( typeDeclr.isTypesafe() );\n+            }\n+        }\n \n         for ( BindingDescr b : patternDescr.getBindings() ) {\n             if ( true ) { // TODO: replace this by legacy mode configuration\n                 String expression = b.getExpression();\n \n                 DrlExprParser parser = new DrlExprParser();\n                 ConstraintConnectiveDescr result = parser.parse( expression );\n                 if ( parser.hasErrors() ) {\n                     for ( DroolsParserException error : parser.getErrors() ) {\n                         context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                       descr,\n                                                                       null,\n                                                                       \"Unable to parser pattern expression:\\n\" + error.getMessage() ) );\n                     }\n                     return null;\n                 }\n                 String left = parser.getLeftMostExpr();\n                 // BELLOW is a hack.. need to implement it properly\n                 if ( expression.equals( left ) ) {\n                     // it is just a bind, so build it\n                     buildRuleBindings( context,\n                            pattern,\n                            b,\n                            null ); // null containers get added to the pattern\n                 } else {\n                     // it is both a binding and a constraint\n                     b.setExpression( left );\n                     buildRuleBindings( context,\n                                        pattern,\n                                        b,\n                                        null ); // null containers get added to the pattern\n                     b.setExpression( expression );\n \n                     // needs to build the actual constraints as well\n                     build(context,\n                           pattern,\n                           new ExprConstraintDescr( b.getExpression() ));\n                 }\n \n             } else {\n                 buildRuleBindings( context,\n                                    pattern,\n                                    b,\n                                    null ); // null containers get added to the pattern\n             }\n         }\n \n         for ( BaseDescr b : patternDescr.getDescrs() ) {\n             build(context,\n                   pattern,\n                  (ExprConstraintDescr) b);\n         }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingTimeWindow window = new SlidingTimeWindow( swd.getLength() );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingLengthWindow window = new SlidingLengthWindow( (int) swd.getLength() );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "b07d76d37a64fc20d5501bdf40b4ef0034b40e1a":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-2642 Getting tests working for new updated parser.\\n removing old code\n",
      "commitDate": "2011-03-13, 6:52 PM",
      "commitName": "b07d76d37a64fc20d5501bdf40b4ef0034b40e1a",
      "commitAuthor": "Mark Proctor",
      "commitDateOld": "2011-03-13, 3:22 PM",
      "commitNameOld": "3b8a6e3dbaa24c6e9ec7469a351f2c9007550278",
      "commitAuthorOld": "Mark Proctor",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,182 +1,178 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 final boolean isEvent = context.getPkg().isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n             if ( rule != null && rule instanceof Query ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 return qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern );\n             } else {\n                 // this isn't a query either, so log an error\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( duplicateBindings ) {\n             // rewrite existing bindings into == constraints, so it unifies\n-            FieldConstraintDescr varDescr = new FieldConstraintDescr( \"this\" );\n-            varDescr.addRestriction( new VariableRestrictionDescr( \"==\",\n-                                                                   patternDescr.getIdentifier() ) );\n-            build( context,\n-                   pattern,\n-                   (FieldConstraintDescr) varDescr,\n-                   null );\n+            build(context, \n+                  pattern, \n+                  new ExprConstraintDescr(\"this == \" + patternDescr.getIdentifier() ));            \n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( BindingDescr b : patternDescr.getBindings() ) {\n             if ( true ) { // TODO: replace this by legacy mode configuration\n                 String expression = b.getExpression();\n \n                 DrlExprParser parser = new DrlExprParser();\n                 ConstraintConnectiveDescr result = parser.parse( expression );\n                 if ( parser.hasErrors() ) {\n                     for ( DroolsParserException error : parser.getErrors() ) {\n                         context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                       descr,\n                                                                       null,\n                                                                       \"Unable to parser pattern expression:\\n\" + error.getMessage() ) );\n                     }\n                     return null;\n                 }\n                 String left = parser.getLeftMostExpr();\n                 // BELLOW is a hack.. need to implement it properly\n                 if ( expression.equals( left ) ) {\n                     // it is just a bind, so build it\n                     buildRuleBindings( context,\n                            pattern,\n                            b,\n                            null ); // null containers get added to the pattern\n                 } else {\n                     // it is both a binding and a constraint\n                     b.setExpression( left );\n                     buildRuleBindings( context,\n                                        pattern,\n                                        b,\n                                        null ); // null containers get added to the pattern\n                     b.setExpression( expression );\n \n                     // needs to build the actual constraints as well\n                     build(context,\n                           pattern,\n                           new ExprConstraintDescr( b.getExpression() ));\n                 }\n \n             } else {\n                 buildRuleBindings( context,\n                                    pattern,\n                                    b,\n                                    null ); // null containers get added to the pattern\n             }\n         }\n \n         for ( BaseDescr b : patternDescr.getDescrs() ) {\n             build(context,\n                   pattern,\n                  (ExprConstraintDescr) b);\n         }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingTimeWindow window = new SlidingTimeWindow( swd.getLength() );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingLengthWindow window = new SlidingLengthWindow( (int) swd.getLength() );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "2cdbe46621379b920f6965a29aa3d62a2a1568db":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-2642 Getting tests working for new updated parser.\\n removed uneeded index/literal/variable collections\n",
      "commitDate": "2011-03-12, 8:16 AM",
      "commitName": "2cdbe46621379b920f6965a29aa3d62a2a1568db",
      "commitAuthor": "Mark Proctor",
      "commitDateOld": "2011-03-12, 8:01 AM",
      "commitNameOld": "27a7c75df9c9baaa3391a769567152c476dbd624",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,219 +1,182 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 final boolean isEvent = context.getPkg().isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n             if ( rule != null && rule instanceof Query ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 return qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern );\n             } else {\n                 // this isn't a query either, so log an error\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( duplicateBindings ) {\n             // rewrite existing bindings into == constraints, so it unifies\n             FieldConstraintDescr varDescr = new FieldConstraintDescr( \"this\" );\n             varDescr.addRestriction( new VariableRestrictionDescr( \"==\",\n                                                                    patternDescr.getIdentifier() ) );\n             build( context,\n                    pattern,\n                    (FieldConstraintDescr) varDescr,\n                    null );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n-        List<DescrBranch> literalConstraints = new ArrayList<DescrBranch>();\n-        List<DescrBranch> literalIndexes = new ArrayList<DescrBranch>();\n-        List<DescrBranch> variableConstraints = new ArrayList<DescrBranch>();\n-        List<DescrBranch> variableIndexes = new ArrayList<DescrBranch>();\n-\n         for ( BindingDescr b : patternDescr.getBindings() ) {\n             if ( true ) { // TODO: replace this by legacy mode configuration\n                 String expression = b.getExpression();\n \n                 DrlExprParser parser = new DrlExprParser();\n                 ConstraintConnectiveDescr result = parser.parse( expression );\n                 if ( parser.hasErrors() ) {\n                     for ( DroolsParserException error : parser.getErrors() ) {\n                         context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                       descr,\n                                                                       null,\n                                                                       \"Unable to parser pattern expression:\\n\" + error.getMessage() ) );\n                     }\n                     return null;\n                 }\n                 String left = parser.getLeftMostExpr();\n                 // BELLOW is a hack.. need to implement it properly\n                 if ( expression.equals( left ) ) {\n                     // it is just a bind, so build it\n                     buildRuleBindings( context,\n                            pattern,\n                            b,\n                            null ); // null containers get added to the pattern\n                 } else {\n                     // it is both a binding and a constraint\n                     b.setExpression( left );\n                     buildRuleBindings( context,\n                                        pattern,\n                                        b,\n                                        null ); // null containers get added to the pattern\n                     b.setExpression( expression );\n \n                     // needs to build the actual constraints as well\n                     build(context,\n                           pattern,\n                           new ExprConstraintDescr( b.getExpression() ));\n                 }\n \n             } else {\n                 buildRuleBindings( context,\n                                    pattern,\n                                    b,\n                                    null ); // null containers get added to the pattern\n             }\n         }\n \n         for ( BaseDescr b : patternDescr.getDescrs() ) {\n             build(context,\n                   pattern,\n                  (ExprConstraintDescr) b);\n-//            processExpr( context,\n-//                         (ExprConstraintDescr) b,\n-//                         literalIndexes,\n-//                         literalConstraints,\n-//                         variableIndexes,\n-//                         variableConstraints );\n         }\n \n-//        for ( DescrBranch branch : literalIndexes ) {\n-//            buildLiteralConstraint( context,\n-//                                    pattern,\n-//                                    branch,\n-//                                    null );\n-//        }\n-//        for ( DescrBranch branch : literalConstraints ) {\n-//            buildLiteralConstraint( context,\n-//                                    pattern,\n-//                                    branch,\n-//                                    null );\n-//        }\n-//\n-//        for ( DescrBranch branch : variableIndexes ) {\n-//            buildVariableConstraint( context,\n-//                                     pattern,\n-//                                     branch,\n-//                                     null );\n-//        }\n-//        for ( DescrBranch branch : variableConstraints ) {\n-//            buildVariableConstraint( context,\n-//                                     pattern,\n-//                                     branch,\n-//                                     null );\n-//        }\n-\n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingTimeWindow window = new SlidingTimeWindow( swd.getLength() );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingLengthWindow window = new SlidingLengthWindow( (int) swd.getLength() );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "904381266a0e9d51f37646c0cf345af50d625250":
    {
      "type": "Ybodychange",
      "commitMessage": "refactored to a single build method to help structure things, will split up again later\n",
      "commitDate": "2011-03-12, 8:01 AM",
      "commitName": "904381266a0e9d51f37646c0cf345af50d625250",
      "commitAuthor": "Mark Proctor",
      "commitDateOld": "2011-03-09, 5:43 PM",
      "commitNameOld": "09ee9a761c109c31cd8789ec5e3419e9c083d302",
      "commitAuthorOld": "Mark Proctor",
      "daysBetweenCommits": 2.6,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,219 +1,219 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 final boolean isEvent = context.getPkg().isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n             if ( rule != null && rule instanceof Query ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 return qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern );\n             } else {\n                 // this isn't a query either, so log an error\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( duplicateBindings ) {\n             // rewrite existing bindings into == constraints, so it unifies\n             FieldConstraintDescr varDescr = new FieldConstraintDescr( \"this\" );\n             varDescr.addRestriction( new VariableRestrictionDescr( \"==\",\n                                                                    patternDescr.getIdentifier() ) );\n             build( context,\n                    pattern,\n                    (FieldConstraintDescr) varDescr,\n                    null );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         List<DescrBranch> literalConstraints = new ArrayList<DescrBranch>();\n         List<DescrBranch> literalIndexes = new ArrayList<DescrBranch>();\n         List<DescrBranch> variableConstraints = new ArrayList<DescrBranch>();\n         List<DescrBranch> variableIndexes = new ArrayList<DescrBranch>();\n \n         for ( BindingDescr b : patternDescr.getBindings() ) {\n             if ( true ) { // TODO: replace this by legacy mode configuration\n                 String expression = b.getExpression();\n \n                 DrlExprParser parser = new DrlExprParser();\n                 ConstraintConnectiveDescr result = parser.parse( expression );\n                 if ( parser.hasErrors() ) {\n                     for ( DroolsParserException error : parser.getErrors() ) {\n                         context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                       descr,\n                                                                       null,\n                                                                       \"Unable to parser pattern expression:\\n\" + error.getMessage() ) );\n                     }\n                     return null;\n                 }\n                 String left = parser.getLeftMostExpr();\n                 // BELLOW is a hack.. need to implement it properly\n                 if ( expression.equals( left ) ) {\n                     // it is just a bind, so build it\n-                    build( context,\n+                    buildRuleBindings( context,\n                            pattern,\n                            b,\n                            null ); // null containers get added to the pattern\n                 } else {\n                     // it is both a binding and a constraint\n                     b.setExpression( left );\n-                    build( context,\n-                           pattern,\n-                           b,\n-                           null ); // null containers get added to the pattern\n+                    buildRuleBindings( context,\n+                                       pattern,\n+                                       b,\n+                                       null ); // null containers get added to the pattern\n                     b.setExpression( expression );\n \n                     // needs to build the actual constraints as well\n-                    processExpr( context,\n-                                 new ExprConstraintDescr( b.getExpression() ),\n-                                 literalIndexes,\n-                                 literalConstraints,\n-                                 variableIndexes,\n-                                 variableConstraints );\n+                    build(context,\n+                          pattern,\n+                          new ExprConstraintDescr( b.getExpression() ));\n                 }\n \n             } else {\n-                build( context,\n-                       pattern,\n-                       b,\n-                       null ); // null containers get added to the pattern\n+                buildRuleBindings( context,\n+                                   pattern,\n+                                   b,\n+                                   null ); // null containers get added to the pattern\n             }\n         }\n \n         for ( BaseDescr b : patternDescr.getDescrs() ) {\n-            processExpr( context,\n-                         (ExprConstraintDescr) b,\n-                         literalIndexes,\n-                         literalConstraints,\n-                         variableIndexes,\n-                         variableConstraints );\n+            build(context,\n+                  pattern,\n+                 (ExprConstraintDescr) b);\n+//            processExpr( context,\n+//                         (ExprConstraintDescr) b,\n+//                         literalIndexes,\n+//                         literalConstraints,\n+//                         variableIndexes,\n+//                         variableConstraints );\n         }\n \n-        for ( DescrBranch branch : literalIndexes ) {\n-            buildLiteralConstraint( context,\n-                                    pattern,\n-                                    branch,\n-                                    null );\n-        }\n-        for ( DescrBranch branch : literalConstraints ) {\n-            buildLiteralConstraint( context,\n-                                    pattern,\n-                                    branch,\n-                                    null );\n-        }\n-\n-        for ( DescrBranch branch : variableIndexes ) {\n-            buildVariableConstraint( context,\n-                                     pattern,\n-                                     branch,\n-                                     null );\n-        }\n-        for ( DescrBranch branch : variableConstraints ) {\n-            buildVariableConstraint( context,\n-                                     pattern,\n-                                     branch,\n-                                     null );\n-        }\n+//        for ( DescrBranch branch : literalIndexes ) {\n+//            buildLiteralConstraint( context,\n+//                                    pattern,\n+//                                    branch,\n+//                                    null );\n+//        }\n+//        for ( DescrBranch branch : literalConstraints ) {\n+//            buildLiteralConstraint( context,\n+//                                    pattern,\n+//                                    branch,\n+//                                    null );\n+//        }\n+//\n+//        for ( DescrBranch branch : variableIndexes ) {\n+//            buildVariableConstraint( context,\n+//                                     pattern,\n+//                                     branch,\n+//                                     null );\n+//        }\n+//        for ( DescrBranch branch : variableConstraints ) {\n+//            buildVariableConstraint( context,\n+//                                     pattern,\n+//                                     branch,\n+//                                     null );\n+//        }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingTimeWindow window = new SlidingTimeWindow( swd.getLength() );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingLengthWindow window = new SlidingLengthWindow( (int) swd.getLength() );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "17463d358c0e756db336f8fe539ea336ba919c99":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-2642: fixing tests\n",
      "commitDate": "2011-03-07, 2:46 PM",
      "commitName": "17463d358c0e756db336f8fe539ea336ba919c99",
      "commitAuthor": "Edson Tirelli",
      "commitDateOld": "2011-03-03, 6:27 PM",
      "commitNameOld": "f128d88bd39fb160dea5342832822f430140aa7b",
      "commitAuthorOld": "Edson Tirelli",
      "daysBetweenCommits": 3.85,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,210 +1,219 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 final boolean isEvent = context.getPkg().isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n             if ( rule != null && rule instanceof Query ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 return qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern );\n             } else {\n                 // this isn't a query either, so log an error\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( duplicateBindings ) {\n             // rewrite existing bindings into == constraints, so it unifies\n             FieldConstraintDescr varDescr = new FieldConstraintDescr( \"this\" );\n             varDescr.addRestriction( new VariableRestrictionDescr( \"==\",\n                                                                    patternDescr.getIdentifier() ) );\n             build( context,\n                    pattern,\n                    (FieldConstraintDescr) varDescr,\n                    null );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n+        List<DescrBranch> literalConstraints = new ArrayList<DescrBranch>();\n+        List<DescrBranch> literalIndexes = new ArrayList<DescrBranch>();\n+        List<DescrBranch> variableConstraints = new ArrayList<DescrBranch>();\n+        List<DescrBranch> variableIndexes = new ArrayList<DescrBranch>();\n+\n         for ( BindingDescr b : patternDescr.getBindings() ) {\n             if( true ) { // TODO: replace this by legacy mode configuration\n                 String expression = b.getExpression();\n                 \n                 DrlExprParser parser = new DrlExprParser();\n                 ConstraintConnectiveDescr result = parser.parse( expression );\n                 if ( parser.hasErrors() ) {\n                     for ( DroolsParserException error : parser.getErrors() ) {\n                         context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                                       descr,\n                                                                       null,\n                                                                       \"Unable to parser pattern expression:\\n\" + error.getMessage() ) );\n                     }\n                     return null;\n                 }\n                 String left = parser.getLeftMostExpr();\n                 // BELLOW is a hack.. need to implement it properly\n                 if( expression.equals( left ) ) {\n                     // it is just a bind, so build it\n                     build( context,\n                            pattern,\n                            b,\n                            null ); // null containers get added to the pattern\n                 } else {\n                     // it is both a binding and a constraint\n                     b.setExpression( left );\n                     build( context,\n                            pattern,\n                            b,\n                            null ); // null containers get added to the pattern\n                     b.setExpression( expression );\n+                    \n+                    // needs to build the actual constraints as well\n+                    processExpr( context,\n+                                 new ExprConstraintDescr( b.getExpression() ),\n+                                 literalIndexes,\n+                                 literalConstraints,\n+                                 variableIndexes,\n+                                 variableConstraints );\n                 }\n                 \n             } else {\n                 build( context,\n                        pattern,\n                        b,\n                        null ); // null containers get added to the pattern\n             }\n         }\n \n-        List<DescrBranch> literalConstraints = new ArrayList<DescrBranch>();\n-        List<DescrBranch> literalIndexes = new ArrayList<DescrBranch>();\n-        List<DescrBranch> variableConstraints = new ArrayList<DescrBranch>();\n-        List<DescrBranch> variableIndexes = new ArrayList<DescrBranch>();\n         for ( BaseDescr b : patternDescr.getDescrs() ) {\n             processExpr( context,\n                          (ExprConstraintDescr) b,\n                          literalIndexes,\n                          literalConstraints,\n                          variableIndexes,\n                          variableConstraints );\n         }\n \n         for ( DescrBranch branch : literalIndexes ) {\n             buildLiteralConstraint( context,\n                                     pattern,\n                                     branch,\n                                     null );\n         }\n         for ( DescrBranch branch : literalConstraints ) {\n             buildLiteralConstraint( context,\n                                     pattern,\n                                     branch,\n                                     null );\n         }\n \n         for ( DescrBranch branch : variableIndexes ) {\n             buildVariableConstraint( context,\n                                      pattern,\n                                      branch,\n                                      null );\n         }\n         for ( DescrBranch branch : variableConstraints ) {\n             buildVariableConstraint( context,\n                                      pattern,\n                                      branch,\n                                      null );\n         }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingTimeWindow window = new SlidingTimeWindow( swd.getLength() );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingLengthWindow window = new SlidingLengthWindow( (int) swd.getLength() );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "f128d88bd39fb160dea5342832822f430140aa7b":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-2642: fixing tests\n",
      "commitDate": "2011-03-03, 6:27 PM",
      "commitName": "f128d88bd39fb160dea5342832822f430140aa7b",
      "commitAuthor": "Edson Tirelli",
      "commitDateOld": "2011-03-03, 4:39 PM",
      "commitNameOld": "4ab9fea91218adfa1c1af1df6a56b1d4dd41c88d",
      "commitAuthorOld": "Edson Tirelli",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,176 +1,210 @@\n     public RuleConditionElement build( RuleBuildContext context,\n                                        BaseDescr descr,\n                                        Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 final boolean isEvent = context.getPkg().isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n             if ( rule != null && rule instanceof Query ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 return qeBuilder.build( context,\n                                         descr,\n                                         prefixPattern );\n             } else {\n                 // this isn't a query either, so log an error\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( duplicateBindings ) {\n             // rewrite existing bindings into == constraints, so it unifies\n             FieldConstraintDescr varDescr = new FieldConstraintDescr( \"this\" );\n             varDescr.addRestriction( new VariableRestrictionDescr( \"==\",\n                                                                    patternDescr.getIdentifier() ) );\n             build( context,\n                    pattern,\n                    (FieldConstraintDescr) varDescr,\n                    null );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( BindingDescr b : patternDescr.getBindings() ) {\n-            build( context,\n-                   pattern,\n-                   b,\n-                   null ); // null containers get added to the pattern\n+            if( true ) { // TODO: replace this by legacy mode configuration\n+                String expression = b.getExpression();\n+                \n+                DrlExprParser parser = new DrlExprParser();\n+                ConstraintConnectiveDescr result = parser.parse( expression );\n+                if ( parser.hasErrors() ) {\n+                    for ( DroolsParserException error : parser.getErrors() ) {\n+                        context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n+                                                                      descr,\n+                                                                      null,\n+                                                                      \"Unable to parser pattern expression:\\n\" + error.getMessage() ) );\n+                    }\n+                    return null;\n+                }\n+                String left = parser.getLeftMostExpr();\n+                // BELLOW is a hack.. need to implement it properly\n+                if( expression.equals( left ) ) {\n+                    // it is just a bind, so build it\n+                    build( context,\n+                           pattern,\n+                           b,\n+                           null ); // null containers get added to the pattern\n+                } else {\n+                    // it is both a binding and a constraint\n+                    b.setExpression( left );\n+                    build( context,\n+                           pattern,\n+                           b,\n+                           null ); // null containers get added to the pattern\n+                    b.setExpression( expression );\n+                }\n+                \n+            } else {\n+                build( context,\n+                       pattern,\n+                       b,\n+                       null ); // null containers get added to the pattern\n+            }\n         }\n \n         List<DescrBranch> literalConstraints = new ArrayList<DescrBranch>();\n         List<DescrBranch> literalIndexes = new ArrayList<DescrBranch>();\n         List<DescrBranch> variableConstraints = new ArrayList<DescrBranch>();\n         List<DescrBranch> variableIndexes = new ArrayList<DescrBranch>();\n         for ( BaseDescr b : patternDescr.getDescrs() ) {\n             processExpr( context,\n                          (ExprConstraintDescr) b,\n                          literalIndexes,\n                          literalConstraints,\n                          variableIndexes,\n                          variableConstraints );\n         }\n \n         for ( DescrBranch branch : literalIndexes ) {\n             buildLiteralConstraint( context,\n                                     pattern,\n                                     branch,\n                                     null );\n         }\n         for ( DescrBranch branch : literalConstraints ) {\n             buildLiteralConstraint( context,\n                                     pattern,\n                                     branch,\n                                     null );\n         }\n \n         for ( DescrBranch branch : variableIndexes ) {\n             buildVariableConstraint( context,\n                                      pattern,\n                                      branch,\n                                      null );\n         }\n         for ( DescrBranch branch : variableConstraints ) {\n             buildVariableConstraint( context,\n                                      pattern,\n                                      branch,\n                                      null );\n         }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingTimeWindow window = new SlidingTimeWindow( swd.getLength() );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingLengthWindow window = new SlidingLengthWindow( (int) swd.getLength() );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n                                                                       + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "4ab9fea91218adfa1c1af1df6a56b1d4dd41c88d":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-2642: fixing tests\n",
      "commitDate": "2011-03-03, 4:39 PM",
      "commitName": "4ab9fea91218adfa1c1af1df6a56b1d4dd41c88d",
      "commitAuthor": "Edson Tirelli",
      "commitDateOld": "2011-03-03, 4:30 PM",
      "commitNameOld": "be9962351617fec59e5f412e95e9ad879508a2c9",
      "commitAuthorOld": "Mark Proctor",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,170 +1,176 @@\n-    public RuleConditionElement build(RuleBuildContext context,\n-                                      BaseDescr descr,\n-                                      Pattern prefixPattern) {\n+    public RuleConditionElement build( RuleBuildContext context,\n+                                       BaseDescr descr,\n+                                       Pattern prefixPattern ) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 final boolean isEvent = context.getPkg().isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n-        \n+\n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n             if ( rule != null && rule instanceof Query ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n-                return qeBuilder.build( context, descr, prefixPattern );\n+                return qeBuilder.build( context,\n+                                        descr,\n+                                        prefixPattern );\n             } else {\n                 // this isn't a query either, so log an error\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n-        \n+\n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n-                                                       \n-        if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings  ) {\n+\n+        if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n-        \n+\n         if ( duplicateBindings ) {\n             // rewrite existing bindings into == constraints, so it unifies\n             FieldConstraintDescr varDescr = new FieldConstraintDescr( \"this\" );\n-            varDescr.addRestriction( new VariableRestrictionDescr(\"==\",  patternDescr.getIdentifier() ) );\n+            varDescr.addRestriction( new VariableRestrictionDescr( \"==\",\n+                                                                   patternDescr.getIdentifier() ) );\n             build( context,\n                    pattern,\n                    (FieldConstraintDescr) varDescr,\n                    null );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n-\n         // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( BindingDescr b : patternDescr.getBindings() ) {\n-        \tbuild(context, pattern, b, null); // null containers get added to the pattern\n+            build( context,\n+                   pattern,\n+                   b,\n+                   null ); // null containers get added to the pattern\n         }\n-                        \n+\n         List<DescrBranch> literalConstraints = new ArrayList<DescrBranch>();\n-        List<DescrBranch> literalIndexes = new ArrayList<DescrBranch>();        \n+        List<DescrBranch> literalIndexes = new ArrayList<DescrBranch>();\n         List<DescrBranch> variableConstraints = new ArrayList<DescrBranch>();\n         List<DescrBranch> variableIndexes = new ArrayList<DescrBranch>();\n         for ( BaseDescr b : patternDescr.getDescrs() ) {\n-            processExpr(context, \n-                        (ExprConstraintDescr) b, \n-                        literalIndexes,\n-                        literalConstraints,  \n-                        variableIndexes,\n-                        variableConstraints );\n+            processExpr( context,\n+                         (ExprConstraintDescr) b,\n+                         literalIndexes,\n+                         literalConstraints,\n+                         variableIndexes,\n+                         variableConstraints );\n         }\n-        \n+\n         for ( DescrBranch branch : literalIndexes ) {\n-            buildLiteralConstraint( context, \n-                                    pattern, \n-                                    branch, \n+            buildLiteralConstraint( context,\n+                                    pattern,\n+                                    branch,\n                                     null );\n-         }           \n+        }\n         for ( DescrBranch branch : literalConstraints ) {\n-           buildLiteralConstraint( context, \n-                                   pattern, \n-                                   branch, \n-                                   null );\n+            buildLiteralConstraint( context,\n+                                    pattern,\n+                                    branch,\n+                                    null );\n         }\n \n         for ( DescrBranch branch : variableIndexes ) {\n-            buildVariableConstraint( context, \n-                                    pattern, \n-                                    branch, \n-                                    null );\n-         }           \n-        for ( DescrBranch branch : variableConstraints ) {\n-            buildVariableConstraint( context, \n-                                     pattern, \n-                                     branch, \n+            buildVariableConstraint( context,\n+                                     pattern,\n+                                     branch,\n                                      null );\n-         }        \n+        }\n+        for ( DescrBranch branch : variableConstraints ) {\n+            buildVariableConstraint( context,\n+                                     pattern,\n+                                     branch,\n+                                     null );\n+        }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n-            if( pattern.getObjectType().isEvent() ) {\n+            if ( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingTimeWindow window = new SlidingTimeWindow( swd.getLength() );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingLengthWindow window = new SlidingLengthWindow( (int) swd.getLength() );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n-                                                              \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName() + \"' is not declared as an Event.\" ) );\n+                                                              \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName()\n+                                                                      + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n-    }   \n\\ No newline at end of file\n+    }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "dde431afddbe0729d07e31b6d77c10a1812d8b18":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-2642 Getting tests working for new updated parser.\n",
      "commitDate": "2011-03-02, 5:00 PM",
      "commitName": "dde431afddbe0729d07e31b6d77c10a1812d8b18",
      "commitAuthor": "Mark Proctor",
      "commitDateOld": "2011-02-18, 11:24 AM",
      "commitNameOld": "147e72800e323c3f9b897bbb33e6b55e9be86a2f",
      "commitAuthorOld": "Geoffrey De Smet",
      "daysBetweenCommits": 12.23,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,170 @@\n     public RuleConditionElement build(RuleBuildContext context,\n                                       BaseDescr descr,\n                                       Pattern prefixPattern) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 final boolean isEvent = context.getPkg().isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n         \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );\n             if ( rule != null && rule instanceof Query ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 return qeBuilder.build( context, descr, prefixPattern );\n             } else {\n                 // this isn't a query either, so log an error\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n         \n         boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                                    patternDescr.getIdentifier() );\n                                                        \n         if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings  ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n         \n         if ( duplicateBindings ) {\n             // rewrite existing bindings into == constraints, so it unifies\n             FieldConstraintDescr varDescr = new FieldConstraintDescr( \"this\" );\n             varDescr.addRestriction( new VariableRestrictionDescr(\"==\",  patternDescr.getIdentifier() ) );\n             build( context,\n                    pattern,\n                    (FieldConstraintDescr) varDescr,\n                    null );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n-        //context.getPkg().getClassFieldAccessorStore().get\n \n-        // adding the newly created pattern to the build stack\n-        // this is necessary in case of local declaration usage\n+        // adding the newly created pattern to the build stack this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n-        for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n-            final Object object = it.next();\n-            buildConstraint( context,\n-                             pattern,\n-                             object,\n-                             null );\n+        for ( BindingDescr b : patternDescr.getBindings() ) {\n+        \tbuild(context, pattern, b, null); // null containers get added to the pattern\n         }\n+                        \n+        List<DescrBranch> literalConstraints = new ArrayList<DescrBranch>();\n+        List<DescrBranch> literalIndexes = new ArrayList<DescrBranch>();        \n+        List<DescrBranch> variableConstraints = new ArrayList<DescrBranch>();\n+        List<DescrBranch> variableIndexes = new ArrayList<DescrBranch>();\n+        for ( BaseDescr b : patternDescr.getDescrs() ) {\n+            processExpr(context, \n+                        (ExprConstraintDescr) b, \n+                        literalIndexes,\n+                        literalConstraints,  \n+                        variableIndexes,\n+                        variableConstraints );\n+        }\n+        \n+        for ( DescrBranch branch : literalIndexes ) {\n+            buildLiteralConstraint( context, \n+                                    pattern, \n+                                    branch, \n+                                    null );\n+         }           \n+        for ( DescrBranch branch : literalConstraints ) {\n+           buildLiteralConstraint( context, \n+                                   pattern, \n+                                   branch, \n+                                   null );\n+        }\n+\n+        for ( DescrBranch branch : variableIndexes ) {\n+            buildVariableConstraint( context, \n+                                    pattern, \n+                                    branch, \n+                                    null );\n+         }           \n+        for ( DescrBranch branch : variableConstraints ) {\n+            buildVariableConstraint( context, \n+                                     pattern, \n+                                     branch, \n+                                     null );\n+         }        \n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingTimeWindow window = new SlidingTimeWindow( swd.getLength() );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingLengthWindow window = new SlidingLengthWindow( (int) swd.getLength() );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName() + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n-    }\n\\ No newline at end of file\n+    }   \n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "c4a0168acf3b6036b0aa96bc83bef438da1dfdb0":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-46 Prolog Style Query Based Backward Chaining\n-Initial queries with unification now works\n-The bug where it would lose indexing on queries is now fixed.\n However patterns that have unification cannot have composite indexes.\n\ninitial refactor for fast iterators\n",
      "commitDate": "2011-02-06, 5:54 PM",
      "commitName": "c4a0168acf3b6036b0aa96bc83bef438da1dfdb0",
      "commitAuthor": "mdproctor",
      "commitDateOld": "2010-10-21, 7:29 PM",
      "commitNameOld": "0e63597fef54e7722317aca32facd24fcdbd3d83",
      "commitAuthorOld": "Tihomir Surdilovic",
      "daysBetweenCommits": 107.98,
      "commitsBetweenForRepo": 338,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,132 +1,137 @@\n     public RuleConditionElement build(RuleBuildContext context,\n                                       BaseDescr descr,\n                                       Pattern prefixPattern) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 final boolean isEvent = context.getPkg().isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 // swallow as we'll do another check in a moment and then record the problem\n             }\n         }\n         \n         // lets see if it maps to a query\n         if ( objectType == null ) {\n             Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );            \n             if ( rule != null && rule instanceof Query ) {\n                 // it's a query so delegate to the QueryElementBuilder\n                 QueryElementBuilder qeBuilder = new QueryElementBuilder();\n                 return qeBuilder.build( context, descr, prefixPattern );\n             } else { \n                 // this isn't a query either, so log an error\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;                \n             }\n         }\n \n         Pattern pattern;\n-        if ( patternDescr.getIdentifier() != null && !patternDescr.getIdentifier().equals( \"\" ) ) {\n-\n-            if ( context.getDeclarationResolver().isDuplicated( context.getRule(),\n-                                                                patternDescr.getIdentifier() ) ) {\n-                // This declaration already  exists, so throw an Exception\n-                context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n-                                                              patternDescr,\n-                                                              null,\n-                                                              \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n-            }\n+        \n+        boolean duplicateBindings = context.getDeclarationResolver().isDuplicated( context.getRule(),\n+                                                                                   patternDescr.getIdentifier() );\n+                                                       \n+        if ( !StringUtils.isEmpty( patternDescr.getIdentifier() ) && !duplicateBindings  ) {\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n-            }\n+            }                      \n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n+        \n+        if ( duplicateBindings ) {\n+            // rewrite existing bindings into == constraints, so it unifies\n+            FieldConstraintDescr varDescr = new FieldConstraintDescr( \"this\" );  \n+            varDescr.addRestriction( new VariableRestrictionDescr(\"==\",  patternDescr.getIdentifier() ) );                \n+            build( context,\n+                   pattern,\n+                   (FieldConstraintDescr) varDescr,\n+                   null );                        \n+        }          \n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         //context.getPkg().getClassFieldAccessorStore().get\n \n         // adding the newly created pattern to the build stack\n         // this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n             final Object object = it.next();\n             buildConstraint( context,\n                              pattern,\n                              object,\n                              null );\n         }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingTimeWindow window = new SlidingTimeWindow( swd.getLength() );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingLengthWindow window = new SlidingLengthWindow( (int) swd.getLength() );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName() + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "a9a66132587f67b3d0acc93872cd481f704dcb02":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-46 Proloq Style Query Based Backward Chaining\n-Now works end to end, except parser. Have added full example constructing descrs directly.\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@32530 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
      "commitDate": "2010-04-12, 8:58 PM",
      "commitName": "a9a66132587f67b3d0acc93872cd481f704dcb02",
      "commitAuthor": "Mark Proctor",
      "commitDateOld": "2010-04-07, 3:30 PM",
      "commitNameOld": "8368c76d74d988c9bf93ed1cb055aa56e934f596",
      "commitAuthorOld": "Mark Proctor",
      "daysBetweenCommits": 5.23,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,132 @@\n     public RuleConditionElement build(RuleBuildContext context,\n                                       BaseDescr descr,\n                                       Pattern prefixPattern) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 final boolean isEvent = context.getPkg().isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n+                // swallow as we'll do another check in a moment and then record the problem\n+            }\n+        }\n+        \n+        // lets see if it maps to a query\n+        if ( objectType == null ) {\n+            Rule rule = context.getPkg().getRule( patternDescr.getObjectType() );            \n+            if ( rule != null && rule instanceof Query ) {\n+                // it's a query so delegate to the QueryElementBuilder\n+                QueryElementBuilder qeBuilder = new QueryElementBuilder();\n+                return qeBuilder.build( context, descr, prefixPattern );\n+            } else { \n+                // this isn't a query either, so log an error\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n-                return null;\n+                return null;                \n             }\n         }\n \n         Pattern pattern;\n         if ( patternDescr.getIdentifier() != null && !patternDescr.getIdentifier().equals( \"\" ) ) {\n \n             if ( context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                 patternDescr.getIdentifier() ) ) {\n                 // This declaration already  exists, so throw an Exception\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         //context.getPkg().getClassFieldAccessorStore().get\n \n         // adding the newly created pattern to the build stack\n         // this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n             final Object object = it.next();\n             buildConstraint( context,\n                              pattern,\n                              object,\n                              null );\n         }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingTimeWindow window = new SlidingTimeWindow( swd.getLength() );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingLengthWindow window = new SlidingLengthWindow( (int) swd.getLength() );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName() + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "4ac53262536b4a56139227fc12559e3d71e56f01":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-2339: JBRULES-2340: fixing true modify\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@31999 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
      "commitDate": "2010-03-08, 9:39 PM",
      "commitName": "4ac53262536b4a56139227fc12559e3d71e56f01",
      "commitAuthor": "Edson Tirelli",
      "commitDateOld": "2010-03-05, 7:12 AM",
      "commitNameOld": "de3deafaaebd28322b4a9503df44eb5921ea2daa",
      "commitAuthorOld": "Edson Tirelli",
      "daysBetweenCommits": 3.6,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,114 +1,119 @@\n     public RuleConditionElement build(RuleBuildContext context,\n                                       BaseDescr descr,\n                                       Pattern prefixPattern) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 final boolean isEvent = context.getPkg().isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n         if ( patternDescr.getIdentifier() != null && !patternDescr.getIdentifier().equals( \"\" ) ) {\n \n             if ( context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                 patternDescr.getIdentifier() ) ) {\n                 // This declaration already  exists, so throw an Exception\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n+            if ( objectType instanceof ClassObjectType ) {\n+                // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n+                context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n+                                                                                  (PatternExtractor) pattern.getDeclaration().getExtractor() );\n+            }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         //context.getPkg().getClassFieldAccessorStore().get\n \n         // adding the newly created pattern to the build stack\n         // this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n             final Object object = it.next();\n             buildConstraint( context,\n                              pattern,\n                              object,\n                              null );\n         }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingTimeWindow window = new SlidingTimeWindow( swd.getLength() );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingLengthWindow window = new SlidingLengthWindow( (int) swd.getLength() );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName() + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "de3deafaaebd28322b4a9503df44eb5921ea2daa":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-2433: Fixing ClassObjectType instantiation. Removing duplicate code from PatternBuilder.\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@31961 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
      "commitDate": "2010-03-05, 7:12 AM",
      "commitName": "de3deafaaebd28322b4a9503df44eb5921ea2daa",
      "commitAuthor": "Edson Tirelli",
      "commitDateOld": "2010-02-18, 12:05 AM",
      "commitNameOld": "1e56def1302c23fcdc76ad662d58a034a6818aa2",
      "commitAuthorOld": "Mark Proctor",
      "daysBetweenCommits": 15.3,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,114 @@\n     public RuleConditionElement build(RuleBuildContext context,\n                                       BaseDescr descr,\n                                       Pattern prefixPattern) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 final boolean isEvent = context.getPkg().isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n         if ( patternDescr.getIdentifier() != null && !patternDescr.getIdentifier().equals( \"\" ) ) {\n \n             if ( context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                 patternDescr.getIdentifier() ) ) {\n                 // This declaration already  exists, so throw an Exception\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n-            if ( objectType instanceof ClassObjectType ) {\n-                // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n-                context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n-                                                                                  (PatternExtractor) pattern.getDeclaration().getExtractor() );\n-            }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         //context.getPkg().getClassFieldAccessorStore().get\n \n         // adding the newly created pattern to the build stack\n         // this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n             final Object object = it.next();\n             buildConstraint( context,\n                              pattern,\n                              object,\n                              null );\n         }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if( pattern.getObjectType().isEvent() ) {\n                 if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingTimeWindow window = new SlidingTimeWindow( swd.getLength() );\n                     pattern.addBehavior( window );\n                 } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getType() ) ) {\n                     SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                     SlidingLengthWindow window = new SlidingLengthWindow( (int) swd.getLength() );\n                     pattern.addBehavior( window );\n                 }\n             } else {\n                 // Some behaviors can only be assigned to patterns declared as events\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName() + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "8b94c44356da8dd49bb140b888594a2100f14344":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-2288: fixing FORALL behavior\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@29630 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
      "commitDate": "2009-10-15, 4:14 PM",
      "commitName": "8b94c44356da8dd49bb140b888594a2100f14344",
      "commitAuthor": "Edson Tirelli",
      "commitDateOld": "2009-03-04, 2:51 PM",
      "commitNameOld": "aff692e6c491b6d32d85a94fd9cb159c36b67a3c",
      "commitAuthorOld": "Edson Tirelli",
      "daysBetweenCommits": 225.02,
      "commitsBetweenForRepo": 436,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,119 @@\n     public RuleConditionElement build(RuleBuildContext context,\n                                       BaseDescr descr,\n                                       Pattern prefixPattern) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 final boolean isEvent = context.getPkg().isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n         if ( patternDescr.getIdentifier() != null && !patternDescr.getIdentifier().equals( \"\" ) ) {\n \n             if ( context.getDeclarationResolver().isDuplicated( context.getRule(),\n                                                                 patternDescr.getIdentifier() ) ) {\n                 // This declaration already  exists, so throw an Exception\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n \n         //context.getPkg().getClassFieldAccessorStore().get\n \n         // adding the newly created pattern to the build stack\n         // this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n             final Object object = it.next();\n             buildConstraint( context,\n                              pattern,\n                              object,\n                              null );\n         }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n-            if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n-                SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n-                SlidingTimeWindow window = new SlidingTimeWindow( swd.getLength() );\n-                pattern.addBehavior( window );\n-            } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getType() ) ) {\n-                SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n-                SlidingLengthWindow window = new SlidingLengthWindow( (int) swd.getLength() );\n-                pattern.addBehavior( window );\n+            if( pattern.getObjectType().isEvent() ) {\n+                if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n+                    SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n+                    SlidingTimeWindow window = new SlidingTimeWindow( swd.getLength() );\n+                    pattern.addBehavior( window );\n+                } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getType() ) ) {\n+                    SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n+                    SlidingLengthWindow window = new SlidingLengthWindow( (int) swd.getLength() );\n+                    pattern.addBehavior( window );\n+                }\n+            } else {\n+                // Some behaviors can only be assigned to patterns declared as events\n+                context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n+                                                              patternDescr,\n+                                                              null,\n+                                                              \"A Sliding Window behavior can only be assigned to patterns declared with @role( event ). The pattern '\" + pattern.getObjectType() + \"' in the rule '\" + context.getRule().getName() + \"' is not declared as an Event.\" ) );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "aff692e6c491b6d32d85a94fd9cb159c36b67a3c":
    {
      "type": "Ybodychange",
      "commitMessage": "Upgrading to mvel 2.0.8.snapshot\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@25496 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
      "commitDate": "2009-03-04, 2:51 PM",
      "commitName": "aff692e6c491b6d32d85a94fd9cb159c36b67a3c",
      "commitAuthor": "Edson Tirelli",
      "commitDateOld": "2009-02-17, 6:41 PM",
      "commitNameOld": "2939219f0467539e5f7a49140d20ba42e25a345c",
      "commitAuthorOld": "Edson Tirelli",
      "daysBetweenCommits": 14.84,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,111 @@\n     public RuleConditionElement build(RuleBuildContext context,\n                                       BaseDescr descr,\n                                       Pattern prefixPattern) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 final boolean isEvent = context.getPkg().isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n         if ( patternDescr.getIdentifier() != null && !patternDescr.getIdentifier().equals( \"\" ) ) {\n \n-            if ( context.getDeclarationResolver().isDuplicated(context.getRule(), patternDescr.getIdentifier() ) ) {\n+            if ( context.getDeclarationResolver().isDuplicated( context.getRule(),\n+                                                                patternDescr.getIdentifier() ) ) {\n                 // This declaration already  exists, so throw an Exception\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n-            }            \n+            }\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n-        \n+\n         //context.getPkg().getClassFieldAccessorStore().get\n \n         // adding the newly created pattern to the build stack\n         // this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n             final Object object = it.next();\n             buildConstraint( context,\n                              pattern,\n                              object,\n                              null );\n         }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n-            RuleConditionBuilder builder = context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n+            RuleConditionBuilder builder = (RuleConditionBuilder) context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n                 SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                 SlidingTimeWindow window = new SlidingTimeWindow( swd.getLength() );\n                 pattern.addBehavior( window );\n-            } else if( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getType() ) ) {\n+            } else if ( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getType() ) ) {\n                 SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                 SlidingLengthWindow window = new SlidingLengthWindow( (int) swd.getLength() );\n                 pattern.addBehavior( window );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "acbcfbd138ecd7ad5023566c8eff0bd8c0d6094e":
    {
      "type": "Ybodychange",
      "commitMessage": "Fixing sliding windows: time and length\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@23597 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
      "commitDate": "2008-10-27, 9:23 AM",
      "commitName": "acbcfbd138ecd7ad5023566c8eff0bd8c0d6094e",
      "commitAuthor": "Edson Tirelli",
      "commitDateOld": "2008-10-20, 3:43 PM",
      "commitNameOld": "9f0498ecaa118cf78a9760ab84056d4435b42d8b",
      "commitAuthorOld": "Michael Rhoden",
      "daysBetweenCommits": 6.74,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,110 @@\n     public RuleConditionElement build(RuleBuildContext context,\n                                       BaseDescr descr,\n                                       Pattern prefixPattern) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 final boolean isEvent = context.getPkg().isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n         if ( patternDescr.getIdentifier() != null && !patternDescr.getIdentifier().equals( \"\" ) ) {\n \n             if ( context.getDeclarationResolver().isDuplicated(context.getRule(), patternDescr.getIdentifier() ) ) {\n                 // This declaration already  exists, so throw an Exception\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }            \n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n         \n         //context.getPkg().getClassFieldAccessorStore().get\n \n         // adding the newly created pattern to the build stack\n         // this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n             final Object object = it.next();\n             buildConstraint( context,\n                              pattern,\n                              object,\n                              null );\n         }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n                 SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                 SlidingTimeWindow window = new SlidingTimeWindow( swd.getLength() );\n                 pattern.addBehavior( window );\n+            } else if( Behavior.BehaviorType.LENGTH_WINDOW.matches( behaviorDescr.getType() ) ) {\n+                SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n+                SlidingLengthWindow window = new SlidingLengthWindow( (int) swd.getLength() );\n+                pattern.addBehavior( window );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "9f0498ecaa118cf78a9760ab84056d4435b42d8b":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-1812 adding rule inheritance for core\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@23526 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
      "commitDate": "2008-10-20, 3:43 PM",
      "commitName": "9f0498ecaa118cf78a9760ab84056d4435b42d8b",
      "commitAuthor": "Michael Rhoden",
      "commitDateOld": "2008-08-15, 12:39 AM",
      "commitNameOld": "b1f7a88fda430f1ea1476cf81f7378592056a834",
      "commitAuthorOld": "Mark Proctor",
      "daysBetweenCommits": 66.63,
      "commitsBetweenForRepo": 139,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,106 @@\n     public RuleConditionElement build(RuleBuildContext context,\n                                       BaseDescr descr,\n                                       Pattern prefixPattern) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 final boolean isEvent = context.getPkg().isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n         if ( patternDescr.getIdentifier() != null && !patternDescr.getIdentifier().equals( \"\" ) ) {\n \n-            if ( context.getDeclarationResolver().isDuplicated( patternDescr.getIdentifier() ) ) {\n+            if ( context.getDeclarationResolver().isDuplicated(context.getRule(), patternDescr.getIdentifier() ) ) {\n                 // This declaration already  exists, so throw an Exception\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n             if ( objectType instanceof ClassObjectType ) {\n                 // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n                 context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                                   (PatternExtractor) pattern.getDeclaration().getExtractor() );\n             }            \n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n \n         if ( objectType instanceof ClassObjectType ) {\n             // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n             context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n                                                                               pattern );\n         }\n         \n         //context.getPkg().getClassFieldAccessorStore().get\n \n         // adding the newly created pattern to the build stack\n         // this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n             final Object object = it.next();\n             buildConstraint( context,\n                              pattern,\n                              object,\n                              null );\n         }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n             if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n                 SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                 SlidingTimeWindow window = new SlidingTimeWindow( swd.getLength() );\n                 pattern.addBehavior( window );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "b1f7a88fda430f1ea1476cf81f7378592056a834":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-1736 Dynamically generated Types \n-initial fix\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@21562 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
      "commitDate": "2008-08-15, 12:39 AM",
      "commitName": "b1f7a88fda430f1ea1476cf81f7378592056a834",
      "commitAuthor": "Mark Proctor",
      "commitDateOld": "2008-06-23, 10:37 AM",
      "commitNameOld": "de8b1b892220c7c03cfb7fb6dcadd991bf79c0fa",
      "commitAuthorOld": "Mark Proctor",
      "daysBetweenCommits": 52.58,
      "commitsBetweenForRepo": 158,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,106 @@\n     public RuleConditionElement build(RuleBuildContext context,\n                                       BaseDescr descr,\n                                       Pattern prefixPattern) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 final boolean isEvent = context.getPkg().isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n         if ( patternDescr.getIdentifier() != null && !patternDescr.getIdentifier().equals( \"\" ) ) {\n \n             if ( context.getDeclarationResolver().isDuplicated( patternDescr.getIdentifier() ) ) {\n                 // This declaration already  exists, so throw an Exception\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n+            if ( objectType instanceof ClassObjectType ) {\n+                // make sure PatternExtractor is wired up to correct ClassObjectType and set as a target for rewiring\n+                context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n+                                                                                  (PatternExtractor) pattern.getDeclaration().getExtractor() );\n+            }            \n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n+\n+        if ( objectType instanceof ClassObjectType ) {\n+            // make sure the Pattern is wired up to correct ClassObjectType and set as a target for rewiring\n+            context.getPkg().getClassFieldAccessorStore().getClassObjectType( ((ClassObjectType) objectType),\n+                                                                              pattern );\n+        }\n+        \n+        //context.getPkg().getClassFieldAccessorStore().get\n+\n         // adding the newly created pattern to the build stack\n         // this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n             final Object object = it.next();\n             buildConstraint( context,\n                              pattern,\n                              object,\n                              null );\n         }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n-        \n-        for( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n-            if( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n+\n+        for ( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n+            if ( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n                 SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n                 SlidingTimeWindow window = new SlidingTimeWindow( swd.getLength() );\n                 pattern.addBehavior( window );\n             }\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "acc13f3f145289380be57a47b597ce7c0af3c21f":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-1599: adding support to absolute time window declaration\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@19873 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
      "commitDate": "2008-05-06, 4:43 PM",
      "commitName": "acc13f3f145289380be57a47b597ce7c0af3c21f",
      "commitAuthor": "Edson Tirelli",
      "commitDateOld": "2008-03-19, 11:11 AM",
      "commitNameOld": "f3de0b9b71fe91ad5a6c59131b00851c61170e3a",
      "commitAuthorOld": "Edson Tirelli",
      "daysBetweenCommits": 48.23,
      "commitsBetweenForRepo": 164,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,92 @@\n     public RuleConditionElement build(RuleBuildContext context,\n                                       BaseDescr descr,\n                                       Pattern prefixPattern) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                           patternDescr,\n                                                           null,\n                                                           \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 final boolean isEvent = context.getPkg().isEvent( userProvidedClass );\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n         if ( patternDescr.getIdentifier() != null && !patternDescr.getIdentifier().equals( \"\" ) ) {\n \n             if ( context.getDeclarationResolver().isDuplicated( patternDescr.getIdentifier() ) ) {\n                 // This declaration already  exists, so throw an Exception\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                               patternDescr,\n                                                               null,\n                                                               \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact() );\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n         // adding the newly created pattern to the build stack\n         // this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n             final Object object = it.next();\n             buildConstraint( context,\n                              pattern,\n                              object,\n                              null );\n         }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n+        \n+        for( BehaviorDescr behaviorDescr : patternDescr.getBehaviors() ) {\n+            if( Behavior.BehaviorType.TIME_WINDOW.matches( behaviorDescr.getType() ) ) {\n+                SlidingWindowDescr swd = (SlidingWindowDescr) behaviorDescr;\n+                SlidingTimeWindow window = new SlidingTimeWindow( swd.getLength() );\n+                pattern.addBehavior( window );\n+            }\n+        }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "369ddf386df7441012fe07bb49fcbe666ba76113":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-1384: merging temporal support for revisions 15772:17159 into trunk\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@17161 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
      "commitDate": "2007-12-10, 10:37 AM",
      "commitName": "369ddf386df7441012fe07bb49fcbe666ba76113",
      "commitAuthor": "Edson Tirelli",
      "commitDateOld": "2007-11-23, 8:34 AM",
      "commitNameOld": "bb94d1beb85384a8acf9f943a6356c800eb3a9f9",
      "commitAuthorOld": "Mark Proctor",
      "daysBetweenCommits": 17.09,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,84 @@\n     public RuleConditionElement build(RuleBuildContext context,\n                                       BaseDescr descr,\n                                       Pattern prefixPattern) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n-                                                    patternDescr,\n-                                                    null,\n-                                                    \"ObjectType not correctly defined\" ) );\n+                                                          patternDescr,\n+                                                          null,\n+                                                          \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n-                objectType = new ClassObjectType( userProvidedClass );\n+                final boolean isEvent = context.getPkg().isEvent( userProvidedClass );\n+                objectType = new ClassObjectType( userProvidedClass,\n+                                                  isEvent );\n             } catch ( final ClassNotFoundException e ) {\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n-                                                        patternDescr,\n-                                                        null,\n-                                                        \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n+                                                              patternDescr,\n+                                                              null,\n+                                                              \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n         if ( patternDescr.getIdentifier() != null && !patternDescr.getIdentifier().equals( \"\" ) ) {\n \n             if ( context.getDeclarationResolver().isDuplicated( patternDescr.getIdentifier() ) ) {\n                 // This declaration already  exists, so throw an Exception\n                 context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n-                                                        patternDescr,\n-                                                        null,\n-                                                        \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n+                                                              patternDescr,\n+                                                              null,\n+                                                              \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n-                                   patternDescr.isInternalFact());\n+                                   patternDescr.isInternalFact() );\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n         // adding the newly created pattern to the build stack\n         // this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n             final Object object = it.next();\n             buildConstraint( context,\n                              pattern,\n                              object,\n                              null );\n         }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "bb94d1beb85384a8acf9f943a6356c800eb3a9f9":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-1197 Extends actions support to include other dialects and callback\n-I'm updating PackageBuilder to be able to handle actions. It's still very messy, but all unit tests are currently passing. So I'm  committing now, before I start on more major refactorings.\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@16763 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
      "commitDate": "2007-11-23, 8:34 AM",
      "commitName": "bb94d1beb85384a8acf9f943a6356c800eb3a9f9",
      "commitAuthor": "Mark Proctor",
      "commitDateOld": "2007-11-05, 2:44 PM",
      "commitNameOld": "986c2d899276de59b8f1152fef31b3d1ff7cbdd7",
      "commitAuthorOld": "Edson Tirelli",
      "daysBetweenCommits": 17.74,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,82 @@\n     public RuleConditionElement build(RuleBuildContext context,\n                                       BaseDescr descr,\n                                       Pattern prefixPattern) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n-            context.getErrors().add( new RuleError( context.getRule(),\n+            context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                     patternDescr,\n                                                     null,\n                                                     \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 objectType = new ClassObjectType( userProvidedClass );\n             } catch ( final ClassNotFoundException e ) {\n-                context.getErrors().add( new RuleError( context.getRule(),\n+                context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                         patternDescr,\n                                                         null,\n                                                         \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n         if ( patternDescr.getIdentifier() != null && !patternDescr.getIdentifier().equals( \"\" ) ) {\n \n             if ( context.getDeclarationResolver().isDuplicated( patternDescr.getIdentifier() ) ) {\n                 // This declaration already  exists, so throw an Exception\n-                context.getErrors().add( new RuleError( context.getRule(),\n+                context.getErrors().add( new DescrBuildError( context.getParentDescr(),\n                                                         patternDescr,\n                                                         null,\n                                                         \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier(),\n                                    patternDescr.isInternalFact());\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n         // adding the newly created pattern to the build stack\n         // this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n             final Object object = it.next();\n             buildConstraint( context,\n                              pattern,\n                              object,\n                              null );\n         }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n \n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "684409ccc18d32554c40adc3eff0d67684f06ac2":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-1115: unwrapping shadow objects when collected by collect CE\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@14552 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
      "commitDate": "2007-08-25, 7:41 AM",
      "commitName": "684409ccc18d32554c40adc3eff0d67684f06ac2",
      "commitAuthor": "Edson Tirelli",
      "commitDateOld": "2007-08-22, 12:24 PM",
      "commitNameOld": "2acb55ed74d2ac19e47ada28badd83ac6c0ce1f7",
      "commitAuthorOld": "Edson Tirelli",
      "daysBetweenCommits": 2.8,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,81 @@\n     public RuleConditionElement build(RuleBuildContext context,\n                                       BaseDescr descr,\n                                       Pattern prefixPattern) {\n \n         final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new RuleError( context.getRule(),\n                                                     patternDescr,\n                                                     null,\n                                                     \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 objectType = new ClassObjectType( userProvidedClass );\n             } catch ( final ClassNotFoundException e ) {\n                 context.getErrors().add( new RuleError( context.getRule(),\n                                                         patternDescr,\n                                                         null,\n                                                         \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n         if ( patternDescr.getIdentifier() != null && !patternDescr.getIdentifier().equals( \"\" ) ) {\n \n             if ( context.getDeclarationResolver().isDuplicated( patternDescr.getIdentifier() ) ) {\n                 // This declaration already  exists, so throw an Exception\n                 context.getErrors().add( new RuleError( context.getRule(),\n                                                         patternDescr,\n                                                         null,\n                                                         \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n-                                   patternDescr.getIdentifier() );\n+                                   patternDescr.getIdentifier(),\n+                                   patternDescr.isInternalFact());\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n         // adding the newly created pattern to the build stack\n         // this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n             final Object object = it.next();\n             buildConstraint( context,\n                              pattern,\n                              object,\n                              null );\n         }\n \n         if ( patternDescr.getSource() != null ) {\n             // we have a pattern source, so build it\n             RuleConditionBuilder builder = context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n \n             PatternSource source = (PatternSource) builder.build( context,\n                                                                   patternDescr.getSource() );\n \n             pattern.setSource( source );\n         }\n \n         // poping the pattern\n         context.getBuildStack().pop();\n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "71639b9f6ed41e4707d9096abdbee9290e6f9ebb":
    {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange,Yparametermetachange)",
      "commitMessage": "JBRULES-546: adding support to 'from' chaining\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@12897 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
      "commitDate": "2007-06-27, 1:04 PM",
      "commitName": "71639b9f6ed41e4707d9096abdbee9290e6f9ebb",
      "commitAuthor": "Edson Tirelli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "JBRULES-546: adding support to 'from' chaining\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@12897 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
          "commitDate": "2007-06-27, 1:04 PM",
          "commitName": "71639b9f6ed41e4707d9096abdbee9290e6f9ebb",
          "commitAuthor": "Edson Tirelli",
          "commitDateOld": "2007-06-19, 4:25 PM",
          "commitNameOld": "b7c43c6fde92d2bdfa1f65bbd462fbfdc9002bac",
          "commitAuthorOld": "Edson Tirelli",
          "daysBetweenCommits": 7.86,
          "commitsBetweenForRepo": 62,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,79 @@\n-    public Pattern build(final RuleBuildContext context,\n-                         final PatternDescr patternDescr) {\n+    public RuleConditionElement build(RuleBuildContext context,\n+                                      BaseDescr descr,\n+                                      Pattern prefixPattern) {\n+\n+        final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new RuleError( context.getRule(),\n                                                     patternDescr,\n                                                     null,\n                                                     \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 objectType = new ClassObjectType( userProvidedClass );\n             } catch ( final ClassNotFoundException e ) {\n                 context.getErrors().add( new RuleError( context.getRule(),\n                                                         patternDescr,\n                                                         null,\n                                                         \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n         if ( patternDescr.getIdentifier() != null && !patternDescr.getIdentifier().equals( \"\" ) ) {\n \n             if ( context.getDeclarationResolver().isDuplicated( patternDescr.getIdentifier() ) ) {\n                 // This declaration already  exists, so throw an Exception\n                 context.getErrors().add( new RuleError( context.getRule(),\n                                                         patternDescr,\n                                                         null,\n                                                         \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier() );\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n         // adding the newly created pattern to the build stack\n         // this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n             final Object object = it.next();\n             buildConstraint( context,\n                              pattern,\n                              object,\n                              null );\n         }\n+        \n+        if( patternDescr.getSource() != null ) {\n+            // we have a pattern source, so build it\n+            RuleConditionBuilder builder = context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n+            \n+            PatternSource source = (PatternSource) builder.build( context, patternDescr.getSource() );\n+            \n+            pattern.setSource( source );\n+        }\n+        \n         // poping the pattern\n         context.getBuildStack().pop();\n         return pattern;\n     }\n\\ No newline at end of file\n",
          "extendedDetails":
          {
            "oldValue": "[context-RuleBuildContext(modifiers-final), patternDescr-PatternDescr(modifiers-final)]",
            "newValue": "[context-RuleBuildContext, descr-BaseDescr, prefixPattern-Pattern]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "JBRULES-546: adding support to 'from' chaining\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@12897 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
          "commitDate": "2007-06-27, 1:04 PM",
          "commitName": "71639b9f6ed41e4707d9096abdbee9290e6f9ebb",
          "commitAuthor": "Edson Tirelli",
          "commitDateOld": "2007-06-19, 4:25 PM",
          "commitNameOld": "b7c43c6fde92d2bdfa1f65bbd462fbfdc9002bac",
          "commitAuthorOld": "Edson Tirelli",
          "daysBetweenCommits": 7.86,
          "commitsBetweenForRepo": 62,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,79 @@\n-    public Pattern build(final RuleBuildContext context,\n-                         final PatternDescr patternDescr) {\n+    public RuleConditionElement build(RuleBuildContext context,\n+                                      BaseDescr descr,\n+                                      Pattern prefixPattern) {\n+\n+        final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new RuleError( context.getRule(),\n                                                     patternDescr,\n                                                     null,\n                                                     \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 objectType = new ClassObjectType( userProvidedClass );\n             } catch ( final ClassNotFoundException e ) {\n                 context.getErrors().add( new RuleError( context.getRule(),\n                                                         patternDescr,\n                                                         null,\n                                                         \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n         if ( patternDescr.getIdentifier() != null && !patternDescr.getIdentifier().equals( \"\" ) ) {\n \n             if ( context.getDeclarationResolver().isDuplicated( patternDescr.getIdentifier() ) ) {\n                 // This declaration already  exists, so throw an Exception\n                 context.getErrors().add( new RuleError( context.getRule(),\n                                                         patternDescr,\n                                                         null,\n                                                         \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier() );\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n         // adding the newly created pattern to the build stack\n         // this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n             final Object object = it.next();\n             buildConstraint( context,\n                              pattern,\n                              object,\n                              null );\n         }\n+        \n+        if( patternDescr.getSource() != null ) {\n+            // we have a pattern source, so build it\n+            RuleConditionBuilder builder = context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n+            \n+            PatternSource source = (PatternSource) builder.build( context, patternDescr.getSource() );\n+            \n+            pattern.setSource( source );\n+        }\n+        \n         // poping the pattern\n         context.getBuildStack().pop();\n         return pattern;\n     }\n\\ No newline at end of file\n",
          "extendedDetails":
          {
            "oldValue": "Pattern",
            "newValue": "RuleConditionElement"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "JBRULES-546: adding support to 'from' chaining\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@12897 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
          "commitDate": "2007-06-27, 1:04 PM",
          "commitName": "71639b9f6ed41e4707d9096abdbee9290e6f9ebb",
          "commitAuthor": "Edson Tirelli",
          "commitDateOld": "2007-06-19, 4:25 PM",
          "commitNameOld": "b7c43c6fde92d2bdfa1f65bbd462fbfdc9002bac",
          "commitAuthorOld": "Edson Tirelli",
          "daysBetweenCommits": 7.86,
          "commitsBetweenForRepo": 62,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,79 @@\n-    public Pattern build(final RuleBuildContext context,\n-                         final PatternDescr patternDescr) {\n+    public RuleConditionElement build(RuleBuildContext context,\n+                                      BaseDescr descr,\n+                                      Pattern prefixPattern) {\n+\n+        final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new RuleError( context.getRule(),\n                                                     patternDescr,\n                                                     null,\n                                                     \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 objectType = new ClassObjectType( userProvidedClass );\n             } catch ( final ClassNotFoundException e ) {\n                 context.getErrors().add( new RuleError( context.getRule(),\n                                                         patternDescr,\n                                                         null,\n                                                         \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n         if ( patternDescr.getIdentifier() != null && !patternDescr.getIdentifier().equals( \"\" ) ) {\n \n             if ( context.getDeclarationResolver().isDuplicated( patternDescr.getIdentifier() ) ) {\n                 // This declaration already  exists, so throw an Exception\n                 context.getErrors().add( new RuleError( context.getRule(),\n                                                         patternDescr,\n                                                         null,\n                                                         \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier() );\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n         // adding the newly created pattern to the build stack\n         // this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n             final Object object = it.next();\n             buildConstraint( context,\n                              pattern,\n                              object,\n                              null );\n         }\n+        \n+        if( patternDescr.getSource() != null ) {\n+            // we have a pattern source, so build it\n+            RuleConditionBuilder builder = context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n+            \n+            PatternSource source = (PatternSource) builder.build( context, patternDescr.getSource() );\n+            \n+            pattern.setSource( source );\n+        }\n+        \n         // poping the pattern\n         context.getBuildStack().pop();\n         return pattern;\n     }\n\\ No newline at end of file\n",
          "extendedDetails":
          {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "JBRULES-546: adding support to 'from' chaining\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@12897 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
          "commitDate": "2007-06-27, 1:04 PM",
          "commitName": "71639b9f6ed41e4707d9096abdbee9290e6f9ebb",
          "commitAuthor": "Edson Tirelli",
          "commitDateOld": "2007-06-19, 4:25 PM",
          "commitNameOld": "b7c43c6fde92d2bdfa1f65bbd462fbfdc9002bac",
          "commitAuthorOld": "Edson Tirelli",
          "daysBetweenCommits": 7.86,
          "commitsBetweenForRepo": 62,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,79 @@\n-    public Pattern build(final RuleBuildContext context,\n-                         final PatternDescr patternDescr) {\n+    public RuleConditionElement build(RuleBuildContext context,\n+                                      BaseDescr descr,\n+                                      Pattern prefixPattern) {\n+\n+        final PatternDescr patternDescr = (PatternDescr) descr;\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new RuleError( context.getRule(),\n                                                     patternDescr,\n                                                     null,\n                                                     \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 objectType = new ClassObjectType( userProvidedClass );\n             } catch ( final ClassNotFoundException e ) {\n                 context.getErrors().add( new RuleError( context.getRule(),\n                                                         patternDescr,\n                                                         null,\n                                                         \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n         if ( patternDescr.getIdentifier() != null && !patternDescr.getIdentifier().equals( \"\" ) ) {\n \n             if ( context.getDeclarationResolver().isDuplicated( patternDescr.getIdentifier() ) ) {\n                 // This declaration already  exists, so throw an Exception\n                 context.getErrors().add( new RuleError( context.getRule(),\n                                                         patternDescr,\n                                                         null,\n                                                         \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier() );\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n         // adding the newly created pattern to the build stack\n         // this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n             final Object object = it.next();\n             buildConstraint( context,\n                              pattern,\n                              object,\n                              null );\n         }\n+        \n+        if( patternDescr.getSource() != null ) {\n+            // we have a pattern source, so build it\n+            RuleConditionBuilder builder = context.getDialect().getBuilder( patternDescr.getSource().getClass() );\n+            \n+            PatternSource source = (PatternSource) builder.build( context, patternDescr.getSource() );\n+            \n+            pattern.setSource( source );\n+        }\n+        \n         // poping the pattern\n         context.getBuildStack().pop();\n         return pattern;\n     }\n\\ No newline at end of file\n",
          "extendedDetails":
          {
            "oldValue": "[context-RuleBuildContext(modifiers-final), patternDescr-PatternDescr(modifiers-final)]",
            "newValue": "[context-RuleBuildContext, descr-BaseDescr, prefixPattern-Pattern]"
          }
        }]
    },
    "d83725c9693433da25f45ea536e127df643e07d0":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-914 Refactor shadow facts into core\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@12447 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
      "commitDate": "2007-06-10, 6:51 PM",
      "commitName": "d83725c9693433da25f45ea536e127df643e07d0",
      "commitAuthor": "Mark Proctor",
      "commitDateOld": "2007-06-08, 8:34 AM",
      "commitNameOld": "ff01d5fac6579b699d85965e7c68d21357468e15",
      "commitAuthorOld": "Edson Tirelli",
      "daysBetweenCommits": 2.43,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,66 @@\n     public Pattern build(final RuleBuildContext context,\n                          final PatternDescr patternDescr) {\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new RuleError( context.getRule(),\n                                                     patternDescr,\n                                                     null,\n                                                     \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n-                final String shadowProxyName = ShadowProxyFactory.getProxyClassNameForClass( userProvidedClass );\n-                Class shadowClass = null;\n-                try {\n-                    // if already loaded\n-                    shadowClass = context.getPkg().getPackageCompilationData().getClassLoader().loadClass( shadowProxyName );\n-                } catch ( final ClassNotFoundException cnfe ) {\n-                    // otherwise, create and load\n-                    final byte[] proxyBytes = ShadowProxyFactory.getProxyBytes( userProvidedClass );\n-                    if ( proxyBytes != null ) {\n-                        context.getPkg().getPackageCompilationData().write( ClassUtils.convertClassToResourcePath( shadowProxyName ),\n-                                                                            proxyBytes );\n-                        shadowClass = context.getPkg().getPackageCompilationData().getClassLoader().loadClass( shadowProxyName );\n-                    }\n-\n-                }\n-                objectType = new ClassObjectType( userProvidedClass,\n-                                                  shadowClass );\n+                objectType = new ClassObjectType( userProvidedClass );\n             } catch ( final ClassNotFoundException e ) {\n                 context.getErrors().add( new RuleError( context.getRule(),\n                                                         patternDescr,\n                                                         null,\n                                                         \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n         if ( patternDescr.getIdentifier() != null && !patternDescr.getIdentifier().equals( \"\" ) ) {\n \n             if ( context.getDeclarationResolver().isDuplicated( patternDescr.getIdentifier() ) ) {\n                 // This declaration already  exists, so throw an Exception\n                 context.getErrors().add( new RuleError( context.getRule(),\n                                                         patternDescr,\n                                                         null,\n                                                         \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier() );\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n         // adding the newly created pattern to the build stack\n         // this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n             final Object object = it.next();\n             buildConstraint( context,\n                              pattern,\n                              object,\n                              null );\n         }\n         // poping the pattern\n         context.getBuildStack().pop();\n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "497f0756292688791b8eea293fa1e483ad1731a9":
    {
      "type": "Ybodychange",
      "commitMessage": "JBRULES-500:\n\n  * Adding support to field constraint connectives AND and OR\n  * Adding support to multi-restriction precedence\n  * Adding unit tests\n\n\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@11962 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
      "commitDate": "2007-05-19, 2:24 PM",
      "commitName": "497f0756292688791b8eea293fa1e483ad1731a9",
      "commitAuthor": "Edson Tirelli",
      "commitDateOld": "2007-04-25, 10:14 AM",
      "commitNameOld": "a27dadde237d406555deea89bbb3360fee3bae1c",
      "commitAuthorOld": "Mark Proctor",
      "daysBetweenCommits": 24.17,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,82 @@\n     public Pattern build(final RuleBuildContext context,\n                          final PatternDescr patternDescr) {\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new RuleError( context.getRule(),\n                                                     patternDescr,\n                                                     null,\n                                                     \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n                 final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 final String shadowProxyName = ShadowProxyFactory.getProxyClassNameForClass( userProvidedClass );\n                 Class shadowClass = null;\n                 try {\n                     // if already loaded\n                     shadowClass = context.getPkg().getPackageCompilationData().getClassLoader().loadClass( shadowProxyName );\n                 } catch ( final ClassNotFoundException cnfe ) {\n                     // otherwise, create and load\n                     final byte[] proxyBytes = ShadowProxyFactory.getProxyBytes( userProvidedClass );\n                     if ( proxyBytes != null ) {\n                         context.getPkg().getPackageCompilationData().write( ClassUtils.convertClassToResourcePath( shadowProxyName ),\n                                                                             proxyBytes );\n                         shadowClass = context.getPkg().getPackageCompilationData().getClassLoader().loadClass( shadowProxyName );\n                     }\n \n                 }\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   shadowClass );\n             } catch ( final ClassNotFoundException e ) {\n                 context.getErrors().add( new RuleError( context.getRule(),\n                                                         patternDescr,\n                                                         null,\n                                                         \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n         if ( patternDescr.getIdentifier() != null && !patternDescr.getIdentifier().equals( \"\" ) ) {\n \n             if ( context.getDeclarationResolver().isDuplicated( patternDescr.getIdentifier() ) ) {\n                 // This declaration already  exists, so throw an Exception\n                 context.getErrors().add( new RuleError( context.getRule(),\n                                                         patternDescr,\n                                                         null,\n                                                         \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n \n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    patternDescr.getIdentifier() );\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n                                    0, // offset is 0 by default\n                                    objectType,\n                                    null );\n         }\n         // adding the newly created pattern to the build stack\n         // this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n             final Object object = it.next();\n-            if ( object instanceof FieldBindingDescr ) {\n-                build( context,\n-                       pattern,\n-                       (FieldBindingDescr) object );\n-            } else if ( object instanceof FieldConstraintDescr ) {\n-                build( context,\n-                       pattern,\n-                       (FieldConstraintDescr) object );\n-            } else if ( object instanceof PredicateDescr ) {\n-                build( context,\n-                       pattern,\n-                       (PredicateDescr) object );\n-            }\n+            buildConstraint( context,\n+                             pattern,\n+                             object,\n+                             null );\n         }\n         // poping the pattern\n         context.getBuildStack().pop();\n         return pattern;\n     }\n\\ No newline at end of file\n",
      "extendedDetails":
      {}
    },
    "a27dadde237d406555deea89bbb3360fee3bae1c":
    {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "JBRULES-713 Make Dialects Pluggeable\n-BuildUtils is now gone, moved into JavaDialect\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@11329 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
      "commitDate": "2007-04-25, 10:14 AM",
      "commitName": "a27dadde237d406555deea89bbb3360fee3bae1c",
      "commitAuthor": "Mark Proctor",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "JBRULES-713 Make Dialects Pluggeable\n-BuildUtils is now gone, moved into JavaDialect\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@11329 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
          "commitDate": "2007-04-25, 10:14 AM",
          "commitName": "a27dadde237d406555deea89bbb3360fee3bae1c",
          "commitAuthor": "Mark Proctor",
          "commitDateOld": "2007-04-24, 5:52 AM",
          "commitNameOld": "7af0694e0e0e0ea4a1488b4ebea44f933a065574",
          "commitAuthorOld": "Mark Proctor",
          "daysBetweenCommits": 1.18,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,95 +1,91 @@\n-    public Pattern build(final BuildContext context,\n-                        final BuildUtils utils,\n-                        final PatternDescr patternDescr) {\n+    public Pattern build(final RuleBuildContext context,\n+                         final PatternDescr patternDescr) {\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new RuleError( context.getRule(),\n                                                     patternDescr,\n                                                     null,\n                                                     \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n-                final Class userProvidedClass = utils.getTypeResolver().resolveType( patternDescr.getObjectType() );\n+                final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 final String shadowProxyName = ShadowProxyFactory.getProxyClassNameForClass( userProvidedClass );\n                 Class shadowClass = null;\n                 try {\n                     // if already loaded\n                     shadowClass = context.getPkg().getPackageCompilationData().getClassLoader().loadClass( shadowProxyName );\n                 } catch ( final ClassNotFoundException cnfe ) {\n                     // otherwise, create and load\n                     final byte[] proxyBytes = ShadowProxyFactory.getProxyBytes( userProvidedClass );\n                     if ( proxyBytes != null ) {\n                         context.getPkg().getPackageCompilationData().write( ClassUtils.convertClassToResourcePath( shadowProxyName ),\n                                                                             proxyBytes );\n                         shadowClass = context.getPkg().getPackageCompilationData().getClassLoader().loadClass( shadowProxyName );\n                     }\n \n                 }\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   shadowClass );\n             } catch ( final ClassNotFoundException e ) {\n                 context.getErrors().add( new RuleError( context.getRule(),\n                                                         patternDescr,\n                                                         null,\n                                                         \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n         if ( patternDescr.getIdentifier() != null && !patternDescr.getIdentifier().equals( \"\" ) ) {\n \n             if ( context.getDeclarationResolver().isDuplicated( patternDescr.getIdentifier() ) ) {\n                 // This declaration already  exists, so throw an Exception\n                 context.getErrors().add( new RuleError( context.getRule(),\n                                                         patternDescr,\n                                                         null,\n                                                         \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n \n             pattern = new Pattern( context.getNextPatternId(),\n-                                 0, // offset is 0 by default\n-                                 objectType,\n-                                 patternDescr.getIdentifier() );\n+                                   0, // offset is 0 by default\n+                                   objectType,\n+                                   patternDescr.getIdentifier() );\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n-                                 0, // offset is 0 by default\n-                                 objectType,\n-                                 null );\n+                                   0, // offset is 0 by default\n+                                   objectType,\n+                                   null );\n         }\n         // adding the newly created pattern to the build stack\n         // this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n             final Object object = it.next();\n             if ( object instanceof FieldBindingDescr ) {\n                 build( context,\n-                       utils,\n                        pattern,\n                        (FieldBindingDescr) object );\n             } else if ( object instanceof FieldConstraintDescr ) {\n                 build( context,\n-                       utils,\n                        pattern,\n                        (FieldConstraintDescr) object );\n             } else if ( object instanceof PredicateDescr ) {\n                 build( context,\n-                       utils,\n                        pattern,\n                        (PredicateDescr) object );\n             }\n         }\n         // poping the pattern\n         context.getBuildStack().pop();\n         return pattern;\n     }\n\\ No newline at end of file\n",
          "extendedDetails":
          {
            "oldValue": "[context-BuildContext(modifiers-final), utils-BuildUtils(modifiers-final), patternDescr-PatternDescr(modifiers-final)]",
            "newValue": "[context-RuleBuildContext(modifiers-final), patternDescr-PatternDescr(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "JBRULES-713 Make Dialects Pluggeable\n-BuildUtils is now gone, moved into JavaDialect\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@11329 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
          "commitDate": "2007-04-25, 10:14 AM",
          "commitName": "a27dadde237d406555deea89bbb3360fee3bae1c",
          "commitAuthor": "Mark Proctor",
          "commitDateOld": "2007-04-24, 5:52 AM",
          "commitNameOld": "7af0694e0e0e0ea4a1488b4ebea44f933a065574",
          "commitAuthorOld": "Mark Proctor",
          "daysBetweenCommits": 1.18,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,95 +1,91 @@\n-    public Pattern build(final BuildContext context,\n-                        final BuildUtils utils,\n-                        final PatternDescr patternDescr) {\n+    public Pattern build(final RuleBuildContext context,\n+                         final PatternDescr patternDescr) {\n \n         if ( patternDescr.getObjectType() == null || patternDescr.getObjectType().equals( \"\" ) ) {\n             context.getErrors().add( new RuleError( context.getRule(),\n                                                     patternDescr,\n                                                     null,\n                                                     \"ObjectType not correctly defined\" ) );\n             return null;\n         }\n \n         ObjectType objectType = null;\n \n         final FactTemplate factTemplate = context.getPkg().getFactTemplate( patternDescr.getObjectType() );\n \n         if ( factTemplate != null ) {\n             objectType = new FactTemplateObjectType( factTemplate );\n         } else {\n             try {\n-                final Class userProvidedClass = utils.getTypeResolver().resolveType( patternDescr.getObjectType() );\n+                final Class userProvidedClass = context.getDialect().getTypeResolver().resolveType( patternDescr.getObjectType() );\n                 final String shadowProxyName = ShadowProxyFactory.getProxyClassNameForClass( userProvidedClass );\n                 Class shadowClass = null;\n                 try {\n                     // if already loaded\n                     shadowClass = context.getPkg().getPackageCompilationData().getClassLoader().loadClass( shadowProxyName );\n                 } catch ( final ClassNotFoundException cnfe ) {\n                     // otherwise, create and load\n                     final byte[] proxyBytes = ShadowProxyFactory.getProxyBytes( userProvidedClass );\n                     if ( proxyBytes != null ) {\n                         context.getPkg().getPackageCompilationData().write( ClassUtils.convertClassToResourcePath( shadowProxyName ),\n                                                                             proxyBytes );\n                         shadowClass = context.getPkg().getPackageCompilationData().getClassLoader().loadClass( shadowProxyName );\n                     }\n \n                 }\n                 objectType = new ClassObjectType( userProvidedClass,\n                                                   shadowClass );\n             } catch ( final ClassNotFoundException e ) {\n                 context.getErrors().add( new RuleError( context.getRule(),\n                                                         patternDescr,\n                                                         null,\n                                                         \"Unable to resolve ObjectType '\" + patternDescr.getObjectType() + \"'\" ) );\n                 return null;\n             }\n         }\n \n         Pattern pattern;\n         if ( patternDescr.getIdentifier() != null && !patternDescr.getIdentifier().equals( \"\" ) ) {\n \n             if ( context.getDeclarationResolver().isDuplicated( patternDescr.getIdentifier() ) ) {\n                 // This declaration already  exists, so throw an Exception\n                 context.getErrors().add( new RuleError( context.getRule(),\n                                                         patternDescr,\n                                                         null,\n                                                         \"Duplicate declaration for variable '\" + patternDescr.getIdentifier() + \"' in the rule '\" + context.getRule().getName() + \"'\" ) );\n             }\n \n             pattern = new Pattern( context.getNextPatternId(),\n-                                 0, // offset is 0 by default\n-                                 objectType,\n-                                 patternDescr.getIdentifier() );\n+                                   0, // offset is 0 by default\n+                                   objectType,\n+                                   patternDescr.getIdentifier() );\n         } else {\n             pattern = new Pattern( context.getNextPatternId(),\n-                                 0, // offset is 0 by default\n-                                 objectType,\n-                                 null );\n+                                   0, // offset is 0 by default\n+                                   objectType,\n+                                   null );\n         }\n         // adding the newly created pattern to the build stack\n         // this is necessary in case of local declaration usage\n         context.getBuildStack().push( pattern );\n \n         for ( final Iterator it = patternDescr.getDescrs().iterator(); it.hasNext(); ) {\n             final Object object = it.next();\n             if ( object instanceof FieldBindingDescr ) {\n                 build( context,\n-                       utils,\n                        pattern,\n                        (FieldBindingDescr) object );\n             } else if ( object instanceof FieldConstraintDescr ) {\n                 build( context,\n-                       utils,\n                        pattern,\n                        (FieldConstraintDescr) object );\n             } else if ( object instanceof PredicateDescr ) {\n                 build( context,\n-                       utils,\n                        pattern,\n                        (PredicateDescr) object );\n             }\n         }\n         // poping the pattern\n         context.getBuildStack().pop();\n         return pattern;\n     }\n\\ No newline at end of file\n",
          "extendedDetails":
          {}
        }]
    },
    "7af0694e0e0e0ea4a1488b4ebea44f933a065574":
    {
      "type": "Yintroduced",
      "commitMessage": "JBRULES-816 Refactor Column to be Pattern\n\ngit-svn-id: https://svn.jboss.org/repos/labs/labs/jbossrules/trunk@11295 c60d74c8-e8f6-0310-9e8f-d4a2fc68ab70\n",
      "commitDate": "2007-04-24, 5:52 AM",
      "commitName": "7af0694e0e0e0ea4a1488b4ebea44f933a065574",
      "commitAuthor": "Mark Proctor"
    }
  }
}
