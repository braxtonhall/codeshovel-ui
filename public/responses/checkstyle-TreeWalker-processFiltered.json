{
	"repo": "https://github.com/checkstyle/checkstyle.git",
	"file": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java",
	"method": {
		"longName": "TreeWalker::processFiltered(File file, FileText fileText)",
		"startLine": 176,
		"methodName": "processFiltered",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "protected"
	},
	"history": {
		"58327e1dd9707b09f82ae2d4d4ce14c253247154": {
			"type": "Ybodychange",
			"commitMessage": "Issue #5436: Split TreeWalker to TreeWalker and JavaParser\n",
			"commitDate": "2018-01-23, 11:39 PM",
			"commitName": "58327e1dd9707b09f82ae2d4d4ce14c253247154",
			"commitAuthor": "Pavel Bludov",
			"commitDateOld": "2018-01-04, 8:20 AM",
			"commitNameOld": "0847a10b9430d9fb0a3f44df03e891da906bea47",
			"commitAuthorOld": "Pavel Bludov",
			"daysBetweenCommits": 19.64,
			"commitsBetweenForRepo": 30,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,43 +1,24 @@\n     protected void processFiltered(File file, FileText fileText) throws CheckstyleException {\n         // check if already checked and passed the file\n-        if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n-            final String msg = \"%s occurred during the analysis of file %s.\";\n-            final String fileName = file.getPath();\n-\n-            try {\n-                if (!ordinaryChecks.isEmpty()\n-                        || !commentChecks.isEmpty()) {\n-                    final FileContents contents = new FileContents(fileText);\n-                    final DetailAST rootAST = parse(contents);\n-\n-                    if (!ordinaryChecks.isEmpty()) {\n-                        walk(rootAST, contents, AstState.ORDINARY);\n-                    }\n-                    if (!commentChecks.isEmpty()) {\n-                        final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n-\n-                        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n-                    }\n-                    if (filters.isEmpty()) {\n-                        addMessages(messages);\n-                    }\n-                    else {\n-                        final SortedSet<LocalizedMessage> filteredMessages =\n-                            getFilteredMessages(fileName, contents, rootAST);\n-                        addMessages(filteredMessages);\n-                    }\n-                    messages.clear();\n-                }\n+        if (CommonUtils.matchesFileExtension(file, getFileExtensions())\n+                && (!ordinaryChecks.isEmpty() || !commentChecks.isEmpty())) {\n+            final FileContents contents = new FileContents(fileText);\n+            final DetailAST rootAST = JavaParser.parse(contents);\n+            if (!ordinaryChecks.isEmpty()) {\n+                walk(rootAST, contents, AstState.ORDINARY);\n             }\n-            catch (final TokenStreamRecognitionException tre) {\n-                final String exceptionMsg = String.format(Locale.ROOT, msg,\n-                        \"TokenStreamRecognitionException\", fileName);\n-                throw new CheckstyleException(exceptionMsg, tre);\n+            if (!commentChecks.isEmpty()) {\n+                final DetailAST astWithComments = JavaParser.appendHiddenCommentNodes(rootAST);\n+                walk(astWithComments, contents, AstState.WITH_COMMENTS);\n             }\n-            catch (RecognitionException | TokenStreamException ex) {\n-                final String exceptionMsg = String.format(Locale.ROOT, msg,\n-                        ex.getClass().getSimpleName(), fileName);\n-                throw new CheckstyleException(exceptionMsg, ex);\n+            if (filters.isEmpty()) {\n+                addMessages(messages);\n             }\n+            else {\n+                final SortedSet<LocalizedMessage> filteredMessages =\n+                    getFilteredMessages(file.getPath(), contents, rootAST);\n+                addMessages(filteredMessages);\n+            }\n+            messages.clear();\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f994512712c08a16def4a3c5a0426b7ab1590cc9": {
			"type": "Ybodychange",
			"commitMessage": "Issue #4422: Implement XpathFilter\n",
			"commitDate": "2017-08-23, 9:11 AM",
			"commitName": "f994512712c08a16def4a3c5a0426b7ab1590cc9",
			"commitAuthor": "Timur",
			"commitDateOld": "2017-08-22, 2:05 AM",
			"commitNameOld": "2f5115bce66f153ddfa02306505c1e81af942ff5",
			"commitAuthorOld": "vasilyeva",
			"daysBetweenCommits": 1.3,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,38 +1,43 @@\n     protected void processFiltered(File file, FileText fileText) throws CheckstyleException {\n         // check if already checked and passed the file\n         if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n             final String msg = \"%s occurred during the analysis of file %s.\";\n             final String fileName = file.getPath();\n \n             try {\n                 if (!ordinaryChecks.isEmpty()\n                         || !commentChecks.isEmpty()) {\n                     final FileContents contents = new FileContents(fileText);\n                     final DetailAST rootAST = parse(contents);\n \n                     if (!ordinaryChecks.isEmpty()) {\n                         walk(rootAST, contents, AstState.ORDINARY);\n                     }\n                     if (!commentChecks.isEmpty()) {\n                         final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n                         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n                     }\n-                    final SortedSet<LocalizedMessage> filteredMessages =\n-                            getFilteredMessages(fileName, contents);\n-                    addMessages(filteredMessages);\n+                    if (filters.isEmpty()) {\n+                        addMessages(messages);\n+                    }\n+                    else {\n+                        final SortedSet<LocalizedMessage> filteredMessages =\n+                            getFilteredMessages(fileName, contents, rootAST);\n+                        addMessages(filteredMessages);\n+                    }\n                     messages.clear();\n                 }\n             }\n             catch (final TokenStreamRecognitionException tre) {\n                 final String exceptionMsg = String.format(Locale.ROOT, msg,\n                         \"TokenStreamRecognitionException\", fileName);\n                 throw new CheckstyleException(exceptionMsg, tre);\n             }\n             catch (RecognitionException | TokenStreamException ex) {\n                 final String exceptionMsg = String.format(Locale.ROOT, msg,\n                         ex.getClass().getSimpleName(), fileName);\n                 throw new CheckstyleException(exceptionMsg, ex);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6d9e8ece85007117e048fef55469623b830f9446": {
			"type": "Ybodychange",
			"commitMessage": "Issue #4714: Make SuppressionCommentFilter and SuppressWithNearbyCommentFilter children of TreeWalker\n",
			"commitDate": "2017-07-24, 2:38 PM",
			"commitName": "6d9e8ece85007117e048fef55469623b830f9446",
			"commitAuthor": "Timur",
			"commitDateOld": "2017-07-07, 6:59 AM",
			"commitNameOld": "7fb0cf6870124032136b06eb7572a1de1b92e87a",
			"commitAuthorOld": "vasilyeva",
			"daysBetweenCommits": 17.32,
			"commitsBetweenForRepo": 111,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,33 +1,38 @@\n     protected void processFiltered(File file, FileText fileText) throws CheckstyleException {\n         // check if already checked and passed the file\n         if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n             final String msg = \"%s occurred during the analysis of file %s.\";\n             final String fileName = file.getPath();\n+\n             try {\n                 if (!ordinaryChecks.isEmpty()\n                         || !commentChecks.isEmpty()) {\n                     final FileContents contents = new FileContents(fileText);\n                     final DetailAST rootAST = parse(contents);\n \n                     if (!ordinaryChecks.isEmpty()) {\n                         walk(rootAST, contents, AstState.ORDINARY);\n                     }\n                     if (!commentChecks.isEmpty()) {\n                         final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n                         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n                     }\n+                    final SortedSet<LocalizedMessage> filteredMessages =\n+                            getFilteredMessages(fileName, contents);\n+                    addMessages(filteredMessages);\n+                    messages.clear();\n                 }\n             }\n             catch (final TokenStreamRecognitionException tre) {\n                 final String exceptionMsg = String.format(Locale.ROOT, msg,\n                         \"TokenStreamRecognitionException\", fileName);\n                 throw new CheckstyleException(exceptionMsg, tre);\n             }\n             catch (RecognitionException | TokenStreamException ex) {\n                 final String exceptionMsg = String.format(Locale.ROOT, msg,\n                         ex.getClass().getSimpleName(), fileName);\n                 throw new CheckstyleException(exceptionMsg, ex);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"82979737c4201b4913ea30b9c9431e71783d1c02": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Issue #3034: FileText should not extends AbstractList\n",
			"commitDate": "2017-07-06, 2:22 PM",
			"commitName": "82979737c4201b4913ea30b9c9431e71783d1c02",
			"commitAuthor": "Timur",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Issue #3034: FileText should not extends AbstractList\n",
					"commitDate": "2017-07-06, 2:22 PM",
					"commitName": "82979737c4201b4913ea30b9c9431e71783d1c02",
					"commitAuthor": "Timur",
					"commitDateOld": "2017-07-03, 7:56 PM",
					"commitNameOld": "ab548244eda102c5dc39cf0fc34e6803be192ba7",
					"commitAuthorOld": "Andrei Selkin",
					"daysBetweenCommits": 2.77,
					"commitsBetweenForRepo": 21,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,34 +1,33 @@\n-    protected void processFiltered(File file, List<String> lines) throws CheckstyleException {\n+    protected void processFiltered(File file, FileText fileText) throws CheckstyleException {\n         // check if already checked and passed the file\n         if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n             final String msg = \"%s occurred during the analysis of file %s.\";\n             final String fileName = file.getPath();\n             try {\n                 if (!ordinaryChecks.isEmpty()\n                         || !commentChecks.isEmpty()) {\n-                    final FileText text = FileText.fromLines(file, lines);\n-                    final FileContents contents = new FileContents(text);\n+                    final FileContents contents = new FileContents(fileText);\n                     final DetailAST rootAST = parse(contents);\n \n                     if (!ordinaryChecks.isEmpty()) {\n                         walk(rootAST, contents, AstState.ORDINARY);\n                     }\n                     if (!commentChecks.isEmpty()) {\n                         final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n                         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n                     }\n                 }\n             }\n             catch (final TokenStreamRecognitionException tre) {\n                 final String exceptionMsg = String.format(Locale.ROOT, msg,\n                         \"TokenStreamRecognitionException\", fileName);\n                 throw new CheckstyleException(exceptionMsg, tre);\n             }\n             catch (RecognitionException | TokenStreamException ex) {\n                 final String exceptionMsg = String.format(Locale.ROOT, msg,\n                         ex.getClass().getSimpleName(), fileName);\n                 throw new CheckstyleException(exceptionMsg, ex);\n             }\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[file-File, lines-List<String>]",
						"newValue": "[file-File, fileText-FileText]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Issue #3034: FileText should not extends AbstractList\n",
					"commitDate": "2017-07-06, 2:22 PM",
					"commitName": "82979737c4201b4913ea30b9c9431e71783d1c02",
					"commitAuthor": "Timur",
					"commitDateOld": "2017-07-03, 7:56 PM",
					"commitNameOld": "ab548244eda102c5dc39cf0fc34e6803be192ba7",
					"commitAuthorOld": "Andrei Selkin",
					"daysBetweenCommits": 2.77,
					"commitsBetweenForRepo": 21,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,34 +1,33 @@\n-    protected void processFiltered(File file, List<String> lines) throws CheckstyleException {\n+    protected void processFiltered(File file, FileText fileText) throws CheckstyleException {\n         // check if already checked and passed the file\n         if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n             final String msg = \"%s occurred during the analysis of file %s.\";\n             final String fileName = file.getPath();\n             try {\n                 if (!ordinaryChecks.isEmpty()\n                         || !commentChecks.isEmpty()) {\n-                    final FileText text = FileText.fromLines(file, lines);\n-                    final FileContents contents = new FileContents(text);\n+                    final FileContents contents = new FileContents(fileText);\n                     final DetailAST rootAST = parse(contents);\n \n                     if (!ordinaryChecks.isEmpty()) {\n                         walk(rootAST, contents, AstState.ORDINARY);\n                     }\n                     if (!commentChecks.isEmpty()) {\n                         final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n                         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n                     }\n                 }\n             }\n             catch (final TokenStreamRecognitionException tre) {\n                 final String exceptionMsg = String.format(Locale.ROOT, msg,\n                         \"TokenStreamRecognitionException\", fileName);\n                 throw new CheckstyleException(exceptionMsg, tre);\n             }\n             catch (RecognitionException | TokenStreamException ex) {\n                 final String exceptionMsg = String.format(Locale.ROOT, msg,\n                         ex.getClass().getSimpleName(), fileName);\n                 throw new CheckstyleException(exceptionMsg, ex);\n             }\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"d72e6f7d0b9f339feef4309a9dada7fd381ba242": {
			"type": "Ybodychange",
			"commitMessage": "Issue #4398: increase coverage of pitest-checkstyle-tree-walker profile to 89%\n",
			"commitDate": "2017-06-22, 8:22 AM",
			"commitName": "d72e6f7d0b9f339feef4309a9dada7fd381ba242",
			"commitAuthor": "vasilyeva",
			"commitDateOld": "2017-06-12, 11:11 AM",
			"commitNameOld": "4a087c020c2b97130e94f9292b94cb4bc1f6ed93",
			"commitAuthorOld": "sagar-shah94",
			"daysBetweenCommits": 9.88,
			"commitsBetweenForRepo": 24,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,36 +1,34 @@\n     protected void processFiltered(File file, List<String> lines) throws CheckstyleException {\n         // check if already checked and passed the file\n         if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n             final String msg = \"%s occurred during the analysis of file %s.\";\n             final String fileName = file.getPath();\n             try {\n                 if (!ordinaryChecks.isEmpty()\n                         || !commentChecks.isEmpty()) {\n                     final FileText text = FileText.fromLines(file, lines);\n                     final FileContents contents = new FileContents(text);\n                     final DetailAST rootAST = parse(contents);\n \n-                    getMessageCollector().reset();\n-\n                     if (!ordinaryChecks.isEmpty()) {\n                         walk(rootAST, contents, AstState.ORDINARY);\n                     }\n                     if (!commentChecks.isEmpty()) {\n                         final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n                         walk(astWithComments, contents, AstState.WITH_COMMENTS);\n                     }\n                 }\n             }\n             catch (final TokenStreamRecognitionException tre) {\n                 final String exceptionMsg = String.format(Locale.ROOT, msg,\n                         \"TokenStreamRecognitionException\", fileName);\n                 throw new CheckstyleException(exceptionMsg, tre);\n             }\n             catch (RecognitionException | TokenStreamException ex) {\n                 final String exceptionMsg = String.format(Locale.ROOT, msg,\n                         ex.getClass().getSimpleName(), fileName);\n                 throw new CheckstyleException(exceptionMsg, ex);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"27e1e94244b6bb369c2ea7502c235260f49f78b0": {
			"type": "Ybodychange",
			"commitMessage": "Issue #4393: ASTs to be generated and walked only when there are corresponding type of checks. No parsing if no checks are specified\n",
			"commitDate": "2017-06-07, 7:02 AM",
			"commitName": "27e1e94244b6bb369c2ea7502c235260f49f78b0",
			"commitAuthor": "Piyush Sharma",
			"commitDateOld": "2017-04-21, 8:14 PM",
			"commitNameOld": "de50d3465849b83d25910590e1f5f39a25fe6e2c",
			"commitAuthorOld": "Vladislav Lisetskii",
			"daysBetweenCommits": 46.45,
			"commitsBetweenForRepo": 143,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,30 +1,36 @@\n     protected void processFiltered(File file, List<String> lines) throws CheckstyleException {\n         // check if already checked and passed the file\n         if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n             final String msg = \"%s occurred during the analysis of file %s.\";\n             final String fileName = file.getPath();\n             try {\n-                final FileText text = FileText.fromLines(file, lines);\n-                final FileContents contents = new FileContents(text);\n-                final DetailAST rootAST = parse(contents);\n+                if (!ordinaryChecks.isEmpty()\n+                        || !commentChecks.isEmpty()) {\n+                    final FileText text = FileText.fromLines(file, lines);\n+                    final FileContents contents = new FileContents(text);\n+                    final DetailAST rootAST = parse(contents);\n \n-                getMessageCollector().reset();\n+                    getMessageCollector().reset();\n \n-                walk(rootAST, contents, AstState.ORDINARY);\n+                    if (!ordinaryChecks.isEmpty()) {\n+                        walk(rootAST, contents, AstState.ORDINARY);\n+                    }\n+                    if (!commentChecks.isEmpty()) {\n+                        final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n-                final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n-\n-                walk(astWithComments, contents, AstState.WITH_COMMENTS);\n+                        walk(astWithComments, contents, AstState.WITH_COMMENTS);\n+                    }\n+                }\n             }\n             catch (final TokenStreamRecognitionException tre) {\n                 final String exceptionMsg = String.format(Locale.ROOT, msg,\n                         \"TokenStreamRecognitionException\", fileName);\n                 throw new CheckstyleException(exceptionMsg, tre);\n             }\n             catch (RecognitionException | TokenStreamException ex) {\n                 final String exceptionMsg = String.format(Locale.ROOT, msg,\n                         ex.getClass().getSimpleName(), fileName);\n                 throw new CheckstyleException(exceptionMsg, ex);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"39b343a32a4f1ce18ee98a34618fda0a5404d6a0": {
			"type": "Ybodychange",
			"commitMessage": "Issue #3143: forbid empty return statements and fixed violations",
			"commitDate": "2016-05-27, 7:42 AM",
			"commitName": "39b343a32a4f1ce18ee98a34618fda0a5404d6a0",
			"commitAuthor": "rnveach",
			"commitDateOld": "2016-05-16, 2:53 PM",
			"commitNameOld": "ecbeaa6e1df7cb021745e111b04395b9fbd509c7",
			"commitAuthorOld": "Andrei Selkin",
			"daysBetweenCommits": 10.7,
			"commitsBetweenForRepo": 27,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,32 +1,30 @@\n     protected void processFiltered(File file, List<String> lines) throws CheckstyleException {\n         // check if already checked and passed the file\n-        if (!CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n-            return;\n-        }\n+        if (CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n+            final String msg = \"%s occurred during the analysis of file %s.\";\n+            final String fileName = file.getPath();\n+            try {\n+                final FileText text = FileText.fromLines(file, lines);\n+                final FileContents contents = new FileContents(text);\n+                final DetailAST rootAST = parse(contents);\n \n-        final String msg = \"%s occurred during the analysis of file %s.\";\n-        final String fileName = file.getPath();\n-        try {\n-            final FileText text = FileText.fromLines(file, lines);\n-            final FileContents contents = new FileContents(text);\n-            final DetailAST rootAST = parse(contents);\n+                getMessageCollector().reset();\n \n-            getMessageCollector().reset();\n+                walk(rootAST, contents, AstState.ORDINARY);\n \n-            walk(rootAST, contents, AstState.ORDINARY);\n+                final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n-            final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n-\n-            walk(astWithComments, contents, AstState.WITH_COMMENTS);\n-        }\n-        catch (final TokenStreamRecognitionException tre) {\n-            final String exceptionMsg = String.format(Locale.ROOT, msg,\n-                    \"TokenStreamRecognitionException\", fileName);\n-            throw new CheckstyleException(exceptionMsg, tre);\n-        }\n-        catch (RecognitionException | TokenStreamException ex) {\n-            final String exceptionMsg = String.format(Locale.ROOT, msg,\n-                    ex.getClass().getSimpleName(), fileName);\n-            throw new CheckstyleException(exceptionMsg, ex);\n+                walk(astWithComments, contents, AstState.WITH_COMMENTS);\n+            }\n+            catch (final TokenStreamRecognitionException tre) {\n+                final String exceptionMsg = String.format(Locale.ROOT, msg,\n+                        \"TokenStreamRecognitionException\", fileName);\n+                throw new CheckstyleException(exceptionMsg, tre);\n+            }\n+            catch (RecognitionException | TokenStreamException ex) {\n+                final String exceptionMsg = String.format(Locale.ROOT, msg,\n+                        ex.getClass().getSimpleName(), fileName);\n+                throw new CheckstyleException(exceptionMsg, ex);\n+            }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d46c2cf0e9df06bb5f424dbd7645574f082f7609": {
			"type": "Ybodychange",
			"commitMessage": "Issue #569: Move TreeWalker cache to Checker\n",
			"commitDate": "2016-02-09, 10:50 AM",
			"commitName": "d46c2cf0e9df06bb5f424dbd7645574f082f7609",
			"commitAuthor": "Andrei Selkin",
			"commitDateOld": "2016-02-05, 7:01 AM",
			"commitNameOld": "cf96dd9adcf0c3c8f8f05a9ffdcb765cafe17479",
			"commitAuthorOld": "rnveach",
			"daysBetweenCommits": 4.16,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,40 +1,32 @@\n     protected void processFiltered(File file, List<String> lines) throws CheckstyleException {\n         // check if already checked and passed the file\n-        final String fileName = file.getPath();\n-        final long timestamp = file.lastModified();\n-        if (cache != null\n-                && (cache.isInCache(fileName, timestamp)\n-                    || !CommonUtils.matchesFileExtension(file, getFileExtensions()))) {\n+        if (!CommonUtils.matchesFileExtension(file, getFileExtensions())) {\n             return;\n         }\n \n         final String msg = \"%s occurred during the analysis of file %s.\";\n-\n+        final String fileName = file.getPath();\n         try {\n             final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg = String.format(Locale.ROOT, msg,\n                     \"TokenStreamRecognitionException\", fileName);\n             throw new CheckstyleException(exceptionMsg, tre);\n         }\n         catch (RecognitionException | TokenStreamException ex) {\n             final String exceptionMsg = String.format(Locale.ROOT, msg,\n                     ex.getClass().getSimpleName(), fileName);\n             throw new CheckstyleException(exceptionMsg, ex);\n         }\n-\n-        if (cache != null && getMessageCollector().size() == 0) {\n-            cache.put(fileName, timestamp);\n-        }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"be3e035ce39a610881cd2c1bfdce3eef101c2e3c": {
			"type": "Ybodychange",
			"commitMessage": "Issue #1217: fixes for violations from 'forbiddenapis' verification tool\n",
			"commitDate": "2015-10-13, 5:37 PM",
			"commitName": "be3e035ce39a610881cd2c1bfdce3eef101c2e3c",
			"commitAuthor": "Ruslan Diachenko",
			"commitDateOld": "2015-10-06, 6:46 PM",
			"commitNameOld": "30c3a362d45721e6925fe89ba71f0fe69d0fc471",
			"commitAuthorOld": "Roman Ivanov",
			"daysBetweenCommits": 6.95,
			"commitsBetweenForRepo": 79,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,39 +1,40 @@\n     protected void processFiltered(File file, List<String> lines) throws CheckstyleException {\n         // check if already checked and passed the file\n         final String fileName = file.getPath();\n         final long timestamp = file.lastModified();\n         if (cache != null\n                 && (cache.isInCache(fileName, timestamp)\n                     || !CommonUtils.matchesFileExtension(file, getFileExtensions()))) {\n             return;\n         }\n \n         final String msg = \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n-            final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n-                     fileName);\n+            final String exceptionMsg = String.format(Locale.ROOT, msg,\n+                    \"TokenStreamRecognitionException\", fileName);\n             throw new CheckstyleException(exceptionMsg, tre);\n         }\n         catch (RecognitionException | TokenStreamException ex) {\n-            final String exceptionMsg = String.format(msg, ex.getClass().getSimpleName(), fileName);\n+            final String exceptionMsg = String.format(Locale.ROOT, msg,\n+                    ex.getClass().getSimpleName(), fileName);\n             throw new CheckstyleException(exceptionMsg, ex);\n         }\n \n         if (cache != null && getMessageCollector().size() == 0) {\n             cache.put(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5922d5a6730d7582d7d66121eb911ef9426f9e24": {
			"type": "Ymultichange(Yexceptionschange,Ybodychange)",
			"commitMessage": "Issue #1566: IllegalCatch violations fixed for TreeWalker\n",
			"commitDate": "2015-08-30, 11:06 PM",
			"commitName": "5922d5a6730d7582d7d66121eb911ef9426f9e24",
			"commitAuthor": "Ruslan Diachenko",
			"subchanges": [
				{
					"type": "Yexceptionschange",
					"commitMessage": "Issue #1566: IllegalCatch violations fixed for TreeWalker\n",
					"commitDate": "2015-08-30, 11:06 PM",
					"commitName": "5922d5a6730d7582d7d66121eb911ef9426f9e24",
					"commitAuthor": "Ruslan Diachenko",
					"commitDateOld": "2015-08-28, 11:50 PM",
					"commitNameOld": "46a52f84c014e4d25379f429f11ed3de11fe8ae7",
					"commitAuthorOld": "Michal Kordas",
					"daysBetweenCommits": 1.97,
					"commitsBetweenForRepo": 59,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,44 +1,39 @@\n-    protected void processFiltered(File file, List<String> lines) {\n+    protected void processFiltered(File file, List<String> lines) throws CheckstyleException {\n         // check if already checked and passed the file\n         final String fileName = file.getPath();\n         final long timestamp = file.lastModified();\n         if (cache != null\n                 && (cache.isInCache(fileName, timestamp)\n                     || !CommonUtils.matchesFileExtension(file, getFileExtensions()))) {\n             return;\n         }\n \n         final String msg = \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n-            LOG.error(exceptionMsg);\n-            final RecognitionException re = tre.recog;\n-            final String message = re.getMessage();\n-            getMessageCollector().add(createLocalizedMessage(message));\n+            throw new CheckstyleException(exceptionMsg, tre);\n         }\n-        // RecognitionException and any other (need to check if needed)\n-        catch (Throwable ex) {\n+        catch (RecognitionException | TokenStreamException ex) {\n             final String exceptionMsg = String.format(msg, ex.getClass().getSimpleName(), fileName);\n-            LOG.error(exceptionMsg, ex);\n-            getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n+            throw new CheckstyleException(exceptionMsg, ex);\n         }\n \n         if (cache != null && getMessageCollector().size() == 0) {\n             cache.put(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[]",
						"newValue": "[CheckstyleException]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Issue #1566: IllegalCatch violations fixed for TreeWalker\n",
					"commitDate": "2015-08-30, 11:06 PM",
					"commitName": "5922d5a6730d7582d7d66121eb911ef9426f9e24",
					"commitAuthor": "Ruslan Diachenko",
					"commitDateOld": "2015-08-28, 11:50 PM",
					"commitNameOld": "46a52f84c014e4d25379f429f11ed3de11fe8ae7",
					"commitAuthorOld": "Michal Kordas",
					"daysBetweenCommits": 1.97,
					"commitsBetweenForRepo": 59,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,44 +1,39 @@\n-    protected void processFiltered(File file, List<String> lines) {\n+    protected void processFiltered(File file, List<String> lines) throws CheckstyleException {\n         // check if already checked and passed the file\n         final String fileName = file.getPath();\n         final long timestamp = file.lastModified();\n         if (cache != null\n                 && (cache.isInCache(fileName, timestamp)\n                     || !CommonUtils.matchesFileExtension(file, getFileExtensions()))) {\n             return;\n         }\n \n         final String msg = \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n-            LOG.error(exceptionMsg);\n-            final RecognitionException re = tre.recog;\n-            final String message = re.getMessage();\n-            getMessageCollector().add(createLocalizedMessage(message));\n+            throw new CheckstyleException(exceptionMsg, tre);\n         }\n-        // RecognitionException and any other (need to check if needed)\n-        catch (Throwable ex) {\n+        catch (RecognitionException | TokenStreamException ex) {\n             final String exceptionMsg = String.format(msg, ex.getClass().getSimpleName(), fileName);\n-            LOG.error(exceptionMsg, ex);\n-            getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n+            throw new CheckstyleException(exceptionMsg, ex);\n         }\n \n         if (cache != null && getMessageCollector().size() == 0) {\n             cache.put(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"46a52f84c014e4d25379f429f11ed3de11fe8ae7": {
			"type": "Ybodychange",
			"commitMessage": "Issue #1555: Rename methods returning boolean to use question word\n\nFixes some `BooleanMethodNameMustStartWithQuestion` inspection violations.\n\nDescription:\n>Reports boolean methods whose names do not start with a question word. Boolean methods that override library methods are ignored by this inspection.\n",
			"commitDate": "2015-08-28, 11:50 PM",
			"commitName": "46a52f84c014e4d25379f429f11ed3de11fe8ae7",
			"commitAuthor": "Michal Kordas",
			"commitDateOld": "2015-08-27, 1:53 PM",
			"commitNameOld": "4d2e6647f9e8385749c382bcab5e64965a943178",
			"commitAuthorOld": "Michal Kordas",
			"daysBetweenCommits": 1.41,
			"commitsBetweenForRepo": 62,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,44 +1,44 @@\n     protected void processFiltered(File file, List<String> lines) {\n         // check if already checked and passed the file\n         final String fileName = file.getPath();\n         final long timestamp = file.lastModified();\n         if (cache != null\n                 && (cache.isInCache(fileName, timestamp)\n-                    || !CommonUtils.fileExtensionMatches(file, getFileExtensions()))) {\n+                    || !CommonUtils.matchesFileExtension(file, getFileExtensions()))) {\n             return;\n         }\n \n         final String msg = \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re = tre.recog;\n             final String message = re.getMessage();\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg = String.format(msg, ex.getClass().getSimpleName(), fileName);\n             LOG.error(exceptionMsg, ex);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (cache != null && getMessageCollector().size() == 0) {\n             cache.put(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4d2e6647f9e8385749c382bcab5e64965a943178": {
			"type": "Ybodychange",
			"commitMessage": "Rename boolean methods to start with question word. #1555\n\nFixes `BooleanMethodNameMustStartWithQuestion` inspection violations.\n\nDescription:\n>Reports boolean methods whose names do not start with a question word. Boolean methods that override library methods are ignored by this inspection.\n",
			"commitDate": "2015-08-27, 1:53 PM",
			"commitName": "4d2e6647f9e8385749c382bcab5e64965a943178",
			"commitAuthor": "Michal Kordas",
			"commitDateOld": "2015-08-27, 6:41 AM",
			"commitNameOld": "60ae95a6219d0e0765040ece0c3a8d439e1375ad",
			"commitAuthorOld": "Michal Kordas",
			"daysBetweenCommits": 0.3,
			"commitsBetweenForRepo": 19,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,44 +1,44 @@\n     protected void processFiltered(File file, List<String> lines) {\n         // check if already checked and passed the file\n         final String fileName = file.getPath();\n         final long timestamp = file.lastModified();\n         if (cache != null\n-                && (cache.inCache(fileName, timestamp)\n+                && (cache.isInCache(fileName, timestamp)\n                     || !CommonUtils.fileExtensionMatches(file, getFileExtensions()))) {\n             return;\n         }\n \n         final String msg = \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re = tre.recog;\n             final String message = re.getMessage();\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg = String.format(msg, ex.getClass().getSimpleName(), fileName);\n             LOG.error(exceptionMsg, ex);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (cache != null && getMessageCollector().size() == 0) {\n             cache.put(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cdf3e56bacd3895262af8a1df9ca5c81f4071970": {
			"type": "Ybodychange",
			"commitMessage": "Utils class has been splitted to CommonUtils and TokenUtils. Issue #1898\n",
			"commitDate": "2015-08-27, 6:17 AM",
			"commitName": "cdf3e56bacd3895262af8a1df9ca5c81f4071970",
			"commitAuthor": "Ilja Dubinin",
			"commitDateOld": "2015-08-27, 6:17 AM",
			"commitNameOld": "ed595de84fba2db507adaf01d04cb089a5e0bac5",
			"commitAuthorOld": "Ilja Dubinin",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,44 +1,44 @@\n     protected void processFiltered(File file, List<String> lines) {\n         // check if already checked and passed the file\n         final String fileName = file.getPath();\n         final long timestamp = file.lastModified();\n         if (cache != null\n                 && (cache.inCache(fileName, timestamp)\n-                    || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n+                    || !CommonUtils.fileExtensionMatches(file, getFileExtensions()))) {\n             return;\n         }\n \n         final String msg = \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re = tre.recog;\n             final String message = re.getMessage();\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg = String.format(msg, ex.getClass().getSimpleName(), fileName);\n             LOG.error(exceptionMsg, ex);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (cache != null && getMessageCollector().size() == 0) {\n             cache.put(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c4928f486c67afa62e7e8fbd5d8f731be7186985": {
			"type": "Ybodychange",
			"commitMessage": "Decrease scope of variables. #1555\n\nFixes `TooBroadScope` inspection violations.\n\nDescription:\n>Reports any variable declarations of which the scope can be narrowed. Especially useful for \"Pascal style\" declarations at the start of a method, but variables with too broad a scope are also often left over after refactorings.\n",
			"commitDate": "2015-08-11, 10:54 PM",
			"commitName": "c4928f486c67afa62e7e8fbd5d8f731be7186985",
			"commitAuthor": "Michal Kordas",
			"commitDateOld": "2015-08-11, 2:14 PM",
			"commitNameOld": "82d8e91024a57a96fbb6410dacb29d6a3f582903",
			"commitAuthorOld": "Michal Kordas",
			"daysBetweenCommits": 0.36,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,44 @@\n     protected void processFiltered(File file, List<String> lines) {\n         // check if already checked and passed the file\n         final String fileName = file.getPath();\n         final long timestamp = file.lastModified();\n         if (cache != null\n                 && (cache.inCache(fileName, timestamp)\n                     || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n             return;\n         }\n \n         final String msg = \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re = tre.recog;\n-            String message;\n-            message = re.getMessage();\n+            final String message = re.getMessage();\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg = String.format(msg, ex.getClass().getSimpleName(), fileName);\n             LOG.error(exceptionMsg, ex);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (cache != null && getMessageCollector().size() == 0) {\n             cache.put(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"82d8e91024a57a96fbb6410dacb29d6a3f582903": {
			"type": "Ybodychange",
			"commitMessage": "Remove unnecessary qualifiers. #1555\n\nFixes `UnnecessarilyQualifiedStaticUsage` inspection violations.\n\nDescription:\n>Reports calls to static methods or accesses of static fields on the current class which are qualified with the class name. Such qualification is unnecessary, and may be safely removed.\n",
			"commitDate": "2015-08-11, 2:14 PM",
			"commitName": "82d8e91024a57a96fbb6410dacb29d6a3f582903",
			"commitAuthor": "Michal Kordas",
			"commitDateOld": "2015-08-11, 6:18 AM",
			"commitNameOld": "1935bed5772c0a939b9168b81acd2ab5aa800538",
			"commitAuthorOld": "Baratali Izmailov",
			"daysBetweenCommits": 0.33,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,45 @@\n     protected void processFiltered(File file, List<String> lines) {\n         // check if already checked and passed the file\n         final String fileName = file.getPath();\n         final long timestamp = file.lastModified();\n         if (cache != null\n                 && (cache.inCache(fileName, timestamp)\n                     || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n             return;\n         }\n \n         final String msg = \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n-            final DetailAST rootAST = TreeWalker.parse(contents);\n+            final DetailAST rootAST = parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re = tre.recog;\n             String message;\n             message = re.getMessage();\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg = String.format(msg, ex.getClass().getSimpleName(), fileName);\n             LOG.error(exceptionMsg, ex);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (cache != null && getMessageCollector().size() == 0) {\n             cache.put(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8a3f5bf6d5389b9e175c9c769992faece6d76ada": {
			"type": "Ybodychange",
			"commitMessage": "Remove unused assignments. #1555\n\nFixes UnusedAssignment inspection violations.\n\nDescription:\n>This inspection points out the cases where a variable value is never used after its assignment, i.e.:\n- the variable never gets read after assignment OR\n- the value is always overwritten with another assignment before the next variable read OR\n - the variable initializer is redundant (for one of the above two reasons) OR\n - the variable is never used.\n",
			"commitDate": "2015-08-07, 10:12 PM",
			"commitName": "8a3f5bf6d5389b9e175c9c769992faece6d76ada",
			"commitAuthor": "Michal Kordas",
			"commitDateOld": "2015-08-05, 6:39 AM",
			"commitNameOld": "a2da840df3bcb4e251695f7fbf1a5d341142459d",
			"commitAuthorOld": "Roman Ivanov",
			"daysBetweenCommits": 2.65,
			"commitsBetweenForRepo": 18,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,45 @@\n     protected void processFiltered(File file, List<String> lines) {\n         // check if already checked and passed the file\n         final String fileName = file.getPath();\n         final long timestamp = file.lastModified();\n         if (cache != null\n                 && (cache.inCache(fileName, timestamp)\n                     || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n             return;\n         }\n \n         final String msg = \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re = tre.recog;\n-            String message = \"TokenStreamRecognitionException occured\";\n+            String message;\n             message = re.getMessage();\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg = String.format(msg, ex.getClass().getSimpleName(), fileName);\n             LOG.error(exceptionMsg, ex);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (cache != null && getMessageCollector().size() == 0) {\n             cache.put(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a2da840df3bcb4e251695f7fbf1a5d341142459d": {
			"type": "Ybodychange",
			"commitMessage": "100% UTs coverage for TreeWalker. #1294\n",
			"commitDate": "2015-08-05, 6:39 AM",
			"commitName": "a2da840df3bcb4e251695f7fbf1a5d341142459d",
			"commitAuthor": "Roman Ivanov",
			"commitDateOld": "2015-08-02, 7:48 PM",
			"commitNameOld": "6fd60de0a4363b806d37d4129d9a430f8f3dee6b",
			"commitAuthorOld": "Michal Kordas",
			"daysBetweenCommits": 2.45,
			"commitsBetweenForRepo": 19,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,47 +1,45 @@\n     protected void processFiltered(File file, List<String> lines) {\n         // check if already checked and passed the file\n         final String fileName = file.getPath();\n         final long timestamp = file.lastModified();\n         if (cache != null\n                 && (cache.inCache(fileName, timestamp)\n                     || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n             return;\n         }\n \n         final String msg = \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re = tre.recog;\n             String message = \"TokenStreamRecognitionException occured\";\n-            if (re != null) {\n-                message = re.getMessage();\n-            }\n+            message = re.getMessage();\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg = String.format(msg, ex.getClass().getSimpleName(), fileName);\n             LOG.error(exceptionMsg, ex);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (cache != null && getMessageCollector().size() == 0) {\n             cache.put(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ea9ff3965d9c657b5b7bd2d969e075f430635c47": {
			"type": "Ybodychange",
			"commitMessage": "100% UTs coverage for PropertyCacheFile. Refactoring of PropertyCacheFile. #1294\n",
			"commitDate": "2015-07-28, 11:12 AM",
			"commitName": "ea9ff3965d9c657b5b7bd2d969e075f430635c47",
			"commitAuthor": "Roman Ivanov",
			"commitDateOld": "2015-07-12, 10:32 AM",
			"commitNameOld": "8da777a68ad936f1a4e07d59cee17ecab2fc293e",
			"commitAuthorOld": "Michal Kordas",
			"daysBetweenCommits": 16.03,
			"commitsBetweenForRepo": 180,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,46 +1,47 @@\n     protected void processFiltered(File file, List<String> lines) {\n         // check if already checked and passed the file\n         final String fileName = file.getPath();\n         final long timestamp = file.lastModified();\n-        if (cache.alreadyChecked(fileName, timestamp)\n-                 || !Utils.fileExtensionMatches(file, getFileExtensions())) {\n+        if (cache != null\n+                && (cache.inCache(fileName, timestamp)\n+                    || !Utils.fileExtensionMatches(file, getFileExtensions()))) {\n             return;\n         }\n \n         final String msg = \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re = tre.recog;\n             String message = \"TokenStreamRecognitionException occured\";\n             if (re != null) {\n                 message = re.getMessage();\n             }\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg = String.format(msg, ex.getClass().getSimpleName(), fileName);\n             LOG.error(exceptionMsg, ex);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n-        if (getMessageCollector().size() == 0) {\n-            cache.checkedOk(fileName, timestamp);\n+        if (cache != null && getMessageCollector().size() == 0) {\n+            cache.put(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"56743942d548686fb90ebd8b7a17fed5977e49dc": {
			"type": "Ybodychange",
			"commitMessage": "Extend ReturnCount Check to treat lambdas  separately. #1068\n",
			"commitDate": "2015-05-16, 11:19 PM",
			"commitName": "56743942d548686fb90ebd8b7a17fed5977e49dc",
			"commitAuthor": "Michal Kordas",
			"commitDateOld": "2015-05-15, 4:31 PM",
			"commitNameOld": "5e0b6286ac1e4f52c9769c764bc2978ab0fc0037",
			"commitAuthorOld": "Roman Ivanov",
			"daysBetweenCommits": 1.28,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,48 +1,48 @@\n     protected void processFiltered(File file, List<String> lines)\n     {\n         // check if already checked and passed the file\n         final String fileName = file.getPath();\n         final long timestamp = file.lastModified();\n         if (cache.alreadyChecked(fileName, timestamp)\n                  || !Utils.fileExtensionMatches(file, getFileExtensions()))\n         {\n             return;\n         }\n \n         final String msg = \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re = tre.recog;\n             String message = \"TokenStreamRecognitionException occured\";\n             if (re != null) {\n                 message = re.getMessage();\n             }\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg = String.format(msg, ex.getClass().getSimpleName(), fileName);\n-            LOG.error(exceptionMsg);\n+            LOG.error(exceptionMsg, ex);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             cache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"aeef83ee58cce5b5bf0f10a8793fc37514751ef5": {
			"type": "Ybodychange",
			"commitMessage": "Remove obsolete space from error message",
			"commitDate": "2015-04-30, 5:21 PM",
			"commitName": "aeef83ee58cce5b5bf0f10a8793fc37514751ef5",
			"commitAuthor": "Micha Kordas",
			"commitDateOld": "2015-04-29, 6:21 PM",
			"commitNameOld": "c0446a825514ea0279b8c22f633f2c4e3c73dc1f",
			"commitAuthorOld": "Michal Kordas",
			"daysBetweenCommits": 0.96,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,48 +1,48 @@\n     protected void processFiltered(File file, List<String> lines)\n     {\n         // check if already checked and passed the file\n         final String fileName = file.getPath();\n         final long timestamp = file.lastModified();\n         if (cache.alreadyChecked(fileName, timestamp)\n                  || !Utils.fileExtensionMatches(file, getFileExtensions()))\n         {\n             return;\n         }\n \n-        final String msg = \"%s occurred during the analysis of file %s .\";\n+        final String msg = \"%s occurred during the analysis of file %s.\";\n \n         try {\n             final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re = tre.recog;\n             String message = \"TokenStreamRecognitionException occured\";\n             if (re != null) {\n                 message = re.getMessage();\n             }\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg = String.format(msg, ex.getClass().getSimpleName(), fileName);\n             LOG.error(exceptionMsg);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             cache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f374e2e7a0b0fe2df21ed85aef77a91630b1dd66": {
			"type": "Ybodychange",
			"commitMessage": "Fix AvoidStaticImport check violations in codebase, issue #979\n",
			"commitDate": "2015-04-26, 10:13 AM",
			"commitName": "f374e2e7a0b0fe2df21ed85aef77a91630b1dd66",
			"commitAuthor": "Michal Kordas",
			"commitDateOld": "2015-04-25, 6:30 PM",
			"commitNameOld": "55b266cd92adf7b5e18f84ddee839d63f9330c5b",
			"commitAuthorOld": "Michal Kordas",
			"daysBetweenCommits": 0.66,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,48 +1,48 @@\n     protected void processFiltered(File file, List<String> lines)\n     {\n         // check if already checked and passed the file\n         final String fileName = file.getPath();\n         final long timestamp = file.lastModified();\n         if (cache.alreadyChecked(fileName, timestamp)\n-                 || !fileExtensionMatches(file, getFileExtensions()))\n+                 || !Utils.fileExtensionMatches(file, getFileExtensions()))\n         {\n             return;\n         }\n \n         final String msg = \"%s occurred during the analysis of file %s .\";\n \n         try {\n             final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             LOG.error(exceptionMsg);\n             final RecognitionException re = tre.recog;\n             String message = \"TokenStreamRecognitionException occured\";\n             if (re != null) {\n                 message = re.getMessage();\n             }\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg = String.format(msg, ex.getClass().getSimpleName(), fileName);\n             LOG.error(exceptionMsg);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             cache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ee518dfe86b29d1fa4d76f0dc0c11fb83afafda1": {
			"type": "Ybodychange",
			"commitMessage": "Fix PMD violations from 'logging-jakarta' ruleset, issue #871\n",
			"commitDate": "2015-04-13, 3:43 PM",
			"commitName": "ee518dfe86b29d1fa4d76f0dc0c11fb83afafda1",
			"commitAuthor": "Michal Kordas",
			"commitDateOld": "2015-04-11, 4:41 PM",
			"commitNameOld": "7dd24c8c35572b5db3e5c905d440e813cfe2538c",
			"commitAuthorOld": "Roman Ivanov",
			"daysBetweenCommits": 1.96,
			"commitsBetweenForRepo": 10,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,48 +1,48 @@\n     protected void processFiltered(File file, List<String> lines)\n     {\n         // check if already checked and passed the file\n         final String fileName = file.getPath();\n         final long timestamp = file.lastModified();\n         if (cache.alreadyChecked(fileName, timestamp)\n                  || !fileExtensionMatches(file, getFileExtensions()))\n         {\n             return;\n         }\n \n         final String msg = \"%s occurred during the analysis of file %s .\";\n \n         try {\n             final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n-            Utils.getExceptionLogger().error(exceptionMsg);\n+            LOG.error(exceptionMsg);\n             final RecognitionException re = tre.recog;\n             String message = \"TokenStreamRecognitionException occured\";\n             if (re != null) {\n                 message = re.getMessage();\n             }\n             getMessageCollector().add(createLocalizedMessage(message));\n         }\n         // RecognitionException and any other (need to check if needed)\n         catch (Throwable ex) {\n             final String exceptionMsg = String.format(msg, ex.getClass().getSimpleName(), fileName);\n-            Utils.getExceptionLogger().error(exceptionMsg);\n+            LOG.error(exceptionMsg);\n             getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             cache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1dacd5303bfe94b9d5476059b6a5676146d96708": {
			"type": "Ybodychange",
			"commitMessage": "Merged catch blocks into one where possible\n\nPull #825\n",
			"commitDate": "2015-03-24, 3:48 PM",
			"commitName": "1dacd5303bfe94b9d5476059b6a5676146d96708",
			"commitAuthor": "Damian Szczepanik",
			"commitDateOld": "2015-03-23, 5:00 PM",
			"commitNameOld": "14e0b0ea52977de4a8d8ceb6bab1420e84093a21",
			"commitAuthorOld": "Michal Kordas",
			"daysBetweenCommits": 0.95,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,97 +1,48 @@\n     protected void processFiltered(File file, List<String> lines)\n     {\n         // check if already checked and passed the file\n         final String fileName = file.getPath();\n         final long timestamp = file.lastModified();\n         if (cache.alreadyChecked(fileName, timestamp)\n                  || !fileExtensionMatches(file, getFileExtensions()))\n         {\n             return;\n         }\n \n         final String msg = \"%s occurred during the analysis of file %s .\";\n \n         try {\n             final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n-        catch (final RecognitionException re) {\n-            final String exceptionMsg = String.format(msg, \"RecognitionException\", fileName);\n-            Utils.getExceptionLogger().error(exceptionMsg);\n-            getMessageCollector().add(\n-                new LocalizedMessage(\n-                    re.getLine(),\n-                    re.getColumn(),\n-                    Defn.CHECKSTYLE_BUNDLE,\n-                    \"general.exception\",\n-                    new String[] {re.getMessage()},\n-                    getId(),\n-                    this.getClass(), null));\n-        }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             final RecognitionException re = tre.recog;\n+            String message = \"TokenStreamRecognitionException occured\";\n             if (re != null) {\n-                getMessageCollector().add(\n-                    new LocalizedMessage(\n-                        re.getLine(),\n-                        re.getColumn(),\n-                        Defn.CHECKSTYLE_BUNDLE,\n-                        \"general.exception\",\n-                        new String[] {re.getMessage()},\n-                        getId(),\n-                        this.getClass(), null));\n+                message = re.getMessage();\n             }\n-            else {\n-                getMessageCollector().add(\n-                    new LocalizedMessage(\n-                        0,\n-                        Defn.CHECKSTYLE_BUNDLE,\n-                        \"general.exception\",\n-                        new String[]\n-                        {\"TokenStreamRecognitionException occured.\"},\n-                        getId(),\n-                        this.getClass(), null));\n-            }\n+            getMessageCollector().add(createLocalizedMessage(message));\n         }\n-        catch (final TokenStreamException te) {\n-            final String exceptionMsg = String.format(msg,\n-                    \"TokenStreamException\", fileName);\n+        // RecognitionException and any other (need to check if needed)\n+        catch (Throwable ex) {\n+            final String exceptionMsg = String.format(msg, ex.getClass().getSimpleName(), fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n-            getMessageCollector().add(\n-                new LocalizedMessage(\n-                    0,\n-                    Defn.CHECKSTYLE_BUNDLE,\n-                    \"general.exception\",\n-                    new String[] {te.getMessage()},\n-                    getId(),\n-                    this.getClass(), null));\n-        }\n-        catch (final Throwable err) {\n-            final String exceptionMsg = String.format(msg, \"Exception\", fileName);\n-            Utils.getExceptionLogger().error(exceptionMsg);\n-            getMessageCollector().add(\n-                new LocalizedMessage(\n-                    0,\n-                    Defn.CHECKSTYLE_BUNDLE,\n-                    \"general.exception\",\n-                    new String[] {\"\" + err},\n-                    getId(),\n-                    this.getClass(), null));\n+            getMessageCollector().add(createLocalizedMessage(ex.getMessage()));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             cache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"14e0b0ea52977de4a8d8ceb6bab1420e84093a21": {
			"type": "Ybodychange",
			"commitMessage": "Remove unwritten field, issue #778\n\nAll violations of Findbugs rule [UwF: Unwritten field](http://findbugs.sourceforge.net/bugDescriptions.html#UWF_UNWRITTEN_FIELD) are fixed.\n",
			"commitDate": "2015-03-23, 5:00 PM",
			"commitName": "14e0b0ea52977de4a8d8ceb6bab1420e84093a21",
			"commitAuthor": "Michal Kordas",
			"commitDateOld": "2015-03-16, 11:46 PM",
			"commitNameOld": "b9a1bec65f9eec7b96add7336dfcca4bf284e479",
			"commitAuthorOld": "alexkravin",
			"daysBetweenCommits": 6.72,
			"commitsBetweenForRepo": 33,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,97 +1,97 @@\n     protected void processFiltered(File file, List<String> lines)\n     {\n         // check if already checked and passed the file\n         final String fileName = file.getPath();\n         final long timestamp = file.lastModified();\n         if (cache.alreadyChecked(fileName, timestamp)\n-                 || !fileExtensionMatches(file, fileExtensions))\n+                 || !fileExtensionMatches(file, getFileExtensions()))\n         {\n             return;\n         }\n \n         final String msg = \"%s occurred during the analysis of file %s .\";\n \n         try {\n             final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final RecognitionException re) {\n             final String exceptionMsg = String.format(msg, \"RecognitionException\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             final RecognitionException re = tre.recog;\n             if (re != null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n                         this.getClass(), null));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n                         this.getClass(), null));\n             }\n         }\n         catch (final TokenStreamException te) {\n             final String exceptionMsg = String.format(msg,\n                     \"TokenStreamException\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final Throwable err) {\n             final String exceptionMsg = String.format(msg, \"Exception\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n                     this.getClass(), null));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             cache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b9a1bec65f9eec7b96add7336dfcca4bf284e479": {
			"type": "Ybodychange",
			"commitMessage": "Removed printStackTrace(...) from whole code, issue #660\n",
			"commitDate": "2015-03-16, 11:46 PM",
			"commitName": "b9a1bec65f9eec7b96add7336dfcca4bf284e479",
			"commitAuthor": "alexkravin",
			"commitDateOld": "2015-03-15, 3:22 PM",
			"commitNameOld": "1c15b6a36baa68dc3f2ebdf9baac131e98bb9e04",
			"commitAuthorOld": "alexkravin",
			"daysBetweenCommits": 1.35,
			"commitsBetweenForRepo": 14,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,98 +1,97 @@\n     protected void processFiltered(File file, List<String> lines)\n     {\n         // check if already checked and passed the file\n         final String fileName = file.getPath();\n         final long timestamp = file.lastModified();\n         if (cache.alreadyChecked(fileName, timestamp)\n                  || !fileExtensionMatches(file, fileExtensions))\n         {\n             return;\n         }\n \n         final String msg = \"%s occurred during the analysis of file %s .\";\n \n         try {\n             final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final RecognitionException re) {\n             final String exceptionMsg = String.format(msg, \"RecognitionException\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             final RecognitionException re = tre.recog;\n             if (re != null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n                         this.getClass(), null));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n                         this.getClass(), null));\n             }\n         }\n         catch (final TokenStreamException te) {\n             final String exceptionMsg = String.format(msg,\n                     \"TokenStreamException\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final Throwable err) {\n             final String exceptionMsg = String.format(msg, \"Exception\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n-            err.printStackTrace();\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n                     this.getClass(), null));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             cache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"204c073294cdca6756bcd546d6af85a797ad7d79": {
			"type": "Ybodychange",
			"commitMessage": "Added file extensions property to Checker & TreeWalker, issue #25\n",
			"commitDate": "2015-01-25, 2:30 AM",
			"commitName": "204c073294cdca6756bcd546d6af85a797ad7d79",
			"commitAuthor": "alexkravin",
			"commitDateOld": "2015-01-22, 5:26 AM",
			"commitNameOld": "95c1a081e0868fc3ac9faf05d09ca8b2bb06a5cc",
			"commitAuthorOld": "alexkravin",
			"daysBetweenCommits": 2.88,
			"commitsBetweenForRepo": 11,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,96 +1,98 @@\n     protected void processFiltered(File file, List<String> lines)\n     {\n         // check if already checked and passed the file\n         final String fileName = file.getPath();\n         final long timestamp = file.lastModified();\n-        if (cache.alreadyChecked(fileName, timestamp)) {\n+        if (cache.alreadyChecked(fileName, timestamp)\n+                 || !fileExtensionMatches(file, fileExtensions))\n+        {\n             return;\n         }\n \n         final String msg = \"%s occurred during the analysis of file %s .\";\n \n         try {\n             final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final RecognitionException re) {\n             final String exceptionMsg = String.format(msg, \"RecognitionException\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             final RecognitionException re = tre.recog;\n             if (re != null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n                         this.getClass(), null));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n                         this.getClass(), null));\n             }\n         }\n         catch (final TokenStreamException te) {\n             final String exceptionMsg = String.format(msg,\n                     \"TokenStreamException\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final Throwable err) {\n             final String exceptionMsg = String.format(msg, \"Exception\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             err.printStackTrace();\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n                     this.getClass(), null));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             cache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Prefixes, checkstyle, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java\n",
			"commitDate": "2015-01-19, 7:38 AM",
			"commitName": "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
			"commitAuthor": "alexkravin",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Prefixes, checkstyle, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java\n",
					"commitDate": "2015-01-19, 7:38 AM",
					"commitName": "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
					"commitAuthor": "alexkravin",
					"commitDateOld": "2015-01-13, 12:20 PM",
					"commitNameOld": "501b7c5240705c6db756608618fdcf58189e807e",
					"commitAuthorOld": "Michal Kordas",
					"daysBetweenCommits": 5.8,
					"commitsBetweenForRepo": 27,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,96 +1,96 @@\n-    protected void processFiltered(File aFile, List<String> aLines)\n+    protected void processFiltered(File file, List<String> lines)\n     {\n         // check if already checked and passed the file\n-        final String fileName = aFile.getPath();\n-        final long timestamp = aFile.lastModified();\n-        if (mCache.alreadyChecked(fileName, timestamp)) {\n+        final String fileName = file.getPath();\n+        final long timestamp = file.lastModified();\n+        if (cache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         final String msg = \"%s occurred during the analysis of file %s .\";\n \n         try {\n-            final FileText text = FileText.fromLines(aFile, aLines);\n+            final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final RecognitionException re) {\n             final String exceptionMsg = String.format(msg, \"RecognitionException\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             final RecognitionException re = tre.recog;\n             if (re != null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n                         this.getClass(), null));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n                         this.getClass(), null));\n             }\n         }\n         catch (final TokenStreamException te) {\n             final String exceptionMsg = String.format(msg,\n                     \"TokenStreamException\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final Throwable err) {\n             final String exceptionMsg = String.format(msg, \"Exception\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             err.printStackTrace();\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n                     this.getClass(), null));\n         }\n \n         if (getMessageCollector().size() == 0) {\n-            mCache.checkedOk(fileName, timestamp);\n+            cache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[aFile-File, aLines-List<String>]",
						"newValue": "[file-File, lines-List<String>]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Prefixes, checkstyle, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java\n",
					"commitDate": "2015-01-19, 7:38 AM",
					"commitName": "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
					"commitAuthor": "alexkravin",
					"commitDateOld": "2015-01-13, 12:20 PM",
					"commitNameOld": "501b7c5240705c6db756608618fdcf58189e807e",
					"commitAuthorOld": "Michal Kordas",
					"daysBetweenCommits": 5.8,
					"commitsBetweenForRepo": 27,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,96 +1,96 @@\n-    protected void processFiltered(File aFile, List<String> aLines)\n+    protected void processFiltered(File file, List<String> lines)\n     {\n         // check if already checked and passed the file\n-        final String fileName = aFile.getPath();\n-        final long timestamp = aFile.lastModified();\n-        if (mCache.alreadyChecked(fileName, timestamp)) {\n+        final String fileName = file.getPath();\n+        final long timestamp = file.lastModified();\n+        if (cache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         final String msg = \"%s occurred during the analysis of file %s .\";\n \n         try {\n-            final FileText text = FileText.fromLines(aFile, aLines);\n+            final FileText text = FileText.fromLines(file, lines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final RecognitionException re) {\n             final String exceptionMsg = String.format(msg, \"RecognitionException\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n                      fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             final RecognitionException re = tre.recog;\n             if (re != null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n                         this.getClass(), null));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n                         this.getClass(), null));\n             }\n         }\n         catch (final TokenStreamException te) {\n             final String exceptionMsg = String.format(msg,\n                     \"TokenStreamException\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final Throwable err) {\n             final String exceptionMsg = String.format(msg, \"Exception\", fileName);\n             Utils.getExceptionLogger().error(exceptionMsg);\n             err.printStackTrace();\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n                     this.getClass(), null));\n         }\n \n         if (getMessageCollector().size() == 0) {\n-            mCache.checkedOk(fileName, timestamp);\n+            cache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"a8b8375b1db65b131938111ff283baed771161ed": {
			"type": "Ybodychange",
			"commitMessage": "Logging of exceptions to console, issue #546\n",
			"commitDate": "2015-01-09, 9:42 AM",
			"commitName": "a8b8375b1db65b131938111ff283baed771161ed",
			"commitAuthor": "alexkravin",
			"commitDateOld": "2014-11-04, 6:30 PM",
			"commitNameOld": "f2b19f10806dc89807888a772de34177c36c602b",
			"commitAuthorOld": "Vladimir Sitnikov",
			"daysBetweenCommits": 65.63,
			"commitsBetweenForRepo": 217,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,91 +1,96 @@\n     protected void processFiltered(File aFile, List<String> aLines)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n+        final String msg = \"%s occurred during the analysis of file %s .\";\n+\n         try {\n             final FileText text = FileText.fromLines(aFile, aLines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n \n             getMessageCollector().reset();\n \n             walk(rootAST, contents, AstState.ORDINARY);\n \n             final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n \n             walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final RecognitionException re) {\n-            Utils.getExceptionLogger()\n-                .debug(\"RecognitionException occured.\", re);\n+            final String exceptionMsg = String.format(msg, \"RecognitionException\", fileName);\n+            Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final TokenStreamRecognitionException tre) {\n-            Utils.getExceptionLogger()\n-                .debug(\"TokenStreamRecognitionException occured.\", tre);\n+            final String exceptionMsg = String.format(msg, \"TokenStreamRecognitionException\",\n+                     fileName);\n+            Utils.getExceptionLogger().error(exceptionMsg);\n             final RecognitionException re = tre.recog;\n             if (re != null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n                         this.getClass(), null));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n                         this.getClass(), null));\n             }\n         }\n         catch (final TokenStreamException te) {\n-            Utils.getExceptionLogger()\n-                .debug(\"TokenStreamException occured.\", te);\n+            final String exceptionMsg = String.format(msg,\n+                    \"TokenStreamException\", fileName);\n+            Utils.getExceptionLogger().error(exceptionMsg);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final Throwable err) {\n+            final String exceptionMsg = String.format(msg, \"Exception\", fileName);\n+            Utils.getExceptionLogger().error(exceptionMsg);\n             err.printStackTrace();\n-            Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n                     this.getClass(), null));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a24df47cafeab03fd65cf72b460aad3d2fafce3d": {
			"type": "Ybodychange",
			"commitMessage": "Issue #49. Added support of single-line and block comments\n",
			"commitDate": "2014-10-17, 11:19 PM",
			"commitName": "a24df47cafeab03fd65cf72b460aad3d2fafce3d",
			"commitAuthor": "Baratali Izmailov",
			"commitDateOld": "2014-10-17, 11:19 PM",
			"commitNameOld": "59014fa7539bdbaacda4325454964492db0c6109",
			"commitAuthorOld": "Baratali Izmailov",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,83 +1,91 @@\n     protected void processFiltered(File aFile, List<String> aLines)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n             final FileText text = FileText.fromLines(aFile, aLines);\n             final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n-            walk(rootAST, contents);\n+\n+            getMessageCollector().reset();\n+\n+            walk(rootAST, contents, AstState.ORDINARY);\n+\n+            final DetailAST astWithComments = appendHiddenCommentNodes(rootAST);\n+\n+            walk(astWithComments, contents, AstState.WITH_COMMENTS);\n         }\n         catch (final RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamRecognitionException occured.\", tre);\n             final RecognitionException re = tre.recog;\n             if (re != null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n                         this.getClass(), null));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n                         this.getClass(), null));\n             }\n         }\n         catch (final TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final Throwable err) {\n+            err.printStackTrace();\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n                     this.getClass(), null));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f1efb27670a93690577f1bae17fc9dcbd88a795d": {
			"type": "Yfilerename",
			"commitMessage": "moving to standard directory layout\n",
			"commitDate": "2014-03-04, 10:18 AM",
			"commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
			"commitAuthor": "Ivan Sopov",
			"commitDateOld": "2014-02-26, 11:35 PM",
			"commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
			"commitAuthorOld": "Andrew Gaul",
			"daysBetweenCommits": 5.45,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
				"newPath": "src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java"
			}
		},
		"3cd6646941eca3da7d3b9a221c88e4c1d214876e": {
			"type": "Ybodychange",
			"commitMessage": "Apply patch #2783226 that uses FileText as an implementation for\nList<String> to pass lines around\n",
			"commitDate": "2010-06-28, 7:02 AM",
			"commitName": "3cd6646941eca3da7d3b9a221c88e4c1d214876e",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2010-02-12, 7:57 PM",
			"commitNameOld": "523080bbf2be11354b94b851ac85d06e7e8a2c14",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 135.42,
			"commitsBetweenForRepo": 15,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,83 +1,83 @@\n     protected void processFiltered(File aFile, List<String> aLines)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n-            final FileContents contents = new FileContents(fileName, aLines\n-                    .toArray(new String[aLines.size()]));\n+            final FileText text = FileText.fromLines(aFile, aLines);\n+            final FileContents contents = new FileContents(text);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (final RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamRecognitionException occured.\", tre);\n             final RecognitionException re = tre.recog;\n             if (re != null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n                         this.getClass(), null));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n                         this.getClass(), null));\n             }\n         }\n         catch (final TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final Throwable err) {\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n                     this.getClass(), null));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"13b7c634337e38d20daa92ca9d5e069a2e72ec55": {
			"type": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange)",
			"commitMessage": "A large refactoring to move the functionality of open/reporting on files into Checker and out of FileSetCheck. The advantages are:\n\n- reduces the logic required in each implementation of FileSetCheck.\n\n- reduces, but not eliminates, the number of times a file is reported as being audited.\n\n- reduces the amount of times a file needs to be read in from the file system.\n\nThe motivation is the desire to move more checks to be purely FileSetCheck based, like the TabCharacter check.\n\nI still need to do some tidying up of the documentation, and make Checker support \"charset\".\n",
			"commitDate": "2008-11-09, 2:37 AM",
			"commitName": "13b7c634337e38d20daa92ca9d5e069a2e72ec55",
			"commitAuthor": "Oliver Burn",
			"subchanges": [
				{
					"type": "Yrename",
					"commitMessage": "A large refactoring to move the functionality of open/reporting on files into Checker and out of FileSetCheck. The advantages are:\n\n- reduces the logic required in each implementation of FileSetCheck.\n\n- reduces, but not eliminates, the number of times a file is reported as being audited.\n\n- reduces the amount of times a file needs to be read in from the file system.\n\nThe motivation is the desire to move more checks to be purely FileSetCheck based, like the TabCharacter check.\n\nI still need to do some tidying up of the documentation, and make Checker support \"charset\".\n",
					"commitDate": "2008-11-09, 2:37 AM",
					"commitName": "13b7c634337e38d20daa92ca9d5e069a2e72ec55",
					"commitAuthor": "Oliver Burn",
					"commitDateOld": "2008-09-18, 5:34 AM",
					"commitNameOld": "d62a2cc02092cb6c1a1666630a51a6ec7c50a878",
					"commitAuthorOld": "Oliver Burn",
					"daysBetweenCommits": 51.92,
					"commitsBetweenForRepo": 14,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,112 +1,83 @@\n-    private void process(File aFile)\n+    protected void processFiltered(File aFile, List<String> aLines)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n-            getMessageDispatcher().fireFileStarted(fileName);\n-            final String[] lines = Utils.getLines(fileName, getCharset());\n-            final FileContents contents = new FileContents(fileName, lines);\n+            final FileContents contents = new FileContents(fileName, aLines\n+                    .toArray(new String[aLines.size()]));\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n-        catch (final FileNotFoundException fnfe) {\n-            Utils.getExceptionLogger()\n-                .debug(\"FileNotFoundException occured.\", fnfe);\n-            getMessageCollector().add(\n-                new LocalizedMessage(\n-                    0,\n-                    Defn.CHECKSTYLE_BUNDLE,\n-                    \"general.fileNotFound\",\n-                    null,\n-                    getId(),\n-                    this.getClass(), null));\n-        }\n-        catch (final IOException ioe) {\n-            Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n-            getMessageCollector().add(\n-                new LocalizedMessage(\n-                    0,\n-                    Defn.CHECKSTYLE_BUNDLE,\n-                    \"general.exception\",\n-                    new String[] {ioe.getMessage()},\n-                    getId(),\n-                    this.getClass(), null));\n-        }\n         catch (final RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamRecognitionException occured.\", tre);\n             final RecognitionException re = tre.recog;\n             if (re != null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n                         this.getClass(), null));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n                         this.getClass(), null));\n             }\n         }\n         catch (final TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final Throwable err) {\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n                     this.getClass(), null));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n-        else {\n-            fireErrors(fileName);\n-        }\n-\n-        getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "process",
						"newValue": "processFiltered"
					}
				},
				{
					"type": "Yparameterchange",
					"commitMessage": "A large refactoring to move the functionality of open/reporting on files into Checker and out of FileSetCheck. The advantages are:\n\n- reduces the logic required in each implementation of FileSetCheck.\n\n- reduces, but not eliminates, the number of times a file is reported as being audited.\n\n- reduces the amount of times a file needs to be read in from the file system.\n\nThe motivation is the desire to move more checks to be purely FileSetCheck based, like the TabCharacter check.\n\nI still need to do some tidying up of the documentation, and make Checker support \"charset\".\n",
					"commitDate": "2008-11-09, 2:37 AM",
					"commitName": "13b7c634337e38d20daa92ca9d5e069a2e72ec55",
					"commitAuthor": "Oliver Burn",
					"commitDateOld": "2008-09-18, 5:34 AM",
					"commitNameOld": "d62a2cc02092cb6c1a1666630a51a6ec7c50a878",
					"commitAuthorOld": "Oliver Burn",
					"daysBetweenCommits": 51.92,
					"commitsBetweenForRepo": 14,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,112 +1,83 @@\n-    private void process(File aFile)\n+    protected void processFiltered(File aFile, List<String> aLines)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n-            getMessageDispatcher().fireFileStarted(fileName);\n-            final String[] lines = Utils.getLines(fileName, getCharset());\n-            final FileContents contents = new FileContents(fileName, lines);\n+            final FileContents contents = new FileContents(fileName, aLines\n+                    .toArray(new String[aLines.size()]));\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n-        catch (final FileNotFoundException fnfe) {\n-            Utils.getExceptionLogger()\n-                .debug(\"FileNotFoundException occured.\", fnfe);\n-            getMessageCollector().add(\n-                new LocalizedMessage(\n-                    0,\n-                    Defn.CHECKSTYLE_BUNDLE,\n-                    \"general.fileNotFound\",\n-                    null,\n-                    getId(),\n-                    this.getClass(), null));\n-        }\n-        catch (final IOException ioe) {\n-            Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n-            getMessageCollector().add(\n-                new LocalizedMessage(\n-                    0,\n-                    Defn.CHECKSTYLE_BUNDLE,\n-                    \"general.exception\",\n-                    new String[] {ioe.getMessage()},\n-                    getId(),\n-                    this.getClass(), null));\n-        }\n         catch (final RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamRecognitionException occured.\", tre);\n             final RecognitionException re = tre.recog;\n             if (re != null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n                         this.getClass(), null));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n                         this.getClass(), null));\n             }\n         }\n         catch (final TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final Throwable err) {\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n                     this.getClass(), null));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n-        else {\n-            fireErrors(fileName);\n-        }\n-\n-        getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[aFile-File]",
						"newValue": "[aFile-File, aLines-List<String>]"
					}
				},
				{
					"type": "Ymodifierchange",
					"commitMessage": "A large refactoring to move the functionality of open/reporting on files into Checker and out of FileSetCheck. The advantages are:\n\n- reduces the logic required in each implementation of FileSetCheck.\n\n- reduces, but not eliminates, the number of times a file is reported as being audited.\n\n- reduces the amount of times a file needs to be read in from the file system.\n\nThe motivation is the desire to move more checks to be purely FileSetCheck based, like the TabCharacter check.\n\nI still need to do some tidying up of the documentation, and make Checker support \"charset\".\n",
					"commitDate": "2008-11-09, 2:37 AM",
					"commitName": "13b7c634337e38d20daa92ca9d5e069a2e72ec55",
					"commitAuthor": "Oliver Burn",
					"commitDateOld": "2008-09-18, 5:34 AM",
					"commitNameOld": "d62a2cc02092cb6c1a1666630a51a6ec7c50a878",
					"commitAuthorOld": "Oliver Burn",
					"daysBetweenCommits": 51.92,
					"commitsBetweenForRepo": 14,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,112 +1,83 @@\n-    private void process(File aFile)\n+    protected void processFiltered(File aFile, List<String> aLines)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n-            getMessageDispatcher().fireFileStarted(fileName);\n-            final String[] lines = Utils.getLines(fileName, getCharset());\n-            final FileContents contents = new FileContents(fileName, lines);\n+            final FileContents contents = new FileContents(fileName, aLines\n+                    .toArray(new String[aLines.size()]));\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n-        catch (final FileNotFoundException fnfe) {\n-            Utils.getExceptionLogger()\n-                .debug(\"FileNotFoundException occured.\", fnfe);\n-            getMessageCollector().add(\n-                new LocalizedMessage(\n-                    0,\n-                    Defn.CHECKSTYLE_BUNDLE,\n-                    \"general.fileNotFound\",\n-                    null,\n-                    getId(),\n-                    this.getClass(), null));\n-        }\n-        catch (final IOException ioe) {\n-            Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n-            getMessageCollector().add(\n-                new LocalizedMessage(\n-                    0,\n-                    Defn.CHECKSTYLE_BUNDLE,\n-                    \"general.exception\",\n-                    new String[] {ioe.getMessage()},\n-                    getId(),\n-                    this.getClass(), null));\n-        }\n         catch (final RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamRecognitionException occured.\", tre);\n             final RecognitionException re = tre.recog;\n             if (re != null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n                         this.getClass(), null));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n                         this.getClass(), null));\n             }\n         }\n         catch (final TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final Throwable err) {\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n                     this.getClass(), null));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n-        else {\n-            fireErrors(fileName);\n-        }\n-\n-        getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[private]",
						"newValue": "[protected]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "A large refactoring to move the functionality of open/reporting on files into Checker and out of FileSetCheck. The advantages are:\n\n- reduces the logic required in each implementation of FileSetCheck.\n\n- reduces, but not eliminates, the number of times a file is reported as being audited.\n\n- reduces the amount of times a file needs to be read in from the file system.\n\nThe motivation is the desire to move more checks to be purely FileSetCheck based, like the TabCharacter check.\n\nI still need to do some tidying up of the documentation, and make Checker support \"charset\".\n",
					"commitDate": "2008-11-09, 2:37 AM",
					"commitName": "13b7c634337e38d20daa92ca9d5e069a2e72ec55",
					"commitAuthor": "Oliver Burn",
					"commitDateOld": "2008-09-18, 5:34 AM",
					"commitNameOld": "d62a2cc02092cb6c1a1666630a51a6ec7c50a878",
					"commitAuthorOld": "Oliver Burn",
					"daysBetweenCommits": 51.92,
					"commitsBetweenForRepo": 14,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,112 +1,83 @@\n-    private void process(File aFile)\n+    protected void processFiltered(File aFile, List<String> aLines)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n-            getMessageDispatcher().fireFileStarted(fileName);\n-            final String[] lines = Utils.getLines(fileName, getCharset());\n-            final FileContents contents = new FileContents(fileName, lines);\n+            final FileContents contents = new FileContents(fileName, aLines\n+                    .toArray(new String[aLines.size()]));\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n-        catch (final FileNotFoundException fnfe) {\n-            Utils.getExceptionLogger()\n-                .debug(\"FileNotFoundException occured.\", fnfe);\n-            getMessageCollector().add(\n-                new LocalizedMessage(\n-                    0,\n-                    Defn.CHECKSTYLE_BUNDLE,\n-                    \"general.fileNotFound\",\n-                    null,\n-                    getId(),\n-                    this.getClass(), null));\n-        }\n-        catch (final IOException ioe) {\n-            Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n-            getMessageCollector().add(\n-                new LocalizedMessage(\n-                    0,\n-                    Defn.CHECKSTYLE_BUNDLE,\n-                    \"general.exception\",\n-                    new String[] {ioe.getMessage()},\n-                    getId(),\n-                    this.getClass(), null));\n-        }\n         catch (final RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamRecognitionException occured.\", tre);\n             final RecognitionException re = tre.recog;\n             if (re != null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n                         this.getClass(), null));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n                         this.getClass(), null));\n             }\n         }\n         catch (final TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n                     this.getClass(), null));\n         }\n         catch (final Throwable err) {\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n                     this.getClass(), null));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n-        else {\n-            fireErrors(fileName);\n-        }\n-\n-        getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"17754d363645285e49bf4323a1af5762af47a8ea": {
			"type": "Ybodychange",
			"commitMessage": "snapshot of changes - need to refactor\n",
			"commitDate": "2008-07-15, 4:27 PM",
			"commitName": "17754d363645285e49bf4323a1af5762af47a8ea",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2008-04-25, 9:45 PM",
			"commitNameOld": "911065320fb39299f442ea08f775cfe08ba2a2ed",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 80.78,
			"commitsBetweenForRepo": 21,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,112 +1,112 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines = Utils.getLines(fileName, getCharset());\n             final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (final FileNotFoundException fnfe) {\n             Utils.getExceptionLogger()\n                 .debug(\"FileNotFoundException occured.\", fnfe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.fileNotFound\",\n                     null,\n                     getId(),\n-                    this.getClass()));\n+                    this.getClass(), null));\n         }\n         catch (final IOException ioe) {\n             Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {ioe.getMessage()},\n                     getId(),\n-                    this.getClass()));\n+                    this.getClass(), null));\n         }\n         catch (final RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n-                    this.getClass()));\n+                    this.getClass(), null));\n         }\n         catch (final TokenStreamRecognitionException tre) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamRecognitionException occured.\", tre);\n             final RecognitionException re = tre.recog;\n             if (re != null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n-                        this.getClass()));\n+                        this.getClass(), null));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n-                        this.getClass()));\n+                        this.getClass(), null));\n             }\n         }\n         catch (final TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n-                    this.getClass()));\n+                    this.getClass(), null));\n         }\n         catch (final Throwable err) {\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n-                    this.getClass()));\n+                    this.getClass(), null));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(fileName);\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"35d1673788bbbac8263fdb69275dc6a63b095a24": {
			"type": "Ybodychange",
			"commitMessage": "Making local variables final where possible.\n",
			"commitDate": "2006-07-06, 9:44 PM",
			"commitName": "35d1673788bbbac8263fdb69275dc6a63b095a24",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2006-07-06, 9:33 PM",
			"commitNameOld": "f4a92dad02a3a36b5e2e988bba04debb1e2c9db9",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,112 +1,112 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines = Utils.getLines(fileName, getCharset());\n             final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n-        catch (FileNotFoundException fnfe) {\n+        catch (final FileNotFoundException fnfe) {\n             Utils.getExceptionLogger()\n                 .debug(\"FileNotFoundException occured.\", fnfe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.fileNotFound\",\n                     null,\n                     getId(),\n                     this.getClass()));\n         }\n-        catch (IOException ioe) {\n+        catch (final IOException ioe) {\n             Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {ioe.getMessage()},\n                     getId(),\n                     this.getClass()));\n         }\n-        catch (RecognitionException re) {\n+        catch (final RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     getId(),\n                     this.getClass()));\n         }\n-        catch (TokenStreamRecognitionException tre) {\n+        catch (final TokenStreamRecognitionException tre) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamRecognitionException occured.\", tre);\n             final RecognitionException re = tre.recog;\n             if (re != null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         getId(),\n                         this.getClass()));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n                         getId(),\n                         this.getClass()));\n             }\n         }\n-        catch (TokenStreamException te) {\n+        catch (final TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     getId(),\n                     this.getClass()));\n         }\n-        catch (Throwable err) {\n+        catch (final Throwable err) {\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     getId(),\n                     this.getClass()));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(fileName);\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"788b41973d5747c7b4699a853b62168cf0001df6": {
			"type": "Ybodychange",
			"commitMessage": "Changes to make it possible to identify a module by an id, and then to\nsuppress messages based on the id. The motivation is to allow for finer\ngrained suppressions. For example, can enable multiple instances of the\nRegexp check, and suppress on the individual instance.\n",
			"commitDate": "2005-12-29, 5:35 AM",
			"commitName": "788b41973d5747c7b4699a853b62168cf0001df6",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2005-12-17, 12:03 PM",
			"commitNameOld": "78e9ce870170ca3ef88fd78f8e0af0681c958eb3",
			"commitAuthorOld": "Oleg Sukhodolsky",
			"daysBetweenCommits": 11.73,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,105 +1,112 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines = Utils.getLines(fileName, getCharset());\n             final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n             Utils.getExceptionLogger()\n                 .debug(\"FileNotFoundException occured.\", fnfe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.fileNotFound\",\n                     null,\n+                    getId(),\n                     this.getClass()));\n         }\n         catch (IOException ioe) {\n             Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {ioe.getMessage()},\n+                    getId(),\n                     this.getClass()));\n         }\n         catch (RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n+                    getId(),\n                     this.getClass()));\n         }\n         catch (TokenStreamRecognitionException tre) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamRecognitionException occured.\", tre);\n             final RecognitionException re = tre.recog;\n             if (re != null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n+                        getId(),\n                         this.getClass()));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[]\n                         {\"TokenStreamRecognitionException occured.\"},\n+                        getId(),\n                         this.getClass()));\n             }\n         }\n         catch (TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n+                    getId(),\n                     this.getClass()));\n         }\n         catch (Throwable err) {\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n+                    getId(),\n                     this.getClass()));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(fileName);\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"76374876692534687016dba762a465bf93039402": {
			"type": "Ybodychange",
			"commitMessage": "Accept Oleg's comments about NPEs, http://sourceforge.net/mailarchive/forum.php?thread_id=5251578&forum_id=2864\n",
			"commitDate": "2004-08-03, 7:45 AM",
			"commitName": "76374876692534687016dba762a465bf93039402",
			"commitAuthor": "Rick Giles",
			"commitDateOld": "2004-07-30, 8:59 AM",
			"commitNameOld": "748df52c1317e298203bf28e48545d3e50db59f1",
			"commitAuthorOld": "Rick Giles",
			"daysBetweenCommits": 3.95,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,104 +1,105 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines = Utils.getLines(fileName, getCharset());\n             final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n             Utils.getExceptionLogger()\n                 .debug(\"FileNotFoundException occured.\", fnfe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.fileNotFound\",\n                     null,\n                     this.getClass()));\n         }\n         catch (IOException ioe) {\n             Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {ioe.getMessage()},\n                     this.getClass()));\n         }\n         catch (RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     this.getClass()));\n         }\n         catch (TokenStreamRecognitionException tre) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamRecognitionException occured.\", tre);\n             final RecognitionException re = tre.recog;\n             if (re != null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         this.getClass()));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n-                        new String[] {\"\"},\n+                        new String[]\n+                            {\"TokenStreamRecognitionException occured.\"},\n                         this.getClass()));\n             }\n         }\n         catch (TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     this.getClass()));\n         }\n         catch (Throwable err) {\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     this.getClass()));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(fileName);\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"748df52c1317e298203bf28e48545d3e50db59f1": {
			"type": "Ybodychange",
			"commitMessage": "fixes possible null pointer exceptions, bad string compares\n",
			"commitDate": "2004-07-30, 8:59 AM",
			"commitName": "748df52c1317e298203bf28e48545d3e50db59f1",
			"commitAuthor": "Rick Giles",
			"commitDateOld": "2004-07-21, 6:02 AM",
			"commitNameOld": "3b5e5d728bf1b8d222c538f7cfc92cab0805eb1f",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 9.12,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,104 +1,104 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines = Utils.getLines(fileName, getCharset());\n             final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n             Utils.getExceptionLogger()\n                 .debug(\"FileNotFoundException occured.\", fnfe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.fileNotFound\",\n                     null,\n                     this.getClass()));\n         }\n         catch (IOException ioe) {\n             Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {ioe.getMessage()},\n                     this.getClass()));\n         }\n         catch (RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     this.getClass()));\n         }\n         catch (TokenStreamRecognitionException tre) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamRecognitionException occured.\", tre);\n             final RecognitionException re = tre.recog;\n             if (re != null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         this.getClass()));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n-                        new String[] {re.getMessage()},\n+                        new String[] {\"\"},\n                         this.getClass()));\n             }\n         }\n         catch (TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     this.getClass()));\n         }\n         catch (Throwable err) {\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     this.getClass()));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(fileName);\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"915c6568cf2cde57c3e92ee9786acb4808562671": {
			"type": "Ybodychange",
			"commitMessage": "Added charset property to TreeWalker and StrictDuplicateCode check (addresses bug 975346)\n",
			"commitDate": "2004-06-22, 5:42 AM",
			"commitName": "915c6568cf2cde57c3e92ee9786acb4808562671",
			"commitAuthor": "Rick Giles",
			"commitDateOld": "2004-06-21, 4:30 PM",
			"commitNameOld": "44e3d33fc25d44157486288d5c77de75156984cb",
			"commitAuthorOld": "Rick Giles",
			"daysBetweenCommits": 0.55,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,104 +1,104 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n-            final String[] lines = Utils.getLines(fileName);\n+            final String[] lines = Utils.getLines(fileName, getCharset());\n             final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n             Utils.getExceptionLogger()\n                 .debug(\"FileNotFoundException occured.\", fnfe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.fileNotFound\",\n                     null,\n                     this.getClass()));\n         }\n         catch (IOException ioe) {\n             Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {ioe.getMessage()},\n                     this.getClass()));\n         }\n         catch (RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     re.getLine(),\n                     re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     this.getClass()));\n         }\n         catch (TokenStreamRecognitionException tre) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamRecognitionException occured.\", tre);\n             final RecognitionException re = tre.recog;\n             if (re != null) {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         re.getLine(),\n                         re.getColumn(),\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         this.getClass()));\n             }\n             else {\n                 getMessageCollector().add(\n                     new LocalizedMessage(\n                         0,\n                         Defn.CHECKSTYLE_BUNDLE,\n                         \"general.exception\",\n                         new String[] {re.getMessage()},\n                         this.getClass()));\n             }\n         }\n         catch (TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     this.getClass()));\n         }\n         catch (Throwable err) {\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     this.getClass()));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(fileName);\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"44e3d33fc25d44157486288d5c77de75156984cb": {
			"type": "Ybodychange",
			"commitMessage": "Better information for unexpected char, RFE 666188\n",
			"commitDate": "2004-06-21, 4:30 PM",
			"commitName": "44e3d33fc25d44157486288d5c77de75156984cb",
			"commitAuthor": "Rick Giles",
			"commitDateOld": "2004-01-14, 2:10 PM",
			"commitNameOld": "5670252b46f4915b276e647fa000361915eb4ff4",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 159.06,
			"commitsBetweenForRepo": 105,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,79 +1,104 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines = Utils.getLines(fileName);\n             final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n             Utils.getExceptionLogger()\n                 .debug(\"FileNotFoundException occured.\", fnfe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.fileNotFound\",\n                     null,\n                     this.getClass()));\n         }\n         catch (IOException ioe) {\n             Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {ioe.getMessage()},\n                     this.getClass()));\n         }\n         catch (RecognitionException re) {\n             Utils.getExceptionLogger()\n                 .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n-                    0,\n+                    re.getLine(),\n+                    re.getColumn(),\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     this.getClass()));\n         }\n+        catch (TokenStreamRecognitionException tre) {\n+            Utils.getExceptionLogger()\n+                .debug(\"TokenStreamRecognitionException occured.\", tre);\n+            final RecognitionException re = tre.recog;\n+            if (re != null) {\n+                getMessageCollector().add(\n+                    new LocalizedMessage(\n+                        re.getLine(),\n+                        re.getColumn(),\n+                        Defn.CHECKSTYLE_BUNDLE,\n+                        \"general.exception\",\n+                        new String[] {re.getMessage()},\n+                        this.getClass()));\n+            }\n+            else {\n+                getMessageCollector().add(\n+                    new LocalizedMessage(\n+                        0,\n+                        Defn.CHECKSTYLE_BUNDLE,\n+                        \"general.exception\",\n+                        new String[] {re.getMessage()},\n+                        this.getClass()));\n+            }\n+        }\n         catch (TokenStreamException te) {\n             Utils.getExceptionLogger()\n                 .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     this.getClass()));\n         }\n         catch (Throwable err) {\n             Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     this.getClass()));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(fileName);\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1e7bbb8cd8a0d8d2167792e917c7cb79a36b20b0": {
			"type": "Ybodychange",
			"commitMessage": "Added exception logging (see request 753883)\n",
			"commitDate": "2003-09-02, 10:35 PM",
			"commitName": "1e7bbb8cd8a0d8d2167792e917c7cb79a36b20b0",
			"commitAuthor": "Oleg Sukhodolsky",
			"commitDateOld": "2003-07-05, 4:47 AM",
			"commitNameOld": "6db0b3effd48f02d741b2202338d710b1b254910",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 59.74,
			"commitsBetweenForRepo": 129,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,71 +1,79 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines = Utils.getLines(fileName);\n             final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n+            Utils.getExceptionLogger()\n+                .debug(\"FileNotFoundException occured.\", fnfe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.fileNotFound\",\n                     null,\n                     this.getClass()));\n         }\n         catch (IOException ioe) {\n+            Utils.getExceptionLogger().debug(\"IOException occured.\", ioe);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {ioe.getMessage()},\n                     this.getClass()));\n         }\n         catch (RecognitionException re) {\n+            Utils.getExceptionLogger()\n+                .debug(\"RecognitionException occured.\", re);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {re.getMessage()},\n                     this.getClass()));\n         }\n         catch (TokenStreamException te) {\n+            Utils.getExceptionLogger()\n+                .debug(\"TokenStreamException occured.\", te);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {te.getMessage()},\n                     this.getClass()));\n         }\n         catch (Throwable err) {\n+            Utils.getExceptionLogger().debug(\"Throwable occured.\", err);\n             getMessageCollector().add(\n                 new LocalizedMessage(\n                     0,\n                     Defn.CHECKSTYLE_BUNDLE,\n                     \"general.exception\",\n                     new String[] {\"\" + err},\n                     this.getClass()));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(fileName);\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6db0b3effd48f02d741b2202338d710b1b254910": {
			"type": "Ybodychange",
			"commitMessage": "Code cleanup to force the class name for the cause of the message to be\nlogged. Required as part of changes I am making for RFE 756416.\n",
			"commitDate": "2003-07-05, 4:47 AM",
			"commitName": "6db0b3effd48f02d741b2202338d710b1b254910",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2003-06-27, 5:04 AM",
			"commitNameOld": "768256c32a3e397f837ce27602bda49e3c5e0062",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 7.99,
			"commitsBetweenForRepo": 24,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,55 +1,71 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines = Utils.getLines(fileName);\n             final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n-            getMessageCollector().add(new LocalizedMessage(\n-                0, Defn.CHECKSTYLE_BUNDLE,\n-                \"general.fileNotFound\", null));\n+            getMessageCollector().add(\n+                new LocalizedMessage(\n+                    0,\n+                    Defn.CHECKSTYLE_BUNDLE,\n+                    \"general.fileNotFound\",\n+                    null,\n+                    this.getClass()));\n         }\n         catch (IOException ioe) {\n-            getMessageCollector().add(new LocalizedMessage(\n-                0, Defn.CHECKSTYLE_BUNDLE,\n-                \"general.exception\",\n-                new String[] {ioe.getMessage()}));\n+            getMessageCollector().add(\n+                new LocalizedMessage(\n+                    0,\n+                    Defn.CHECKSTYLE_BUNDLE,\n+                    \"general.exception\",\n+                    new String[] {ioe.getMessage()},\n+                    this.getClass()));\n         }\n         catch (RecognitionException re) {\n-            getMessageCollector().add(new LocalizedMessage(\n-                0, Defn.CHECKSTYLE_BUNDLE,\n-                \"general.exception\",\n-                new String[] {re.getMessage()}));\n+            getMessageCollector().add(\n+                new LocalizedMessage(\n+                    0,\n+                    Defn.CHECKSTYLE_BUNDLE,\n+                    \"general.exception\",\n+                    new String[] {re.getMessage()},\n+                    this.getClass()));\n         }\n         catch (TokenStreamException te) {\n-            getMessageCollector().add(new LocalizedMessage(\n-                0, Defn.CHECKSTYLE_BUNDLE,\n-                \"general.exception\",\n-                new String[] {te.getMessage()}));\n+            getMessageCollector().add(\n+                new LocalizedMessage(\n+                    0,\n+                    Defn.CHECKSTYLE_BUNDLE,\n+                    \"general.exception\",\n+                    new String[] {te.getMessage()},\n+                    this.getClass()));\n         }\n         catch (Throwable err) {\n-            getMessageCollector().add(new LocalizedMessage(\n-                0, Defn.CHECKSTYLE_BUNDLE,\n-                \"general.exception\",\n-                new String[] {\"\" + err}));\n+            getMessageCollector().add(\n+                new LocalizedMessage(\n+                    0,\n+                    Defn.CHECKSTYLE_BUNDLE,\n+                    \"general.exception\",\n+                    new String[] {\"\" + err},\n+                    this.getClass()));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(fileName);\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5ace399de6c8963584b1fbe08007721433c4bad3": {
			"type": "Ybodychange",
			"commitMessage": "Another quality patch from Oleg Sukhodolsky to fix TranslationCheck Test\nbug. (bug 720925).\n",
			"commitDate": "2003-04-24, 2:18 AM",
			"commitName": "5ace399de6c8963584b1fbe08007721433c4bad3",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2003-04-18, 2:50 AM",
			"commitNameOld": "55fcf189eb1c1c4d776ce3b3ad7835fb404b21d8",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 5.98,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,57 +1,55 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n-        getMessageCollector().reset();\n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines = Utils.getLines(fileName);\n             final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n             getMessageCollector().add(new LocalizedMessage(\n                 0, Defn.CHECKSTYLE_BUNDLE,\n                 \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n             getMessageCollector().add(new LocalizedMessage(\n                 0, Defn.CHECKSTYLE_BUNDLE,\n                 \"general.exception\",\n                 new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n             getMessageCollector().add(new LocalizedMessage(\n                 0, Defn.CHECKSTYLE_BUNDLE,\n                 \"general.exception\",\n                 new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n             getMessageCollector().add(new LocalizedMessage(\n                 0, Defn.CHECKSTYLE_BUNDLE,\n                 \"general.exception\",\n                 new String[] {te.getMessage()}));\n         }\n         catch (Throwable err) {\n             getMessageCollector().add(new LocalizedMessage(\n                 0, Defn.CHECKSTYLE_BUNDLE,\n                 \"general.exception\",\n                 new String[] {\"\" + err}));\n         }\n \n         if (getMessageCollector().size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n-            getMessageDispatcher().fireErrors(\n-                fileName, getMessageCollector().getMessages());\n+            fireErrors(fileName);\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d216ec75255a120ce7c24e51da7df63a2b9864de": {
			"type": "Ybodychange",
			"commitMessage": "Major refactorings to allow the use of SeverityLevels in FileSetChecks\nas well as in Checks and to simplify logging of messages in FileSetChecks.\n\nIntroduction of a new class called AbstractViolationReporter, from which\nboth Check and FileSetCheck are derived.\n\nSeverity is passed to submodules by means of the Contextualizable\nmechanism. This means that the user can f.ex. set severity to INFO\nin a TreeWalker and all Checks below that TreeWalker will use severity INFO.\n",
			"commitDate": "2003-03-26, 12:52 PM",
			"commitName": "d216ec75255a120ce7c24e51da7df63a2b9864de",
			"commitAuthor": "Lars Khne",
			"commitDateOld": "2003-02-28, 11:24 AM",
			"commitNameOld": "784b3270054dd61d8c6dbe413bcedfc628063171",
			"commitAuthorOld": "Rick Giles",
			"daysBetweenCommits": 26.06,
			"commitsBetweenForRepo": 37,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,53 +1,57 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n-        mMessages.reset();\n+        getMessageCollector().reset();\n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines = Utils.getLines(fileName);\n             final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n-            mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n-                                               \"general.fileNotFound\", null));\n+            getMessageCollector().add(new LocalizedMessage(\n+                0, Defn.CHECKSTYLE_BUNDLE,\n+                \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n-            mMessages.add(new LocalizedMessage(\n-                              0, Defn.CHECKSTYLE_BUNDLE,\n-                              \"general.exception\",\n-                              new String[] {ioe.getMessage()}));\n+            getMessageCollector().add(new LocalizedMessage(\n+                0, Defn.CHECKSTYLE_BUNDLE,\n+                \"general.exception\",\n+                new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n-            mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n-                                               \"general.exception\",\n-                                               new String[] {re.getMessage()}));\n+            getMessageCollector().add(new LocalizedMessage(\n+                0, Defn.CHECKSTYLE_BUNDLE,\n+                \"general.exception\",\n+                new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n-            mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n-                                               \"general.exception\",\n-                                               new String[] {te.getMessage()}));\n+            getMessageCollector().add(new LocalizedMessage(\n+                0, Defn.CHECKSTYLE_BUNDLE,\n+                \"general.exception\",\n+                new String[] {te.getMessage()}));\n         }\n         catch (Throwable err) {\n-            mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n-                                               \"general.exception\",\n-                                               new String[] {\"\" + err}));\n+            getMessageCollector().add(new LocalizedMessage(\n+                0, Defn.CHECKSTYLE_BUNDLE,\n+                \"general.exception\",\n+                new String[] {\"\" + err}));\n         }\n \n-        if (mMessages.size() == 0) {\n+        if (getMessageCollector().size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             getMessageDispatcher().fireErrors(\n-                fileName, mMessages.getMessages());\n+                fileName, getMessageCollector().getMessages());\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"784b3270054dd61d8c6dbe413bcedfc628063171": {
			"type": "Ybodychange",
			"commitMessage": "Handle all parse errors,esp.those throws by the ANTLR parser on a\nsyntax error (see bug request id 694111).\n",
			"commitDate": "2003-02-28, 11:24 AM",
			"commitName": "784b3270054dd61d8c6dbe413bcedfc628063171",
			"commitAuthor": "Rick Giles",
			"commitDateOld": "2003-02-15, 7:50 PM",
			"commitNameOld": "04b0bd64047e8eee752405a01de145b67f5fb845",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 12.65,
			"commitsBetweenForRepo": 27,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,48 +1,53 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         mMessages.reset();\n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines = Utils.getLines(fileName);\n             final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n             mMessages.add(new LocalizedMessage(\n                               0, Defn.CHECKSTYLE_BUNDLE,\n                               \"general.exception\",\n                               new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {te.getMessage()}));\n         }\n+        catch (Throwable err) {\n+            mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n+                                               \"general.exception\",\n+                                               new String[] {\"\" + err}));\n+        }\n \n         if (mMessages.size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             getMessageDispatcher().fireErrors(\n                 fileName, mMessages.getMessages());\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2149a9c42dce7a3913cca83755c8f562b0442929": {
			"type": "Ybodychange",
			"commitMessage": "removed todo items that have already been resolved\n",
			"commitDate": "2002-12-27, 2:58 AM",
			"commitName": "2149a9c42dce7a3913cca83755c8f562b0442929",
			"commitAuthor": "Lars Khne",
			"commitDateOld": "2002-12-26, 10:21 AM",
			"commitNameOld": "2a71cac7e02c012add5e75f35aaf6aca7c561401",
			"commitAuthorOld": "Lars Khne",
			"daysBetweenCommits": 0.69,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,50 +1,48 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         mMessages.reset();\n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines = Utils.getLines(fileName);\n             final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n-            // TODO: this dependency on the checkstyle package is not good. It\n-            // introduces a circular dependency between packages.\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n             mMessages.add(new LocalizedMessage(\n                               0, Defn.CHECKSTYLE_BUNDLE,\n                               \"general.exception\",\n                               new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {te.getMessage()}));\n         }\n \n         if (mMessages.size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             getMessageDispatcher().fireErrors(\n                 fileName, mMessages.getMessages());\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9f6a98ac725727519c43f6496f020c2e595dac57": {
			"type": "Ybodychange",
			"commitMessage": "Added a flag - something needs to be done about\ndependencies\n",
			"commitDate": "2002-12-07, 4:12 AM",
			"commitName": "9f6a98ac725727519c43f6496f020c2e595dac57",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2002-12-06, 6:40 AM",
			"commitNameOld": "53e4d78c1934b2681c70d560c8805b1e83199fa5",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 0.9,
			"commitsBetweenForRepo": 14,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,48 +1,50 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         mMessages.reset();\n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines = Utils.getLines(fileName);\n             final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n+            // TODO: this dependency on the checkstyle package is not good. It\n+            // introduces a circular dependency between packages.\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n             mMessages.add(new LocalizedMessage(\n                               0, Defn.CHECKSTYLE_BUNDLE,\n                               \"general.exception\",\n                               new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {te.getMessage()}));\n         }\n \n         if (mMessages.size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             getMessageDispatcher().fireErrors(\n                 fileName, mMessages.getMessages());\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6ffc8dd26075456b055ffcd35d3915c23049bfbb": {
			"type": "Ybodychange",
			"commitMessage": "avalonization\n",
			"commitDate": "2002-11-30, 11:29 AM",
			"commitName": "6ffc8dd26075456b055ffcd35d3915c23049bfbb",
			"commitAuthor": "Lars Khne",
			"commitDateOld": "2002-11-19, 10:56 PM",
			"commitNameOld": "6568a9b88220366da3fc9e58fc9de93af9a6520d",
			"commitAuthorOld": "Lars Khne",
			"daysBetweenCommits": 10.52,
			"commitsBetweenForRepo": 59,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,48 +1,48 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         mMessages.reset();\n         try {\n             getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines = Utils.getLines(fileName);\n             final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n-            walk(rootAST, contents, mConfig.getClassLoader());\n+            walk(rootAST, contents);\n         }\n         catch (FileNotFoundException fnfe) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n             mMessages.add(new LocalizedMessage(\n                               0, Defn.CHECKSTYLE_BUNDLE,\n                               \"general.exception\",\n                               new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {te.getMessage()}));\n         }\n \n         if (mMessages.size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             getMessageDispatcher().fireErrors(\n                     fileName, mMessages.getMessages());\n         }\n \n         getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"abff1a2489ea8af10e1bc0a335551262d22f44e7": {
			"type": "Ymultichange(Ymovefromfile,Ybodychange)",
			"commitMessage": "Made TreeWalker a FileSetCheck and moved the\nprocessing logic from Checker to TreeWalker.\n\nChecker is now only concerned with managing FileSetChecks,\nalthough the setup is still hardcoded in the constructor,\nc.f. TODO comments in Checker constructor.\n\nUncommenting the addFileSetCheck calls for real is\nleft until we have better control our configuration.\n",
			"commitDate": "2002-11-19, 1:21 PM",
			"commitName": "abff1a2489ea8af10e1bc0a335551262d22f44e7",
			"commitAuthor": "Lars Khne",
			"subchanges": [
				{
					"type": "Ymovefromfile",
					"commitMessage": "Made TreeWalker a FileSetCheck and moved the\nprocessing logic from Checker to TreeWalker.\n\nChecker is now only concerned with managing FileSetChecks,\nalthough the setup is still hardcoded in the constructor,\nc.f. TODO comments in Checker constructor.\n\nUncommenting the addFileSetCheck calls for real is\nleft until we have better control our configuration.\n",
					"commitDate": "2002-11-19, 1:21 PM",
					"commitName": "abff1a2489ea8af10e1bc0a335551262d22f44e7",
					"commitAuthor": "Lars Khne",
					"commitDateOld": "2002-11-19, 12:17 PM",
					"commitNameOld": "54a09706ec1db32435b09e6b6910813325558f8d",
					"commitAuthorOld": "Lars Khne",
					"daysBetweenCommits": 0.04,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,47 +1,47 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         mMessages.reset();\n         try {\n-            fireFileStarted(fileName);\n+            getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines = Utils.getLines(fileName);\n             final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n-            mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n+            walk(rootAST, contents, mConfig.getClassLoader());\n         }\n         catch (FileNotFoundException fnfe) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n             mMessages.add(new LocalizedMessage(\n                               0, Defn.CHECKSTYLE_BUNDLE,\n                               \"general.exception\",\n                               new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {te.getMessage()}));\n         }\n \n         if (mMessages.size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n-            fireErrors(fileName, mMessages.getMessages());\n+            getMessageDispatcher().fireErrors(fileName, mMessages.getMessages());\n         }\n \n-        fireFileFinished(fileName);\n+        getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/Checker.java",
						"newPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/TreeWalker.java",
						"oldMethodName": "process",
						"newMethodName": "process"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Made TreeWalker a FileSetCheck and moved the\nprocessing logic from Checker to TreeWalker.\n\nChecker is now only concerned with managing FileSetChecks,\nalthough the setup is still hardcoded in the constructor,\nc.f. TODO comments in Checker constructor.\n\nUncommenting the addFileSetCheck calls for real is\nleft until we have better control our configuration.\n",
					"commitDate": "2002-11-19, 1:21 PM",
					"commitName": "abff1a2489ea8af10e1bc0a335551262d22f44e7",
					"commitAuthor": "Lars Khne",
					"commitDateOld": "2002-11-19, 12:17 PM",
					"commitNameOld": "54a09706ec1db32435b09e6b6910813325558f8d",
					"commitAuthorOld": "Lars Khne",
					"daysBetweenCommits": 0.04,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,47 +1,47 @@\n     private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return;\n         }\n \n         mMessages.reset();\n         try {\n-            fireFileStarted(fileName);\n+            getMessageDispatcher().fireFileStarted(fileName);\n             final String[] lines = Utils.getLines(fileName);\n             final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n-            mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n+            walk(rootAST, contents, mConfig.getClassLoader());\n         }\n         catch (FileNotFoundException fnfe) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n             mMessages.add(new LocalizedMessage(\n                               0, Defn.CHECKSTYLE_BUNDLE,\n                               \"general.exception\",\n                               new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {te.getMessage()}));\n         }\n \n         if (mMessages.size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n-            fireErrors(fileName, mMessages.getMessages());\n+            getMessageDispatcher().fireErrors(fileName, mMessages.getMessages());\n         }\n \n-        fireFileFinished(fileName);\n+        getMessageDispatcher().fireFileFinished(fileName);\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"54a09706ec1db32435b09e6b6910813325558f8d": {
			"type": "Ymultichange(Yreturntypechange,Ybodychange)",
			"commitMessage": "Introduced MessageDispatcher interface so\nFileSetChecks do not need to be tightly coupled\nwith Checker to report errors.\n\nFileSetCheck implementations report errors now.\n\nError counting in Checker is now done via an\nAuditListener, no need to bother about that in\neach individual FileSetCheck.\n",
			"commitDate": "2002-11-19, 12:17 PM",
			"commitName": "54a09706ec1db32435b09e6b6910813325558f8d",
			"commitAuthor": "Lars Khne",
			"subchanges": [
				{
					"type": "Yreturntypechange",
					"commitMessage": "Introduced MessageDispatcher interface so\nFileSetChecks do not need to be tightly coupled\nwith Checker to report errors.\n\nFileSetCheck implementations report errors now.\n\nError counting in Checker is now done via an\nAuditListener, no need to bother about that in\neach individual FileSetCheck.\n",
					"commitDate": "2002-11-19, 12:17 PM",
					"commitName": "54a09706ec1db32435b09e6b6910813325558f8d",
					"commitAuthor": "Lars Khne",
					"commitDateOld": "2002-11-17, 1:24 AM",
					"commitNameOld": "82b2ba526976588d550cac698e512f8de6c1ffc6",
					"commitAuthorOld": "Lars Khne",
					"daysBetweenCommits": 2.45,
					"commitsBetweenForRepo": 9,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,48 +1,47 @@\n-    private int process(File aFile)\n+    private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n-            return 0;\n+            return;\n         }\n \n         mMessages.reset();\n         try {\n             fireFileStarted(fileName);\n             final String[] lines = Utils.getLines(fileName);\n             final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n         }\n         catch (FileNotFoundException fnfe) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n             mMessages.add(new LocalizedMessage(\n                               0, Defn.CHECKSTYLE_BUNDLE,\n                               \"general.exception\",\n                               new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {te.getMessage()}));\n         }\n \n         if (mMessages.size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(fileName, mMessages.getMessages());\n         }\n \n         fireFileFinished(fileName);\n-        return mMessages.size();\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "int",
						"newValue": "void"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Introduced MessageDispatcher interface so\nFileSetChecks do not need to be tightly coupled\nwith Checker to report errors.\n\nFileSetCheck implementations report errors now.\n\nError counting in Checker is now done via an\nAuditListener, no need to bother about that in\neach individual FileSetCheck.\n",
					"commitDate": "2002-11-19, 12:17 PM",
					"commitName": "54a09706ec1db32435b09e6b6910813325558f8d",
					"commitAuthor": "Lars Khne",
					"commitDateOld": "2002-11-17, 1:24 AM",
					"commitNameOld": "82b2ba526976588d550cac698e512f8de6c1ffc6",
					"commitAuthorOld": "Lars Khne",
					"daysBetweenCommits": 2.45,
					"commitsBetweenForRepo": 9,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,48 +1,47 @@\n-    private int process(File aFile)\n+    private void process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n-            return 0;\n+            return;\n         }\n \n         mMessages.reset();\n         try {\n             fireFileStarted(fileName);\n             final String[] lines = Utils.getLines(fileName);\n             final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n         }\n         catch (FileNotFoundException fnfe) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n             mMessages.add(new LocalizedMessage(\n                               0, Defn.CHECKSTYLE_BUNDLE,\n                               \"general.exception\",\n                               new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {te.getMessage()}));\n         }\n \n         if (mMessages.size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(fileName, mMessages.getMessages());\n         }\n \n         fireFileFinished(fileName);\n-        return mMessages.size();\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"82b2ba526976588d550cac698e512f8de6c1ffc6": {
			"type": "Ybodychange",
			"commitMessage": "Moved stripping of basedir to the event handling routines.\nThis separates concerns in parse(File) as a preparation for moving that method to TreeWalker.\nIt also fixes bug #622290 (package name reported incorrectly) once I integrate PackageHtmlCheck.\n",
			"commitDate": "2002-11-17, 1:24 AM",
			"commitName": "82b2ba526976588d550cac698e512f8de6c1ffc6",
			"commitAuthor": "Lars Khne",
			"commitDateOld": "2002-11-17, 1:05 AM",
			"commitNameOld": "93390fbc8a6952bbb20571ac1b18a705814fc219",
			"commitAuthorOld": "Lars Khne",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,60 +1,48 @@\n     private int process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return 0;\n         }\n \n-        // Create a stripped down version\n-        final String stripped;\n-        final String basedir = mConfig.getBasedir();\n-        if ((basedir == null) || !fileName.startsWith(basedir)) {\n-            stripped = fileName;\n-        }\n-        else {\n-            // making the assumption that there is text after basedir\n-            final int skipSep = basedir.endsWith(File.separator) ? 0 : 1;\n-            stripped = fileName.substring(basedir.length() + skipSep);\n-        }\n-\n         mMessages.reset();\n         try {\n-            fireFileStarted(stripped);\n+            fireFileStarted(fileName);\n             final String[] lines = Utils.getLines(fileName);\n             final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = TreeWalker.parse(contents);\n             mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n         }\n         catch (FileNotFoundException fnfe) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n             mMessages.add(new LocalizedMessage(\n                               0, Defn.CHECKSTYLE_BUNDLE,\n                               \"general.exception\",\n                               new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {te.getMessage()}));\n         }\n \n         if (mMessages.size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n-            fireErrors(stripped, mMessages.getMessages());\n+            fireErrors(fileName, mMessages.getMessages());\n         }\n \n-        fireFileFinished(stripped);\n+        fireFileFinished(fileName);\n         return mMessages.size();\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"93390fbc8a6952bbb20571ac1b18a705814fc219": {
			"type": "Ybodychange",
			"commitMessage": "moved parse() from Checker to TreeWalker\n",
			"commitDate": "2002-11-17, 1:05 AM",
			"commitName": "93390fbc8a6952bbb20571ac1b18a705814fc219",
			"commitAuthor": "Lars Khne",
			"commitDateOld": "2002-11-16, 11:48 PM",
			"commitNameOld": "822384a711290170148b43b5ae390dd4e8cfaf4f",
			"commitAuthorOld": "Lars Khne",
			"daysBetweenCommits": 0.05,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,60 +1,60 @@\n     private int process(File aFile)\n     {\n         // check if already checked and passed the file\n         final String fileName = aFile.getPath();\n         final long timestamp = aFile.lastModified();\n         if (mCache.alreadyChecked(fileName, timestamp)) {\n             return 0;\n         }\n \n         // Create a stripped down version\n         final String stripped;\n         final String basedir = mConfig.getBasedir();\n         if ((basedir == null) || !fileName.startsWith(basedir)) {\n             stripped = fileName;\n         }\n         else {\n             // making the assumption that there is text after basedir\n             final int skipSep = basedir.endsWith(File.separator) ? 0 : 1;\n             stripped = fileName.substring(basedir.length() + skipSep);\n         }\n \n         mMessages.reset();\n         try {\n             fireFileStarted(stripped);\n             final String[] lines = Utils.getLines(fileName);\n             final FileContents contents = new FileContents(fileName, lines);\n-            final DetailAST rootAST = parse(contents);\n+            final DetailAST rootAST = TreeWalker.parse(contents);\n             mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n         }\n         catch (FileNotFoundException fnfe) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n             mMessages.add(new LocalizedMessage(\n                               0, Defn.CHECKSTYLE_BUNDLE,\n                               \"general.exception\",\n                               new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {te.getMessage()}));\n         }\n \n         if (mMessages.size() == 0) {\n             mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(stripped, mMessages.getMessages());\n         }\n \n         fireFileFinished(stripped);\n         return mMessages.size();\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"822384a711290170148b43b5ae390dd4e8cfaf4f": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Changed signature of Checker.process(String[]) to process(File[])\n\nThis is a step towards making TreeWalker a FileSetCheck, next some\nmethods need to be moved around.\n",
			"commitDate": "2002-11-16, 11:48 PM",
			"commitName": "822384a711290170148b43b5ae390dd4e8cfaf4f",
			"commitAuthor": "Lars Khne",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Changed signature of Checker.process(String[]) to process(File[])\n\nThis is a step towards making TreeWalker a FileSetCheck, next some\nmethods need to be moved around.\n",
					"commitDate": "2002-11-16, 11:48 PM",
					"commitName": "822384a711290170148b43b5ae390dd4e8cfaf4f",
					"commitAuthor": "Lars Khne",
					"commitDateOld": "2002-11-15, 11:18 AM",
					"commitNameOld": "3c0608f33a6c41cf96056c52ae99070cbe5062d5",
					"commitAuthorOld": "Rick Giles",
					"daysBetweenCommits": 1.52,
					"commitsBetweenForRepo": 5,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,60 +1,60 @@\n-    private int process(String aFileName)\n+    private int process(File aFile)\n     {\n         // check if already checked and passed the file\n-        final File f = new File(aFileName);\n-        final long timestamp = f.lastModified();\n-        if (mCache.alreadyChecked(aFileName, timestamp)) {\n+        final String fileName = aFile.getPath();\n+        final long timestamp = aFile.lastModified();\n+        if (mCache.alreadyChecked(fileName, timestamp)) {\n             return 0;\n         }\n \n         // Create a stripped down version\n         final String stripped;\n         final String basedir = mConfig.getBasedir();\n-        if ((basedir == null) || !aFileName.startsWith(basedir)) {\n-            stripped = aFileName;\n+        if ((basedir == null) || !fileName.startsWith(basedir)) {\n+            stripped = fileName;\n         }\n         else {\n             // making the assumption that there is text after basedir\n             final int skipSep = basedir.endsWith(File.separator) ? 0 : 1;\n-            stripped = aFileName.substring(basedir.length() + skipSep);\n+            stripped = fileName.substring(basedir.length() + skipSep);\n         }\n \n         mMessages.reset();\n         try {\n             fireFileStarted(stripped);\n-            final String[] lines = Utils.getLines(aFileName);\n-            final FileContents contents = new FileContents(aFileName, lines);\n+            final String[] lines = Utils.getLines(fileName);\n+            final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = parse(contents);\n             mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n         }\n         catch (FileNotFoundException fnfe) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n             mMessages.add(new LocalizedMessage(\n                               0, Defn.CHECKSTYLE_BUNDLE,\n                               \"general.exception\",\n                               new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {te.getMessage()}));\n         }\n \n         if (mMessages.size() == 0) {\n-            mCache.checkedOk(aFileName, timestamp);\n+            mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(stripped, mMessages.getMessages());\n         }\n \n         fireFileFinished(stripped);\n         return mMessages.size();\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[aFileName-String]",
						"newValue": "[aFile-File]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Changed signature of Checker.process(String[]) to process(File[])\n\nThis is a step towards making TreeWalker a FileSetCheck, next some\nmethods need to be moved around.\n",
					"commitDate": "2002-11-16, 11:48 PM",
					"commitName": "822384a711290170148b43b5ae390dd4e8cfaf4f",
					"commitAuthor": "Lars Khne",
					"commitDateOld": "2002-11-15, 11:18 AM",
					"commitNameOld": "3c0608f33a6c41cf96056c52ae99070cbe5062d5",
					"commitAuthorOld": "Rick Giles",
					"daysBetweenCommits": 1.52,
					"commitsBetweenForRepo": 5,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,60 +1,60 @@\n-    private int process(String aFileName)\n+    private int process(File aFile)\n     {\n         // check if already checked and passed the file\n-        final File f = new File(aFileName);\n-        final long timestamp = f.lastModified();\n-        if (mCache.alreadyChecked(aFileName, timestamp)) {\n+        final String fileName = aFile.getPath();\n+        final long timestamp = aFile.lastModified();\n+        if (mCache.alreadyChecked(fileName, timestamp)) {\n             return 0;\n         }\n \n         // Create a stripped down version\n         final String stripped;\n         final String basedir = mConfig.getBasedir();\n-        if ((basedir == null) || !aFileName.startsWith(basedir)) {\n-            stripped = aFileName;\n+        if ((basedir == null) || !fileName.startsWith(basedir)) {\n+            stripped = fileName;\n         }\n         else {\n             // making the assumption that there is text after basedir\n             final int skipSep = basedir.endsWith(File.separator) ? 0 : 1;\n-            stripped = aFileName.substring(basedir.length() + skipSep);\n+            stripped = fileName.substring(basedir.length() + skipSep);\n         }\n \n         mMessages.reset();\n         try {\n             fireFileStarted(stripped);\n-            final String[] lines = Utils.getLines(aFileName);\n-            final FileContents contents = new FileContents(aFileName, lines);\n+            final String[] lines = Utils.getLines(fileName);\n+            final FileContents contents = new FileContents(fileName, lines);\n             final DetailAST rootAST = parse(contents);\n             mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n         }\n         catch (FileNotFoundException fnfe) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n             mMessages.add(new LocalizedMessage(\n                               0, Defn.CHECKSTYLE_BUNDLE,\n                               \"general.exception\",\n                               new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n             mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                                \"general.exception\",\n                                                new String[] {te.getMessage()}));\n         }\n \n         if (mMessages.size() == 0) {\n-            mCache.checkedOk(aFileName, timestamp);\n+            mCache.checkedOk(fileName, timestamp);\n         }\n         else {\n             fireErrors(stripped, mMessages.getMessages());\n         }\n \n         fireFileFinished(stripped);\n         return mMessages.size();\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"4cbd709c019cf1b69796858506d673f7b66d37c7": {
			"type": "Ybodychange",
			"commitMessage": "This is a really enjoyable commit to make. I have finally got to remove the\nugly Verifier class. The only remaining check are based on the new fileset\ncheck that Lars putting together. Magic. :-)\n",
			"commitDate": "2002-11-12, 9:21 PM",
			"commitName": "4cbd709c019cf1b69796858506d673f7b66d37c7",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2002-11-05, 8:57 PM",
			"commitNameOld": "5fc3ff2bfbed94f88e1af95f38e970a832e4dbe6",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 7.02,
			"commitsBetweenForRepo": 61,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,94 +1,60 @@\n     private int process(String aFileName)\n     {\n         // check if already checked and passed the file\n         final File f = new File(aFileName);\n         final long timestamp = f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         // Create a stripped down version\n         final String stripped;\n         final String basedir = mConfig.getBasedir();\n         if ((basedir == null) || !aFileName.startsWith(basedir)) {\n             stripped = aFileName;\n         }\n         else {\n             // making the assumption that there is text after basedir\n             final int skipSep = basedir.endsWith(File.separator) ? 0 : 1;\n             stripped = aFileName.substring(basedir.length() + skipSep);\n         }\n \n-        LocalizedMessage[] errors;\n+        mMessages.reset();\n         try {\n             fireFileStarted(stripped);\n             final String[] lines = Utils.getLines(aFileName);\n-            try {\n-                // try the 1.4 grammar first, this will succeed for\n-                // all code that compiles without any warnings in JDK 1.4,\n-                // that should cover most cases\n-                VerifierSingleton.getInstance().reset();\n-                VerifierSingleton.getInstance().setLines(lines);\n-                final Reader sar = new StringArrayReader(lines);\n-                final GeneratedJava14Lexer jl = new GeneratedJava14Lexer(sar);\n-                jl.setFilename(aFileName);\n-                final GeneratedJava14Recognizer jr =\n-                    new SilentJava14Recognizer(jl);\n-                jr.setFilename(aFileName);\n-                jr.setASTNodeClass(MyCommonAST.class.getName());\n-                jr.compilationUnit();\n-            }\n-            catch (RecognitionException re) {\n-                // Parsing might have failed because the checked\n-                // file contains \"assert\" as an identifier. Retry with a\n-                // grammar that treats \"assert\" as an identifier\n-                // and not as a keyword\n-\n-                // Arghh - the pain - duplicate code!\n-                VerifierSingleton.getInstance().reset();\n-                VerifierSingleton.getInstance().setLines(lines);\n-                final Reader sar = new StringArrayReader(lines);\n-                final GeneratedJavaLexer jl = new GeneratedJavaLexer(sar);\n-                jl.setFilename(aFileName);\n-                final GeneratedJavaRecognizer jr =\n-                    new GeneratedJavaRecognizer(jl);\n-                jr.setFilename(aFileName);\n-                jr.setASTNodeClass(MyCommonAST.class.getName());\n-                jr.compilationUnit();\n-            }\n-            errors = VerifierSingleton.getInstance().getMessages();\n+            final FileContents contents = new FileContents(aFileName, lines);\n+            final DetailAST rootAST = parse(contents);\n+            mWalker.walk(rootAST, contents, mConfig.getClassLoader());\n         }\n         catch (FileNotFoundException fnfe) {\n-            errors = new LocalizedMessage[] {\n-                new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n-                                     \"general.fileNotFound\", null)};\n+            mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n+                                               \"general.fileNotFound\", null));\n         }\n         catch (IOException ioe) {\n-            errors = new LocalizedMessage[] {\n-                new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n-                                     \"general.exception\",\n-                                     new String[] {ioe.getMessage()})};\n+            mMessages.add(new LocalizedMessage(\n+                              0, Defn.CHECKSTYLE_BUNDLE,\n+                              \"general.exception\",\n+                              new String[] {ioe.getMessage()}));\n         }\n         catch (RecognitionException re) {\n-            errors = new LocalizedMessage[] {\n-                new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n-                                     \"general.exception\",\n-                                     new String[] {re.getMessage()})};\n+            mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n+                                               \"general.exception\",\n+                                               new String[] {re.getMessage()}));\n         }\n         catch (TokenStreamException te) {\n-            errors = new LocalizedMessage[] {\n-                new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n-                                     \"general.exception\",\n-                                     new String[] {te.getMessage()})};\n+            mMessages.add(new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n+                                               \"general.exception\",\n+                                               new String[] {te.getMessage()}));\n         }\n \n-        if (errors.length == 0) {\n+        if (mMessages.size() == 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n-            fireErrors(stripped, errors);\n+            fireErrors(stripped, mMessages.getMessages());\n         }\n \n         fireFileFinished(stripped);\n-        return errors.length;\n+        return mMessages.size();\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"51941dcf2475545cee7b754acd5e2494c53acf9c": {
			"type": "Ybodychange",
			"commitMessage": "added TreeViewer to help with development.\n",
			"commitDate": "2002-10-06, 5:52 PM",
			"commitName": "51941dcf2475545cee7b754acd5e2494c53acf9c",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2002-10-01, 2:47 AM",
			"commitNameOld": "eb7b7bfd3e63a926c3f3b2801d519caa0e1fffc3",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 5.63,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,94 +1,94 @@\n     private int process(String aFileName)\n     {\n         // check if already checked and passed the file\n         final File f = new File(aFileName);\n         final long timestamp = f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         // Create a stripped down version\n         final String stripped;\n         final String basedir = mConfig.getBasedir();\n         if ((basedir == null) || !aFileName.startsWith(basedir)) {\n             stripped = aFileName;\n         }\n         else {\n             // making the assumption that there is text after basedir\n             final int skipSep = basedir.endsWith(File.separator) ? 0 : 1;\n             stripped = aFileName.substring(basedir.length() + skipSep);\n         }\n \n         LocalizedMessage[] errors;\n         try {\n             fireFileStarted(stripped);\n-            final String[] lines = getLines(aFileName);\n+            final String[] lines = Utils.getLines(aFileName);\n             try {\n                 // try the 1.4 grammar first, this will succeed for\n                 // all code that compiles without any warnings in JDK 1.4,\n                 // that should cover most cases\n                 VerifierSingleton.getInstance().reset();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar = new StringArrayReader(lines);\n                 final GeneratedJava14Lexer jl = new GeneratedJava14Lexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJava14Recognizer jr =\n                     new SilentJava14Recognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             catch (RecognitionException re) {\n                 // Parsing might have failed because the checked\n                 // file contains \"assert\" as an identifier. Retry with a\n                 // grammar that treats \"assert\" as an identifier\n                 // and not as a keyword\n \n                 // Arghh - the pain - duplicate code!\n                 VerifierSingleton.getInstance().reset();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar = new StringArrayReader(lines);\n                 final GeneratedJavaLexer jl = new GeneratedJavaLexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJavaRecognizer jr =\n                     new GeneratedJavaRecognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             errors = VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors = new LocalizedMessage[] {\n                 new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                      \"general.fileNotFound\", null)};\n         }\n         catch (IOException ioe) {\n             errors = new LocalizedMessage[] {\n                 new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                      \"general.exception\",\n                                      new String[] {ioe.getMessage()})};\n         }\n         catch (RecognitionException re) {\n             errors = new LocalizedMessage[] {\n                 new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                      \"general.exception\",\n                                      new String[] {re.getMessage()})};\n         }\n         catch (TokenStreamException te) {\n             errors = new LocalizedMessage[] {\n                 new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n                                      \"general.exception\",\n                                      new String[] {te.getMessage()})};\n         }\n \n         if (errors.length == 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(stripped, errors);\n         }\n \n         fireFileFinished(stripped);\n         return errors.length;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"03f8352479400cd2c80511bfe0242932a4f00f11": {
			"type": "Ybodychange",
			"commitMessage": "Got the unit tests to pass again. They highlighted a bug in the recent\nchanges, and once again prove they are worth the effort. ;-)\n",
			"commitDate": "2002-09-19, 3:07 AM",
			"commitName": "03f8352479400cd2c80511bfe0242932a4f00f11",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2002-09-17, 11:08 PM",
			"commitNameOld": "4880b50a3a89db93e7e7c1b8bae8036ec06e186b",
			"commitAuthorOld": "Lars Khne",
			"daysBetweenCommits": 1.17,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,90 +1,94 @@\n     private int process(String aFileName)\n     {\n         // check if already checked and passed the file\n         final File f = new File(aFileName);\n         final long timestamp = f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         // Create a stripped down version\n         final String stripped;\n         final String basedir = mConfig.getBasedir();\n         if ((basedir == null) || !aFileName.startsWith(basedir)) {\n             stripped = aFileName;\n         }\n         else {\n             // making the assumption that there is text after basedir\n             final int skipSep = basedir.endsWith(File.separator) ? 0 : 1;\n             stripped = aFileName.substring(basedir.length() + skipSep);\n         }\n \n         LocalizedMessage[] errors;\n         try {\n             fireFileStarted(stripped);\n             final String[] lines = getLines(aFileName);\n             try {\n                 // try the 1.4 grammar first, this will succeed for\n                 // all code that compiles without any warnings in JDK 1.4,\n                 // that should cover most cases\n                 VerifierSingleton.getInstance().reset();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar = new StringArrayReader(lines);\n                 final GeneratedJava14Lexer jl = new GeneratedJava14Lexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJava14Recognizer jr =\n                     new SilentJava14Recognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             catch (RecognitionException re) {\n                 // Parsing might have failed because the checked\n                 // file contains \"assert\" as an identifier. Retry with a\n                 // grammar that treats \"assert\" as an identifier\n                 // and not as a keyword\n \n                 // Arghh - the pain - duplicate code!\n                 VerifierSingleton.getInstance().reset();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar = new StringArrayReader(lines);\n                 final GeneratedJavaLexer jl = new GeneratedJavaLexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJavaRecognizer jr =\n                     new GeneratedJavaRecognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             errors = VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors = new LocalizedMessage[] {\n-                new LocalizedMessage(0, \"general.fileNotFound\", null, null)};\n+                new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n+                                     \"general.fileNotFound\", null)};\n         }\n         catch (IOException ioe) {\n             errors = new LocalizedMessage[] {\n-                new LocalizedMessage(0, \"general.exception\", null,\n+                new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n+                                     \"general.exception\",\n                                      new String[] {ioe.getMessage()})};\n         }\n         catch (RecognitionException re) {\n             errors = new LocalizedMessage[] {\n-                new LocalizedMessage(0, \"general.exception\", null,\n+                new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n+                                     \"general.exception\",\n                                      new String[] {re.getMessage()})};\n         }\n         catch (TokenStreamException te) {\n             errors = new LocalizedMessage[] {\n-                new LocalizedMessage(0, \"general.exception\", null,\n+                new LocalizedMessage(0, Defn.CHECKSTYLE_BUNDLE,\n+                                     \"general.exception\",\n                                      new String[] {te.getMessage()})};\n         }\n \n         if (errors.length == 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(stripped, errors);\n         }\n \n         fireFileFinished(stripped);\n         return errors.length;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4880b50a3a89db93e7e7c1b8bae8036ec06e186b": {
			"type": "Ybodychange",
			"commitMessage": "improved resource bundle handling:\n- plugins can use their own bundle (location determined automatically)\n- return the message key if ResourceBundle is not available\n- added log helper methods in Check.java\n",
			"commitDate": "2002-09-17, 11:08 PM",
			"commitName": "4880b50a3a89db93e7e7c1b8bae8036ec06e186b",
			"commitAuthor": "Lars Khne",
			"commitDateOld": "2002-09-17, 6:33 AM",
			"commitNameOld": "672b27dd5551de63a1fb08d8ea80376d70f2aa60",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 0.69,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,90 +1,90 @@\n     private int process(String aFileName)\n     {\n         // check if already checked and passed the file\n         final File f = new File(aFileName);\n         final long timestamp = f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         // Create a stripped down version\n         final String stripped;\n         final String basedir = mConfig.getBasedir();\n         if ((basedir == null) || !aFileName.startsWith(basedir)) {\n             stripped = aFileName;\n         }\n         else {\n             // making the assumption that there is text after basedir\n             final int skipSep = basedir.endsWith(File.separator) ? 0 : 1;\n             stripped = aFileName.substring(basedir.length() + skipSep);\n         }\n \n         LocalizedMessage[] errors;\n         try {\n             fireFileStarted(stripped);\n             final String[] lines = getLines(aFileName);\n             try {\n                 // try the 1.4 grammar first, this will succeed for\n                 // all code that compiles without any warnings in JDK 1.4,\n                 // that should cover most cases\n                 VerifierSingleton.getInstance().reset();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar = new StringArrayReader(lines);\n                 final GeneratedJava14Lexer jl = new GeneratedJava14Lexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJava14Recognizer jr =\n                     new SilentJava14Recognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             catch (RecognitionException re) {\n                 // Parsing might have failed because the checked\n                 // file contains \"assert\" as an identifier. Retry with a\n                 // grammar that treats \"assert\" as an identifier\n                 // and not as a keyword\n \n                 // Arghh - the pain - duplicate code!\n                 VerifierSingleton.getInstance().reset();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar = new StringArrayReader(lines);\n                 final GeneratedJavaLexer jl = new GeneratedJavaLexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJavaRecognizer jr =\n                     new GeneratedJavaRecognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             errors = VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors = new LocalizedMessage[] {\n-                new LocalizedMessage(0, \"general.fileNotFound\", null)};\n+                new LocalizedMessage(0, \"general.fileNotFound\", null, null)};\n         }\n         catch (IOException ioe) {\n             errors = new LocalizedMessage[] {\n-                new LocalizedMessage(0, \"general.exception\",\n+                new LocalizedMessage(0, \"general.exception\", null,\n                                      new String[] {ioe.getMessage()})};\n         }\n         catch (RecognitionException re) {\n             errors = new LocalizedMessage[] {\n-                new LocalizedMessage(0, \"general.exception\",\n+                new LocalizedMessage(0, \"general.exception\", null,\n                                      new String[] {re.getMessage()})};\n         }\n         catch (TokenStreamException te) {\n             errors = new LocalizedMessage[] {\n-                new LocalizedMessage(0, \"general.exception\",\n+                new LocalizedMessage(0, \"general.exception\", null,\n                                      new String[] {te.getMessage()})};\n         }\n \n         if (errors.length == 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(stripped, errors);\n         }\n \n         fireFileFinished(stripped);\n         return errors.length;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"751257987b2ef5f301e2deb3b55302196e5015af": {
			"type": "Ybodychange",
			"commitMessage": "Refactored the logging out of Verifier. Also fixed all gump errors.\n",
			"commitDate": "2002-08-12, 7:18 AM",
			"commitName": "751257987b2ef5f301e2deb3b55302196e5015af",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2002-08-12, 6:10 AM",
			"commitNameOld": "ecc852d48b9d26398926b255e3cd68572119c106",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 0.05,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,90 +1,90 @@\n     private int process(String aFileName)\n     {\n         // check if already checked and passed the file\n         final File f = new File(aFileName);\n         final long timestamp = f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         // Create a stripped down version\n         final String stripped;\n         final String basedir = mConfig.getBasedir();\n         if ((basedir == null) || !aFileName.startsWith(basedir)) {\n             stripped = aFileName;\n         }\n         else {\n             // making the assumption that there is text after basedir\n             final int skipSep = basedir.endsWith(File.separator) ? 0 : 1;\n             stripped = aFileName.substring(basedir.length() + skipSep);\n         }\n \n         LocalizedMessage[] errors;\n         try {\n             fireFileStarted(stripped);\n             final String[] lines = getLines(aFileName);\n             try {\n                 // try the 1.4 grammar first, this will succeed for\n                 // all code that compiles without any warnings in JDK 1.4,\n                 // that should cover most cases\n-                VerifierSingleton.getInstance().clearMessages();\n+                VerifierSingleton.getInstance().reset();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar = new StringArrayReader(lines);\n                 final GeneratedJava14Lexer jl = new GeneratedJava14Lexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJava14Recognizer jr =\n                     new SilentJava14Recognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             catch (RecognitionException re) {\n                 // Parsing might have failed because the checked\n                 // file contains \"assert\" as an identifier. Retry with a\n                 // grammar that treats \"assert\" as an identifier\n                 // and not as a keyword\n \n                 // Arghh - the pain - duplicate code!\n-                VerifierSingleton.getInstance().clearMessages();\n+                VerifierSingleton.getInstance().reset();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar = new StringArrayReader(lines);\n                 final GeneratedJavaLexer jl = new GeneratedJavaLexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJavaRecognizer jr =\n                     new GeneratedJavaRecognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             errors = VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors = new LocalizedMessage[] {\n                 new LocalizedMessage(0, \"general.fileNotFound\", null)};\n         }\n         catch (IOException ioe) {\n             errors = new LocalizedMessage[] {\n                 new LocalizedMessage(0, \"general.exception\",\n                                      new String[] {ioe.getMessage()})};\n         }\n         catch (RecognitionException re) {\n             errors = new LocalizedMessage[] {\n                 new LocalizedMessage(0, \"general.exception\",\n                                      new String[] {re.getMessage()})};\n         }\n         catch (TokenStreamException te) {\n             errors = new LocalizedMessage[] {\n                 new LocalizedMessage(0, \"general.exception\",\n                                      new String[] {te.getMessage()})};\n         }\n \n         if (errors.length == 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(stripped, errors);\n         }\n \n         fireFileFinished(stripped);\n         return errors.length;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c682b5725d22afc38bf19d9667b23a7deab6d8c3": {
			"type": "Ybodychange",
			"commitMessage": "Major rework to support localized error messages. Inspired by patch 580410. At\nthe moment it is not possible to override the system locale, this probably\nshould be added.\n",
			"commitDate": "2002-08-10, 8:15 AM",
			"commitName": "c682b5725d22afc38bf19d9667b23a7deab6d8c3",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2002-07-06, 12:35 AM",
			"commitNameOld": "7521f1897b007e3acc06ea3330df5124f4206589",
			"commitAuthorOld": "Lars Khne",
			"daysBetweenCommits": 35.32,
			"commitsBetweenForRepo": 17,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,88 +1,90 @@\n     private int process(String aFileName)\n     {\n         // check if already checked and passed the file\n         final File f = new File(aFileName);\n         final long timestamp = f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         // Create a stripped down version\n         final String stripped;\n         final String basedir = mConfig.getBasedir();\n         if ((basedir == null) || !aFileName.startsWith(basedir)) {\n             stripped = aFileName;\n         }\n         else {\n             // making the assumption that there is text after basedir\n             final int skipSep = basedir.endsWith(File.separator) ? 0 : 1;\n             stripped = aFileName.substring(basedir.length() + skipSep);\n         }\n \n-        LineText[] errors;\n+        LocalizedMessage[] errors;\n         try {\n             fireFileStarted(stripped);\n             final String[] lines = getLines(aFileName);\n             try {\n                 // try the 1.4 grammar first, this will succeed for\n                 // all code that compiles without any warnings in JDK 1.4,\n                 // that should cover most cases\n                 VerifierSingleton.getInstance().clearMessages();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar = new StringArrayReader(lines);\n                 final GeneratedJava14Lexer jl = new GeneratedJava14Lexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJava14Recognizer jr =\n                     new SilentJava14Recognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             catch (RecognitionException re) {\n                 // Parsing might have failed because the checked\n                 // file contains \"assert\" as an identifier. Retry with a\n                 // grammar that treats \"assert\" as an identifier\n                 // and not as a keyword\n \n                 // Arghh - the pain - duplicate code!\n                 VerifierSingleton.getInstance().clearMessages();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar = new StringArrayReader(lines);\n                 final GeneratedJavaLexer jl = new GeneratedJavaLexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJavaRecognizer jr =\n                     new GeneratedJavaRecognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             errors = VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n-            errors = new LineText[] {new LineText(0, \"File not found!\")};\n+            errors = new LocalizedMessage[] {\n+                new LocalizedMessage(0, \"general.fileNotFound\", null)};\n         }\n         catch (IOException ioe) {\n-            errors = new LineText[] {\n-                new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n+            errors = new LocalizedMessage[] {\n+                new LocalizedMessage(0, \"general.exception\",\n+                                     new String[] {ioe.getMessage()})};\n         }\n         catch (RecognitionException re) {\n-            errors = new LineText[] {\n-                new LineText(0,\n-                             \"Got a RecognitionException -\" + re.getMessage())};\n+            errors = new LocalizedMessage[] {\n+                new LocalizedMessage(0, \"general.exception\",\n+                                     new String[] {re.getMessage()})};\n         }\n         catch (TokenStreamException te) {\n-            errors = new LineText[] {\n-                new LineText(0,\n-                             \"Got a TokenStreamException -\" + te.getMessage())};\n+            errors = new LocalizedMessage[] {\n+                new LocalizedMessage(0, \"general.exception\",\n+                                     new String[] {te.getMessage()})};\n         }\n \n         if (errors.length == 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(stripped, errors);\n         }\n \n         fireFileFinished(stripped);\n         return errors.length;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7521f1897b007e3acc06ea3330df5124f4206589": {
			"type": "Ybodychange",
			"commitMessage": "fixed bug where reported file names were not correct when checkstyle.basedir ended with File.separator\n",
			"commitDate": "2002-07-06, 12:35 AM",
			"commitName": "7521f1897b007e3acc06ea3330df5124f4206589",
			"commitAuthor": "Lars Khne",
			"commitDateOld": "2002-07-02, 2:08 PM",
			"commitNameOld": "add2bdfb27494bff5fa9c305d9782f57c6170b18",
			"commitAuthorOld": "Lars Khne",
			"daysBetweenCommits": 3.44,
			"commitsBetweenForRepo": 15,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,88 +1,88 @@\n     private int process(String aFileName)\n     {\n         // check if already checked and passed the file\n         final File f = new File(aFileName);\n         final long timestamp = f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         // Create a stripped down version\n         final String stripped;\n-        if ((mConfig.getBasedir() == null)\n-            || !aFileName.startsWith(mConfig.getBasedir()))\n-        {\n+        final String basedir = mConfig.getBasedir();\n+        if ((basedir == null) || !aFileName.startsWith(basedir)) {\n             stripped = aFileName;\n         }\n         else {\n             // making the assumption that there is text after basedir\n-            stripped = aFileName.substring(mConfig.getBasedir().length() + 1);\n+            final int skipSep = basedir.endsWith(File.separator) ? 0 : 1;\n+            stripped = aFileName.substring(basedir.length() + skipSep);\n         }\n \n         LineText[] errors;\n         try {\n             fireFileStarted(stripped);\n             final String[] lines = getLines(aFileName);\n             try {\n                 // try the 1.4 grammar first, this will succeed for\n                 // all code that compiles without any warnings in JDK 1.4,\n                 // that should cover most cases\n                 VerifierSingleton.getInstance().clearMessages();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar = new StringArrayReader(lines);\n                 final GeneratedJava14Lexer jl = new GeneratedJava14Lexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJava14Recognizer jr =\n                     new SilentJava14Recognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             catch (RecognitionException re) {\n                 // Parsing might have failed because the checked\n                 // file contains \"assert\" as an identifier. Retry with a\n                 // grammar that treats \"assert\" as an identifier\n                 // and not as a keyword\n \n                 // Arghh - the pain - duplicate code!\n                 VerifierSingleton.getInstance().clearMessages();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar = new StringArrayReader(lines);\n                 final GeneratedJavaLexer jl = new GeneratedJavaLexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJavaRecognizer jr =\n                     new GeneratedJavaRecognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             errors = VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors = new LineText[] {new LineText(0, \"File not found!\")};\n         }\n         catch (IOException ioe) {\n             errors = new LineText[] {\n                 new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n         }\n         catch (RecognitionException re) {\n             errors = new LineText[] {\n                 new LineText(0,\n                              \"Got a RecognitionException -\" + re.getMessage())};\n         }\n         catch (TokenStreamException te) {\n             errors = new LineText[] {\n                 new LineText(0,\n                              \"Got a TokenStreamException -\" + te.getMessage())};\n         }\n \n         if (errors.length == 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(stripped, errors);\n         }\n \n         fireFileFinished(stripped);\n         return errors.length;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"bbe51f6884ac0a961f55310e15ec90411709d970": {
			"type": "Ybodychange",
			"commitMessage": "571161: Added support for basedir attribute.\n",
			"commitDate": "2002-06-30, 7:57 PM",
			"commitName": "bbe51f6884ac0a961f55310e15ec90411709d970",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2002-05-14, 11:02 PM",
			"commitNameOld": "032b3801aa80bff181235ddd05244d07cc5f43f8",
			"commitAuthorOld": "Lars Khne",
			"daysBetweenCommits": 46.87,
			"commitsBetweenForRepo": 55,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,75 +1,88 @@\n     private int process(String aFileName)\n     {\n+        // check if already checked and passed the file\n         final File f = new File(aFileName);\n         final long timestamp = f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n+        // Create a stripped down version\n+        final String stripped;\n+        if ((mConfig.getBasedir() == null)\n+            || !aFileName.startsWith(mConfig.getBasedir()))\n+        {\n+            stripped = aFileName;\n+        }\n+        else {\n+            // making the assumption that there is text after basedir\n+            stripped = aFileName.substring(mConfig.getBasedir().length() + 1);\n+        }\n+\n         LineText[] errors;\n         try {\n-            fireFileStarted(aFileName);\n+            fireFileStarted(stripped);\n             final String[] lines = getLines(aFileName);\n             try {\n                 // try the 1.4 grammar first, this will succeed for\n                 // all code that compiles without any warnings in JDK 1.4,\n                 // that should cover most cases\n                 VerifierSingleton.getInstance().clearMessages();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar = new StringArrayReader(lines);\n                 final GeneratedJava14Lexer jl = new GeneratedJava14Lexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJava14Recognizer jr =\n                     new SilentJava14Recognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             catch (RecognitionException re) {\n                 // Parsing might have failed because the checked\n                 // file contains \"assert\" as an identifier. Retry with a\n                 // grammar that treats \"assert\" as an identifier\n                 // and not as a keyword\n \n                 // Arghh - the pain - duplicate code!\n                 VerifierSingleton.getInstance().clearMessages();\n                 VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar = new StringArrayReader(lines);\n                 final GeneratedJavaLexer jl = new GeneratedJavaLexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJavaRecognizer jr =\n                     new GeneratedJavaRecognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             errors = VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors = new LineText[] {new LineText(0, \"File not found!\")};\n         }\n         catch (IOException ioe) {\n             errors = new LineText[] {\n                 new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n         }\n         catch (RecognitionException re) {\n             errors = new LineText[] {\n                 new LineText(0,\n                              \"Got a RecognitionException -\" + re.getMessage())};\n         }\n         catch (TokenStreamException te) {\n             errors = new LineText[] {\n                 new LineText(0,\n                              \"Got a TokenStreamException -\" + te.getMessage())};\n         }\n \n         if (errors.length == 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n-            fireErrors(aFileName, errors);\n+            fireErrors(stripped, errors);\n         }\n \n-        fireFileFinished(aFileName);\n+        fireFileFinished(stripped);\n         return errors.length;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8f8879df46592e6e35658026c354b804ef328097": {
			"type": "Ybodychange",
			"commitMessage": "Fixed bug with the parser falling back when failing on assert\nstatements. Found with problems with imports.\n",
			"commitDate": "2002-04-30, 4:56 AM",
			"commitName": "8f8879df46592e6e35658026c354b804ef328097",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2002-04-25, 1:03 AM",
			"commitNameOld": "6970485b88600343de72af03a6bf87cf78e6cf55",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 5.16,
			"commitsBetweenForRepo": 15,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,75 @@\n     private int process(String aFileName)\n     {\n         final File f = new File(aFileName);\n         final long timestamp = f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         LineText[] errors;\n         try {\n             fireFileStarted(aFileName);\n             final String[] lines = getLines(aFileName);\n-            VerifierSingleton.getInstance().clearMessages();\n-            VerifierSingleton.getInstance().setLines(lines);\n             try {\n                 // try the 1.4 grammar first, this will succeed for\n                 // all code that compiles without any warnings in JDK 1.4,\n                 // that should cover most cases\n-\n+                VerifierSingleton.getInstance().clearMessages();\n+                VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar = new StringArrayReader(lines);\n                 final GeneratedJava14Lexer jl = new GeneratedJava14Lexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJava14Recognizer jr =\n                     new SilentJava14Recognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             catch (RecognitionException re) {\n                 // Parsing might have failed because the checked\n                 // file contains \"assert\" as an identifier. Retry with a\n                 // grammar that treats \"assert\" as an identifier\n                 // and not as a keyword\n \n                 // Arghh - the pain - duplicate code!\n+                VerifierSingleton.getInstance().clearMessages();\n+                VerifierSingleton.getInstance().setLines(lines);\n                 final Reader sar = new StringArrayReader(lines);\n                 final GeneratedJavaLexer jl = new GeneratedJavaLexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJavaRecognizer jr =\n                     new GeneratedJavaRecognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             errors = VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors = new LineText[] {new LineText(0, \"File not found!\")};\n         }\n         catch (IOException ioe) {\n             errors = new LineText[] {\n                 new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n         }\n         catch (RecognitionException re) {\n             errors = new LineText[] {\n                 new LineText(0,\n                              \"Got a RecognitionException -\" + re.getMessage())};\n         }\n         catch (TokenStreamException te) {\n             errors = new LineText[] {\n                 new LineText(0,\n                              \"Got a TokenStreamException -\" + te.getMessage())};\n         }\n \n         if (errors.length == 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(aFileName, errors);\n         }\n \n         fireFileFinished(aFileName);\n         return errors.length;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"190c0e5ca6cff056a136bc2c17f7678eb10686c7": {
			"type": "Ybodychange",
			"commitMessage": "Fixed bug introduced during cleanup of duplicate code:\nReader cannot be reused by fallback lexer, it would\nnever see the characters that have been consumed before\nthe RecognitionException in the first parsing attempt.\n\nAlso added comment why the JDK 1.4 grammar is tried first.\n",
			"commitDate": "2002-03-19, 1:26 PM",
			"commitName": "190c0e5ca6cff056a136bc2c17f7678eb10686c7",
			"commitAuthor": "Lars Khne",
			"commitDateOld": "2002-03-19, 12:35 PM",
			"commitNameOld": "dd476d336818a95e58163cd1c4f8cb00be239eae",
			"commitAuthorOld": "Lars Khne",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,69 +1,74 @@\n     private int process(String aFileName)\n     {\n         final File f = new File(aFileName);\n         final long timestamp = f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         LineText[] errors;\n         try {\n             fireFileStarted(aFileName);\n             final String[] lines = getLines(aFileName);\n-            final Reader sar = new StringArrayReader(lines);\n             VerifierSingleton.getInstance().clearMessages();\n             VerifierSingleton.getInstance().setLines(lines);\n             try {\n+                // try the 1.4 grammar first, this will succeed for\n+                // all code that compiles without any warnings in JDK 1.4,\n+                // that should cover most cases\n+\n+                final Reader sar = new StringArrayReader(lines);\n                 final GeneratedJava14Lexer jl = new GeneratedJava14Lexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJava14Recognizer jr =\n                     new SilentJava14Recognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             catch (RecognitionException re) {\n                 // Parsing might have failed because the checked\n-                // filecontains \"assert\" statement. Retry with a\n+                // file contains \"assert\" as an identifier. Retry with a\n                 // grammar that treats \"assert\" as an identifier\n                 // and not as a keyword\n \n                 // Arghh - the pain - duplicate code!\n+                final Reader sar = new StringArrayReader(lines);\n                 final GeneratedJavaLexer jl = new GeneratedJavaLexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJavaRecognizer jr =\n                     new GeneratedJavaRecognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             errors = VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors = new LineText[] {new LineText(0, \"File not found!\")};\n         }\n         catch (IOException ioe) {\n             errors = new LineText[] {\n                 new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n         }\n         catch (RecognitionException re) {\n             errors = new LineText[] {\n                 new LineText(0,\n                              \"Got a RecognitionException -\" + re.getMessage())};\n         }\n         catch (TokenStreamException te) {\n             errors = new LineText[] {\n                 new LineText(0,\n                              \"Got a TokenStreamException -\" + te.getMessage())};\n         }\n \n         if (errors.length == 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(aFileName, errors);\n         }\n \n         fireFileFinished(aFileName);\n         return errors.length;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b671e6bb1c0652cfc1ccd07355cac99df584eb2f": {
			"type": "Ybodychange",
			"commitMessage": "Removed some duplicate code, as I also feel the pain. I like the patch, but\nI question using the Java14 lexer/recognizer first. Is this because most of\nthe time it will succeed (especially with 1.4 source:-). Be great if a\ncomment could be added to the code.\n",
			"commitDate": "2002-03-14, 3:20 AM",
			"commitName": "b671e6bb1c0652cfc1ccd07355cac99df584eb2f",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2002-03-13, 11:19 PM",
			"commitNameOld": "e2ec464f27b2e30ee66802cb9f8f1899b2dc4a24",
			"commitAuthorOld": "Lars Khne",
			"daysBetweenCommits": 0.17,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,69 @@\n     private int process(String aFileName)\n     {\n         final File f = new File(aFileName);\n         final long timestamp = f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         LineText[] errors;\n         try {\n             fireFileStarted(aFileName);\n             final String[] lines = getLines(aFileName);\n+            final Reader sar = new StringArrayReader(lines);\n+            VerifierSingleton.getInstance().clearMessages();\n+            VerifierSingleton.getInstance().setLines(lines);\n             try {\n-                VerifierSingleton.getInstance().clearMessages();\n-                VerifierSingleton.getInstance().setLines(lines);\n-                final Reader sar = new StringArrayReader(lines);\n                 final GeneratedJava14Lexer jl = new GeneratedJava14Lexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJava14Recognizer jr =\n                     new SilentJava14Recognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             catch (RecognitionException re) {\n-\n                 // Parsing might have failed because the checked\n                 // filecontains \"assert\" statement. Retry with a\n                 // grammar that treats \"assert\" as an identifier\n                 // and not as a keyword\n \n                 // Arghh - the pain - duplicate code!\n-\n-                VerifierSingleton.getInstance().clearMessages();\n-                VerifierSingleton.getInstance().setLines(lines);\n-                final Reader sar = new StringArrayReader(lines);\n                 final GeneratedJavaLexer jl = new GeneratedJavaLexer(sar);\n                 jl.setFilename(aFileName);\n                 final GeneratedJavaRecognizer jr =\n                     new GeneratedJavaRecognizer(jl);\n                 jr.setFilename(aFileName);\n                 jr.setASTNodeClass(MyCommonAST.class.getName());\n                 jr.compilationUnit();\n             }\n             errors = VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors = new LineText[] {new LineText(0, \"File not found!\")};\n         }\n         catch (IOException ioe) {\n             errors = new LineText[] {\n                 new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n         }\n         catch (RecognitionException re) {\n             errors = new LineText[] {\n                 new LineText(0,\n                              \"Got a RecognitionException -\" + re.getMessage())};\n         }\n         catch (TokenStreamException te) {\n             errors = new LineText[] {\n                 new LineText(0,\n                              \"Got a TokenStreamException -\" + te.getMessage())};\n         }\n \n         if (errors.length == 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(aFileName, errors);\n         }\n \n         fireFileFinished(aFileName);\n         return errors.length;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e2ec464f27b2e30ee66802cb9f8f1899b2dc4a24": {
			"type": "Ybodychange",
			"commitMessage": "added support for jdk 1.4 assert statements\n\ngrammar changes inspired by John Pybus on the antlr-interest mailing list,\nsee http://groups.yahoo.com/group/antlr-interest/message/4968\n\nthe changes to Checker.java are not very clean, but I don't see a better\nsolution unless the ANTLR api is improved (compilationUnit() should be an\nabstract member of Parser, error reporting should be pluggable)\n",
			"commitDate": "2002-03-13, 11:19 PM",
			"commitName": "e2ec464f27b2e30ee66802cb9f8f1899b2dc4a24",
			"commitAuthor": "Lars Khne",
			"commitDateOld": "2002-03-05, 1:53 PM",
			"commitNameOld": "ec1e3e834918a32d63025d60175189b3437769d7",
			"commitAuthorOld": "Lars Khne",
			"daysBetweenCommits": 8.39,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,51 +1,74 @@\n     private int process(String aFileName)\n     {\n         final File f = new File(aFileName);\n         final long timestamp = f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         LineText[] errors;\n         try {\n             fireFileStarted(aFileName);\n             final String[] lines = getLines(aFileName);\n-            VerifierSingleton.getInstance().clearMessages();\n-            VerifierSingleton.getInstance().setLines(lines);\n-            final Reader sar = new StringArrayReader(lines);\n-            final GeneratedJavaLexer jl = new GeneratedJavaLexer(sar);\n-            jl.setFilename(aFileName);\n-            final GeneratedJavaRecognizer jr = new GeneratedJavaRecognizer(jl);\n-            jr.setFilename(aFileName);\n-            jr.setASTNodeClass(MyCommonAST.class.getName());\n-            jr.compilationUnit();\n+            try {\n+                VerifierSingleton.getInstance().clearMessages();\n+                VerifierSingleton.getInstance().setLines(lines);\n+                final Reader sar = new StringArrayReader(lines);\n+                final GeneratedJava14Lexer jl = new GeneratedJava14Lexer(sar);\n+                jl.setFilename(aFileName);\n+                final GeneratedJava14Recognizer jr =\n+                    new SilentJava14Recognizer(jl);\n+                jr.setFilename(aFileName);\n+                jr.setASTNodeClass(MyCommonAST.class.getName());\n+                jr.compilationUnit();\n+            }\n+            catch (RecognitionException re) {\n+\n+                // Parsing might have failed because the checked\n+                // filecontains \"assert\" statement. Retry with a\n+                // grammar that treats \"assert\" as an identifier\n+                // and not as a keyword\n+\n+                // Arghh - the pain - duplicate code!\n+\n+                VerifierSingleton.getInstance().clearMessages();\n+                VerifierSingleton.getInstance().setLines(lines);\n+                final Reader sar = new StringArrayReader(lines);\n+                final GeneratedJavaLexer jl = new GeneratedJavaLexer(sar);\n+                jl.setFilename(aFileName);\n+                final GeneratedJavaRecognizer jr =\n+                    new GeneratedJavaRecognizer(jl);\n+                jr.setFilename(aFileName);\n+                jr.setASTNodeClass(MyCommonAST.class.getName());\n+                jr.compilationUnit();\n+            }\n             errors = VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors = new LineText[] {new LineText(0, \"File not found!\")};\n         }\n         catch (IOException ioe) {\n             errors = new LineText[] {\n                 new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n         }\n         catch (RecognitionException re) {\n             errors = new LineText[] {\n                 new LineText(0,\n                              \"Got a RecognitionException -\" + re.getMessage())};\n         }\n         catch (TokenStreamException te) {\n             errors = new LineText[] {\n                 new LineText(0,\n                              \"Got a TokenStreamException -\" + te.getMessage())};\n         }\n \n         if (errors.length == 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(aFileName, errors);\n         }\n \n         fireFileFinished(aFileName);\n         return errors.length;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f8ea4c69a2228c5aca6c0b6e08a39a613d157708": {
			"type": "Ybodychange",
			"commitMessage": "Removed all evidence of the java.tree.g file.\n",
			"commitDate": "2002-01-13, 6:33 PM",
			"commitName": "f8ea4c69a2228c5aca6c0b6e08a39a613d157708",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2002-01-06, 12:40 AM",
			"commitNameOld": "edf2c95634cd0c657465723eb0dc2e6f1834eeba",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 7.75,
			"commitsBetweenForRepo": 23,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,47 +1,51 @@\n     private int process(String aFileName)\n     {\n         final File f = new File(aFileName);\n         final long timestamp = f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         LineText[] errors;\n         try {\n             fireFileStarted(aFileName);\n             final String[] lines = getLines(aFileName);\n             VerifierSingleton.getInstance().clearMessages();\n             VerifierSingleton.getInstance().setLines(lines);\n             final Reader sar = new StringArrayReader(lines);\n-            final AST ast = getAST(aFileName, sar);\n-            processAST(ast);\n+            final GeneratedJavaLexer jl = new GeneratedJavaLexer(sar);\n+            jl.setFilename(aFileName);\n+            final GeneratedJavaRecognizer jr = new GeneratedJavaRecognizer(jl);\n+            jr.setFilename(aFileName);\n+            jr.setASTNodeClass(MyCommonAST.class.getName());\n+            jr.compilationUnit();\n             errors = VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors = new LineText[] {new LineText(0, \"File not found!\")};\n         }\n         catch (IOException ioe) {\n             errors = new LineText[] {\n                 new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n         }\n         catch (RecognitionException re) {\n             errors = new LineText[] {\n                 new LineText(0,\n                              \"Got a RecognitionException -\" + re.getMessage())};\n         }\n         catch (TokenStreamException te) {\n             errors = new LineText[] {\n                 new LineText(0,\n                              \"Got a TokenStreamException -\" + te.getMessage())};\n         }\n \n         if (errors.length == 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(aFileName, errors);\n         }\n \n         fireFileFinished(aFileName);\n         return errors.length;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"030798a11d2d21330cbdddd159cdc1824492157a": {
			"type": "Ybodychange",
			"commitMessage": "incorporate performance patch\n",
			"commitDate": "2001-10-31, 5:42 AM",
			"commitName": "030798a11d2d21330cbdddd159cdc1824492157a",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2001-08-30, 10:13 AM",
			"commitNameOld": "0e3fe5643667a53079dbd114e5b1e9aa91fde083",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 61.85,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,47 @@\n     private int process(String aFileName)\n     {\n         final File f = new File(aFileName);\n         final long timestamp = f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         LineText[] errors;\n         try {\n             fireFileStarted(aFileName);\n+            final String[] lines = getLines(aFileName);\n             VerifierSingleton.getInstance().clearMessages();\n-            VerifierSingleton.getInstance().setLines(getLines(aFileName));\n-            final AST ast = getAST(aFileName);\n+            VerifierSingleton.getInstance().setLines(lines);\n+            final Reader sar = new StringArrayReader(lines);\n+            final AST ast = getAST(aFileName, sar);\n             processAST(ast);\n             errors = VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors = new LineText[] {new LineText(0, \"File not found!\")};\n         }\n         catch (IOException ioe) {\n             errors = new LineText[] {\n                 new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n         }\n         catch (RecognitionException re) {\n             errors = new LineText[] {\n                 new LineText(0,\n                              \"Got a RecognitionException -\" + re.getMessage())};\n         }\n         catch (TokenStreamException te) {\n             errors = new LineText[] {\n                 new LineText(0,\n                              \"Got a TokenStreamException -\" + te.getMessage())};\n         }\n \n         if (errors.length == 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n             fireErrors(aFileName, errors);\n         }\n \n         fireFileFinished(aFileName);\n         return errors.length;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0e3fe5643667a53079dbd114e5b1e9aa91fde083": {
			"type": "Ymultichange(Ymodifierchange,Ybodychange)",
			"commitMessage": "started to incorporate logging events\n",
			"commitDate": "2001-08-30, 10:13 AM",
			"commitName": "0e3fe5643667a53079dbd114e5b1e9aa91fde083",
			"commitAuthor": "Oliver Burn",
			"subchanges": [
				{
					"type": "Ymodifierchange",
					"commitMessage": "started to incorporate logging events\n",
					"commitDate": "2001-08-30, 10:13 AM",
					"commitName": "0e3fe5643667a53079dbd114e5b1e9aa91fde083",
					"commitAuthor": "Oliver Burn",
					"commitDateOld": "2001-08-05, 8:12 AM",
					"commitNameOld": "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7",
					"commitAuthorOld": "Oliver Burn",
					"daysBetweenCommits": 25.08,
					"commitsBetweenForRepo": 5,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,42 +1,45 @@\n-    int process(String aFileName)\n+    private int process(String aFileName)\n     {\n-        final long timestamp = new File(aFileName).lastModified();\n+        final File f = new File(aFileName);\n+        final long timestamp = f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         LineText[] errors;\n         try {\n+            fireFileStarted(aFileName);\n             VerifierSingleton.getInstance().clearMessages();\n             VerifierSingleton.getInstance().setLines(getLines(aFileName));\n             final AST ast = getAST(aFileName);\n             processAST(ast);\n             errors = VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors = new LineText[] {new LineText(0, \"File not found!\")};\n         }\n         catch (IOException ioe) {\n             errors = new LineText[] {\n                 new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n         }\n         catch (RecognitionException re) {\n             errors = new LineText[] {\n                 new LineText(0,\n-                             \"Got a RecognitionException -\" +\n-                             re.getMessage())};\n+                             \"Got a RecognitionException -\" + re.getMessage())};\n         }\n         catch (TokenStreamException te) {\n             errors = new LineText[] {\n                 new LineText(0,\n                              \"Got a TokenStreamException -\" + te.getMessage())};\n         }\n \n         if (errors.length == 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n-            displayErrors(aFileName, errors);\n+            fireErrors(aFileName, errors);\n         }\n+\n+        fireFileFinished(aFileName);\n         return errors.length;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[]",
						"newValue": "[private]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "started to incorporate logging events\n",
					"commitDate": "2001-08-30, 10:13 AM",
					"commitName": "0e3fe5643667a53079dbd114e5b1e9aa91fde083",
					"commitAuthor": "Oliver Burn",
					"commitDateOld": "2001-08-05, 8:12 AM",
					"commitNameOld": "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7",
					"commitAuthorOld": "Oliver Burn",
					"daysBetweenCommits": 25.08,
					"commitsBetweenForRepo": 5,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,42 +1,45 @@\n-    int process(String aFileName)\n+    private int process(String aFileName)\n     {\n-        final long timestamp = new File(aFileName).lastModified();\n+        final File f = new File(aFileName);\n+        final long timestamp = f.lastModified();\n         if (mCache.alreadyChecked(aFileName, timestamp)) {\n             return 0;\n         }\n \n         LineText[] errors;\n         try {\n+            fireFileStarted(aFileName);\n             VerifierSingleton.getInstance().clearMessages();\n             VerifierSingleton.getInstance().setLines(getLines(aFileName));\n             final AST ast = getAST(aFileName);\n             processAST(ast);\n             errors = VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors = new LineText[] {new LineText(0, \"File not found!\")};\n         }\n         catch (IOException ioe) {\n             errors = new LineText[] {\n                 new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n         }\n         catch (RecognitionException re) {\n             errors = new LineText[] {\n                 new LineText(0,\n-                             \"Got a RecognitionException -\" +\n-                             re.getMessage())};\n+                             \"Got a RecognitionException -\" + re.getMessage())};\n         }\n         catch (TokenStreamException te) {\n             errors = new LineText[] {\n                 new LineText(0,\n                              \"Got a TokenStreamException -\" + te.getMessage())};\n         }\n \n         if (errors.length == 0) {\n             mCache.checkedOk(aFileName, timestamp);\n         }\n         else {\n-            displayErrors(aFileName, errors);\n+            fireErrors(aFileName, errors);\n         }\n+\n+        fireFileFinished(aFileName);\n         return errors.length;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7": {
			"type": "Ybodychange",
			"commitMessage": "added support for caching\n",
			"commitDate": "2001-08-05, 8:12 AM",
			"commitName": "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2001-06-29, 1:21 AM",
			"commitNameOld": "69138e40225407ef560fd9d06d2903de37c83c2c",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 37.29,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,32 +1,42 @@\n     int process(String aFileName)\n     {\n+        final long timestamp = new File(aFileName).lastModified();\n+        if (mCache.alreadyChecked(aFileName, timestamp)) {\n+            return 0;\n+        }\n+\n         LineText[] errors;\n         try {\n             VerifierSingleton.getInstance().clearMessages();\n             VerifierSingleton.getInstance().setLines(getLines(aFileName));\n             final AST ast = getAST(aFileName);\n             processAST(ast);\n             errors = VerifierSingleton.getInstance().getMessages();\n         }\n         catch (FileNotFoundException fnfe) {\n             errors = new LineText[] {new LineText(0, \"File not found!\")};\n         }\n         catch (IOException ioe) {\n             errors = new LineText[] {\n                 new LineText(0, \"Got an IOException -\" + ioe.getMessage())};\n         }\n         catch (RecognitionException re) {\n             errors = new LineText[] {\n                 new LineText(0,\n                              \"Got a RecognitionException -\" +\n                              re.getMessage())};\n         }\n         catch (TokenStreamException te) {\n             errors = new LineText[] {\n                 new LineText(0,\n                              \"Got a TokenStreamException -\" + te.getMessage())};\n         }\n \n-        displayErrors(aFileName, errors);\n+        if (errors.length == 0) {\n+            mCache.checkedOk(aFileName, timestamp);\n+        }\n+        else {\n+            displayErrors(aFileName, errors);\n+        }\n         return errors.length;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0fd69594a4c3e82f92f93f0371791da66938f8c3": {
			"type": "Yintroduced",
			"commitMessage": "first cut\n",
			"commitDate": "2001-06-22, 7:24 AM",
			"commitName": "0fd69594a4c3e82f92f93f0371791da66938f8c3",
			"commitAuthor": "Oliver Burn"
		}
	},
	"sha": "119fd4fb33bef9f5c66fc950396669af842c21a3"
}