{
	"repo": "https://github.com/apache/commons-lang.git",
	"file": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
	"method": {
		"longName": "StrSubstitutor::substitute(StrBuilder buf, int offset, int length, List<String> priorVariables)",
		"startLine": 758,
		"methodName": "substitute",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "private"
	},
	"history": {
		"4f82195afdc4279c05826fc20f8642bfdaaafec3": {
			"type": "Ybodychange",
			"commitMessage": "Remove redundant type arguments.",
			"commitDate": "2016-10-23, 11:52 AM",
			"commitName": "4f82195afdc4279c05826fc20f8642bfdaaafec3",
			"commitAuthor": "Gary Gregory",
			"commitDateOld": "2016-09-11, 8:07 AM",
			"commitNameOld": "ecf6de89ba1a6542c68194e95d14ea944b6c92b7",
			"commitAuthorOld": "Benedikt Ritter",
			"daysBetweenCommits": 42.16,
			"commitsBetweenForRepo": 89,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,135 +1,135 @@\n     private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) {\n         final StrMatcher pfxMatcher = getVariablePrefixMatcher();\n         final StrMatcher suffMatcher = getVariableSuffixMatcher();\n         final char escape = getEscapeChar();\n         final StrMatcher valueDelimMatcher = getValueDelimiterMatcher();\n         final boolean substitutionInVariablesEnabled = isEnableSubstitutionInVariables();\n \n         final boolean top = priorVariables == null;\n         boolean altered = false;\n         int lengthChange = 0;\n         char[] chars = buf.buffer;\n         int bufEnd = offset + length;\n         int pos = offset;\n         while (pos < bufEnd) {\n             final int startMatchLen = pfxMatcher.isMatch(chars, pos, offset,\n                     bufEnd);\n             if (startMatchLen == 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos > offset && chars[pos - 1] == escape) {\n                     // escaped\n                     if (preserveEscapes) {\n                         pos++;\n                         continue;\n                     }\n                     buf.deleteCharAt(pos - 1);\n                     chars = buf.buffer; // in case buffer was altered\n                     lengthChange--;\n                     altered = true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     final int startPos = pos;\n                     pos += startMatchLen;\n                     int endMatchLen = 0;\n                     int nestedVarCount = 0;\n                     while (pos < bufEnd) {\n                         if (substitutionInVariablesEnabled\n                                 && (endMatchLen = pfxMatcher.isMatch(chars,\n                                         pos, offset, bufEnd)) != 0) {\n                             // found a nested variable start\n                             nestedVarCount++;\n                             pos += endMatchLen;\n                             continue;\n                         }\n \n                         endMatchLen = suffMatcher.isMatch(chars, pos, offset,\n                                 bufEnd);\n                         if (endMatchLen == 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             if (nestedVarCount == 0) {\n                                 String varNameExpr = new String(chars, startPos\n                                         + startMatchLen, pos - startPos\n                                         - startMatchLen);\n                                 if (substitutionInVariablesEnabled) {\n                                     final StrBuilder bufName = new StrBuilder(varNameExpr);\n                                     substitute(bufName, 0, bufName.length());\n                                     varNameExpr = bufName.toString();\n                                 }\n                                 pos += endMatchLen;\n                                 final int endPos = pos;\n \n                                 String varName = varNameExpr;\n                                 String varDefaultValue = null;\n \n                                 if (valueDelimMatcher != null) {\n                                     final char [] varNameExprChars = varNameExpr.toCharArray();\n                                     int valueDelimiterMatchLen = 0;\n                                     for (int i = 0; i < varNameExprChars.length; i++) {\n                                         // if there's any nested variable when nested variable substitution disabled, then stop resolving name and default value.\n                                         if (!substitutionInVariablesEnabled\n                                                 && pfxMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) != 0) {\n                                             break;\n                                         }\n                                         if ((valueDelimiterMatchLen = valueDelimMatcher.isMatch(varNameExprChars, i)) != 0) {\n                                             varName = varNameExpr.substring(0, i);\n                                             varDefaultValue = varNameExpr.substring(i + valueDelimiterMatchLen);\n                                             break;\n                                         }\n                                     }\n                                 }\n \n                                 // on the first call initialize priorVariables\n                                 if (priorVariables == null) {\n-                                    priorVariables = new ArrayList<String>();\n+                                    priorVariables = new ArrayList<>();\n                                     priorVariables.add(new String(chars,\n                                             offset, length));\n                                 }\n \n                                 // handle cyclic substitution\n                                 checkCyclicSubstitution(varName, priorVariables);\n                                 priorVariables.add(varName);\n \n                                 // resolve the variable\n                                 String varValue = resolveVariable(varName, buf,\n                                         startPos, endPos);\n                                 if (varValue == null) {\n                                     varValue = varDefaultValue;\n                                 }\n                                 if (varValue != null) {\n                                     // recursive replace\n                                     final int varLen = varValue.length();\n                                     buf.replace(startPos, endPos, varValue);\n                                     altered = true;\n                                     int change = substitute(buf, startPos,\n                                             varLen, priorVariables);\n                                     change = change\n                                             + varLen - (endPos - startPos);\n                                     pos += change;\n                                     bufEnd += change;\n                                     lengthChange += change;\n                                     chars = buf.buffer; // in case buffer was\n                                                         // altered\n                                 }\n \n                                 // remove variable from the cyclic stack\n                                 priorVariables\n                                         .remove(priorVariables.size() - 1);\n                                 break;\n                             }\n                             nestedVarCount--;\n                             pos += endMatchLen;\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return altered ? 1 : 0;\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e55aaa5706f031df2e8d68bdf088604c79944246": {
			"type": "Ybodychange",
			"commitMessage": "StrSubstitutor can preserve escapes\n\nStrSubstitutor can now optionally preserve the escape character for an\nescaped reference, which is useful when substitution takes place in\nmultiple phases and some references are intentionally unresolved.  Prior\nto this change, an unresolved reference `${a}` and an escaped reference\n`$${a}` may result in the same string `${a}`, making it impossible for\nan additional substitution phase to distinguish between escaped\nreferences and non-escaped references.\n",
			"commitDate": "2016-02-25, 6:02 PM",
			"commitName": "e55aaa5706f031df2e8d68bdf088604c79944246",
			"commitAuthor": "Samuel Karp",
			"commitDateOld": "2015-05-05, 1:12 PM",
			"commitNameOld": "740c0f95fbd99cb7c07bcf7c54bc077c3ab27bd1",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 296.24,
			"commitsBetweenForRepo": 130,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,131 +1,135 @@\n     private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) {\n         final StrMatcher pfxMatcher = getVariablePrefixMatcher();\n         final StrMatcher suffMatcher = getVariableSuffixMatcher();\n         final char escape = getEscapeChar();\n         final StrMatcher valueDelimMatcher = getValueDelimiterMatcher();\n         final boolean substitutionInVariablesEnabled = isEnableSubstitutionInVariables();\n \n         final boolean top = priorVariables == null;\n         boolean altered = false;\n         int lengthChange = 0;\n         char[] chars = buf.buffer;\n         int bufEnd = offset + length;\n         int pos = offset;\n         while (pos < bufEnd) {\n             final int startMatchLen = pfxMatcher.isMatch(chars, pos, offset,\n                     bufEnd);\n             if (startMatchLen == 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos > offset && chars[pos - 1] == escape) {\n                     // escaped\n+                    if (preserveEscapes) {\n+                        pos++;\n+                        continue;\n+                    }\n                     buf.deleteCharAt(pos - 1);\n                     chars = buf.buffer; // in case buffer was altered\n                     lengthChange--;\n                     altered = true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     final int startPos = pos;\n                     pos += startMatchLen;\n                     int endMatchLen = 0;\n                     int nestedVarCount = 0;\n                     while (pos < bufEnd) {\n                         if (substitutionInVariablesEnabled\n                                 && (endMatchLen = pfxMatcher.isMatch(chars,\n                                         pos, offset, bufEnd)) != 0) {\n                             // found a nested variable start\n                             nestedVarCount++;\n                             pos += endMatchLen;\n                             continue;\n                         }\n \n                         endMatchLen = suffMatcher.isMatch(chars, pos, offset,\n                                 bufEnd);\n                         if (endMatchLen == 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             if (nestedVarCount == 0) {\n                                 String varNameExpr = new String(chars, startPos\n                                         + startMatchLen, pos - startPos\n                                         - startMatchLen);\n                                 if (substitutionInVariablesEnabled) {\n                                     final StrBuilder bufName = new StrBuilder(varNameExpr);\n                                     substitute(bufName, 0, bufName.length());\n                                     varNameExpr = bufName.toString();\n                                 }\n                                 pos += endMatchLen;\n                                 final int endPos = pos;\n \n                                 String varName = varNameExpr;\n                                 String varDefaultValue = null;\n \n                                 if (valueDelimMatcher != null) {\n                                     final char [] varNameExprChars = varNameExpr.toCharArray();\n                                     int valueDelimiterMatchLen = 0;\n                                     for (int i = 0; i < varNameExprChars.length; i++) {\n                                         // if there's any nested variable when nested variable substitution disabled, then stop resolving name and default value.\n                                         if (!substitutionInVariablesEnabled\n                                                 && pfxMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) != 0) {\n                                             break;\n                                         }\n                                         if ((valueDelimiterMatchLen = valueDelimMatcher.isMatch(varNameExprChars, i)) != 0) {\n                                             varName = varNameExpr.substring(0, i);\n                                             varDefaultValue = varNameExpr.substring(i + valueDelimiterMatchLen);\n                                             break;\n                                         }\n                                     }\n                                 }\n \n                                 // on the first call initialize priorVariables\n                                 if (priorVariables == null) {\n                                     priorVariables = new ArrayList<String>();\n                                     priorVariables.add(new String(chars,\n                                             offset, length));\n                                 }\n \n                                 // handle cyclic substitution\n                                 checkCyclicSubstitution(varName, priorVariables);\n                                 priorVariables.add(varName);\n \n                                 // resolve the variable\n                                 String varValue = resolveVariable(varName, buf,\n                                         startPos, endPos);\n                                 if (varValue == null) {\n                                     varValue = varDefaultValue;\n                                 }\n                                 if (varValue != null) {\n                                     // recursive replace\n                                     final int varLen = varValue.length();\n                                     buf.replace(startPos, endPos, varValue);\n                                     altered = true;\n                                     int change = substitute(buf, startPos,\n                                             varLen, priorVariables);\n                                     change = change\n                                             + varLen - (endPos - startPos);\n                                     pos += change;\n                                     bufEnd += change;\n                                     lengthChange += change;\n                                     chars = buf.buffer; // in case buffer was\n                                                         // altered\n                                 }\n \n                                 // remove variable from the cyclic stack\n                                 priorVariables\n                                         .remove(priorVariables.size() - 1);\n                                 break;\n                             }\n                             nestedVarCount--;\n                             pos += endMatchLen;\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return altered ? 1 : 0;\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"93b1808e523c252098139c37ee5b23324e855b4a": {
			"type": "Ybodychange",
			"commitMessage": "Statement unnecessarily nested within else clause.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1606063 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2014-06-27, 6:34 AM",
			"commitName": "93b1808e523c252098139c37ee5b23324e855b4a",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2014-06-27, 6:22 AM",
			"commitNameOld": "96c30e248d6d27a1df8e26be14aa10c633168cdb",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,132 +1,131 @@\n     private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) {\n         final StrMatcher pfxMatcher = getVariablePrefixMatcher();\n         final StrMatcher suffMatcher = getVariableSuffixMatcher();\n         final char escape = getEscapeChar();\n         final StrMatcher valueDelimMatcher = getValueDelimiterMatcher();\n         final boolean substitutionInVariablesEnabled = isEnableSubstitutionInVariables();\n \n         final boolean top = priorVariables == null;\n         boolean altered = false;\n         int lengthChange = 0;\n         char[] chars = buf.buffer;\n         int bufEnd = offset + length;\n         int pos = offset;\n         while (pos < bufEnd) {\n             final int startMatchLen = pfxMatcher.isMatch(chars, pos, offset,\n                     bufEnd);\n             if (startMatchLen == 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos > offset && chars[pos - 1] == escape) {\n                     // escaped\n                     buf.deleteCharAt(pos - 1);\n                     chars = buf.buffer; // in case buffer was altered\n                     lengthChange--;\n                     altered = true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     final int startPos = pos;\n                     pos += startMatchLen;\n                     int endMatchLen = 0;\n                     int nestedVarCount = 0;\n                     while (pos < bufEnd) {\n                         if (substitutionInVariablesEnabled\n                                 && (endMatchLen = pfxMatcher.isMatch(chars,\n                                         pos, offset, bufEnd)) != 0) {\n                             // found a nested variable start\n                             nestedVarCount++;\n                             pos += endMatchLen;\n                             continue;\n                         }\n \n                         endMatchLen = suffMatcher.isMatch(chars, pos, offset,\n                                 bufEnd);\n                         if (endMatchLen == 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             if (nestedVarCount == 0) {\n                                 String varNameExpr = new String(chars, startPos\n                                         + startMatchLen, pos - startPos\n                                         - startMatchLen);\n                                 if (substitutionInVariablesEnabled) {\n                                     final StrBuilder bufName = new StrBuilder(varNameExpr);\n                                     substitute(bufName, 0, bufName.length());\n                                     varNameExpr = bufName.toString();\n                                 }\n                                 pos += endMatchLen;\n                                 final int endPos = pos;\n \n                                 String varName = varNameExpr;\n                                 String varDefaultValue = null;\n \n                                 if (valueDelimMatcher != null) {\n                                     final char [] varNameExprChars = varNameExpr.toCharArray();\n                                     int valueDelimiterMatchLen = 0;\n                                     for (int i = 0; i < varNameExprChars.length; i++) {\n                                         // if there's any nested variable when nested variable substitution disabled, then stop resolving name and default value.\n                                         if (!substitutionInVariablesEnabled\n                                                 && pfxMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) != 0) {\n                                             break;\n                                         }\n                                         if ((valueDelimiterMatchLen = valueDelimMatcher.isMatch(varNameExprChars, i)) != 0) {\n                                             varName = varNameExpr.substring(0, i);\n                                             varDefaultValue = varNameExpr.substring(i + valueDelimiterMatchLen);\n                                             break;\n                                         }\n                                     }\n                                 }\n \n                                 // on the first call initialize priorVariables\n                                 if (priorVariables == null) {\n                                     priorVariables = new ArrayList<String>();\n                                     priorVariables.add(new String(chars,\n                                             offset, length));\n                                 }\n \n                                 // handle cyclic substitution\n                                 checkCyclicSubstitution(varName, priorVariables);\n                                 priorVariables.add(varName);\n \n                                 // resolve the variable\n                                 String varValue = resolveVariable(varName, buf,\n                                         startPos, endPos);\n                                 if (varValue == null) {\n                                     varValue = varDefaultValue;\n                                 }\n                                 if (varValue != null) {\n                                     // recursive replace\n                                     final int varLen = varValue.length();\n                                     buf.replace(startPos, endPos, varValue);\n                                     altered = true;\n                                     int change = substitute(buf, startPos,\n                                             varLen, priorVariables);\n                                     change = change\n                                             + varLen - (endPos - startPos);\n                                     pos += change;\n                                     bufEnd += change;\n                                     lengthChange += change;\n                                     chars = buf.buffer; // in case buffer was\n                                                         // altered\n                                 }\n \n                                 // remove variable from the cyclic stack\n                                 priorVariables\n                                         .remove(priorVariables.size() - 1);\n                                 break;\n-                            } else {\n-                                nestedVarCount--;\n-                                pos += endMatchLen;\n                             }\n+                            nestedVarCount--;\n+                            pos += endMatchLen;\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return altered ? 1 : 0;\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1d97f23c08d8dbf889e976f9248d37173dbadb95": {
			"type": "Ybodychange",
			"commitMessage": "It's confusing to re-use field names locally\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1533551 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-10-18, 10:49 AM",
			"commitName": "1d97f23c08d8dbf889e976f9248d37173dbadb95",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2013-09-29, 12:06 PM",
			"commitNameOld": "a328fd00a7092768758c0a76d68eeebaf8116440",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 18.95,
			"commitsBetweenForRepo": 36,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,132 +1,132 @@\n     private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) {\n-        final StrMatcher prefixMatcher = getVariablePrefixMatcher();\n-        final StrMatcher suffixMatcher = getVariableSuffixMatcher();\n+        final StrMatcher pfxMatcher = getVariablePrefixMatcher();\n+        final StrMatcher suffMatcher = getVariableSuffixMatcher();\n         final char escape = getEscapeChar();\n-        final StrMatcher valueDelimiterMatcher = getValueDelimiterMatcher();\n+        final StrMatcher valueDelimMatcher = getValueDelimiterMatcher();\n         final boolean substitutionInVariablesEnabled = isEnableSubstitutionInVariables();\n \n         final boolean top = priorVariables == null;\n         boolean altered = false;\n         int lengthChange = 0;\n         char[] chars = buf.buffer;\n         int bufEnd = offset + length;\n         int pos = offset;\n         while (pos < bufEnd) {\n-            final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset,\n+            final int startMatchLen = pfxMatcher.isMatch(chars, pos, offset,\n                     bufEnd);\n             if (startMatchLen == 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos > offset && chars[pos - 1] == escape) {\n                     // escaped\n                     buf.deleteCharAt(pos - 1);\n                     chars = buf.buffer; // in case buffer was altered\n                     lengthChange--;\n                     altered = true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     final int startPos = pos;\n                     pos += startMatchLen;\n                     int endMatchLen = 0;\n                     int nestedVarCount = 0;\n                     while (pos < bufEnd) {\n                         if (substitutionInVariablesEnabled\n-                                && (endMatchLen = prefixMatcher.isMatch(chars,\n+                                && (endMatchLen = pfxMatcher.isMatch(chars,\n                                         pos, offset, bufEnd)) != 0) {\n                             // found a nested variable start\n                             nestedVarCount++;\n                             pos += endMatchLen;\n                             continue;\n                         }\n \n-                        endMatchLen = suffixMatcher.isMatch(chars, pos, offset,\n+                        endMatchLen = suffMatcher.isMatch(chars, pos, offset,\n                                 bufEnd);\n                         if (endMatchLen == 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             if (nestedVarCount == 0) {\n                                 String varNameExpr = new String(chars, startPos\n                                         + startMatchLen, pos - startPos\n                                         - startMatchLen);\n                                 if (substitutionInVariablesEnabled) {\n                                     final StrBuilder bufName = new StrBuilder(varNameExpr);\n                                     substitute(bufName, 0, bufName.length());\n                                     varNameExpr = bufName.toString();\n                                 }\n                                 pos += endMatchLen;\n                                 final int endPos = pos;\n \n                                 String varName = varNameExpr;\n                                 String varDefaultValue = null;\n \n-                                if (valueDelimiterMatcher != null) {\n+                                if (valueDelimMatcher != null) {\n                                     final char [] varNameExprChars = varNameExpr.toCharArray();\n                                     int valueDelimiterMatchLen = 0;\n                                     for (int i = 0; i < varNameExprChars.length; i++) {\n                                         // if there's any nested variable when nested variable substitution disabled, then stop resolving name and default value.\n                                         if (!substitutionInVariablesEnabled\n-                                                && prefixMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) != 0) {\n+                                                && pfxMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) != 0) {\n                                             break;\n                                         }\n-                                        if ((valueDelimiterMatchLen = valueDelimiterMatcher.isMatch(varNameExprChars, i)) != 0) {\n+                                        if ((valueDelimiterMatchLen = valueDelimMatcher.isMatch(varNameExprChars, i)) != 0) {\n                                             varName = varNameExpr.substring(0, i);\n                                             varDefaultValue = varNameExpr.substring(i + valueDelimiterMatchLen);\n                                             break;\n                                         }\n                                     }\n                                 }\n \n                                 // on the first call initialize priorVariables\n                                 if (priorVariables == null) {\n                                     priorVariables = new ArrayList<String>();\n                                     priorVariables.add(new String(chars,\n                                             offset, length));\n                                 }\n \n                                 // handle cyclic substitution\n                                 checkCyclicSubstitution(varName, priorVariables);\n                                 priorVariables.add(varName);\n \n                                 // resolve the variable\n                                 String varValue = resolveVariable(varName, buf,\n                                         startPos, endPos);\n                                 if (varValue == null) {\n                                     varValue = varDefaultValue;\n                                 }\n                                 if (varValue != null) {\n                                     // recursive replace\n                                     final int varLen = varValue.length();\n                                     buf.replace(startPos, endPos, varValue);\n                                     altered = true;\n                                     int change = substitute(buf, startPos,\n                                             varLen, priorVariables);\n                                     change = change\n                                             + varLen - (endPos - startPos);\n                                     pos += change;\n                                     bufEnd += change;\n                                     lengthChange += change;\n                                     chars = buf.buffer; // in case buffer was\n                                                         // altered\n                                 }\n \n                                 // remove variable from the cyclic stack\n                                 priorVariables\n                                         .remove(priorVariables.size() - 1);\n                                 break;\n                             } else {\n                                 nestedVarCount--;\n                                 pos += endMatchLen;\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return altered ? 1 : 0;\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"abc5dda962fe00fba27f98807ca70439a37a3746": {
			"type": "Ybodychange",
			"commitMessage": "[LANG-893] StrSubstitutor now supports the declaration of default values for the variables to be replaced. Thanks to Woonsan Ko for the patch.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1524541 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-09-18, 1:35 PM",
			"commitName": "abc5dda962fe00fba27f98807ca70439a37a3746",
			"commitAuthor": "Oliver Heger",
			"commitDateOld": "2013-05-30, 10:36 AM",
			"commitNameOld": "8b494b784dca4de7d79c58e0f00dd4756c04cf89",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 111.12,
			"commitsBetweenForRepo": 27,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,107 +1,132 @@\n     private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) {\n         final StrMatcher prefixMatcher = getVariablePrefixMatcher();\n         final StrMatcher suffixMatcher = getVariableSuffixMatcher();\n         final char escape = getEscapeChar();\n+        final StrMatcher valueDelimiterMatcher = getValueDelimiterMatcher();\n+        final boolean substitutionInVariablesEnabled = isEnableSubstitutionInVariables();\n \n         final boolean top = priorVariables == null;\n         boolean altered = false;\n         int lengthChange = 0;\n         char[] chars = buf.buffer;\n         int bufEnd = offset + length;\n         int pos = offset;\n         while (pos < bufEnd) {\n             final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset,\n                     bufEnd);\n             if (startMatchLen == 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos > offset && chars[pos - 1] == escape) {\n                     // escaped\n                     buf.deleteCharAt(pos - 1);\n                     chars = buf.buffer; // in case buffer was altered\n                     lengthChange--;\n                     altered = true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     final int startPos = pos;\n                     pos += startMatchLen;\n                     int endMatchLen = 0;\n                     int nestedVarCount = 0;\n                     while (pos < bufEnd) {\n-                        if (isEnableSubstitutionInVariables()\n+                        if (substitutionInVariablesEnabled\n                                 && (endMatchLen = prefixMatcher.isMatch(chars,\n                                         pos, offset, bufEnd)) != 0) {\n                             // found a nested variable start\n                             nestedVarCount++;\n                             pos += endMatchLen;\n                             continue;\n                         }\n \n                         endMatchLen = suffixMatcher.isMatch(chars, pos, offset,\n                                 bufEnd);\n                         if (endMatchLen == 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             if (nestedVarCount == 0) {\n-                                String varName = new String(chars, startPos\n+                                String varNameExpr = new String(chars, startPos\n                                         + startMatchLen, pos - startPos\n                                         - startMatchLen);\n-                                if (isEnableSubstitutionInVariables()) {\n-                                    final StrBuilder bufName = new StrBuilder(varName);\n+                                if (substitutionInVariablesEnabled) {\n+                                    final StrBuilder bufName = new StrBuilder(varNameExpr);\n                                     substitute(bufName, 0, bufName.length());\n-                                    varName = bufName.toString();\n+                                    varNameExpr = bufName.toString();\n                                 }\n                                 pos += endMatchLen;\n                                 final int endPos = pos;\n \n+                                String varName = varNameExpr;\n+                                String varDefaultValue = null;\n+\n+                                if (valueDelimiterMatcher != null) {\n+                                    final char [] varNameExprChars = varNameExpr.toCharArray();\n+                                    int valueDelimiterMatchLen = 0;\n+                                    for (int i = 0; i < varNameExprChars.length; i++) {\n+                                        // if there's any nested variable when nested variable substitution disabled, then stop resolving name and default value.\n+                                        if (!substitutionInVariablesEnabled\n+                                                && prefixMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) != 0) {\n+                                            break;\n+                                        }\n+                                        if ((valueDelimiterMatchLen = valueDelimiterMatcher.isMatch(varNameExprChars, i)) != 0) {\n+                                            varName = varNameExpr.substring(0, i);\n+                                            varDefaultValue = varNameExpr.substring(i + valueDelimiterMatchLen);\n+                                            break;\n+                                        }\n+                                    }\n+                                }\n+\n                                 // on the first call initialize priorVariables\n                                 if (priorVariables == null) {\n                                     priorVariables = new ArrayList<String>();\n                                     priorVariables.add(new String(chars,\n                                             offset, length));\n                                 }\n \n                                 // handle cyclic substitution\n                                 checkCyclicSubstitution(varName, priorVariables);\n                                 priorVariables.add(varName);\n \n                                 // resolve the variable\n-                                final String varValue = resolveVariable(varName, buf,\n+                                String varValue = resolveVariable(varName, buf,\n                                         startPos, endPos);\n+                                if (varValue == null) {\n+                                    varValue = varDefaultValue;\n+                                }\n                                 if (varValue != null) {\n                                     // recursive replace\n                                     final int varLen = varValue.length();\n                                     buf.replace(startPos, endPos, varValue);\n                                     altered = true;\n                                     int change = substitute(buf, startPos,\n                                             varLen, priorVariables);\n                                     change = change\n                                             + varLen - (endPos - startPos);\n                                     pos += change;\n                                     bufEnd += change;\n                                     lengthChange += change;\n                                     chars = buf.buffer; // in case buffer was\n                                                         // altered\n                                 }\n \n                                 // remove variable from the cyclic stack\n                                 priorVariables\n                                         .remove(priorVariables.size() - 1);\n                                 break;\n                             } else {\n                                 nestedVarCount--;\n                                 pos += endMatchLen;\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return altered ? 1 : 0;\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5292526e476ffbb19c6613a98464054236c86ace": {
			"type": "Ybodychange",
			"commitMessage": "Add final modifier to local variables.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436770 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-01-22, 12:09 AM",
			"commitName": "5292526e476ffbb19c6613a98464054236c86ace",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2013-01-22, 12:07 AM",
			"commitNameOld": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,107 +1,107 @@\n     private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) {\n-        StrMatcher prefixMatcher = getVariablePrefixMatcher();\n-        StrMatcher suffixMatcher = getVariableSuffixMatcher();\n-        char escape = getEscapeChar();\n+        final StrMatcher prefixMatcher = getVariablePrefixMatcher();\n+        final StrMatcher suffixMatcher = getVariableSuffixMatcher();\n+        final char escape = getEscapeChar();\n \n-        boolean top = priorVariables == null;\n+        final boolean top = priorVariables == null;\n         boolean altered = false;\n         int lengthChange = 0;\n         char[] chars = buf.buffer;\n         int bufEnd = offset + length;\n         int pos = offset;\n         while (pos < bufEnd) {\n-            int startMatchLen = prefixMatcher.isMatch(chars, pos, offset,\n+            final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset,\n                     bufEnd);\n             if (startMatchLen == 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos > offset && chars[pos - 1] == escape) {\n                     // escaped\n                     buf.deleteCharAt(pos - 1);\n                     chars = buf.buffer; // in case buffer was altered\n                     lengthChange--;\n                     altered = true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n-                    int startPos = pos;\n+                    final int startPos = pos;\n                     pos += startMatchLen;\n                     int endMatchLen = 0;\n                     int nestedVarCount = 0;\n                     while (pos < bufEnd) {\n                         if (isEnableSubstitutionInVariables()\n                                 && (endMatchLen = prefixMatcher.isMatch(chars,\n                                         pos, offset, bufEnd)) != 0) {\n                             // found a nested variable start\n                             nestedVarCount++;\n                             pos += endMatchLen;\n                             continue;\n                         }\n \n                         endMatchLen = suffixMatcher.isMatch(chars, pos, offset,\n                                 bufEnd);\n                         if (endMatchLen == 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             if (nestedVarCount == 0) {\n                                 String varName = new String(chars, startPos\n                                         + startMatchLen, pos - startPos\n                                         - startMatchLen);\n                                 if (isEnableSubstitutionInVariables()) {\n-                                    StrBuilder bufName = new StrBuilder(varName);\n+                                    final StrBuilder bufName = new StrBuilder(varName);\n                                     substitute(bufName, 0, bufName.length());\n                                     varName = bufName.toString();\n                                 }\n                                 pos += endMatchLen;\n-                                int endPos = pos;\n+                                final int endPos = pos;\n \n                                 // on the first call initialize priorVariables\n                                 if (priorVariables == null) {\n                                     priorVariables = new ArrayList<String>();\n                                     priorVariables.add(new String(chars,\n                                             offset, length));\n                                 }\n \n                                 // handle cyclic substitution\n                                 checkCyclicSubstitution(varName, priorVariables);\n                                 priorVariables.add(varName);\n \n                                 // resolve the variable\n-                                String varValue = resolveVariable(varName, buf,\n+                                final String varValue = resolveVariable(varName, buf,\n                                         startPos, endPos);\n                                 if (varValue != null) {\n                                     // recursive replace\n-                                    int varLen = varValue.length();\n+                                    final int varLen = varValue.length();\n                                     buf.replace(startPos, endPos, varValue);\n                                     altered = true;\n                                     int change = substitute(buf, startPos,\n                                             varLen, priorVariables);\n                                     change = change\n                                             + varLen - (endPos - startPos);\n                                     pos += change;\n                                     bufEnd += change;\n                                     lengthChange += change;\n                                     chars = buf.buffer; // in case buffer was\n                                                         // altered\n                                 }\n \n                                 // remove variable from the cyclic stack\n                                 priorVariables\n                                         .remove(priorVariables.size() - 1);\n                                 break;\n                             } else {\n                                 nestedVarCount--;\n                                 pos += endMatchLen;\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return altered ? 1 : 0;\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5bd622dab027ef37001a630a7c825c5b8c19d1db": {
			"type": "Yparametermetachange",
			"commitMessage": "Add final modifier to method parameters.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436768 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-01-22, 12:07 AM",
			"commitName": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2011-11-09, 10:53 AM",
			"commitNameOld": "371e866442f46131cc38a9a5018e1703f52f9b60",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 439.55,
			"commitsBetweenForRepo": 243,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,107 +1,107 @@\n-    private int substitute(StrBuilder buf, int offset, int length, List<String> priorVariables) {\n+    private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) {\n         StrMatcher prefixMatcher = getVariablePrefixMatcher();\n         StrMatcher suffixMatcher = getVariableSuffixMatcher();\n         char escape = getEscapeChar();\n \n         boolean top = priorVariables == null;\n         boolean altered = false;\n         int lengthChange = 0;\n         char[] chars = buf.buffer;\n         int bufEnd = offset + length;\n         int pos = offset;\n         while (pos < bufEnd) {\n             int startMatchLen = prefixMatcher.isMatch(chars, pos, offset,\n                     bufEnd);\n             if (startMatchLen == 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos > offset && chars[pos - 1] == escape) {\n                     // escaped\n                     buf.deleteCharAt(pos - 1);\n                     chars = buf.buffer; // in case buffer was altered\n                     lengthChange--;\n                     altered = true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     int startPos = pos;\n                     pos += startMatchLen;\n                     int endMatchLen = 0;\n                     int nestedVarCount = 0;\n                     while (pos < bufEnd) {\n                         if (isEnableSubstitutionInVariables()\n                                 && (endMatchLen = prefixMatcher.isMatch(chars,\n                                         pos, offset, bufEnd)) != 0) {\n                             // found a nested variable start\n                             nestedVarCount++;\n                             pos += endMatchLen;\n                             continue;\n                         }\n \n                         endMatchLen = suffixMatcher.isMatch(chars, pos, offset,\n                                 bufEnd);\n                         if (endMatchLen == 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             if (nestedVarCount == 0) {\n                                 String varName = new String(chars, startPos\n                                         + startMatchLen, pos - startPos\n                                         - startMatchLen);\n                                 if (isEnableSubstitutionInVariables()) {\n                                     StrBuilder bufName = new StrBuilder(varName);\n                                     substitute(bufName, 0, bufName.length());\n                                     varName = bufName.toString();\n                                 }\n                                 pos += endMatchLen;\n                                 int endPos = pos;\n \n                                 // on the first call initialize priorVariables\n                                 if (priorVariables == null) {\n                                     priorVariables = new ArrayList<String>();\n                                     priorVariables.add(new String(chars,\n                                             offset, length));\n                                 }\n \n                                 // handle cyclic substitution\n                                 checkCyclicSubstitution(varName, priorVariables);\n                                 priorVariables.add(varName);\n \n                                 // resolve the variable\n                                 String varValue = resolveVariable(varName, buf,\n                                         startPos, endPos);\n                                 if (varValue != null) {\n                                     // recursive replace\n                                     int varLen = varValue.length();\n                                     buf.replace(startPos, endPos, varValue);\n                                     altered = true;\n                                     int change = substitute(buf, startPos,\n                                             varLen, priorVariables);\n                                     change = change\n                                             + varLen - (endPos - startPos);\n                                     pos += change;\n                                     bufEnd += change;\n                                     lengthChange += change;\n                                     chars = buf.buffer; // in case buffer was\n                                                         // altered\n                                 }\n \n                                 // remove variable from the cyclic stack\n                                 priorVariables\n                                         .remove(priorVariables.size() - 1);\n                                 break;\n                             } else {\n                                 nestedVarCount--;\n                                 pos += endMatchLen;\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return altered ? 1 : 0;\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[buf-StrBuilder, offset-int, length-int, priorVariables-List<String>]",
				"newValue": "[buf-StrBuilder(modifiers-final), offset-int(modifiers-final), length-int(modifiers-final), priorVariables-List<String>]"
			}
		},
		"371e866442f46131cc38a9a5018e1703f52f9b60": {
			"type": "Ybodychange",
			"commitMessage": "Remove superfluous parens like:\nreturn (foo + 1);\nint len = (foo + 1);\nif ((foo + 1 > 2))\n((String) foo)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1199894 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2011-11-09, 10:53 AM",
			"commitName": "371e866442f46131cc38a9a5018e1703f52f9b60",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2011-04-04, 11:31 PM",
			"commitNameOld": "3a0c152c22b6e96fc809fdee2d6ea5b816a139e6",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 218.52,
			"commitsBetweenForRepo": 424,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,107 +1,107 @@\n     private int substitute(StrBuilder buf, int offset, int length, List<String> priorVariables) {\n         StrMatcher prefixMatcher = getVariablePrefixMatcher();\n         StrMatcher suffixMatcher = getVariableSuffixMatcher();\n         char escape = getEscapeChar();\n \n-        boolean top = (priorVariables == null);\n+        boolean top = priorVariables == null;\n         boolean altered = false;\n         int lengthChange = 0;\n         char[] chars = buf.buffer;\n         int bufEnd = offset + length;\n         int pos = offset;\n         while (pos < bufEnd) {\n             int startMatchLen = prefixMatcher.isMatch(chars, pos, offset,\n                     bufEnd);\n             if (startMatchLen == 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos > offset && chars[pos - 1] == escape) {\n                     // escaped\n                     buf.deleteCharAt(pos - 1);\n                     chars = buf.buffer; // in case buffer was altered\n                     lengthChange--;\n                     altered = true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     int startPos = pos;\n                     pos += startMatchLen;\n                     int endMatchLen = 0;\n                     int nestedVarCount = 0;\n                     while (pos < bufEnd) {\n                         if (isEnableSubstitutionInVariables()\n                                 && (endMatchLen = prefixMatcher.isMatch(chars,\n                                         pos, offset, bufEnd)) != 0) {\n                             // found a nested variable start\n                             nestedVarCount++;\n                             pos += endMatchLen;\n                             continue;\n                         }\n \n                         endMatchLen = suffixMatcher.isMatch(chars, pos, offset,\n                                 bufEnd);\n                         if (endMatchLen == 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             if (nestedVarCount == 0) {\n                                 String varName = new String(chars, startPos\n                                         + startMatchLen, pos - startPos\n                                         - startMatchLen);\n                                 if (isEnableSubstitutionInVariables()) {\n                                     StrBuilder bufName = new StrBuilder(varName);\n                                     substitute(bufName, 0, bufName.length());\n                                     varName = bufName.toString();\n                                 }\n                                 pos += endMatchLen;\n                                 int endPos = pos;\n \n                                 // on the first call initialize priorVariables\n                                 if (priorVariables == null) {\n                                     priorVariables = new ArrayList<String>();\n                                     priorVariables.add(new String(chars,\n                                             offset, length));\n                                 }\n \n                                 // handle cyclic substitution\n                                 checkCyclicSubstitution(varName, priorVariables);\n                                 priorVariables.add(varName);\n \n                                 // resolve the variable\n                                 String varValue = resolveVariable(varName, buf,\n                                         startPos, endPos);\n                                 if (varValue != null) {\n                                     // recursive replace\n                                     int varLen = varValue.length();\n                                     buf.replace(startPos, endPos, varValue);\n                                     altered = true;\n                                     int change = substitute(buf, startPos,\n                                             varLen, priorVariables);\n                                     change = change\n-                                            + (varLen - (endPos - startPos));\n+                                            + varLen - (endPos - startPos);\n                                     pos += change;\n                                     bufEnd += change;\n                                     lengthChange += change;\n                                     chars = buf.buffer; // in case buffer was\n                                                         // altered\n                                 }\n \n                                 // remove variable from the cyclic stack\n                                 priorVariables\n                                         .remove(priorVariables.size() - 1);\n                                 break;\n                             } else {\n                                 nestedVarCount--;\n                                 pos += endMatchLen;\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n-            return (altered ? 1 : 0);\n+            return altered ? 1 : 0;\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6f6eddbf3a41fa2838f062fee7724a69b86206df": {
			"type": "Ybodychange",
			"commitMessage": "[lang-482] Added support for substitution in variable names.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1005974 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-10-08, 1:17 PM",
			"commitName": "6f6eddbf3a41fa2838f062fee7724a69b86206df",
			"commitAuthor": "Oliver Heger",
			"commitDateOld": "2010-10-02, 12:37 PM",
			"commitNameOld": "802ebc4279f6020c4bb9a8d11fc164920c54949f",
			"commitAuthorOld": "Oliver Heger",
			"daysBetweenCommits": 6.03,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,78 +1,107 @@\n     private int substitute(StrBuilder buf, int offset, int length, List<String> priorVariables) {\n         StrMatcher prefixMatcher = getVariablePrefixMatcher();\n         StrMatcher suffixMatcher = getVariableSuffixMatcher();\n         char escape = getEscapeChar();\n \n         boolean top = (priorVariables == null);\n         boolean altered = false;\n         int lengthChange = 0;\n         char[] chars = buf.buffer;\n         int bufEnd = offset + length;\n         int pos = offset;\n         while (pos < bufEnd) {\n-            int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n+            int startMatchLen = prefixMatcher.isMatch(chars, pos, offset,\n+                    bufEnd);\n             if (startMatchLen == 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos > offset && chars[pos - 1] == escape) {\n                     // escaped\n                     buf.deleteCharAt(pos - 1);\n-                    chars = buf.buffer;  // in case buffer was altered\n+                    chars = buf.buffer; // in case buffer was altered\n                     lengthChange--;\n                     altered = true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     int startPos = pos;\n                     pos += startMatchLen;\n                     int endMatchLen = 0;\n+                    int nestedVarCount = 0;\n                     while (pos < bufEnd) {\n-                        endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n+                        if (isEnableSubstitutionInVariables()\n+                                && (endMatchLen = prefixMatcher.isMatch(chars,\n+                                        pos, offset, bufEnd)) != 0) {\n+                            // found a nested variable start\n+                            nestedVarCount++;\n+                            pos += endMatchLen;\n+                            continue;\n+                        }\n+\n+                        endMatchLen = suffixMatcher.isMatch(chars, pos, offset,\n+                                bufEnd);\n                         if (endMatchLen == 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n-                            String varName = new String(chars, startPos + startMatchLen,\n-                                                        pos - startPos - startMatchLen);\n-                            pos += endMatchLen;\n-                            int endPos = pos;\n+                            if (nestedVarCount == 0) {\n+                                String varName = new String(chars, startPos\n+                                        + startMatchLen, pos - startPos\n+                                        - startMatchLen);\n+                                if (isEnableSubstitutionInVariables()) {\n+                                    StrBuilder bufName = new StrBuilder(varName);\n+                                    substitute(bufName, 0, bufName.length());\n+                                    varName = bufName.toString();\n+                                }\n+                                pos += endMatchLen;\n+                                int endPos = pos;\n \n-                            // on the first call initialize priorVariables\n-                            if (priorVariables == null) {\n-                                priorVariables = new ArrayList<String>();\n-                                priorVariables.add(new String(chars, offset, length));\n+                                // on the first call initialize priorVariables\n+                                if (priorVariables == null) {\n+                                    priorVariables = new ArrayList<String>();\n+                                    priorVariables.add(new String(chars,\n+                                            offset, length));\n+                                }\n+\n+                                // handle cyclic substitution\n+                                checkCyclicSubstitution(varName, priorVariables);\n+                                priorVariables.add(varName);\n+\n+                                // resolve the variable\n+                                String varValue = resolveVariable(varName, buf,\n+                                        startPos, endPos);\n+                                if (varValue != null) {\n+                                    // recursive replace\n+                                    int varLen = varValue.length();\n+                                    buf.replace(startPos, endPos, varValue);\n+                                    altered = true;\n+                                    int change = substitute(buf, startPos,\n+                                            varLen, priorVariables);\n+                                    change = change\n+                                            + (varLen - (endPos - startPos));\n+                                    pos += change;\n+                                    bufEnd += change;\n+                                    lengthChange += change;\n+                                    chars = buf.buffer; // in case buffer was\n+                                                        // altered\n+                                }\n+\n+                                // remove variable from the cyclic stack\n+                                priorVariables\n+                                        .remove(priorVariables.size() - 1);\n+                                break;\n+                            } else {\n+                                nestedVarCount--;\n+                                pos += endMatchLen;\n                             }\n-\n-                            // handle cyclic substitution\n-                            checkCyclicSubstitution(varName, priorVariables);\n-                            priorVariables.add(varName);\n-\n-                            // resolve the variable\n-                            String varValue = resolveVariable(varName, buf, startPos, endPos);\n-                            if (varValue != null) {\n-                                // recursive replace\n-                                int varLen = varValue.length();\n-                                buf.replace(startPos, endPos, varValue);\n-                                altered = true;\n-                                int change = substitute(buf, startPos, varLen, priorVariables);\n-                                change = change + (varLen - (endPos - startPos));\n-                                pos += change;\n-                                bufEnd += change;\n-                                lengthChange += change;\n-                                chars = buf.buffer;  // in case buffer was altered\n-                            }\n-\n-                            // remove variable from the cyclic stack\n-                            priorVariables.remove(priorVariables.size() - 1);\n-                            break;\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return (altered ? 1 : 0);\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fc5c081e22a61bb5a6810af302be3f22f7966df4": {
			"type": "Yfilerename",
			"commitMessage": "Move main source to src/main/java\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@895322 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-01-02, 7:11 PM",
			"commitName": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
			"commitAuthor": "Paul C. Benedict Jr",
			"commitDateOld": "2010-01-02, 7:09 PM",
			"commitNameOld": "6b32246f5f9f77c74b32a5290cdbdd4e0f5c71c6",
			"commitAuthorOld": "Paul C. Benedict Jr",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/java/org/apache/commons/lang3/text/StrSubstitutor.java",
				"newPath": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java"
			}
		},
		"debc02c6d9b94c717b4182ae4dd7a97d47293a52": {
			"type": "Yfilerename",
			"commitMessage": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@889202 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2009-12-10, 4:33 AM",
			"commitName": "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2009-12-10, 4:31 AM",
			"commitNameOld": "375d7d0954cae60c4c7292cc65abbc972178857c",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/java/org/apache/commons/lang/text/StrSubstitutor.java",
				"newPath": "src/java/org/apache/commons/lang3/text/StrSubstitutor.java"
			}
		},
		"654fb75d80a63fa551ced73c3b652f4120573590": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Genericize some more classes\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@754810 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2009-03-15, 9:35 PM",
			"commitName": "654fb75d80a63fa551ced73c3b652f4120573590",
			"commitAuthor": "Sebastian Bazley",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Genericize some more classes\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@754810 13f79535-47bb-0310-9956-ffa450edef68\n",
					"commitDate": "2009-03-15, 9:35 PM",
					"commitName": "654fb75d80a63fa551ced73c3b652f4120573590",
					"commitAuthor": "Sebastian Bazley",
					"commitDateOld": "2006-08-28, 12:21 AM",
					"commitNameOld": "a5a4f9067a0b22e629463b1ef059818ccda6f37e",
					"commitAuthorOld": "Henri Yandell",
					"daysBetweenCommits": 930.88,
					"commitsBetweenForRepo": 510,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,78 +1,78 @@\n-    private int substitute(StrBuilder buf, int offset, int length, List priorVariables) {\n+    private int substitute(StrBuilder buf, int offset, int length, List<String> priorVariables) {\n         StrMatcher prefixMatcher = getVariablePrefixMatcher();\n         StrMatcher suffixMatcher = getVariableSuffixMatcher();\n         char escape = getEscapeChar();\n         \n         boolean top = (priorVariables == null);\n         boolean altered = false;\n         int lengthChange = 0;\n         char[] chars = buf.buffer;\n         int bufEnd = offset + length;\n         int pos = offset;\n         while (pos < bufEnd) {\n             int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n             if (startMatchLen == 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos > offset && chars[pos - 1] == escape) {\n                     // escaped\n                     buf.deleteCharAt(pos - 1);\n                     chars = buf.buffer;  // in case buffer was altered\n                     lengthChange--;\n                     altered = true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     int startPos = pos;\n                     pos += startMatchLen;\n                     int endMatchLen = 0;\n                     while (pos < bufEnd) {\n                         endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                         if (endMatchLen == 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             String varName = new String(chars, startPos + startMatchLen, \n                                                         pos - startPos - startMatchLen);\n                             pos += endMatchLen;\n                             int endPos = pos;\n                             \n                             // on the first call initialize priorVariables\n                             if (priorVariables == null) {\n-                                priorVariables = new ArrayList();\n+                                priorVariables = new ArrayList<String>();\n                                 priorVariables.add(new String(chars, offset, length));\n                             }\n                             \n                             // handle cyclic substitution\n                             checkCyclicSubstitution(varName, priorVariables);\n                             priorVariables.add(varName);\n                             \n                             // resolve the variable\n                             String varValue = resolveVariable(varName, buf, startPos, endPos);\n                             if (varValue != null) {\n                                 // recursive replace\n                                 int varLen = varValue.length();\n                                 buf.replace(startPos, endPos, varValue);\n                                 altered = true;\n                                 int change = substitute(buf, startPos, varLen, priorVariables);\n                                 change = change + (varLen - (endPos - startPos));\n                                 pos += change;\n                                 bufEnd += change;\n                                 lengthChange += change;\n                                 chars = buf.buffer;  // in case buffer was altered\n                             }\n                             \n                             // remove variable from the cyclic stack\n                             priorVariables.remove(priorVariables.size() - 1);\n                             break;\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return (altered ? 1 : 0);\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[buf-StrBuilder, offset-int, length-int, priorVariables-List]",
						"newValue": "[buf-StrBuilder, offset-int, length-int, priorVariables-List<String>]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Genericize some more classes\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@754810 13f79535-47bb-0310-9956-ffa450edef68\n",
					"commitDate": "2009-03-15, 9:35 PM",
					"commitName": "654fb75d80a63fa551ced73c3b652f4120573590",
					"commitAuthor": "Sebastian Bazley",
					"commitDateOld": "2006-08-28, 12:21 AM",
					"commitNameOld": "a5a4f9067a0b22e629463b1ef059818ccda6f37e",
					"commitAuthorOld": "Henri Yandell",
					"daysBetweenCommits": 930.88,
					"commitsBetweenForRepo": 510,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,78 +1,78 @@\n-    private int substitute(StrBuilder buf, int offset, int length, List priorVariables) {\n+    private int substitute(StrBuilder buf, int offset, int length, List<String> priorVariables) {\n         StrMatcher prefixMatcher = getVariablePrefixMatcher();\n         StrMatcher suffixMatcher = getVariableSuffixMatcher();\n         char escape = getEscapeChar();\n         \n         boolean top = (priorVariables == null);\n         boolean altered = false;\n         int lengthChange = 0;\n         char[] chars = buf.buffer;\n         int bufEnd = offset + length;\n         int pos = offset;\n         while (pos < bufEnd) {\n             int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n             if (startMatchLen == 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos > offset && chars[pos - 1] == escape) {\n                     // escaped\n                     buf.deleteCharAt(pos - 1);\n                     chars = buf.buffer;  // in case buffer was altered\n                     lengthChange--;\n                     altered = true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     int startPos = pos;\n                     pos += startMatchLen;\n                     int endMatchLen = 0;\n                     while (pos < bufEnd) {\n                         endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                         if (endMatchLen == 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             String varName = new String(chars, startPos + startMatchLen, \n                                                         pos - startPos - startMatchLen);\n                             pos += endMatchLen;\n                             int endPos = pos;\n                             \n                             // on the first call initialize priorVariables\n                             if (priorVariables == null) {\n-                                priorVariables = new ArrayList();\n+                                priorVariables = new ArrayList<String>();\n                                 priorVariables.add(new String(chars, offset, length));\n                             }\n                             \n                             // handle cyclic substitution\n                             checkCyclicSubstitution(varName, priorVariables);\n                             priorVariables.add(varName);\n                             \n                             // resolve the variable\n                             String varValue = resolveVariable(varName, buf, startPos, endPos);\n                             if (varValue != null) {\n                                 // recursive replace\n                                 int varLen = varValue.length();\n                                 buf.replace(startPos, endPos, varValue);\n                                 altered = true;\n                                 int change = substitute(buf, startPos, varLen, priorVariables);\n                                 change = change + (varLen - (endPos - startPos));\n                                 pos += change;\n                                 bufEnd += change;\n                                 lengthChange += change;\n                                 chars = buf.buffer;  // in case buffer was altered\n                             }\n                             \n                             // remove variable from the cyclic stack\n                             priorVariables.remove(priorVariables.size() - 1);\n                             break;\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return (altered ? 1 : 0);\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"927e7361037fa495cafece987c1c7d54b7e8128b": {
			"type": "Ybodychange",
			"commitMessage": "Give more power to StrSubstitutor subclasses\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@429507 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2006-08-07, 5:06 PM",
			"commitName": "927e7361037fa495cafece987c1c7d54b7e8128b",
			"commitAuthor": "Stephen Colebourne",
			"commitDateOld": "2006-08-04, 12:35 AM",
			"commitNameOld": "2d4e279d1983870d88612afec782f18638b85ce7",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 3.69,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,78 +1,78 @@\n     private int substitute(StrBuilder buf, int offset, int length, List priorVariables) {\n         StrMatcher prefixMatcher = getVariablePrefixMatcher();\n         StrMatcher suffixMatcher = getVariableSuffixMatcher();\n         char escape = getEscapeChar();\n         \n         boolean top = (priorVariables == null);\n         boolean altered = false;\n         int lengthChange = 0;\n         char[] chars = buf.buffer;\n         int bufEnd = offset + length;\n         int pos = offset;\n         while (pos < bufEnd) {\n             int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n             if (startMatchLen == 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos > offset && chars[pos - 1] == escape) {\n                     // escaped\n                     buf.deleteCharAt(pos - 1);\n                     chars = buf.buffer;  // in case buffer was altered\n                     lengthChange--;\n                     altered = true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     int startPos = pos;\n                     pos += startMatchLen;\n                     int endMatchLen = 0;\n                     while (pos < bufEnd) {\n                         endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                         if (endMatchLen == 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             String varName = new String(chars, startPos + startMatchLen, \n                                                         pos - startPos - startMatchLen);\n                             pos += endMatchLen;\n                             int endPos = pos;\n                             \n                             // on the first call initialize priorVariables\n                             if (priorVariables == null) {\n                                 priorVariables = new ArrayList();\n                                 priorVariables.add(new String(chars, offset, length));\n                             }\n                             \n                             // handle cyclic substitution\n                             checkCyclicSubstitution(varName, priorVariables);\n                             priorVariables.add(varName);\n                             \n                             // resolve the variable\n-                            String varValue = resolveVariable(varName);\n+                            String varValue = resolveVariable(varName, buf, startPos, endPos);\n                             if (varValue != null) {\n                                 // recursive replace\n                                 int varLen = varValue.length();\n                                 buf.replace(startPos, endPos, varValue);\n                                 altered = true;\n                                 int change = substitute(buf, startPos, varLen, priorVariables);\n                                 change = change + (varLen - (endPos - startPos));\n                                 pos += change;\n                                 bufEnd += change;\n                                 lengthChange += change;\n                                 chars = buf.buffer;  // in case buffer was altered\n                             }\n                             \n                             // remove variable from the cyclic stack\n                             priorVariables.remove(priorVariables.size() - 1);\n                             break;\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return (altered ? 1 : 0);\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4bfa1f6cb94c368ffa4febc3a2236886ced2290f": {
			"type": "Yintroduced",
			"commitMessage": "Initial commit of StrSubstitutor (VariableFormatter) for review\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@424871 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2006-07-23, 7:00 PM",
			"commitName": "4bfa1f6cb94c368ffa4febc3a2236886ced2290f",
			"commitAuthor": "Stephen Colebourne"
		}
	},
	"sha": "a36c903d4f1065bc59f5e6d2bb0f9d92a5e71d83"
}