{
	"repo": "https://github.com/javaparser/javaparser.git",
	"file": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
	"method": {
		"longName": "MethodResolutionLogic::isApplicable(ResolvedMethodDeclaration method, String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance)",
		"startLine": 71,
		"methodName": "isApplicable",
		"isStatic": true,
		"isAbstract": false,
		"visibility": "private"
	},
	"history": {
		"09232ff6b0ea19e850482f3a87ac6ef1c063c759": {
			"type": "Yfilerename",
			"commitMessage": "rename JSS modules\n",
			"commitDate": "2018-01-10, 5:52 AM",
			"commitName": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2018-01-10, 1:01 AM",
			"commitNameOld": "30c04db173cc439556df2a238c99cd81ada320ff",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.2,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
				"newPath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java"
			}
		},
		"e15d5a8aa84a34917e4ef47135dfc62e58ea7650": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "correcting module core to use new classes\n",
			"commitDate": "2017-09-29, 12:07 AM",
			"commitName": "e15d5a8aa84a34917e4ef47135dfc62e58ea7650",
			"commitAuthor": "Federico Tomassetti",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "correcting module core to use new classes\n",
					"commitDate": "2017-09-29, 12:07 AM",
					"commitName": "e15d5a8aa84a34917e4ef47135dfc62e58ea7650",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2017-09-28, 2:36 PM",
					"commitNameOld": "5d8d0cb7947efcf2282f7d056302dd905f348532",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.4,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,73 +1,73 @@\n-    private static boolean isApplicable(MethodDeclaration method, String name, List<Type> argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n+    private static boolean isApplicable(ResolvedMethodDeclaration method, String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos = method.getNumberOfParams() - 1;\n             if (method.getNumberOfParams() == argumentsTypes.size()) {\n                 // check if the last value is directly assignable as an array\n-                Type expectedType = method.getLastParam().getType();\n-                Type actualType = argumentsTypes.get(pos);\n+                ResolvedType expectedType = method.getLastParam().getType();\n+                ResolvedType actualType = argumentsTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n-                    for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n+                    for (ResolvedTypeParameterDeclaration tp : method.getTypeParameters()) {\n                         expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                             argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                         } else {\n                             argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 if (pos > argumentsTypes.size()) {\n                   return false;\n                 }\n                 argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNumberOfParams() != argumentsTypes.size()) {\n             return false;\n         }\n-        Map<String, Type> matchedParameters = new HashMap<>();\n+        Map<String, ResolvedType> matchedParameters = new HashMap<>();\n         boolean needForWildCardTolerance = false;\n         for (int i = 0; i < method.getNumberOfParams(); i++) {\n-            Type expectedType = method.getParam(i).getType();\n-            Type actualType = argumentsTypes.get(i);\n+            ResolvedType expectedType = method.getParam(i).getType();\n+            ResolvedType actualType = argumentsTypes.get(i);\n             if ((expectedType.isTypeVariable() && !(expectedType.isWildcard())) && expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) ||\n-                    (method.getParam(i).isVariadic() && new ArrayType(expectedType).isAssignableBy(actualType));\n+                    (method.getParam(i).isVariadic() && new ResolvedArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                         expectedType.asReferenceType(),\n                         actualType.asReferenceType(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n-                List<TypeParameterDeclaration> typeParameters = method.getTypeParameters();\n+                List<ResolvedTypeParameterDeclaration> typeParameters = method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n-                for (TypeParameterDeclaration tp : typeParameters) {\n+                for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                         needForWildCardTolerance = true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() && i == method.getNumberOfParams() - 1) {\n-                        if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n+                        if (new ResolvedArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[method-MethodDeclaration, name-String, argumentsTypes-List<Type>, typeSolver-TypeSolver, withWildcardTolerance-boolean]",
						"newValue": "[method-ResolvedMethodDeclaration, name-String, argumentsTypes-List<ResolvedType>, typeSolver-TypeSolver, withWildcardTolerance-boolean]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "correcting module core to use new classes\n",
					"commitDate": "2017-09-29, 12:07 AM",
					"commitName": "e15d5a8aa84a34917e4ef47135dfc62e58ea7650",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2017-09-28, 2:36 PM",
					"commitNameOld": "5d8d0cb7947efcf2282f7d056302dd905f348532",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.4,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,73 +1,73 @@\n-    private static boolean isApplicable(MethodDeclaration method, String name, List<Type> argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n+    private static boolean isApplicable(ResolvedMethodDeclaration method, String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos = method.getNumberOfParams() - 1;\n             if (method.getNumberOfParams() == argumentsTypes.size()) {\n                 // check if the last value is directly assignable as an array\n-                Type expectedType = method.getLastParam().getType();\n-                Type actualType = argumentsTypes.get(pos);\n+                ResolvedType expectedType = method.getLastParam().getType();\n+                ResolvedType actualType = argumentsTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n-                    for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n+                    for (ResolvedTypeParameterDeclaration tp : method.getTypeParameters()) {\n                         expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                             argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                         } else {\n                             argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 if (pos > argumentsTypes.size()) {\n                   return false;\n                 }\n                 argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNumberOfParams() != argumentsTypes.size()) {\n             return false;\n         }\n-        Map<String, Type> matchedParameters = new HashMap<>();\n+        Map<String, ResolvedType> matchedParameters = new HashMap<>();\n         boolean needForWildCardTolerance = false;\n         for (int i = 0; i < method.getNumberOfParams(); i++) {\n-            Type expectedType = method.getParam(i).getType();\n-            Type actualType = argumentsTypes.get(i);\n+            ResolvedType expectedType = method.getParam(i).getType();\n+            ResolvedType actualType = argumentsTypes.get(i);\n             if ((expectedType.isTypeVariable() && !(expectedType.isWildcard())) && expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) ||\n-                    (method.getParam(i).isVariadic() && new ArrayType(expectedType).isAssignableBy(actualType));\n+                    (method.getParam(i).isVariadic() && new ResolvedArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                         expectedType.asReferenceType(),\n                         actualType.asReferenceType(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n-                List<TypeParameterDeclaration> typeParameters = method.getTypeParameters();\n+                List<ResolvedTypeParameterDeclaration> typeParameters = method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n-                for (TypeParameterDeclaration tp : typeParameters) {\n+                for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                         needForWildCardTolerance = true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() && i == method.getNumberOfParams() - 1) {\n-                        if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n+                        if (new ResolvedArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"c990d23490f5c4ac4322119b03d5951b63eef055": {
			"type": "Ybodychange",
			"commitMessage": "loads of changes to support our code",
			"commitDate": "2016-12-13, 6:10 AM",
			"commitName": "c990d23490f5c4ac4322119b03d5951b63eef055",
			"commitAuthor": "Fred Lefévère-Laoide",
			"commitDateOld": "2016-11-06, 1:42 AM",
			"commitNameOld": "a7803cf050435e3162f7fdde83fb9692a891e92e",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 37.19,
			"commitsBetweenForRepo": 37,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,70 +1,73 @@\n     private static boolean isApplicable(MethodDeclaration method, String name, List<Type> argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos = method.getNumberOfParams() - 1;\n             if (method.getNumberOfParams() == argumentsTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 Type expectedType = method.getLastParam().getType();\n                 Type actualType = argumentsTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                         expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                             argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                         } else {\n                             argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n+                if (pos > argumentsTypes.size()) {\n+                  return false;\n+                }\n                 argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNumberOfParams() != argumentsTypes.size()) {\n             return false;\n         }\n         Map<String, Type> matchedParameters = new HashMap<>();\n         boolean needForWildCardTolerance = false;\n         for (int i = 0; i < method.getNumberOfParams(); i++) {\n             Type expectedType = method.getParam(i).getType();\n             Type actualType = argumentsTypes.get(i);\n             if ((expectedType.isTypeVariable() && !(expectedType.isWildcard())) && expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() && new ArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                         expectedType.asReferenceType(),\n                         actualType.asReferenceType(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List<TypeParameterDeclaration> typeParameters = method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameterDeclaration tp : typeParameters) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                         needForWildCardTolerance = true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() && i == method.getNumberOfParams() - 1) {\n                         if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b32947e8c85bc21fe533173f50d4a0a91036fdaf": {
			"type": "Ybodychange",
			"commitMessage": "adding more comments in model declarations\n",
			"commitDate": "2016-10-21, 12:55 AM",
			"commitName": "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-20, 2:06 PM",
			"commitNameOld": "1e7780e554428a10c73de88ca64e5933b2291593",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.45,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,70 +1,70 @@\n     private static boolean isApplicable(MethodDeclaration method, String name, List<Type> argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n-            int pos = method.getNoParams() - 1;\n-            if (method.getNoParams() == argumentsTypes.size()) {\n+            int pos = method.getNumberOfParams() - 1;\n+            if (method.getNumberOfParams() == argumentsTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 Type expectedType = method.getLastParam().getType();\n                 Type actualType = argumentsTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                         expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                             argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                         } else {\n                             argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n-        if (method.getNoParams() != argumentsTypes.size()) {\n+        if (method.getNumberOfParams() != argumentsTypes.size()) {\n             return false;\n         }\n         Map<String, Type> matchedParameters = new HashMap<>();\n         boolean needForWildCardTolerance = false;\n-        for (int i = 0; i < method.getNoParams(); i++) {\n+        for (int i = 0; i < method.getNumberOfParams(); i++) {\n             Type expectedType = method.getParam(i).getType();\n             Type actualType = argumentsTypes.get(i);\n             if ((expectedType.isTypeVariable() && !(expectedType.isWildcard())) && expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() && new ArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                         expectedType.asReferenceType(),\n                         actualType.asReferenceType(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List<TypeParameterDeclaration> typeParameters = method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameterDeclaration tp : typeParameters) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                         needForWildCardTolerance = true;\n                         continue;\n                     }\n-                    if (method.hasVariadicParameter() && i == method.getNoParams() - 1) {\n+                    if (method.hasVariadicParameter() && i == method.getNumberOfParams() - 1) {\n                         if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9c53c2cbc607ea694438ade8630be0c155a33162": {
			"type": "Yfilerename",
			"commitMessage": "renamed packages to com.github.javapaerser\n",
			"commitDate": "2016-10-20, 12:39 AM",
			"commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-20, 12:32 AM",
			"commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
				"newPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java"
			}
		},
		"88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "issue90: using the right terminology for parameters and arguments\n",
			"commitDate": "2016-10-17, 11:25 AM",
			"commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
			"commitAuthor": "Federico Tomassetti",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "issue90: using the right terminology for parameters and arguments\n",
					"commitDate": "2016-10-17, 11:25 AM",
					"commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-16, 10:13 AM",
					"commitNameOld": "656bb37a1dba87d61d24e69f2346f35dbc73d81d",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 1.05,
					"commitsBetweenForRepo": 7,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,70 +1,70 @@\n-    private static boolean isApplicable(MethodDeclaration method, String name, List<Type> paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n+    private static boolean isApplicable(MethodDeclaration method, String name, List<Type> argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos = method.getNoParams() - 1;\n-            if (method.getNoParams() == paramTypes.size()) {\n+            if (method.getNoParams() == argumentsTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 Type expectedType = method.getLastParam().getType();\n-                Type actualType = paramTypes.get(pos);\n+                Type actualType = argumentsTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                         expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n-                            paramTypes.set(pos, actualType.asArrayType().getComponentType());\n+                            argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                         } else {\n-                            paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+                            argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n-                paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+                argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n-        if (method.getNoParams() != paramTypes.size()) {\n+        if (method.getNoParams() != argumentsTypes.size()) {\n             return false;\n         }\n         Map<String, Type> matchedParameters = new HashMap<>();\n         boolean needForWildCardTolerance = false;\n         for (int i = 0; i < method.getNoParams(); i++) {\n             Type expectedType = method.getParam(i).getType();\n-            Type actualType = paramTypes.get(i);\n+            Type actualType = argumentsTypes.get(i);\n             if ((expectedType.isTypeVariable() && !(expectedType.isWildcard())) && expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() && new ArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                         expectedType.asReferenceType(),\n                         actualType.asReferenceType(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List<TypeParameterDeclaration> typeParameters = method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameterDeclaration tp : typeParameters) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                         needForWildCardTolerance = true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() && i == method.getNoParams() -1) {\n                         if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[method-MethodDeclaration, name-String, paramTypes-List<Type>, typeSolver-TypeSolver, withWildcardTolerance-boolean]",
						"newValue": "[method-MethodDeclaration, name-String, argumentsTypes-List<Type>, typeSolver-TypeSolver, withWildcardTolerance-boolean]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "issue90: using the right terminology for parameters and arguments\n",
					"commitDate": "2016-10-17, 11:25 AM",
					"commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-16, 10:13 AM",
					"commitNameOld": "656bb37a1dba87d61d24e69f2346f35dbc73d81d",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 1.05,
					"commitsBetweenForRepo": 7,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,70 +1,70 @@\n-    private static boolean isApplicable(MethodDeclaration method, String name, List<Type> paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n+    private static boolean isApplicable(MethodDeclaration method, String name, List<Type> argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos = method.getNoParams() - 1;\n-            if (method.getNoParams() == paramTypes.size()) {\n+            if (method.getNoParams() == argumentsTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 Type expectedType = method.getLastParam().getType();\n-                Type actualType = paramTypes.get(pos);\n+                Type actualType = argumentsTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                         expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n-                            paramTypes.set(pos, actualType.asArrayType().getComponentType());\n+                            argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                         } else {\n-                            paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+                            argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n-                paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+                argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n-        if (method.getNoParams() != paramTypes.size()) {\n+        if (method.getNoParams() != argumentsTypes.size()) {\n             return false;\n         }\n         Map<String, Type> matchedParameters = new HashMap<>();\n         boolean needForWildCardTolerance = false;\n         for (int i = 0; i < method.getNoParams(); i++) {\n             Type expectedType = method.getParam(i).getType();\n-            Type actualType = paramTypes.get(i);\n+            Type actualType = argumentsTypes.get(i);\n             if ((expectedType.isTypeVariable() && !(expectedType.isWildcard())) && expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() && new ArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                         expectedType.asReferenceType(),\n                         actualType.asReferenceType(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List<TypeParameterDeclaration> typeParameters = method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameterDeclaration tp : typeParameters) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                         needForWildCardTolerance = true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() && i == method.getNoParams() -1) {\n                         if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"69e724f5a168e148ea4479c872cfbf656fce8acc": {
			"type": "Ybodychange",
			"commitMessage": "improvement on verifying method compatibility\n",
			"commitDate": "2016-10-15, 6:29 AM",
			"commitName": "69e724f5a168e148ea4479c872cfbf656fce8acc",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-14, 2:57 PM",
			"commitNameOld": "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.65,
			"commitsBetweenForRepo": 11,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,70 +1,70 @@\n     private static boolean isApplicable(MethodDeclaration method, String name, List<Type> paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos = method.getNoParams() - 1;\n             if (method.getNoParams() == paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 Type expectedType = method.getLastParam().getType();\n                 Type actualType = paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                         expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                             paramTypes.set(pos, actualType.asArrayType().getComponentType());\n                         } else {\n                             paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         Map<String, Type> matchedParameters = new HashMap<>();\n         boolean needForWildCardTolerance = false;\n         for (int i = 0; i < method.getNoParams(); i++) {\n             Type expectedType = method.getParam(i).getType();\n             Type actualType = paramTypes.get(i);\n-            if (expectedType.isTypeVariable() && expectedType.asTypeParameter().declaredOnMethod()) {\n+            if ((expectedType.isTypeVariable() && !(expectedType.isWildcard())) && expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() && new ArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                         expectedType.asReferenceType(),\n                         actualType.asReferenceType(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List<TypeParameterDeclaration> typeParameters = method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameterDeclaration tp : typeParameters) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                         needForWildCardTolerance = true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() && i == method.getNoParams() -1) {\n                         if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"051dbd94c17c4f142d3fe9e8fbd03c29d09ace54": {
			"type": "Ybodychange",
			"commitMessage": "add test JavaParserClassDeclarationTest.testGetSuperclassWithTypeParameters\n",
			"commitDate": "2016-10-14, 2:57 PM",
			"commitName": "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-14, 11:24 AM",
			"commitNameOld": "70f3e66c944670a818922f101162226ef604b263",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.15,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,70 +1,70 @@\n     private static boolean isApplicable(MethodDeclaration method, String name, List<Type> paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos = method.getNoParams() - 1;\n             if (method.getNoParams() == paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 Type expectedType = method.getLastParam().getType();\n                 Type actualType = paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                         expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n-                        if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n-                            paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n+                        if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n+                            paramTypes.set(pos, actualType.asArrayType().getComponentType());\n                         } else {\n                             paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         Map<String, Type> matchedParameters = new HashMap<>();\n         boolean needForWildCardTolerance = false;\n         for (int i = 0; i < method.getNoParams(); i++) {\n             Type expectedType = method.getParam(i).getType();\n             Type actualType = paramTypes.get(i);\n             if (expectedType.isTypeVariable() && expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() && new ArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n-                        expectedType.asReferenceTypeUsage(),\n-                        actualType.asReferenceTypeUsage(),\n+                        expectedType.asReferenceType(),\n+                        actualType.asReferenceType(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List<TypeParameterDeclaration> typeParameters = method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameterDeclaration tp : typeParameters) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                         needForWildCardTolerance = true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() && i == method.getNoParams() -1) {\n                         if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ecc78c8b480ceb41019f764c983aaa69c2dabfe3": {
			"type": "Ybodychange",
			"commitMessage": "reorganize packages in model\n",
			"commitDate": "2016-10-14, 10:51 AM",
			"commitName": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-14, 12:36 AM",
			"commitNameOld": "8d234965b572759181da7787fead07b225e9e5ca",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.43,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,70 +1,70 @@\n     private static boolean isApplicable(MethodDeclaration method, String name, List<Type> paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos = method.getNoParams() - 1;\n             if (method.getNoParams() == paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 Type expectedType = method.getLastParam().getType();\n                 Type actualType = paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n-                    for (TypeParameter tp : method.getTypeParameters()) {\n+                    for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                         expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                             paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                         } else {\n                             paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         Map<String, Type> matchedParameters = new HashMap<>();\n         boolean needForWildCardTolerance = false;\n         for (int i = 0; i < method.getNoParams(); i++) {\n             Type expectedType = method.getParam(i).getType();\n             Type actualType = paramTypes.get(i);\n             if (expectedType.isTypeVariable() && expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() && new ArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n-                List<TypeParameter> typeParameters = method.getTypeParameters();\n+                List<TypeParameterDeclaration> typeParameters = method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n-                for (TypeParameter tp : typeParameters) {\n+                for (TypeParameterDeclaration tp : typeParameters) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                         needForWildCardTolerance = true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() && i == method.getNoParams() -1) {\n                         if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"82eb44707b620803d424188a1eb8708fcaf093cb": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "rename TypeUsage into Type\n",
			"commitDate": "2016-10-13, 2:11 PM",
			"commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
			"commitAuthor": "Federico Tomassetti",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "rename TypeUsage into Type\n",
					"commitDate": "2016-10-13, 2:11 PM",
					"commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-13, 1:29 PM",
					"commitNameOld": "6e654694b8d141fd5503b46f9e77b8763cfa9a81",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.03,
					"commitsBetweenForRepo": 5,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,70 +1,70 @@\n-    private static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n+    private static boolean isApplicable(MethodDeclaration method, String name, List<Type> paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos = method.getNoParams() - 1;\n             if (method.getNoParams() == paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n-                TypeUsage expectedType = method.getLastParam().getType();\n-                TypeUsage actualType = paramTypes.get(pos);\n+                Type expectedType = method.getLastParam().getType();\n+                Type actualType = paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameter tp : method.getTypeParameters()) {\n                         expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                             paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                         } else {\n                             paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n-        Map<String, TypeUsage> matchedParameters = new HashMap<>();\n+        Map<String, Type> matchedParameters = new HashMap<>();\n         boolean needForWildCardTolerance = false;\n         for (int i = 0; i < method.getNoParams(); i++) {\n-            TypeUsage expectedType = method.getParam(i).getType();\n-            TypeUsage actualType = paramTypes.get(i);\n+            Type expectedType = method.getParam(i).getType();\n+            Type actualType = paramTypes.get(i);\n             if (expectedType.isTypeVariable() && expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) ||\n-                    (method.getParam(i).isVariadic() && new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n+                    (method.getParam(i).isVariadic() && new ArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List<TypeParameter> typeParameters = method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameter tp : typeParameters) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                         needForWildCardTolerance = true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() && i == method.getNoParams() -1) {\n-                        if (new ArrayTypeUsage(expectedType).isAssignableBy(actualType)) {\n+                        if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[method-MethodDeclaration, name-String, paramTypes-List<TypeUsage>, typeSolver-TypeSolver, withWildcardTolerance-boolean]",
						"newValue": "[method-MethodDeclaration, name-String, paramTypes-List<Type>, typeSolver-TypeSolver, withWildcardTolerance-boolean]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "rename TypeUsage into Type\n",
					"commitDate": "2016-10-13, 2:11 PM",
					"commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-13, 1:29 PM",
					"commitNameOld": "6e654694b8d141fd5503b46f9e77b8763cfa9a81",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.03,
					"commitsBetweenForRepo": 5,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,70 +1,70 @@\n-    private static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n+    private static boolean isApplicable(MethodDeclaration method, String name, List<Type> paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos = method.getNoParams() - 1;\n             if (method.getNoParams() == paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n-                TypeUsage expectedType = method.getLastParam().getType();\n-                TypeUsage actualType = paramTypes.get(pos);\n+                Type expectedType = method.getLastParam().getType();\n+                Type actualType = paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameter tp : method.getTypeParameters()) {\n                         expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                             paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                         } else {\n                             paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n-        Map<String, TypeUsage> matchedParameters = new HashMap<>();\n+        Map<String, Type> matchedParameters = new HashMap<>();\n         boolean needForWildCardTolerance = false;\n         for (int i = 0; i < method.getNoParams(); i++) {\n-            TypeUsage expectedType = method.getParam(i).getType();\n-            TypeUsage actualType = paramTypes.get(i);\n+            Type expectedType = method.getParam(i).getType();\n+            Type actualType = paramTypes.get(i);\n             if (expectedType.isTypeVariable() && expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) ||\n-                    (method.getParam(i).isVariadic() && new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n+                    (method.getParam(i).isVariadic() && new ArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List<TypeParameter> typeParameters = method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameter tp : typeParameters) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                         needForWildCardTolerance = true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() && i == method.getNoParams() -1) {\n-                        if (new ArrayTypeUsage(expectedType).isAssignableBy(actualType)) {\n+                        if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"6e654694b8d141fd5503b46f9e77b8763cfa9a81": {
			"type": "Ybodychange",
			"commitMessage": "issue80: resolve conflicts between variadic and not variadic alternatives\n",
			"commitDate": "2016-10-13, 1:29 PM",
			"commitName": "6e654694b8d141fd5503b46f9e77b8763cfa9a81",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-13, 10:07 AM",
			"commitNameOld": "b20f28d6034a54108c056947c631c360fa079138",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.14,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,66 +1,70 @@\n     private static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos = method.getNoParams() - 1;\n             if (method.getNoParams() == paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 TypeUsage expectedType = method.getLastParam().getType();\n                 TypeUsage actualType = paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameter tp : method.getTypeParameters()) {\n                         expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                             paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                         } else {\n                             paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         Map<String, TypeUsage> matchedParameters = new HashMap<>();\n         boolean needForWildCardTolerance = false;\n         for (int i = 0; i < method.getNoParams(); i++) {\n             TypeUsage expectedType = method.getParam(i).getType();\n             TypeUsage actualType = paramTypes.get(i);\n+            if (expectedType.isTypeVariable() && expectedType.asTypeParameter().declaredOnMethod()) {\n+                matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n+                continue;\n+            }\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() && new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List<TypeParameter> typeParameters = method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameter tp : typeParameters) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                         needForWildCardTolerance = true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() && i == method.getNoParams() -1) {\n                         if (new ArrayTypeUsage(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b20f28d6034a54108c056947c631c360fa079138": {
			"type": "Ybodychange",
			"commitMessage": "issue80: other fix for variadic arguments\n",
			"commitDate": "2016-10-13, 10:07 AM",
			"commitName": "b20f28d6034a54108c056947c631c360fa079138",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-13, 9:26 AM",
			"commitNameOld": "c48864ccaea00039c2f6a8390d21cffd3fbde054",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,57 +1,66 @@\n     private static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos = method.getNoParams() - 1;\n             if (method.getNoParams() == paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 TypeUsage expectedType = method.getLastParam().getType();\n                 TypeUsage actualType = paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameter tp : method.getTypeParameters()) {\n                         expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n-                        paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+                        if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n+                            paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n+                        } else {\n+                            paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+                        }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         Map<String, TypeUsage> matchedParameters = new HashMap<>();\n         boolean needForWildCardTolerance = false;\n         for (int i = 0; i < method.getNoParams(); i++) {\n             TypeUsage expectedType = method.getParam(i).getType();\n             TypeUsage actualType = paramTypes.get(i);\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() && new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List<TypeParameter> typeParameters = method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameter tp : typeParameters) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n                         needForWildCardTolerance = true;\n                         continue;\n                     }\n+                    if (method.hasVariadicParameter() && i == method.getNoParams() -1) {\n+                        if (new ArrayTypeUsage(expectedType).isAssignableBy(actualType)) {\n+                            continue;\n+                        }\n+                    }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c48864ccaea00039c2f6a8390d21cffd3fbde054": {
			"type": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
			"commitMessage": "issue80: usage of an extremely dirty trick for matching method calls involving wildcards\n",
			"commitDate": "2016-10-13, 9:26 AM",
			"commitName": "c48864ccaea00039c2f6a8390d21cffd3fbde054",
			"commitAuthor": "Federico Tomassetti",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "issue80: usage of an extremely dirty trick for matching method calls involving wildcards\n",
					"commitDate": "2016-10-13, 9:26 AM",
					"commitName": "c48864ccaea00039c2f6a8390d21cffd3fbde054",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-13, 4:43 AM",
					"commitNameOld": "e3e4b88ee821fdcec76aa3c940cb4b4f466bc2cd",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.2,
					"commitsBetweenForRepo": 9,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,52 +1,57 @@\n-    public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n+    private static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos = method.getNoParams() - 1;\n             if (method.getNoParams() == paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 TypeUsage expectedType = method.getLastParam().getType();\n                 TypeUsage actualType = paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameter tp : method.getTypeParameters()) {\n                         expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         Map<String, TypeUsage> matchedParameters = new HashMap<>();\n+        boolean needForWildCardTolerance = false;\n         for (int i = 0; i < method.getNoParams(); i++) {\n             TypeUsage expectedType = method.getParam(i).getType();\n             TypeUsage actualType = paramTypes.get(i);\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() && new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List<TypeParameter> typeParameters = method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameter tp : typeParameters) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n+                    if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n+                        needForWildCardTolerance = true;\n+                        continue;\n+                    }\n                     return false;\n                 }\n             }\n         }\n-        return true;\n+        return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[method-MethodDeclaration, name-String, paramTypes-List<TypeUsage>, typeSolver-TypeSolver]",
						"newValue": "[method-MethodDeclaration, name-String, paramTypes-List<TypeUsage>, typeSolver-TypeSolver, withWildcardTolerance-boolean]"
					}
				},
				{
					"type": "Ymodifierchange",
					"commitMessage": "issue80: usage of an extremely dirty trick for matching method calls involving wildcards\n",
					"commitDate": "2016-10-13, 9:26 AM",
					"commitName": "c48864ccaea00039c2f6a8390d21cffd3fbde054",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-13, 4:43 AM",
					"commitNameOld": "e3e4b88ee821fdcec76aa3c940cb4b4f466bc2cd",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.2,
					"commitsBetweenForRepo": 9,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,52 +1,57 @@\n-    public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n+    private static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos = method.getNoParams() - 1;\n             if (method.getNoParams() == paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 TypeUsage expectedType = method.getLastParam().getType();\n                 TypeUsage actualType = paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameter tp : method.getTypeParameters()) {\n                         expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         Map<String, TypeUsage> matchedParameters = new HashMap<>();\n+        boolean needForWildCardTolerance = false;\n         for (int i = 0; i < method.getNoParams(); i++) {\n             TypeUsage expectedType = method.getParam(i).getType();\n             TypeUsage actualType = paramTypes.get(i);\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() && new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List<TypeParameter> typeParameters = method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameter tp : typeParameters) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n+                    if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n+                        needForWildCardTolerance = true;\n+                        continue;\n+                    }\n                     return false;\n                 }\n             }\n         }\n-        return true;\n+        return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[public, static]",
						"newValue": "[private, static]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "issue80: usage of an extremely dirty trick for matching method calls involving wildcards\n",
					"commitDate": "2016-10-13, 9:26 AM",
					"commitName": "c48864ccaea00039c2f6a8390d21cffd3fbde054",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-13, 4:43 AM",
					"commitNameOld": "e3e4b88ee821fdcec76aa3c940cb4b4f466bc2cd",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.2,
					"commitsBetweenForRepo": 9,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,52 +1,57 @@\n-    public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n+    private static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos = method.getNoParams() - 1;\n             if (method.getNoParams() == paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 TypeUsage expectedType = method.getLastParam().getType();\n                 TypeUsage actualType = paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameter tp : method.getTypeParameters()) {\n                         expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         Map<String, TypeUsage> matchedParameters = new HashMap<>();\n+        boolean needForWildCardTolerance = false;\n         for (int i = 0; i < method.getNoParams(); i++) {\n             TypeUsage expectedType = method.getParam(i).getType();\n             TypeUsage actualType = paramTypes.get(i);\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() && new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List<TypeParameter> typeParameters = method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameter tp : typeParameters) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n+                    if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {\n+                        needForWildCardTolerance = true;\n+                        continue;\n+                    }\n                     return false;\n                 }\n             }\n         }\n-        return true;\n+        return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"e3e4b88ee821fdcec76aa3c940cb4b4f466bc2cd": {
			"type": "Ybodychange",
			"commitMessage": "issue80: improving support for variadic arguments\n",
			"commitDate": "2016-10-13, 4:43 AM",
			"commitName": "e3e4b88ee821fdcec76aa3c940cb4b4f466bc2cd",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-11, 2:53 PM",
			"commitNameOld": "37576d078d11264fec1a28bbffea400003160b6b",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 1.58,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,51 +1,52 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos = method.getNoParams() - 1;\n             if (method.getNoParams() == paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 TypeUsage expectedType = method.getLastParam().getType();\n                 TypeUsage actualType = paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameter tp : method.getTypeParameters()) {\n                         expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         Map<String, TypeUsage> matchedParameters = new HashMap<>();\n         for (int i = 0; i < method.getNoParams(); i++) {\n             TypeUsage expectedType = method.getParam(i).getType();\n             TypeUsage actualType = paramTypes.get(i);\n-            boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType);\n+            boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) ||\n+                    (method.getParam(i).isVariadic() && new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List<TypeParameter> typeParameters = method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameter tp : typeParameters) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     return false;\n                 }\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"84afc7be2fabd511eccc69e29fca9c4238c9469e": {
			"type": "Ybodychange",
			"commitMessage": "unused code removed\n",
			"commitDate": "2016-10-05, 7:04 AM",
			"commitName": "84afc7be2fabd511eccc69e29fca9c4238c9469e",
			"commitAuthor": "rpau",
			"commitDateOld": "2016-10-03, 7:24 AM",
			"commitNameOld": "e2cc24a4f5a54a058c1d9ba971b7c8aa0a445601",
			"commitAuthorOld": "malte_langkabel",
			"daysBetweenCommits": 1.99,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,52 +1,51 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n-        List<TypeUsage> originalParamTypes = paramTypes;\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos = method.getNoParams() - 1;\n             if (method.getNoParams() == paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 TypeUsage expectedType = method.getLastParam().getType();\n                 TypeUsage actualType = paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameter tp : method.getTypeParameters()) {\n                         expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         Map<String, TypeUsage> matchedParameters = new HashMap<>();\n         for (int i = 0; i < method.getNoParams(); i++) {\n             TypeUsage expectedType = method.getParam(i).getType();\n             TypeUsage actualType = paramTypes.get(i);\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType);\n             if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List<TypeParameter> typeParameters = method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameter tp : typeParameters) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     return false;\n                 }\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e2cc24a4f5a54a058c1d9ba971b7c8aa0a445601": {
			"type": "Ybodychange",
			"commitMessage": "Regard type parameter of method's declaring type when testing if method is applicable. Solves issue #67.\n",
			"commitDate": "2016-10-03, 7:24 AM",
			"commitName": "e2cc24a4f5a54a058c1d9ba971b7c8aa0a445601",
			"commitAuthor": "malte_langkabel",
			"commitDateOld": "2016-09-28, 5:58 AM",
			"commitNameOld": "325c0dcdee2e0fcfe28f64abec9e39fc9d9adba5",
			"commitAuthorOld": "malte_langkabel",
			"daysBetweenCommits": 5.06,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,50 +1,52 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n         List<TypeUsage> originalParamTypes = paramTypes;\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos = method.getNoParams() - 1;\n             if (method.getNoParams() == paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 TypeUsage expectedType = method.getLastParam().getType();\n                 TypeUsage actualType = paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameter tp : method.getTypeParameters()) {\n                         expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         Map<String, TypeUsage> matchedParameters = new HashMap<>();\n         for (int i = 0; i < method.getNoParams(); i++) {\n             TypeUsage expectedType = method.getParam(i).getType();\n             TypeUsage actualType = paramTypes.get(i);\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType);\n             if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n-                for (TypeParameter tp : method.getTypeParameters()) {\n+                List<TypeParameter> typeParameters = method.getTypeParameters();\n+                typeParameters.addAll(method.declaringType().getTypeParameters());\n+                for (TypeParameter tp : typeParameters) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     return false;\n                 }\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8907128c87954825abed135e781f272f67648f95": {
			"type": "Yfilerename",
			"commitMessage": "modules: create logic module\n",
			"commitDate": "2015-11-20, 3:00 PM",
			"commitName": "8907128c87954825abed135e781f272f67648f95",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-20, 10:31 AM",
			"commitNameOld": "01dd50e954e60eb6c50ddbff8937e4186c8bb587",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.19,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/logic/MethodResolutionLogic.java",
				"newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java"
			}
		},
		"ead147279ca0b84d2f479a714943b20cd689e7c7": {
			"type": "Ybodychange",
			"commitMessage": "issue7: consider type parameters and varargs combinations\n",
			"commitDate": "2015-11-20, 9:04 AM",
			"commitName": "ead147279ca0b84d2f479a714943b20cd689e7c7",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-14, 4:41 AM",
			"commitNameOld": "454904fe0cb3b15aa506e3f5fa8f0c9fb1313f61",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 6.18,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,31 +1,50 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n+        List<TypeUsage> originalParamTypes = paramTypes;\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n-        // TODO Consider varargs\n+        if (method.hasVariadicParameter()) {\n+            int pos = method.getNoParams() - 1;\n+            if (method.getNoParams() == paramTypes.size()) {\n+                // check if the last value is directly assignable as an array\n+                TypeUsage expectedType = method.getLastParam().getType();\n+                TypeUsage actualType = paramTypes.get(pos);\n+                if (!expectedType.isAssignableBy(actualType)) {\n+                    for (TypeParameter tp : method.getTypeParameters()) {\n+                        expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n+                    }\n+                    if (!expectedType.isAssignableBy(actualType)) {\n+                        paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+                    }\n+                } // else it is already assignable, nothing to do\n+            } else {\n+                paramTypes = groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+            }\n+        }\n+\n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         Map<String, TypeUsage> matchedParameters = new HashMap<>();\n         for (int i = 0; i < method.getNoParams(); i++) {\n             TypeUsage expectedType = method.getParam(i).getType();\n             TypeUsage actualType = paramTypes.get(i);\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType);\n             if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     return false;\n                 }\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f4b07b1a2deac6d1b562424ac2380b92cec77a90": {
			"type": "Yfilerename",
			"commitMessage": "modules: organization in modules\n",
			"commitDate": "2015-11-13, 2:12 AM",
			"commitName": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-13, 1:53 AM",
			"commitNameOld": "d96a8ff67d857a2988488f1fc31202f0e2ed8061",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/me/tomassetti/symbolsolver/logic/MethodResolutionLogic.java",
				"newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/logic/MethodResolutionLogic.java"
			}
		},
		"9506a1844d5076b4edcc2b9a5bc375acf7e95c35": {
			"type": "Yfilerename",
			"commitMessage": "creating AbstractClassDeclaration\n",
			"commitDate": "2015-11-02, 12:55 PM",
			"commitName": "9506a1844d5076b4edcc2b9a5bc375acf7e95c35",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-02, 12:48 PM",
			"commitNameOld": "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
				"newPath": "src/main/java/me/tomassetti/symbolsolver/logic/MethodResolutionLogic.java"
			}
		},
		"39477e7f9375d6a539eb0ddc69eb69d986b2a8c8": {
			"type": "Ybodychange",
			"commitMessage": "removing TypeSolver from model.declarations\n",
			"commitDate": "2015-11-02, 12:48 PM",
			"commitName": "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-01, 6:35 AM",
			"commitNameOld": "52869e6fb17d3b13f60dea0064b90a81307392b4",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 1.26,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,31 +1,31 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         Map<String, TypeUsage> matchedParameters = new HashMap<>();\n         for (int i=0; i<method.getNoParams(); i++) {\n-            TypeUsage expectedType = method.getParam(i).getType(typeSolver);\n+            TypeUsage expectedType = method.getParam(i).getType();\n             TypeUsage actualType = paramTypes.get(i);\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType);\n             if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     return false;\n                 }\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3337bf584f7ef47f4f56b81743ca0d83930763bf": {
			"type": "Ybodychange",
			"commitMessage": "wip\n",
			"commitDate": "2015-11-01, 4:02 AM",
			"commitName": "3337bf584f7ef47f4f56b81743ca0d83930763bf",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-10-31, 5:08 PM",
			"commitNameOld": "0b419e87200878fe13db395a415efc4d1338cef2",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.5,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,24 +1,31 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n+        Map<String, TypeUsage> matchedParameters = new HashMap<>();\n         for (int i=0; i<method.getNoParams(); i++) {\n             TypeUsage expectedType = method.getParam(i).getType(typeSolver);\n             TypeUsage actualType = paramTypes.get(i);\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType);\n+            if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {\n+                isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n+                        expectedType.asReferenceTypeUsage(),\n+                        actualType.asReferenceTypeUsage(),\n+                        matchedParameters);\n+            }\n             if (!isAssignableWithoutSubstitution) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     return false;\n                 }\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0b419e87200878fe13db395a415efc4d1338cef2": {
			"type": "Ybodychange",
			"commitMessage": "wip\n",
			"commitDate": "2015-10-31, 5:08 PM",
			"commitName": "0b419e87200878fe13db395a415efc4d1338cef2",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-10-31, 3:22 AM",
			"commitNameOld": "960364fad3fc2ead6113d4c5d4b7d9ebf23e2f9a",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.57,
			"commitsBetweenForRepo": 11,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,23 +1,24 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         for (int i=0; i<method.getNoParams(); i++) {\n             TypeUsage expectedType = method.getParam(i).getType(typeSolver);\n-            boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(paramTypes.get(i));\n+            TypeUsage actualType = paramTypes.get(i);\n+            boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType);\n             if (!isAssignableWithoutSubstitution) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n-                if (!expectedType.isAssignableBy(paramTypes.get(i))) {\n+                if (!expectedType.isAssignableBy(actualType)) {\n                     return false;\n                 }\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"adb02497ed443e836ae552e20bcb11ab8c1ab623": {
			"type": "Ybodychange",
			"commitMessage": "TypeUsage: clean up completed\n",
			"commitDate": "2015-10-30, 4:51 PM",
			"commitName": "adb02497ed443e836ae552e20bcb11ab8c1ab623",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-10-30, 4:37 PM",
			"commitNameOld": "0e81f51c40996b42cb262dc2397126cee8f60965",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,23 +1,23 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         for (int i=0; i<method.getNoParams(); i++) {\n             TypeUsage expectedType = method.getParam(i).getType(typeSolver);\n-            boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(paramTypes.get(i), typeSolver);\n+            boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(paramTypes.get(i));\n             if (!isAssignableWithoutSubstitution) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n                     expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n-                if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n+                if (!expectedType.isAssignableBy(paramTypes.get(i))) {\n                     return false;\n                 }\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b36f33050149a62a5b3c8c7451ae93f736715029": {
			"type": "Yfilerename",
			"commitMessage": "reorganize packages\n",
			"commitDate": "2015-10-30, 3:53 AM",
			"commitName": "b36f33050149a62a5b3c8c7451ae93f736715029",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-10-30, 3:29 AM",
			"commitNameOld": "90999800bdc73eacb5ef25dafcd36c8518af3072",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/me/tomassetti/symbolsolver/model/MethodResolutionLogic.java",
				"newPath": "src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java"
			}
		},
		"eec165d9e3ef0ab1d93f69a231964984a3379762": {
			"type": "Ybodychange",
			"commitMessage": "consider array modifiers\n",
			"commitDate": "2015-08-25, 3:57 AM",
			"commitName": "eec165d9e3ef0ab1d93f69a231964984a3379762",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-25, 1:22 AM",
			"commitNameOld": "558fc9b4f808d718b9b266071078752ba68d4203",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.11,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,23 +1,23 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         for (int i=0; i<method.getNoParams(); i++) {\n             TypeUsage expectedType = method.getParam(i).getType(typeSolver);\n             boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(paramTypes.get(i), typeSolver);\n             if (!isAssignableWithoutSubstitution) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n-                    expectedType = replaceTypeParam(expectedType, tp);\n+                    expectedType = replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n                     return false;\n                 }\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"558fc9b4f808d718b9b266071078752ba68d4203": {
			"type": "Ybodychange",
			"commitMessage": "improve method type parameter substitution\n",
			"commitDate": "2015-08-25, 1:22 AM",
			"commitName": "558fc9b4f808d718b9b266071078752ba68d4203",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-24, 3:05 PM",
			"commitNameOld": "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.43,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,20 +1,23 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         for (int i=0; i<method.getNoParams(); i++) {\n             TypeUsage expectedType = method.getParam(i).getType(typeSolver);\n-            for (TypeParameter tp : method.getTypeParameters()) {\n-                expectedType = replaceTypeParam(expectedType, tp);\n-            }\n+            boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(paramTypes.get(i), typeSolver);\n+            if (!isAssignableWithoutSubstitution) {\n+                for (TypeParameter tp : method.getTypeParameters()) {\n+                    expectedType = replaceTypeParam(expectedType, tp);\n+                }\n \n-            if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)){\n-                return false;\n+                if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n+                    return false;\n+                }\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"640eb2479a4e05bb8ee0d95f74172be9dfa283f6": {
			"type": "Ybodychange",
			"commitMessage": "remove noise\n",
			"commitDate": "2015-08-24, 3:05 PM",
			"commitName": "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-24, 2:42 PM",
			"commitNameOld": "f821be8dfe72fcd3f4e14f75420617b87ddb8689",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,24 +1,20 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         for (int i=0; i<method.getNoParams(); i++) {\n             TypeUsage expectedType = method.getParam(i).getType(typeSolver);\n             for (TypeParameter tp : method.getTypeParameters()) {\n                 expectedType = replaceTypeParam(expectedType, tp);\n             }\n \n-            if (name.equals(\"cloneNodes\")) {\n-                System.out.println(\"foo\");\n-            }\n-\n             if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)){\n                 return false;\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f821be8dfe72fcd3f4e14f75420617b87ddb8689": {
			"type": "Ybodychange",
			"commitMessage": "considering method type parameters\n",
			"commitDate": "2015-08-24, 2:42 PM",
			"commitName": "f821be8dfe72fcd3f4e14f75420617b87ddb8689",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-24, 1:19 PM",
			"commitNameOld": "283204dd5840cb11dd6c73dbbb196e80db79c9a4",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.06,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,15 +1,24 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         for (int i=0; i<method.getNoParams(); i++) {\n-            if (!method.getParam(i).getType(typeSolver).isAssignableBy(paramTypes.get(i), typeSolver)){\n+            TypeUsage expectedType = method.getParam(i).getType(typeSolver);\n+            for (TypeParameter tp : method.getTypeParameters()) {\n+                expectedType = replaceTypeParam(expectedType, tp);\n+            }\n+\n+            if (name.equals(\"cloneNodes\")) {\n+                System.out.println(\"foo\");\n+            }\n+\n+            if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)){\n                 return false;\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a7fa0c3db19bd74be9affdd624447251963b68af": {
			"type": "Ybodychange",
			"commitMessage": "add tests for ClassOrInterfaceDeclarationContext.solveMethodAsUsage\n",
			"commitDate": "2015-08-19, 3:17 AM",
			"commitName": "a7fa0c3db19bd74be9affdd624447251963b68af",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-17, 1:28 PM",
			"commitNameOld": "b7eaf3c62cf45b94426b96eaf4ccab268bb5eaac",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 1.58,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,15 +1,15 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         for (int i=0; i<method.getNoParams(); i++) {\n-            if (!method.getParam(i).getType(typeSolver).isAssignableBy(paramTypes.get(i))){\n+            if (!method.getParam(i).getType(typeSolver).isAssignableBy(paramTypes.get(i), typeSolver)){\n                 return false;\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"80f951258992f75441239c79e0f31eda7d47e107": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "wip\n",
			"commitDate": "2015-08-04, 7:54 AM",
			"commitName": "80f951258992f75441239c79e0f31eda7d47e107",
			"commitAuthor": "Federico Tomassetti",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "wip\n",
					"commitDate": "2015-08-04, 7:54 AM",
					"commitName": "80f951258992f75441239c79e0f31eda7d47e107",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2015-08-03, 12:37 AM",
					"commitNameOld": "630eb94d43670f2080c7273584d49c0b0d4162f1",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 1.3,
					"commitsBetweenForRepo": 8,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,15 +1,15 @@\n-    public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes) {\n+    public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         for (int i=0; i<method.getNoParams(); i++) {\n-            if (!method.getParam(i).getType().isAssignableBy(paramTypes.get(i))){\n+            if (!method.getParam(i).getType(typeSolver).isAssignableBy(paramTypes.get(i))){\n                 return false;\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[method-MethodDeclaration, name-String, paramTypes-List<TypeUsage>]",
						"newValue": "[method-MethodDeclaration, name-String, paramTypes-List<TypeUsage>, typeSolver-TypeSolver]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "wip\n",
					"commitDate": "2015-08-04, 7:54 AM",
					"commitName": "80f951258992f75441239c79e0f31eda7d47e107",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2015-08-03, 12:37 AM",
					"commitNameOld": "630eb94d43670f2080c7273584d49c0b0d4162f1",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 1.3,
					"commitsBetweenForRepo": 8,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,15 +1,15 @@\n-    public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes) {\n+    public static boolean isApplicable(MethodDeclaration method, String name, List<TypeUsage> paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() != paramTypes.size()) {\n             return false;\n         }\n         for (int i=0; i<method.getNoParams(); i++) {\n-            if (!method.getParam(i).getType().isAssignableBy(paramTypes.get(i))){\n+            if (!method.getParam(i).getType(typeSolver).isAssignableBy(paramTypes.get(i))){\n                 return false;\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"d420a496cd03b7e9b5c4cce5074d8a74da69f3cd": {
			"type": "Yintroduced",
			"commitMessage": "wip\n",
			"commitDate": "2015-08-02, 9:54 AM",
			"commitName": "d420a496cd03b7e9b5c4cce5074d8a74da69f3cd",
			"commitAuthor": "Federico Tomassetti"
		}
	},
	"sha": "97555053af3025556efe1a168fd7943dac28a2a6"
}