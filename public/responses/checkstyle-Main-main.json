{
	"repo": "https://github.com/checkstyle/checkstyle.git",
	"file": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java",
	"method": {
		"longName": "Main::main(String args)",
		"startLine": 181,
		"methodName": "main",
		"isStatic": true,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"b1b49751d38af0bf2476aea1f4595283615ab7de": {
			"type": "Ybodychange",
			"commitMessage": "Issue #4399: increase coverage of pitest-checkstyle main profile to 100%\n",
			"commitDate": "2017-07-27, 6:54 AM",
			"commitName": "b1b49751d38af0bf2476aea1f4595283615ab7de",
			"commitAuthor": "vasilyeva",
			"commitDateOld": "2017-07-23, 7:19 PM",
			"commitNameOld": "4c10bc55b4aea0f7e3b95b06d820eedb7c6a6fb2",
			"commitAuthorOld": "vasilyeva",
			"daysBetweenCommits": 3.48,
			"commitsBetweenForRepo": 19,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,61 +1,64 @@\n     public static void main(String... args) throws IOException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation = -1;\n         int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus = 0;\n             }\n             else {\n                 final List<File> filesToProcess = getFilesToProcess(getExclusions(commandLine),\n                         commandLine.getArgs());\n \n                 // return error if something is wrong in arguments\n                 final List<String> messages = validateCli(commandLine, filesToProcess);\n                 cliViolations = !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     messages.forEach(System.out::println);\n                 }\n                 else {\n                     errorCounter = runCli(commandLine, filesToProcess);\n                     exitStatus = errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations = true;\n             exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException ex) {\n             exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter = 1;\n             ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n-            if (errorCounter != 0 && !cliViolations) {\n-                final LocalizedMessage errorCounterMessage = new LocalizedMessage(0,\n-                        Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER,\n-                        new String[] {String.valueOf(errorCounter)}, null, Main.class, null);\n-                System.out.println(errorCounterMessage.getMessage());\n+            // two ifs exist till https://github.com/hcoles/pitest/issues/377\n+            if (errorCounter != 0) {\n+                if (!cliViolations) {\n+                    final LocalizedMessage errorCounterMessage = new LocalizedMessage(0,\n+                            Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER,\n+                            new String[] {String.valueOf(errorCounter)}, null, Main.class, null);\n+                    System.out.println(errorCounterMessage.getMessage());\n+                }\n             }\n             if (exitStatus != 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dab682c2f0e2853858a6d24e1fe2c2088315a0cc": {
			"type": "Ybodychange",
			"commitMessage": "Issue #3110: Modified Main to remove hardcoded messages and to support i18n for the messages\n",
			"commitDate": "2017-07-07, 8:55 PM",
			"commitName": "dab682c2f0e2853858a6d24e1fe2c2088315a0cc",
			"commitAuthor": "Subbu Dantu",
			"commitDateOld": "2017-07-02, 8:43 PM",
			"commitNameOld": "036582d728d2e2bb37f360bb3a74f899f04d587d",
			"commitAuthorOld": "Andrew Kuchev",
			"daysBetweenCommits": 5.01,
			"commitsBetweenForRepo": 45,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,58 +1,61 @@\n     public static void main(String... args) throws IOException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation = -1;\n         int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus = 0;\n             }\n             else {\n                 final List<File> filesToProcess = getFilesToProcess(getExclusions(commandLine),\n                         commandLine.getArgs());\n \n                 // return error if something is wrong in arguments\n                 final List<String> messages = validateCli(commandLine, filesToProcess);\n                 cliViolations = !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     messages.forEach(System.out::println);\n                 }\n                 else {\n                     errorCounter = runCli(commandLine, filesToProcess);\n                     exitStatus = errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations = true;\n             exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException ex) {\n             exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter = 1;\n             ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n-                System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n+                final LocalizedMessage errorCounterMessage = new LocalizedMessage(0,\n+                        Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER,\n+                        new String[] {String.valueOf(errorCounter)}, null, Main.class, null);\n+                System.out.println(errorCounterMessage.getMessage());\n             }\n             if (exitStatus != 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"de022d2434e58dd633fd50a7f9bb50565a8767b5": {
			"type": "Ybodychange",
			"commitMessage": "Issue #3233: Resolve IntelijIdea inspection violations for java8 migration (#3434)\n\n",
			"commitDate": "2016-09-08, 6:30 AM",
			"commitName": "de022d2434e58dd633fd50a7f9bb50565a8767b5",
			"commitAuthor": "Mariia Mykhailova",
			"commitDateOld": "2016-08-02, 8:23 AM",
			"commitNameOld": "77081171f2d8deade9fb4f5f677c4b07e05d1540",
			"commitAuthorOld": "Glenn Hollingsworth",
			"daysBetweenCommits": 36.92,
			"commitsBetweenForRepo": 29,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,60 +1,58 @@\n     public static void main(String... args) throws IOException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation = -1;\n         int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus = 0;\n             }\n             else {\n                 final List<File> filesToProcess = getFilesToProcess(getExclusions(commandLine),\n                         commandLine.getArgs());\n \n                 // return error if something is wrong in arguments\n                 final List<String> messages = validateCli(commandLine, filesToProcess);\n                 cliViolations = !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n-                    for (String message : messages) {\n-                        System.out.println(message);\n-                    }\n+                    messages.forEach(System.out::println);\n                 }\n                 else {\n                     errorCounter = runCli(commandLine, filesToProcess);\n                     exitStatus = errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations = true;\n             exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException ex) {\n             exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter = 1;\n             ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus != 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6ee753af51a58c1c6ecc5e6d5946a32ee937eaa6": {
			"type": "Ybodychange",
			"commitMessage": "Issue #3287: added exclude directory option (#3288)\n\n",
			"commitDate": "2016-07-26, 8:55 PM",
			"commitName": "6ee753af51a58c1c6ecc5e6d5946a32ee937eaa6",
			"commitAuthor": "rnveach",
			"commitDateOld": "2016-07-11, 10:47 PM",
			"commitNameOld": "44119413b68542bb1db3f50d2585834b9d00d1b3",
			"commitAuthorOld": "Roman Ivanov",
			"daysBetweenCommits": 14.92,
			"commitsBetweenForRepo": 20,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,59 +1,60 @@\n     public static void main(String... args) throws IOException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation = -1;\n         int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus = 0;\n             }\n             else {\n-                final List<File> filesToProcess = getFilesToProcess(commandLine.getArgs());\n+                final List<File> filesToProcess = getFilesToProcess(getExclusions(commandLine),\n+                        commandLine.getArgs());\n \n                 // return error if something is wrong in arguments\n                 final List<String> messages = validateCli(commandLine, filesToProcess);\n                 cliViolations = !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     errorCounter = runCli(commandLine, filesToProcess);\n                     exitStatus = errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations = true;\n             exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException ex) {\n             exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter = 1;\n             ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus != 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a6ab6053e6b3d421d19764418cba3858c683e6e8": {
			"type": "Ybodychange",
			"commitMessage": "Issue #3086: added debug option",
			"commitDate": "2016-05-27, 7:18 AM",
			"commitName": "a6ab6053e6b3d421d19764418cba3858c683e6e8",
			"commitAuthor": "rnveach",
			"commitDateOld": "2016-04-10, 3:08 PM",
			"commitNameOld": "1549ea4822139938296a58f59c38ae14f633c5aa",
			"commitAuthorOld": "Baratali Izmailov",
			"daysBetweenCommits": 46.67,
			"commitsBetweenForRepo": 96,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,85 +1,59 @@\n     public static void main(String... args) throws IOException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation = -1;\n         int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus = 0;\n             }\n             else {\n                 final List<File> filesToProcess = getFilesToProcess(commandLine.getArgs());\n \n                 // return error if something is wrong in arguments\n                 final List<String> messages = validateCli(commandLine, filesToProcess);\n                 cliViolations = !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n-                    // create config helper object\n-                    final CliOptions config = convertCliToPojo(commandLine, filesToProcess);\n-                    if (commandLine.hasOption(OPTION_T_NAME)) {\n-                        // print AST\n-                        final File file = config.files.get(0);\n-                        final String stringAst = AstTreeStringPrinter.printFileAst(file, false);\n-                        System.out.print(stringAst);\n-                    }\n-                    else if (commandLine.hasOption(OPTION_CAPITAL_T_NAME)) {\n-                        final File file = config.files.get(0);\n-                        final String stringAst = AstTreeStringPrinter.printFileAst(file, true);\n-                        System.out.print(stringAst);\n-                    }\n-                    else if (commandLine.hasOption(OPTION_J_NAME)) {\n-                        final File file = config.files.get(0);\n-                        final String stringAst = DetailNodeTreeStringPrinter.printFileAst(file);\n-                        System.out.print(stringAst);\n-                    }\n-                    else if (commandLine.hasOption(OPTION_CAPITAL_J_NAME)) {\n-                        final File file = config.files.get(0);\n-                        final String stringAst = AstTreeStringPrinter.printJavaAndJavadocTree(file);\n-                        System.out.print(stringAst);\n-                    }\n-                    else {\n-                        // run Checker\n-                        errorCounter = runCheckstyle(config);\n-                        exitStatus = errorCounter;\n-                    }\n+                    errorCounter = runCli(commandLine, filesToProcess);\n+                    exitStatus = errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations = true;\n             exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException ex) {\n             exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter = 1;\n             ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus != 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1549ea4822139938296a58f59c38ae14f633c5aa": {
			"type": "Ybodychange",
			"commitMessage": "Issue #3040: New CLI option to print full tree (java+comments+javadoc). (#3078)",
			"commitDate": "2016-04-10, 3:08 PM",
			"commitName": "1549ea4822139938296a58f59c38ae14f633c5aa",
			"commitAuthor": "Baratali Izmailov",
			"commitDateOld": "2016-03-17, 7:19 AM",
			"commitNameOld": "68b49fd2843f23f55dc711a89213d59f2acf3a0a",
			"commitAuthorOld": "Baratali Izmailov",
			"daysBetweenCommits": 24.33,
			"commitsBetweenForRepo": 47,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,80 +1,85 @@\n     public static void main(String... args) throws IOException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation = -1;\n         int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus = 0;\n             }\n             else {\n                 final List<File> filesToProcess = getFilesToProcess(commandLine.getArgs());\n \n                 // return error if something is wrong in arguments\n                 final List<String> messages = validateCli(commandLine, filesToProcess);\n                 cliViolations = !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config = convertCliToPojo(commandLine, filesToProcess);\n                     if (commandLine.hasOption(OPTION_T_NAME)) {\n                         // print AST\n                         final File file = config.files.get(0);\n                         final String stringAst = AstTreeStringPrinter.printFileAst(file, false);\n                         System.out.print(stringAst);\n                     }\n                     else if (commandLine.hasOption(OPTION_CAPITAL_T_NAME)) {\n                         final File file = config.files.get(0);\n                         final String stringAst = AstTreeStringPrinter.printFileAst(file, true);\n                         System.out.print(stringAst);\n                     }\n                     else if (commandLine.hasOption(OPTION_J_NAME)) {\n                         final File file = config.files.get(0);\n                         final String stringAst = DetailNodeTreeStringPrinter.printFileAst(file);\n                         System.out.print(stringAst);\n                     }\n+                    else if (commandLine.hasOption(OPTION_CAPITAL_J_NAME)) {\n+                        final File file = config.files.get(0);\n+                        final String stringAst = AstTreeStringPrinter.printJavaAndJavadocTree(file);\n+                        System.out.print(stringAst);\n+                    }\n                     else {\n                         // run Checker\n                         errorCounter = runCheckstyle(config);\n                         exitStatus = errorCounter;\n                     }\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations = true;\n             exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException ex) {\n             exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter = 1;\n             ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus != 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"68b49fd2843f23f55dc711a89213d59f2acf3a0a": {
			"type": "Ybodychange",
			"commitMessage": "Issue #652: New CLI option to print Javadoc comment parse tree\n",
			"commitDate": "2016-03-17, 7:19 AM",
			"commitName": "68b49fd2843f23f55dc711a89213d59f2acf3a0a",
			"commitAuthor": "Baratali Izmailov",
			"commitDateOld": "2016-02-23, 8:07 AM",
			"commitNameOld": "25621a3c3391ddf4bc0bb56535d23e73cd293657",
			"commitAuthorOld": "Baratali Izmailov",
			"daysBetweenCommits": 22.93,
			"commitsBetweenForRepo": 60,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,75 +1,80 @@\n     public static void main(String... args) throws IOException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation = -1;\n         int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus = 0;\n             }\n             else {\n                 final List<File> filesToProcess = getFilesToProcess(commandLine.getArgs());\n \n                 // return error if something is wrong in arguments\n                 final List<String> messages = validateCli(commandLine, filesToProcess);\n                 cliViolations = !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config = convertCliToPojo(commandLine, filesToProcess);\n                     if (commandLine.hasOption(OPTION_T_NAME)) {\n                         // print AST\n                         final File file = config.files.get(0);\n                         final String stringAst = AstTreeStringPrinter.printFileAst(file, false);\n                         System.out.print(stringAst);\n                     }\n                     else if (commandLine.hasOption(OPTION_CAPITAL_T_NAME)) {\n                         final File file = config.files.get(0);\n                         final String stringAst = AstTreeStringPrinter.printFileAst(file, true);\n                         System.out.print(stringAst);\n                     }\n+                    else if (commandLine.hasOption(OPTION_J_NAME)) {\n+                        final File file = config.files.get(0);\n+                        final String stringAst = DetailNodeTreeStringPrinter.printFileAst(file);\n+                        System.out.print(stringAst);\n+                    }\n                     else {\n                         // run Checker\n                         errorCounter = runCheckstyle(config);\n                         exitStatus = errorCounter;\n                     }\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations = true;\n             exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException ex) {\n             exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter = 1;\n             ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus != 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"25621a3c3391ddf4bc0bb56535d23e73cd293657": {
			"type": "Ybodychange",
			"commitMessage": "Issue #652: New option to print AST with comment nodes.\n",
			"commitDate": "2016-02-23, 8:07 AM",
			"commitName": "25621a3c3391ddf4bc0bb56535d23e73cd293657",
			"commitAuthor": "Baratali Izmailov",
			"commitDateOld": "2016-02-10, 7:07 AM",
			"commitNameOld": "1b72b4905bf3520aa47697cc7d1bcdad8b7ad1e6",
			"commitAuthorOld": "rnveach",
			"daysBetweenCommits": 13.04,
			"commitsBetweenForRepo": 55,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,71 +1,75 @@\n     public static void main(String... args) throws IOException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation = -1;\n         int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus = 0;\n             }\n             else {\n                 final List<File> filesToProcess = getFilesToProcess(commandLine.getArgs());\n \n                 // return error if something is wrong in arguments\n                 final List<String> messages = validateCli(commandLine, filesToProcess);\n                 cliViolations = !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config = convertCliToPojo(commandLine, filesToProcess);\n-\n                     if (commandLine.hasOption(OPTION_T_NAME)) {\n                         // print AST\n                         final File file = config.files.get(0);\n-                        final String stringAst = AstTreeStringPrinter.printFileAst(file);\n+                        final String stringAst = AstTreeStringPrinter.printFileAst(file, false);\n+                        System.out.print(stringAst);\n+                    }\n+                    else if (commandLine.hasOption(OPTION_CAPITAL_T_NAME)) {\n+                        final File file = config.files.get(0);\n+                        final String stringAst = AstTreeStringPrinter.printFileAst(file, true);\n                         System.out.print(stringAst);\n                     }\n                     else {\n                         // run Checker\n                         errorCounter = runCheckstyle(config);\n                         exitStatus = errorCounter;\n                     }\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations = true;\n             exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException ex) {\n             exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter = 1;\n             ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus != 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1b72b4905bf3520aa47697cc7d1bcdad8b7ad1e6": {
			"type": "Ybodychange",
			"commitMessage": "Issue #2103: removed excess file gathering in main",
			"commitDate": "2016-02-10, 7:07 AM",
			"commitName": "1b72b4905bf3520aa47697cc7d1bcdad8b7ad1e6",
			"commitAuthor": "rnveach",
			"commitDateOld": "2016-02-04, 3:32 AM",
			"commitNameOld": "c225479c7d3a7b82fec7d26131ac27496d336853",
			"commitAuthorOld": "Vladislav Lisetskiy",
			"daysBetweenCommits": 6.15,
			"commitsBetweenForRepo": 21,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,69 +1,71 @@\n     public static void main(String... args) throws IOException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation = -1;\n         int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus = 0;\n             }\n             else {\n+                final List<File> filesToProcess = getFilesToProcess(commandLine.getArgs());\n+\n                 // return error if something is wrong in arguments\n-                final List<String> messages = validateCli(commandLine);\n+                final List<String> messages = validateCli(commandLine, filesToProcess);\n                 cliViolations = !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n-                    final CliOptions config = convertCliToPojo(commandLine);\n+                    final CliOptions config = convertCliToPojo(commandLine, filesToProcess);\n \n                     if (commandLine.hasOption(OPTION_T_NAME)) {\n                         // print AST\n                         final File file = config.files.get(0);\n                         final String stringAst = AstTreeStringPrinter.printFileAst(file);\n                         System.out.print(stringAst);\n                     }\n                     else {\n                         // run Checker\n                         errorCounter = runCheckstyle(config);\n                         exitStatus = errorCounter;\n                     }\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations = true;\n             exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException ex) {\n             exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter = 1;\n             ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus != 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c225479c7d3a7b82fec7d26131ac27496d336853": {
			"type": "Ymultichange(Yexceptionschange,Ybodychange)",
			"commitMessage": "Issue #2638: Print parse tree from CLI to terminal\n",
			"commitDate": "2016-02-04, 3:32 AM",
			"commitName": "c225479c7d3a7b82fec7d26131ac27496d336853",
			"commitAuthor": "Vladislav Lisetskiy",
			"subchanges": [
				{
					"type": "Yexceptionschange",
					"commitMessage": "Issue #2638: Print parse tree from CLI to terminal\n",
					"commitDate": "2016-02-04, 3:32 AM",
					"commitName": "c225479c7d3a7b82fec7d26131ac27496d336853",
					"commitAuthor": "Vladislav Lisetskiy",
					"commitDateOld": "2016-01-24, 7:35 AM",
					"commitNameOld": "0d8e93ce79ea33b72b3e904d8796984271ee3d8d",
					"commitAuthorOld": "Bhavik Patel",
					"daysBetweenCommits": 10.83,
					"commitsBetweenForRepo": 35,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,60 +1,69 @@\n-    public static void main(String... args) throws FileNotFoundException {\n+    public static void main(String... args) throws IOException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation = -1;\n         int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus = 0;\n             }\n             else {\n                 // return error if something is wrong in arguments\n                 final List<String> messages = validateCli(commandLine);\n                 cliViolations = !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config = convertCliToPojo(commandLine);\n-                    // run Checker\n-                    errorCounter = runCheckstyle(config);\n-                    exitStatus = errorCounter;\n+\n+                    if (commandLine.hasOption(OPTION_T_NAME)) {\n+                        // print AST\n+                        final File file = config.files.get(0);\n+                        final String stringAst = AstTreeStringPrinter.printFileAst(file);\n+                        System.out.print(stringAst);\n+                    }\n+                    else {\n+                        // run Checker\n+                        errorCounter = runCheckstyle(config);\n+                        exitStatus = errorCounter;\n+                    }\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations = true;\n             exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException ex) {\n             exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter = 1;\n             ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus != 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[FileNotFoundException]",
						"newValue": "[IOException]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Issue #2638: Print parse tree from CLI to terminal\n",
					"commitDate": "2016-02-04, 3:32 AM",
					"commitName": "c225479c7d3a7b82fec7d26131ac27496d336853",
					"commitAuthor": "Vladislav Lisetskiy",
					"commitDateOld": "2016-01-24, 7:35 AM",
					"commitNameOld": "0d8e93ce79ea33b72b3e904d8796984271ee3d8d",
					"commitAuthorOld": "Bhavik Patel",
					"daysBetweenCommits": 10.83,
					"commitsBetweenForRepo": 35,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,60 +1,69 @@\n-    public static void main(String... args) throws FileNotFoundException {\n+    public static void main(String... args) throws IOException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation = -1;\n         int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus = 0;\n             }\n             else {\n                 // return error if something is wrong in arguments\n                 final List<String> messages = validateCli(commandLine);\n                 cliViolations = !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config = convertCliToPojo(commandLine);\n-                    // run Checker\n-                    errorCounter = runCheckstyle(config);\n-                    exitStatus = errorCounter;\n+\n+                    if (commandLine.hasOption(OPTION_T_NAME)) {\n+                        // print AST\n+                        final File file = config.files.get(0);\n+                        final String stringAst = AstTreeStringPrinter.printFileAst(file);\n+                        System.out.print(stringAst);\n+                    }\n+                    else {\n+                        // run Checker\n+                        errorCounter = runCheckstyle(config);\n+                        exitStatus = errorCounter;\n+                    }\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations = true;\n             exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException ex) {\n             exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter = 1;\n             ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus != 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"f65b17cbc30795247fef3077cce16a8bb53e9ffc": {
			"type": "Ybodychange",
			"commitMessage": "Issue #2616: Fix CatchParameterName check violations in Checkstyle code\n",
			"commitDate": "2015-12-03, 4:16 PM",
			"commitName": "f65b17cbc30795247fef3077cce16a8bb53e9ffc",
			"commitAuthor": "Michal Kordas",
			"commitDateOld": "2015-11-03, 7:04 AM",
			"commitNameOld": "1c5d01c3b48ab48fcfb0e7f3764e98d46727870e",
			"commitAuthorOld": "rnveach",
			"daysBetweenCommits": 30.38,
			"commitsBetweenForRepo": 138,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,60 +1,60 @@\n     public static void main(String... args) throws FileNotFoundException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation = -1;\n         int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus = 0;\n             }\n             else {\n                 // return error if something is wrong in arguments\n                 final List<String> messages = validateCli(commandLine);\n                 cliViolations = !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config = convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter = runCheckstyle(config);\n                     exitStatus = errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations = true;\n             exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n-        catch (CheckstyleException e) {\n+        catch (CheckstyleException ex) {\n             exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter = 1;\n-            e.printStackTrace();\n+            ex.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus != 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f020066f8bdfb378df36904af3df8b5bc48858fd": {
			"type": "Ybodychange",
			"commitMessage": "Issue #2109: CLI should print a file name where exception is happen\n",
			"commitDate": "2015-11-01, 6:52 AM",
			"commitName": "f020066f8bdfb378df36904af3df8b5bc48858fd",
			"commitAuthor": "Roman Ivanov",
			"commitDateOld": "2015-10-07, 6:55 PM",
			"commitNameOld": "423ed9e469db620671459827b58c89025d8f6c66",
			"commitAuthorOld": "Roman Ivanov",
			"daysBetweenCommits": 24.54,
			"commitsBetweenForRepo": 188,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,60 +1,60 @@\n     public static void main(String... args) throws FileNotFoundException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation = -1;\n         int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus = 0;\n             }\n             else {\n                 // return error if something is wrong in arguments\n                 final List<String> messages = validateCli(commandLine);\n                 cliViolations = !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config = convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter = runCheckstyle(config);\n                     exitStatus = errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations = true;\n             exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException e) {\n             exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter = 1;\n-            printMessageAndCause(e);\n+            e.printStackTrace();\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus != 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5391df43637f6522979d46c5c4e35f772f08f4ac": {
			"type": "Ybodychange",
			"commitMessage": "Issue #2213: Print missing cause of exception to console on error\n",
			"commitDate": "2015-09-20, 6:48 AM",
			"commitName": "5391df43637f6522979d46c5c4e35f772f08f4ac",
			"commitAuthor": "Michal Kordas",
			"commitDateOld": "2015-09-17, 4:01 PM",
			"commitNameOld": "b6d9344d1c152f225a22ce9ce09341b3cc9488af",
			"commitAuthorOld": "Michael Osipov",
			"daysBetweenCommits": 2.62,
			"commitsBetweenForRepo": 16,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,60 +1,60 @@\n     public static void main(String... args) throws FileNotFoundException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation = -1;\n         int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus = 0;\n             }\n             else {\n                 // return error if something is wrong in arguments\n                 final List<String> messages = validateCli(commandLine);\n                 cliViolations = !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config = convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter = runCheckstyle(config);\n                     exitStatus = errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations = true;\n             exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException e) {\n             exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter = 1;\n-            System.out.println(e.getMessage());\n+            printMessageAndCause(e);\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus != 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b6d9344d1c152f225a22ce9ce09341b3cc9488af": {
			"type": "Yexceptionschange",
			"commitMessage": "Pull #2034: Use StandardCharsets and get rid of UnsupportedEncodingException\n",
			"commitDate": "2015-09-17, 4:01 PM",
			"commitName": "b6d9344d1c152f225a22ce9ce09341b3cc9488af",
			"commitAuthor": "Michael Osipov",
			"commitDateOld": "2015-09-11, 5:32 PM",
			"commitNameOld": "0fc8b62a35beddc89cb3412388c27e88cd8cab4a",
			"commitAuthorOld": "Michal Kordas",
			"daysBetweenCommits": 5.94,
			"commitsBetweenForRepo": 22,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,61 +1,60 @@\n-    public static void main(String... args) throws UnsupportedEncodingException,\n-            FileNotFoundException {\n+    public static void main(String... args) throws FileNotFoundException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation = -1;\n         int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus = 0;\n             }\n             else {\n                 // return error if something is wrong in arguments\n                 final List<String> messages = validateCli(commandLine);\n                 cliViolations = !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config = convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter = runCheckstyle(config);\n                     exitStatus = errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // something wrong with arguments - print error and manual\n             cliViolations = true;\n             exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException e) {\n             exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter = 1;\n             System.out.println(e.getMessage());\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus != 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[UnsupportedEncodingException, FileNotFoundException]",
				"newValue": "[FileNotFoundException]"
			}
		},
		"0fc8b62a35beddc89cb3412388c27e88cd8cab4a": {
			"type": "Ybodychange",
			"commitMessage": "Issue #2080: Fix typos in code\n",
			"commitDate": "2015-09-11, 5:32 PM",
			"commitName": "0fc8b62a35beddc89cb3412388c27e88cd8cab4a",
			"commitAuthor": "Michal Kordas",
			"commitDateOld": "2015-09-10, 3:57 AM",
			"commitNameOld": "a29f01a95b9dee1e64ec7ed91b4d0876eb82c0bf",
			"commitAuthorOld": "Andrei Selkin",
			"daysBetweenCommits": 1.57,
			"commitsBetweenForRepo": 10,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,61 +1,61 @@\n     public static void main(String... args) throws UnsupportedEncodingException,\n             FileNotFoundException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation = -1;\n         int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus = 0;\n             }\n             else {\n-                // return error is smth is wrong in arguments\n+                // return error if something is wrong in arguments\n                 final List<String> messages = validateCli(commandLine);\n                 cliViolations = !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config = convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter = runCheckstyle(config);\n                     exitStatus = errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n-            // smth wrong with arguments - print error and manual\n+            // something wrong with arguments - print error and manual\n             cliViolations = true;\n             exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException e) {\n             exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter = 1;\n             System.out.println(e.getMessage());\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus != 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8c3e4a50749044ae3177fc4c84db9c4fd93abca2": {
			"type": "Ybodychange",
			"commitMessage": "Issue #1566: MultipleStringLiterals violations partial fix\n",
			"commitDate": "2015-08-25, 6:12 AM",
			"commitName": "8c3e4a50749044ae3177fc4c84db9c4fd93abca2",
			"commitAuthor": "Ruslan Diachenko",
			"commitDateOld": "2015-08-19, 9:42 PM",
			"commitNameOld": "da6a8d083cb82a94707146de559911578f39affe",
			"commitAuthorOld": "Michal Kordas",
			"daysBetweenCommits": 5.35,
			"commitsBetweenForRepo": 91,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,61 +1,61 @@\n     public static void main(String... args) throws UnsupportedEncodingException,\n             FileNotFoundException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation = -1;\n         int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n-            if (commandLine.hasOption(\"v\")) {\n+            if (commandLine.hasOption(OPTION_V_NAME)) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus = 0;\n             }\n             else {\n                 // return error is smth is wrong in arguments\n                 final List<String> messages = validateCli(commandLine);\n                 cliViolations = !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config = convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter = runCheckstyle(config);\n                     exitStatus = errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // smth wrong with arguments - print error and manual\n             cliViolations = true;\n             exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException e) {\n             exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter = 1;\n             System.out.println(e.getMessage());\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus != 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"da6a8d083cb82a94707146de559911578f39affe": {
			"type": "Ybodychange",
			"commitMessage": "Remove unnecessary local variables. #1555\n\nFixes `UnnecessaryLocalVariable` inspection violation.\n\nDescription:\n>Reports unnecessary local variables, which add nothing to the comprehensibility of a method. Variables caught include local variables which are immediately returned, local variables that are immediately assigned to another variable and then not used, and local variables which always have the same value as another local variable or parameter.\n",
			"commitDate": "2015-08-19, 9:42 PM",
			"commitName": "da6a8d083cb82a94707146de559911578f39affe",
			"commitAuthor": "Michal Kordas",
			"commitDateOld": "2015-08-18, 2:25 AM",
			"commitNameOld": "54ccca18635a4aeea90da86d30590df498f76b08",
			"commitAuthorOld": "Baratali Izmailov",
			"daysBetweenCommits": 1.8,
			"commitsBetweenForRepo": 36,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,62 +1,61 @@\n     public static void main(String... args) throws UnsupportedEncodingException,\n             FileNotFoundException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation = -1;\n         int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(\"v\")) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus = 0;\n             }\n             else {\n                 // return error is smth is wrong in arguments\n                 final List<String> messages = validateCli(commandLine);\n                 cliViolations = !messages.isEmpty();\n                 if (cliViolations) {\n                     exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n                 else {\n                     // create config helper object\n                     final CliOptions config = convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter = runCheckstyle(config);\n                     exitStatus = errorCounter;\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // smth wrong with arguments - print error and manual\n             cliViolations = true;\n             exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException e) {\n-            final int exitWithCheckstyleException = -2;\n-            exitStatus = exitWithCheckstyleException;\n+            exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n             errorCounter = 1;\n             System.out.println(e.getMessage());\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus != 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"86826e1fa3fe3d793ee4723bb84ee0fc4ca38df1": {
			"type": "Ybodychange",
			"commitMessage": "Invert if statements with negated conditions. #1555\n\nFixes `NegatedIfElse` inspection violations.\n\nDescription:\n>Reports if statements which contain else branches and whose conditions are negated. Flipping the order of the if and else branches will usually increase the clarity of such statements.\n",
			"commitDate": "2015-08-10, 12:46 AM",
			"commitName": "86826e1fa3fe3d793ee4723bb84ee0fc4ca38df1",
			"commitAuthor": "Michal Kordas",
			"commitDateOld": "2015-08-07, 11:23 PM",
			"commitNameOld": "186625600d7678f597f56aa6a83d4b0a89e1fe35",
			"commitAuthorOld": "Andrei Selkin",
			"daysBetweenCommits": 2.06,
			"commitsBetweenForRepo": 52,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,62 +1,62 @@\n     public static void main(String... args) throws UnsupportedEncodingException,\n             FileNotFoundException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation = -1;\n         int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(\"v\")) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus = 0;\n             }\n             else {\n                 // return error is smth is wrong in arguments\n                 final List<String> messages = validateCli(commandLine);\n                 cliViolations = !messages.isEmpty();\n-                if (!cliViolations) {\n-                    // create config helper object\n-                    final CliOptions config = convertCliToPojo(commandLine);\n-                    // run Checker\n-                    errorCounter = runCheckstyle(config);\n-                    exitStatus = errorCounter;\n-                }\n-                else {\n+                if (cliViolations) {\n                     exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n+                else {\n+                    // create config helper object\n+                    final CliOptions config = convertCliToPojo(commandLine);\n+                    // run Checker\n+                    errorCounter = runCheckstyle(config);\n+                    exitStatus = errorCounter;\n+                }\n             }\n         }\n         catch (ParseException pex) {\n             // smth wrong with arguments - print error and manual\n             cliViolations = true;\n             exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException e) {\n             final int exitWithCheckstyleException = -2;\n             exitStatus = exitWithCheckstyleException;\n             errorCounter = 1;\n             System.out.println(e.getMessage());\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus != 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2880edd6554400955fb950bf8127311c436d2a7a": {
			"type": "Ybodychange",
			"commitMessage": "Decrease scope of variables. #1538\n",
			"commitDate": "2015-08-02, 7:48 PM",
			"commitName": "2880edd6554400955fb950bf8127311c436d2a7a",
			"commitAuthor": "Michal Kordas",
			"commitDateOld": "2015-07-30, 4:23 AM",
			"commitNameOld": "88f75f5413914bea5b39ba318edf912ee706226d",
			"commitAuthorOld": "Roman Ivanov",
			"daysBetweenCommits": 3.64,
			"commitsBetweenForRepo": 47,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,62 +1,62 @@\n     public static void main(String... args) throws UnsupportedEncodingException,\n             FileNotFoundException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation = -1;\n-        final int exitWithCheckstyleException = -2;\n         int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(\"v\")) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus = 0;\n             }\n             else {\n                 // return error is smth is wrong in arguments\n                 final List<String> messages = validateCli(commandLine);\n                 cliViolations = !messages.isEmpty();\n                 if (!cliViolations) {\n                     // create config helper object\n                     final CliOptions config = convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter = runCheckstyle(config);\n                     exitStatus = errorCounter;\n                 }\n                 else {\n                     exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // smth wrong with arguments - print error and manual\n             cliViolations = true;\n             exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException e) {\n+            final int exitWithCheckstyleException = -2;\n             exitStatus = exitWithCheckstyleException;\n             errorCounter = 1;\n             System.out.println(e.getMessage());\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             if (exitStatus != 0) {\n                 System.exit(exitStatus);\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"aaf39002ac7fa00b95f4719beca058f6f7445574": {
			"type": "Ybodychange",
			"commitMessage": "100% coverage for Main.java . #1294\n",
			"commitDate": "2015-07-29, 1:29 AM",
			"commitName": "aaf39002ac7fa00b95f4719beca058f6f7445574",
			"commitAuthor": "Roman Ivanov",
			"commitDateOld": "2015-07-22, 11:58 PM",
			"commitNameOld": "acbd47a66b01acc392a7bd37ad3a2e65eecd308a",
			"commitAuthorOld": "Aleksandr Ivanov",
			"daysBetweenCommits": 6.06,
			"commitsBetweenForRepo": 73,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,60 +1,62 @@\n     public static void main(String... args) throws UnsupportedEncodingException,\n             FileNotFoundException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n         // provide proper exit code based on results.\n         final int exitWithCliViolation = -1;\n         final int exitWithCheckstyleException = -2;\n         int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(\"v\")) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n                 exitStatus = 0;\n             }\n             else {\n                 // return error is smth is wrong in arguments\n                 final List<String> messages = validateCli(commandLine);\n                 cliViolations = !messages.isEmpty();\n                 if (!cliViolations) {\n                     // create config helper object\n                     final CliOptions config = convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter = runCheckstyle(config);\n                     exitStatus = errorCounter;\n                 }\n                 else {\n                     exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // smth wrong with arguments - print error and manual\n             cliViolations = true;\n             exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException e) {\n             exitStatus = exitWithCheckstyleException;\n             errorCounter = 1;\n             System.out.println(e.getMessage());\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n-            System.exit(exitStatus);\n+            if (exitStatus != 0) {\n+                System.exit(exitStatus);\n+            }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4299a4b408304cd0bcad6c25b4a322dbd94169a3": {
			"type": "Ymultichange(Yexceptionschange,Ybodychange)",
			"commitMessage": "Clarify misleading command line tool (CLI) output solves #1062\n",
			"commitDate": "2015-06-14, 8:37 AM",
			"commitName": "4299a4b408304cd0bcad6c25b4a322dbd94169a3",
			"commitAuthor": "Bhavik Patel",
			"subchanges": [
				{
					"type": "Yexceptionschange",
					"commitMessage": "Clarify misleading command line tool (CLI) output solves #1062\n",
					"commitDate": "2015-06-14, 8:37 AM",
					"commitName": "4299a4b408304cd0bcad6c25b4a322dbd94169a3",
					"commitAuthor": "Bhavik Patel",
					"commitDateOld": "2015-06-13, 9:41 AM",
					"commitNameOld": "3004b4d8810fae5956864d1493ea94f183b9442c",
					"commitAuthorOld": "Bhavik Patel",
					"daysBetweenCommits": 0.96,
					"commitsBetweenForRepo": 24,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,54 +1,60 @@\n     public static void main(String... args) throws UnsupportedEncodingException,\n-            CheckstyleException, FileNotFoundException {\n+            FileNotFoundException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n+        // provide proper exit code based on results.\n+        final int exitWithCliViolation = -1;\n+        final int exitWithCheckstyleException = -2;\n+        int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(\"v\")) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n+                exitStatus = 0;\n             }\n             else {\n                 // return error is smth is wrong in arguments\n                 final List<String> messages = validateCli(commandLine);\n                 cliViolations = !messages.isEmpty();\n-                if (messages.isEmpty()) {\n-\n+                if (!cliViolations) {\n                     // create config helper object\n                     final CliOptions config = convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter = runCheckstyle(config);\n-\n+                    exitStatus = errorCounter;\n                 }\n                 else {\n+                    exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // smth wrong with arguments - print error and manual\n             cliViolations = true;\n+            exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException e) {\n+            exitStatus = exitWithCheckstyleException;\n             errorCounter = 1;\n             System.out.println(e.getMessage());\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n-            // provide proper exit code based on results.\n-            System.exit(errorCounter);\n+            System.exit(exitStatus);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[UnsupportedEncodingException, CheckstyleException, FileNotFoundException]",
						"newValue": "[UnsupportedEncodingException, FileNotFoundException]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Clarify misleading command line tool (CLI) output solves #1062\n",
					"commitDate": "2015-06-14, 8:37 AM",
					"commitName": "4299a4b408304cd0bcad6c25b4a322dbd94169a3",
					"commitAuthor": "Bhavik Patel",
					"commitDateOld": "2015-06-13, 9:41 AM",
					"commitNameOld": "3004b4d8810fae5956864d1493ea94f183b9442c",
					"commitAuthorOld": "Bhavik Patel",
					"daysBetweenCommits": 0.96,
					"commitsBetweenForRepo": 24,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,54 +1,60 @@\n     public static void main(String... args) throws UnsupportedEncodingException,\n-            CheckstyleException, FileNotFoundException {\n+            FileNotFoundException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n+        // provide proper exit code based on results.\n+        final int exitWithCliViolation = -1;\n+        final int exitWithCheckstyleException = -2;\n+        int exitStatus = 0;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(\"v\")) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n+                exitStatus = 0;\n             }\n             else {\n                 // return error is smth is wrong in arguments\n                 final List<String> messages = validateCli(commandLine);\n                 cliViolations = !messages.isEmpty();\n-                if (messages.isEmpty()) {\n-\n+                if (!cliViolations) {\n                     // create config helper object\n                     final CliOptions config = convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter = runCheckstyle(config);\n-\n+                    exitStatus = errorCounter;\n                 }\n                 else {\n+                    exitStatus = exitWithCliViolation;\n                     errorCounter = 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // smth wrong with arguments - print error and manual\n             cliViolations = true;\n+            exitStatus = exitWithCliViolation;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n         catch (CheckstyleException e) {\n+            exitStatus = exitWithCheckstyleException;\n             errorCounter = 1;\n             System.out.println(e.getMessage());\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n-            // provide proper exit code based on results.\n-            System.exit(errorCounter);\n+            System.exit(exitStatus);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"fe6db3ab8a864e11eebfb0496f6a41852bdee019": {
			"type": "Ybodychange",
			"commitMessage": "Solution to \"Incorrect config file cause CLI finish with error but no output with details\" solves #1180\n",
			"commitDate": "2015-06-08, 12:42 PM",
			"commitName": "fe6db3ab8a864e11eebfb0496f6a41852bdee019",
			"commitAuthor": "Bhavik Patel",
			"commitDateOld": "2015-06-07, 9:42 AM",
			"commitNameOld": "8a3ccee4918bc1ce5f6bc2dfea51389a59684eb0",
			"commitAuthorOld": "Bhavik Patel",
			"daysBetweenCommits": 1.13,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,55 +1,54 @@\n     public static void main(String... args) throws UnsupportedEncodingException,\n             CheckstyleException, FileNotFoundException {\n         int errorCounter = 0;\n         boolean cliViolations = false;\n \n         try {\n             //parse CLI arguments\n             final CommandLine commandLine = parseCli(args);\n \n             // show version and exit if it is requested\n             if (commandLine.hasOption(\"v\")) {\n                 System.out.println(\"Checkstyle version: \"\n                         + Main.class.getPackage().getImplementationVersion());\n             }\n             else {\n                 // return error is smth is wrong in arguments\n                 final List<String> messages = validateCli(commandLine);\n                 cliViolations = !messages.isEmpty();\n                 if (messages.isEmpty()) {\n \n                     // create config helper object\n                     final CliOptions config = convertCliToPojo(commandLine);\n                     // run Checker\n                     errorCounter = runCheckstyle(config);\n \n                 }\n                 else {\n                     errorCounter = 1;\n                     for (String message : messages) {\n                         System.out.println(message);\n                     }\n                 }\n             }\n         }\n         catch (ParseException pex) {\n             // smth wrong with arguments - print error and manual\n             cliViolations = true;\n             errorCounter = 1;\n             System.out.println(pex.getMessage());\n             printUsage();\n         }\n-        catch (Exception ex) {\n-            // smth wrong during processing\n+        catch (CheckstyleException e) {\n             errorCounter = 1;\n-            throw ex;\n+            System.out.println(e.getMessage());\n         }\n         finally {\n             // return exit code base on validation of Checker\n             if (errorCounter != 0 && !cliViolations) {\n                 System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             // provide proper exit code based on results.\n             System.exit(errorCounter);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1a2c318e22a0b2b22ccc76019217c0892fe2d59b": {
			"type": "Ymultichange(Yexceptionschange,Ybodychange)",
			"commitMessage": "huge refactoring for CLI Main class. Issue #596\n",
			"commitDate": "2015-05-05, 12:12 PM",
			"commitName": "1a2c318e22a0b2b22ccc76019217c0892fe2d59b",
			"commitAuthor": "Roman Ivanov",
			"subchanges": [
				{
					"type": "Yexceptionschange",
					"commitMessage": "huge refactoring for CLI Main class. Issue #596\n",
					"commitDate": "2015-05-05, 12:12 PM",
					"commitName": "1a2c318e22a0b2b22ccc76019217c0892fe2d59b",
					"commitAuthor": "Roman Ivanov",
					"commitDateOld": "2015-05-03, 12:27 AM",
					"commitNameOld": "0f543a21fee9dec9b388bb6f2c42540fe8bf02ec",
					"commitAuthorOld": "Michal Kordas",
					"daysBetweenCommits": 2.49,
					"commitsBetweenForRepo": 5,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,23 +1,56 @@\n     public static void main(String... args) throws UnsupportedEncodingException\n+            , CheckstyleException, FileNotFoundException\n     {\n-        boolean parseResult = false;\n+        int errorCounter = 0;\n+        boolean cliViolations = false;\n+\n         try {\n-            processCommandLine(parseCli(args));\n-            parseResult = true;\n+            //parse CLI arguments\n+            final CommandLine commandLine = parseCli(args);\n+\n+            // show version and exit if it is requested\n+            if (commandLine.hasOption(\"v\")) {\n+                System.out.println(\"Checkstyle version: \"\n+                        + Main.class.getPackage().getImplementationVersion());\n+            }\n+            else {\n+                // return error is smth is wrong in arguments\n+                final List<String> messages = validateCli(commandLine);\n+                cliViolations = !messages.isEmpty();\n+                if (messages.isEmpty()) {\n+\n+                    // create config helper object\n+                    final CliOptions config = convertCliToPojo(commandLine);\n+                    // run Checker\n+                    errorCounter = runCheckstyle(config);\n+\n+                }\n+                else {\n+                    errorCounter = 1;\n+                    for (String message : messages) {\n+                        System.out.println(message);\n+                    }\n+                }\n+            }\n         }\n-        catch (final ParseException e) {\n-            System.err.println(\"Could not parse parameters: \" + e.getMessage());\n-            e.printStackTrace();\n+        catch (ParseException pex) {\n+            // smth wrong with arguments - print error and manual\n+            cliViolations = true;\n+            errorCounter = 1;\n+            System.out.println(pex.getMessage());\n+            printUsage();\n         }\n-        catch (final Exception e) {\n-            System.err.println(\"Could not execute Checkstyle: \" + e.getMessage());\n-            e.printStackTrace();\n+        catch (Exception ex) {\n+            // smth wrong during processing\n+            errorCounter = 1;\n+            throw ex;\n         }\n         finally {\n-            if (!parseResult) {\n-                usage();\n+            // return exit code base on validation of Checker\n+            if (errorCounter != 0 && !cliViolations) {\n+                System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             // provide proper exit code based on results.\n-            System.exit(parseResult ? 0 : 1);\n+            System.exit(errorCounter);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[UnsupportedEncodingException]",
						"newValue": "[UnsupportedEncodingException, CheckstyleException, FileNotFoundException]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "huge refactoring for CLI Main class. Issue #596\n",
					"commitDate": "2015-05-05, 12:12 PM",
					"commitName": "1a2c318e22a0b2b22ccc76019217c0892fe2d59b",
					"commitAuthor": "Roman Ivanov",
					"commitDateOld": "2015-05-03, 12:27 AM",
					"commitNameOld": "0f543a21fee9dec9b388bb6f2c42540fe8bf02ec",
					"commitAuthorOld": "Michal Kordas",
					"daysBetweenCommits": 2.49,
					"commitsBetweenForRepo": 5,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,23 +1,56 @@\n     public static void main(String... args) throws UnsupportedEncodingException\n+            , CheckstyleException, FileNotFoundException\n     {\n-        boolean parseResult = false;\n+        int errorCounter = 0;\n+        boolean cliViolations = false;\n+\n         try {\n-            processCommandLine(parseCli(args));\n-            parseResult = true;\n+            //parse CLI arguments\n+            final CommandLine commandLine = parseCli(args);\n+\n+            // show version and exit if it is requested\n+            if (commandLine.hasOption(\"v\")) {\n+                System.out.println(\"Checkstyle version: \"\n+                        + Main.class.getPackage().getImplementationVersion());\n+            }\n+            else {\n+                // return error is smth is wrong in arguments\n+                final List<String> messages = validateCli(commandLine);\n+                cliViolations = !messages.isEmpty();\n+                if (messages.isEmpty()) {\n+\n+                    // create config helper object\n+                    final CliOptions config = convertCliToPojo(commandLine);\n+                    // run Checker\n+                    errorCounter = runCheckstyle(config);\n+\n+                }\n+                else {\n+                    errorCounter = 1;\n+                    for (String message : messages) {\n+                        System.out.println(message);\n+                    }\n+                }\n+            }\n         }\n-        catch (final ParseException e) {\n-            System.err.println(\"Could not parse parameters: \" + e.getMessage());\n-            e.printStackTrace();\n+        catch (ParseException pex) {\n+            // smth wrong with arguments - print error and manual\n+            cliViolations = true;\n+            errorCounter = 1;\n+            System.out.println(pex.getMessage());\n+            printUsage();\n         }\n-        catch (final Exception e) {\n-            System.err.println(\"Could not execute Checkstyle: \" + e.getMessage());\n-            e.printStackTrace();\n+        catch (Exception ex) {\n+            // smth wrong during processing\n+            errorCounter = 1;\n+            throw ex;\n         }\n         finally {\n-            if (!parseResult) {\n-                usage();\n+            // return exit code base on validation of Checker\n+            if (errorCounter != 0 && !cliViolations) {\n+                System.out.println(String.format(\"Checkstyle ends with %d errors.\", errorCounter));\n             }\n             // provide proper exit code based on results.\n-            System.exit(parseResult ? 0 : 1);\n+            System.exit(errorCounter);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"c0446a825514ea0279b8c22f633f2c4e3c73dc1f": {
			"type": "Yparameterchange",
			"commitMessage": "Fix PMD violations from UseVarargs rule, issue #999\n\nThe changes are fully backward-compatible. Method with vararg can be invoked both using array and list of parameters.\n",
			"commitDate": "2015-04-29, 6:21 PM",
			"commitName": "c0446a825514ea0279b8c22f633f2c4e3c73dc1f",
			"commitAuthor": "Michal Kordas",
			"commitDateOld": "2015-04-25, 6:30 PM",
			"commitNameOld": "55b266cd92adf7b5e18f84ddee839d63f9330c5b",
			"commitAuthorOld": "Michal Kordas",
			"daysBetweenCommits": 3.99,
			"commitsBetweenForRepo": 19,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,23 +1,23 @@\n-    public static void main(String[] args) throws UnsupportedEncodingException\n+    public static void main(String... args) throws UnsupportedEncodingException\n     {\n         boolean parseResult = false;\n         try {\n             processCommandLine(parseCli(args));\n             parseResult = true;\n         }\n         catch (final ParseException e) {\n             System.err.println(\"Could not parse parameters: \" + e.getMessage());\n             e.printStackTrace();\n         }\n         catch (final Exception e) {\n             System.err.println(\"Could not execute Checkstyle: \" + e.getMessage());\n             e.printStackTrace();\n         }\n         finally {\n             if (!parseResult) {\n                 usage();\n             }\n             // provide proper exit code based on results.\n             System.exit(parseResult ? 0 : 1);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[args-String[]]",
				"newValue": "[args-String]"
			}
		},
		"ab2f93f9bf61816d84154e636d32c81c05854e24": {
			"type": "Ybodychange",
			"commitMessage": "Delete System.exit() and delegate exit control into separate method.\n\nIssue #596\n",
			"commitDate": "2015-04-23, 11:18 PM",
			"commitName": "ab2f93f9bf61816d84154e636d32c81c05854e24",
			"commitAuthor": "Damian Szczepanik",
			"commitDateOld": "2015-04-08, 11:37 PM",
			"commitNameOld": "702a1a957607881e72bb94b3104c2603ef10891f",
			"commitAuthorOld": "Roman Ivanov",
			"daysBetweenCommits": 14.99,
			"commitsBetweenForRepo": 78,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,60 +1,23 @@\n     public static void main(String[] args) throws UnsupportedEncodingException\n     {\n-        // parse the parameters\n-        final CommandLineParser clp = new PosixParser();\n-        CommandLine line = null;\n+        boolean parseResult = false;\n         try {\n-            line = clp.parse(OPTS, args);\n+            processCommandLine(parseCli(args));\n+            parseResult = true;\n         }\n         catch (final ParseException e) {\n-            usage();\n+            System.err.println(\"Could not parse parameters: \" + e.getMessage());\n+            e.printStackTrace();\n         }\n-        assert line != null;\n-\n-        // show version and exit\n-        if (line.hasOption(\"v\")) {\n-            System.out.println(\"Checkstyle version: \"\n-                    + Main.class.getPackage().getImplementationVersion());\n-            System.exit(0);\n+        catch (final Exception e) {\n+            System.err.println(\"Could not execute Checkstyle: \" + e.getMessage());\n+            e.printStackTrace();\n         }\n-\n-        // setup the properties\n-        final Properties props =\n-            line.hasOption(\"p\")\n-                ? loadProperties(new File(line.getOptionValue(\"p\")))\n-                : System.getProperties();\n-\n-        // ensure a config file is specified\n-        if (!line.hasOption(\"c\")) {\n-            System.out.println(\"Must specify a config XML file.\");\n-            usage();\n-        }\n-\n-        final Configuration config = loadConfig(line, props);\n-\n-        // setup the output stream\n-        OutputStream out = null;\n-        boolean closeOut = false;\n-        if (line.hasOption(\"o\")) {\n-            final String fname = line.getOptionValue(\"o\");\n-            try {\n-                out = new FileOutputStream(fname);\n-                closeOut = true;\n+        finally {\n+            if (!parseResult) {\n+                usage();\n             }\n-            catch (final FileNotFoundException e) {\n-                System.out.println(\"Could not find file: '\" + fname + \"'\");\n-                System.exit(1);\n-            }\n+            // provide proper exit code based on results.\n+            System.exit(parseResult ? 0 : 1);\n         }\n-        else {\n-            out = System.out;\n-            closeOut = false;\n-        }\n-\n-        final AuditListener listener = createListener(line, out, closeOut);\n-        final List<File> files = getFilesToProcess(line);\n-        final Checker c = createChecker(config, listener);\n-        final int numErrs = c.process(files);\n-        c.destroy();\n-        System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"702a1a957607881e72bb94b3104c2603ef10891f": {
			"type": "Yexceptionschange",
			"commitMessage": "fix for Findbugs violation DM_DEFAULT_ENCODING. Issue #778\n",
			"commitDate": "2015-04-08, 11:37 PM",
			"commitName": "702a1a957607881e72bb94b3104c2603ef10891f",
			"commitAuthor": "Roman Ivanov",
			"commitDateOld": "2015-03-21, 9:17 AM",
			"commitNameOld": "48eee721d989ee5933fe6849a2f693c28a9385c3",
			"commitAuthorOld": "Michal Kordas",
			"daysBetweenCommits": 18.6,
			"commitsBetweenForRepo": 65,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,60 +1,60 @@\n-    public static void main(String[] args)\n+    public static void main(String[] args) throws UnsupportedEncodingException\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, args);\n         }\n         catch (final ParseException e) {\n             usage();\n         }\n         assert line != null;\n \n         // show version and exit\n         if (line.hasOption(\"v\")) {\n             System.out.println(\"Checkstyle version: \"\n                     + Main.class.getPackage().getImplementationVersion());\n             System.exit(0);\n         }\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         final Configuration config = loadConfig(line, props);\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (final FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n         final AuditListener listener = createListener(line, out, closeOut);\n         final List<File> files = getFilesToProcess(line);\n         final Checker c = createChecker(config, listener);\n         final int numErrs = c.process(files);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[]",
				"newValue": "[UnsupportedEncodingException]"
			}
		},
		"b9a1bec65f9eec7b96add7336dfcca4bf284e479": {
			"type": "Ybodychange",
			"commitMessage": "Removed printStackTrace(...) from whole code, issue #660\n",
			"commitDate": "2015-03-16, 11:46 PM",
			"commitName": "b9a1bec65f9eec7b96add7336dfcca4bf284e479",
			"commitAuthor": "alexkravin",
			"commitDateOld": "2015-03-15, 4:17 PM",
			"commitNameOld": "ca1c33e3112d9217e89eec82bbcd589381d48715",
			"commitAuthorOld": "Michal Kordas",
			"daysBetweenCommits": 1.31,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,61 +1,60 @@\n     public static void main(String[] args)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, args);\n         }\n         catch (final ParseException e) {\n-            e.printStackTrace();\n             usage();\n         }\n         assert line != null;\n \n         // show version and exit\n         if (line.hasOption(\"v\")) {\n             System.out.println(\"Checkstyle version: \"\n                     + Main.class.getPackage().getImplementationVersion());\n             System.exit(0);\n         }\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         final Configuration config = loadConfig(line, props);\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (final FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n         final AuditListener listener = createListener(line, out, closeOut);\n         final List<File> files = getFilesToProcess(line);\n         final Checker c = createChecker(config, listener);\n         final int numErrs = c.process(files);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Prefixes, checkstyle, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java\n",
			"commitDate": "2015-01-19, 7:38 AM",
			"commitName": "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
			"commitAuthor": "alexkravin",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Prefixes, checkstyle, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java\n",
					"commitDate": "2015-01-19, 7:38 AM",
					"commitName": "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
					"commitAuthor": "alexkravin",
					"commitDateOld": "2014-12-29, 3:41 PM",
					"commitNameOld": "d91236c5ca052899bfd21ac5f378dcaf8e864750",
					"commitAuthorOld": "ychulovskyy",
					"daysBetweenCommits": 20.66,
					"commitsBetweenForRepo": 49,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,61 +1,61 @@\n-    public static void main(String[] aArgs)\n+    public static void main(String[] args)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n-            line = clp.parse(OPTS, aArgs);\n+            line = clp.parse(OPTS, args);\n         }\n         catch (final ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n         assert line != null;\n \n         // show version and exit\n         if (line.hasOption(\"v\")) {\n             System.out.println(\"Checkstyle version: \"\n                     + Main.class.getPackage().getImplementationVersion());\n             System.exit(0);\n         }\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         final Configuration config = loadConfig(line, props);\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (final FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n         final AuditListener listener = createListener(line, out, closeOut);\n         final List<File> files = getFilesToProcess(line);\n         final Checker c = createChecker(config, listener);\n         final int numErrs = c.process(files);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[aArgs-String[]]",
						"newValue": "[args-String[]]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Prefixes, checkstyle, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java\n",
					"commitDate": "2015-01-19, 7:38 AM",
					"commitName": "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
					"commitAuthor": "alexkravin",
					"commitDateOld": "2014-12-29, 3:41 PM",
					"commitNameOld": "d91236c5ca052899bfd21ac5f378dcaf8e864750",
					"commitAuthorOld": "ychulovskyy",
					"daysBetweenCommits": 20.66,
					"commitsBetweenForRepo": 49,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,61 +1,61 @@\n-    public static void main(String[] aArgs)\n+    public static void main(String[] args)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n-            line = clp.parse(OPTS, aArgs);\n+            line = clp.parse(OPTS, args);\n         }\n         catch (final ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n         assert line != null;\n \n         // show version and exit\n         if (line.hasOption(\"v\")) {\n             System.out.println(\"Checkstyle version: \"\n                     + Main.class.getPackage().getImplementationVersion());\n             System.exit(0);\n         }\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         final Configuration config = loadConfig(line, props);\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (final FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n         final AuditListener listener = createListener(line, out, closeOut);\n         final List<File> files = getFilesToProcess(line);\n         final Checker c = createChecker(config, listener);\n         final int numErrs = c.process(files);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"f85edb712767e01dafb8bf4a4a07d0d0ed3e9a38": {
			"type": "Ybodychange",
			"commitMessage": "#9 -v CLI flag for querying the installed Checkstyle version\n",
			"commitDate": "2014-11-21, 12:52 PM",
			"commitName": "f85edb712767e01dafb8bf4a4a07d0d0ed3e9a38",
			"commitAuthor": "ychulovskyy",
			"commitDateOld": "2014-03-04, 10:18 AM",
			"commitNameOld": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
			"commitAuthorOld": "Ivan Sopov",
			"daysBetweenCommits": 262.11,
			"commitsBetweenForRepo": 268,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,54 +1,60 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, aArgs);\n         }\n         catch (final ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n         assert line != null;\n \n+        // show version and exit\n+        if (line.hasOption(\"v\")) {\n+            System.out.println(\"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion());\n+            System.exit(0);\n+        }\n+\n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         final Configuration config = loadConfig(line, props);\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (final FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n         final AuditListener listener = createListener(line, out, closeOut);\n         final List<File> files = getFilesToProcess(line);\n         final Checker c = createChecker(config, listener);\n         final int numErrs = c.process(files);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f1efb27670a93690577f1bae17fc9dcbd88a795d": {
			"type": "Yfilerename",
			"commitMessage": "moving to standard directory layout\n",
			"commitDate": "2014-03-04, 10:18 AM",
			"commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
			"commitAuthor": "Ivan Sopov",
			"commitDateOld": "2014-02-26, 11:35 PM",
			"commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
			"commitAuthorOld": "Andrew Gaul",
			"daysBetweenCommits": 5.45,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/Main.java",
				"newPath": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java"
			}
		},
		"fe9057366308642868c25d427c3ee94411b37170": {
			"type": "Ybodychange",
			"commitMessage": "Apply patch #1914806 for PackageNamesLoader from Lars Koedderitzsch.\n",
			"commitDate": "2008-04-07, 7:35 PM",
			"commitName": "fe9057366308642868c25d427c3ee94411b37170",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2008-01-12, 7:47 PM",
			"commitNameOld": "5a7e221b757e91d49be1aea105eb4b839e653fbd",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 85.95,
			"commitsBetweenForRepo": 27,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,60 +1,54 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, aArgs);\n         }\n         catch (final ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n         assert line != null;\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         final Configuration config = loadConfig(line, props);\n \n-        //Load the set of package names\n-        ModuleFactory moduleFactory = null;\n-        if (line.hasOption(\"n\")) {\n-            moduleFactory = loadPackages(line);\n-        }\n-\n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (final FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n         final AuditListener listener = createListener(line, out, closeOut);\n         final List<File> files = getFilesToProcess(line);\n-        final Checker c = createChecker(config, moduleFactory, listener);\n+        final Checker c = createChecker(config, listener);\n         final int numErrs = c.process(files);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f38d8abd42c3e824635e542e6031b3da1997c02e": {
			"type": "Ybodychange",
			"commitMessage": "Removed a native array in favour of a List<File> -- was it worth it??\n\nAdded @Override where possible -- did this as I got bitten by a subtle bug when making the first change. The @Override would have prevented it.\n",
			"commitDate": "2007-12-19, 11:21 PM",
			"commitName": "f38d8abd42c3e824635e542e6031b3da1997c02e",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2007-12-15, 3:28 AM",
			"commitNameOld": "e50e1fcd1c17ba1f73d11df38382907cc163a1d1",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 4.83,
			"commitsBetweenForRepo": 20,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,63 +1,60 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, aArgs);\n         }\n         catch (final ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n         assert line != null;\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         final Configuration config = loadConfig(line, props);\n \n         //Load the set of package names\n         ModuleFactory moduleFactory = null;\n         if (line.hasOption(\"n\")) {\n             moduleFactory = loadPackages(line);\n         }\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (final FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n         final AuditListener listener = createListener(line, out, closeOut);\n         final List<File> files = getFilesToProcess(line);\n         final Checker c = createChecker(config, moduleFactory, listener);\n-\n-        final File[] processedFiles = new File[files.size()];\n-        files.toArray(processedFiles);\n-        final int numErrs = c.process(processedFiles);\n+        final int numErrs = c.process(files);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f1afaf83f39b83cc3bd07a2388448b262652a76b": {
			"type": "Ybodychange",
			"commitMessage": "Finish of adding generics.\n",
			"commitDate": "2007-12-15, 1:14 AM",
			"commitName": "f1afaf83f39b83cc3bd07a2388448b262652a76b",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2007-01-27, 7:51 AM",
			"commitNameOld": "1efc394250b8f1c79bd7f8344b738a7d13396ed3",
			"commitAuthorOld": "Lars Kühne",
			"daysBetweenCommits": 321.72,
			"commitsBetweenForRepo": 33,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,63 +1,63 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, aArgs);\n         }\n         catch (final ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n         assert line != null;\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         final Configuration config = loadConfig(line, props);\n \n         //Load the set of package names\n         ModuleFactory moduleFactory = null;\n         if (line.hasOption(\"n\")) {\n             moduleFactory = loadPackages(line);\n         }\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (final FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n         final AuditListener listener = createListener(line, out, closeOut);\n-        final List files = getFilesToProcess(line);\n+        final List<File> files = getFilesToProcess(line);\n         final Checker c = createChecker(config, moduleFactory, listener);\n \n         final File[] processedFiles = new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs = c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7dfcb39a0e377bd03a5c0b87dace9c07de9b02d0": {
			"type": "Ybodychange",
			"commitMessage": "Fix up warning about line possibly being null.\n",
			"commitDate": "2006-07-06, 9:51 PM",
			"commitName": "7dfcb39a0e377bd03a5c0b87dace9c07de9b02d0",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2006-07-06, 9:44 PM",
			"commitNameOld": "35d1673788bbbac8263fdb69275dc6a63b095a24",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,62 +1,63 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, aArgs);\n         }\n         catch (final ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n+        assert line != null;\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         final Configuration config = loadConfig(line, props);\n \n         //Load the set of package names\n         ModuleFactory moduleFactory = null;\n         if (line.hasOption(\"n\")) {\n             moduleFactory = loadPackages(line);\n         }\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (final FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n         final AuditListener listener = createListener(line, out, closeOut);\n         final List files = getFilesToProcess(line);\n         final Checker c = createChecker(config, moduleFactory, listener);\n \n         final File[] processedFiles = new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs = c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"35d1673788bbbac8263fdb69275dc6a63b095a24": {
			"type": "Ybodychange",
			"commitMessage": "Making local variables final where possible.\n",
			"commitDate": "2006-07-06, 9:44 PM",
			"commitName": "35d1673788bbbac8263fdb69275dc6a63b095a24",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2005-01-09, 3:50 AM",
			"commitNameOld": "0d887cde58e54d920644ee543dab346b93e8aae9",
			"commitAuthorOld": "Lars Kühne",
			"daysBetweenCommits": 543.7,
			"commitsBetweenForRepo": 275,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,62 +1,62 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, aArgs);\n         }\n-        catch (ParseException e) {\n+        catch (final ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         final Configuration config = loadConfig(line, props);\n \n         //Load the set of package names\n         ModuleFactory moduleFactory = null;\n         if (line.hasOption(\"n\")) {\n             moduleFactory = loadPackages(line);\n         }\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n-            catch (FileNotFoundException e) {\n+            catch (final FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n         final AuditListener listener = createListener(line, out, closeOut);\n         final List files = getFilesToProcess(line);\n         final Checker c = createChecker(config, moduleFactory, listener);\n \n         final File[] processedFiles = new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs = c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dd477210aefeabb265e105a9fe8120c8310605e8": {
			"type": "Ybodychange",
			"commitMessage": "Custom listeners can be incorported as config modules,\nnot command line arguments and ant task elements.\n",
			"commitDate": "2003-07-18, 5:31 AM",
			"commitName": "dd477210aefeabb265e105a9fe8120c8310605e8",
			"commitAuthor": "Rick Giles",
			"commitDateOld": "2003-06-27, 6:10 AM",
			"commitNameOld": "784842200f5307597d721ba0190c912cfab1b77f",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 20.97,
			"commitsBetweenForRepo": 82,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,63 +1,62 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         final Configuration config = loadConfig(line, props);\n \n         //Load the set of package names\n         ModuleFactory moduleFactory = null;\n         if (line.hasOption(\"n\")) {\n             moduleFactory = loadPackages(line);\n         }\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n         final AuditListener listener = createListener(line, out, closeOut);\n         final List files = getFilesToProcess(line);\n         final Checker c = createChecker(config, moduleFactory, listener);\n-        addCustomListeners(c, line);\n \n         final File[] processedFiles = new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs = c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"784842200f5307597d721ba0190c912cfab1b77f": {
			"type": "Ybodychange",
			"commitMessage": "Refactored, that was really ugly code I had written.\n",
			"commitDate": "2003-06-27, 6:10 AM",
			"commitName": "784842200f5307597d721ba0190c912cfab1b77f",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2003-06-27, 5:04 AM",
			"commitNameOld": "768256c32a3e397f837ce27602bda49e3c5e0062",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 0.05,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,148 +1,63 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n-        // Load the config file\n-        Configuration config = null;\n-        try {\n-            config = ConfigurationLoader.loadConfiguration(\n-                    line.getOptionValue(\"c\"), new PropertiesExpander(props));\n-        }\n-        catch (CheckstyleException e) {\n-            System.out.println(\"Error loading configuration file\");\n-            e.printStackTrace(System.out);\n-            System.exit(1);\n-        }\n+        final Configuration config = loadConfig(line, props);\n \n         //Load the set of package names\n         ModuleFactory moduleFactory = null;\n         if (line.hasOption(\"n\")) {\n-            try {\n-                moduleFactory = PackageNamesLoader.loadModuleFactory(\n-                    line.getOptionValue(\"n\"));\n-            }\n-            catch (CheckstyleException e) {\n-                System.out.println(\"Error loading package names file\");\n-                e.printStackTrace(System.out);\n-                System.exit(1);\n-            }\n+            moduleFactory = loadPackages(line);\n         }\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n-        // create the appropriate listener\n-        final String format =\n-            line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n-\n-        AuditListener listener = null;\n-        if (\"xml\".equals(format)) {\n-            listener = new XMLLogger(out, closeOut);\n-        }\n-        else if (\"plain\".equals(format)) {\n-            listener = new DefaultLogger(out, closeOut);\n-        }\n-        else {\n-            System.out.println(\"Invalid format: (\" + format\n-                               + \"). Must be 'plain' or 'xml'.\");\n-            usage();\n-        }\n-\n-        // Get all the Java files\n-        final List files = new LinkedList();\n-        if (line.hasOption(\"r\")) {\n-            final String[] values = line.getOptionValues(\"r\");\n-            for (int i = 0; i < values.length; i++) {\n-                traverse(new File(values[i]), files);\n-            }\n-        }\n-\n-        final String[] remainingArgs = line.getArgs();\n-        for (int i = 0; i < remainingArgs.length; i++) {\n-            files.add(new File(remainingArgs[i]));\n-        }\n-\n-        if (files.isEmpty()) {\n-            System.out.println(\"Must specify files to process\");\n-            usage();\n-        }\n-\n-        // create the checker\n-        Checker c = null;\n-        try {\n-            c = new Checker();\n-            c.setModuleFactory(moduleFactory);\n-            c.configure(config);\n-            c.addListener(listener);\n-        }\n-        catch (Exception e) {\n-            System.out.println(\"Unable to create Checker: \"\n-                               + e.getMessage());\n-            e.printStackTrace(System.out);\n-            System.exit(1);\n-        }\n-\n-        // add custom listeners\n-        if (line.hasOption(\"l\")) {\n-            final String listeners = line.getOptionValue(\"l\");\n-            final StringTokenizer t = new StringTokenizer(listeners, \",\");\n-            while (t.hasMoreTokens()) {\n-                final String className = t.nextToken();\n-                AuditListener customListener = null;\n-                try {\n-                    customListener =\n-                        (AuditListener) Class.forName(className).newInstance();\n-                }\n-                catch (Exception e) {\n-                    System.out.println(\"Unable to create listener '\"\n-                        + className + \"': \" + e);\n-                    e.printStackTrace(System.out);\n-                    System.exit(1);\n-                }\n-                c.addListener(customListener);\n-            }\n-        }\n+        final AuditListener listener = createListener(line, out, closeOut);\n+        final List files = getFilesToProcess(line);\n+        final Checker c = createChecker(config, moduleFactory, listener);\n+        addCustomListeners(c, line);\n \n         final File[] processedFiles = new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs = c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f2b01a44a216e88957eb6cb22e4b0e39429a6c84": {
			"type": "Ybodychange",
			"commitMessage": "Added custom listener feature\n",
			"commitDate": "2003-05-27, 11:33 AM",
			"commitName": "f2b01a44a216e88957eb6cb22e4b0e39429a6c84",
			"commitAuthor": "Rick Giles",
			"commitDateOld": "2003-05-26, 3:52 PM",
			"commitNameOld": "7dd1ab24d1a75687f426cb43a6e70d18d435b0a7",
			"commitAuthorOld": "Rick Giles",
			"daysBetweenCommits": 0.82,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,127 +1,148 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n         Configuration config = null;\n         try {\n             config = ConfigurationLoader.loadConfiguration(\n                     line.getOptionValue(\"c\"), new PropertiesExpander(props));\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         //Load the set of package names\n         ModuleFactory moduleFactory = null;\n         if (line.hasOption(\"n\")) {\n             try {\n                 moduleFactory = PackageNamesLoader.loadModuleFactory(\n                     line.getOptionValue(\"n\"));\n             }\n             catch (CheckstyleException e) {\n                 System.out.println(\"Error loading package names file\");\n                 e.printStackTrace(System.out);\n                 System.exit(1);\n             }\n         }\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n         // create the appropriate listener\n         final String format =\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener = null;\n         if (\"xml\".equals(format)) {\n             listener = new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener = new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be 'plain' or 'xml'.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files = new LinkedList();\n         if (line.hasOption(\"r\")) {\n             final String[] values = line.getOptionValues(\"r\");\n             for (int i = 0; i < values.length; i++) {\n                 traverse(new File(values[i]), files);\n             }\n         }\n \n         final String[] remainingArgs = line.getArgs();\n         for (int i = 0; i < remainingArgs.length; i++) {\n             files.add(new File(remainingArgs[i]));\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n         // create the checker\n         Checker c = null;\n         try {\n             c = new Checker();\n             c.setModuleFactory(moduleFactory);\n             c.configure(config);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n+        // add custom listeners\n+        if (line.hasOption(\"l\")) {\n+            final String listeners = line.getOptionValue(\"l\");\n+            final StringTokenizer t = new StringTokenizer(listeners, \",\");\n+            while (t.hasMoreTokens()) {\n+                final String className = t.nextToken();\n+                AuditListener customListener = null;\n+                try {\n+                    customListener =\n+                        (AuditListener) Class.forName(className).newInstance();\n+                }\n+                catch (Exception e) {\n+                    System.out.println(\"Unable to create listener '\"\n+                        + className + \"': \" + e);\n+                    e.printStackTrace(System.out);\n+                    System.exit(1);\n+                }\n+                c.addListener(customListener);\n+            }\n+        }\n+\n         final File[] processedFiles = new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs = c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"47802121745d9113b54cdb2d8ccef59e74ce3e72": {
			"type": "Ybodychange",
			"commitMessage": "use a PropertyResolver interface instead of using Properties directly\n",
			"commitDate": "2003-02-23, 5:29 AM",
			"commitName": "47802121745d9113b54cdb2d8ccef59e74ce3e72",
			"commitAuthor": "Lars Kühne",
			"commitDateOld": "2003-02-15, 5:13 AM",
			"commitNameOld": "00fb7f0c1852eb015933c7c121284597de29caad",
			"commitAuthorOld": "Lars Kühne",
			"daysBetweenCommits": 8.01,
			"commitsBetweenForRepo": 26,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,127 +1,127 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n         Configuration config = null;\n         try {\n             config = ConfigurationLoader.loadConfiguration(\n-                    line.getOptionValue(\"c\"), props);\n+                    line.getOptionValue(\"c\"), new PropertiesExpander(props));\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         //Load the set of package names\n         ModuleFactory moduleFactory = null;\n         if (line.hasOption(\"n\")) {\n             try {\n                 moduleFactory = PackageNamesLoader.loadModuleFactory(\n                     line.getOptionValue(\"n\"));\n             }\n             catch (CheckstyleException e) {\n                 System.out.println(\"Error loading package names file\");\n                 e.printStackTrace(System.out);\n                 System.exit(1);\n             }\n         }\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n         // create the appropriate listener\n         final String format =\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener = null;\n         if (\"xml\".equals(format)) {\n             listener = new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener = new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be 'plain' or 'xml'.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files = new LinkedList();\n         if (line.hasOption(\"r\")) {\n             final String[] values = line.getOptionValues(\"r\");\n             for (int i = 0; i < values.length; i++) {\n                 traverse(new File(values[i]), files);\n             }\n         }\n \n         final String[] remainingArgs = line.getArgs();\n         for (int i = 0; i < remainingArgs.length; i++) {\n             files.add(new File(remainingArgs[i]));\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n         // create the checker\n         Checker c = null;\n         try {\n             c = new Checker();\n             c.setModuleFactory(moduleFactory);\n             c.configure(config);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final File[] processedFiles = new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs = c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"00fb7f0c1852eb015933c7c121284597de29caad": {
			"type": "Ybodychange",
			"commitMessage": "FileSetChecks are now responsible for filtering\nout the files they are not interested in, as discussed\non the checkstyle-devel list\n",
			"commitDate": "2003-02-15, 5:13 AM",
			"commitName": "00fb7f0c1852eb015933c7c121284597de29caad",
			"commitAuthor": "Lars Kühne",
			"commitDateOld": "2003-02-04, 4:45 AM",
			"commitNameOld": "c13f6dd07d38a702143f7f78f74c59548e1f8453",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 11.02,
			"commitsBetweenForRepo": 16,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,131 +1,127 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n         Configuration config = null;\n         try {\n             config = ConfigurationLoader.loadConfiguration(\n                     line.getOptionValue(\"c\"), props);\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         //Load the set of package names\n         ModuleFactory moduleFactory = null;\n         if (line.hasOption(\"n\")) {\n             try {\n                 moduleFactory = PackageNamesLoader.loadModuleFactory(\n                     line.getOptionValue(\"n\"));\n             }\n             catch (CheckstyleException e) {\n                 System.out.println(\"Error loading package names file\");\n                 e.printStackTrace(System.out);\n                 System.exit(1);\n             }\n         }\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n-        // Get the file extension\n-        final String javaExtn =\n-            \".\" + (line.hasOption(\"e\") ? line.getOptionValue(\"e\") : \"java\");\n-\n         // create the appropriate listener\n         final String format =\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener = null;\n         if (\"xml\".equals(format)) {\n             listener = new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener = new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be 'plain' or 'xml'.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files = new LinkedList();\n         if (line.hasOption(\"r\")) {\n             final String[] values = line.getOptionValues(\"r\");\n             for (int i = 0; i < values.length; i++) {\n-                traverse(new File(values[i]), files, javaExtn);\n+                traverse(new File(values[i]), files);\n             }\n         }\n \n         final String[] remainingArgs = line.getArgs();\n         for (int i = 0; i < remainingArgs.length; i++) {\n             files.add(new File(remainingArgs[i]));\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n         // create the checker\n         Checker c = null;\n         try {\n             c = new Checker();\n             c.setModuleFactory(moduleFactory);\n             c.configure(config);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final File[] processedFiles = new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs = c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2820c1d09d418935f7e7c410274f86da173eb96b": {
			"type": "Ybodychange",
			"commitMessage": "rfe-652294: added support for specifying file extension for Java files\n",
			"commitDate": "2003-02-01, 6:29 PM",
			"commitName": "2820c1d09d418935f7e7c410274f86da173eb96b",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2002-12-15, 11:26 PM",
			"commitNameOld": "88e89a138aa39f50f7642106cde6568f6e07783f",
			"commitAuthorOld": "Lars Kühne",
			"daysBetweenCommits": 47.79,
			"commitsBetweenForRepo": 155,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,127 +1,131 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n         Configuration config = null;\n         try {\n             config = ConfigurationLoader.loadConfiguration(\n                     line.getOptionValue(\"c\"), props);\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n         \n         //Load the set of package names\n         ModuleFactory moduleFactory = null;\n         if (line.hasOption(\"n\")) {\n             try {\n                 moduleFactory = PackageNamesLoader.loadModuleFactory(\n                     line.getOptionValue(\"n\"));\n             }\n             catch (CheckstyleException e) {\n                 System.out.println(\"Error loading package names file\");\n                 e.printStackTrace(System.out);\n                 System.exit(1);\n             }\n         }\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n+        // Get the file extension\n+        final String javaExtn =\n+            \".\" + (line.hasOption(\"e\") ? line.getOptionValue(\"e\") : \"java\");\n+        \n         // create the appropriate listener\n         final String format =\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener = null;\n         if (\"xml\".equals(format)) {\n             listener = new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener = new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be 'plain' or 'xml'.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files = new LinkedList();\n         if (line.hasOption(\"r\")) {\n             final String[] values = line.getOptionValues(\"r\");\n             for (int i = 0; i < values.length; i++) {\n-                traverse(new File(values[i]), files);\n+                traverse(new File(values[i]), files, javaExtn);\n             }\n         }\n \n         final String[] remainingArgs = line.getArgs();\n         for (int i = 0; i < remainingArgs.length; i++) {\n             files.add(new File(remainingArgs[i]));\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n         // create the checker\n         Checker c = null;\n         try {\n             c = new Checker();\n             c.setModuleFactory(moduleFactory);\n             c.configure(config);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final File[] processedFiles = new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs = c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"88e89a138aa39f50f7642106cde6568f6e07783f": {
			"type": "Ybodychange",
			"commitMessage": "Changed implementation of module name resolution from inheritance to delegation approach\n",
			"commitDate": "2002-12-15, 11:26 PM",
			"commitName": "88e89a138aa39f50f7642106cde6568f6e07783f",
			"commitAuthor": "Lars Kühne",
			"commitDateOld": "2002-12-05, 11:54 AM",
			"commitNameOld": "16ba5b35f9f346e7cea294afaad7f9211605ecaa",
			"commitAuthorOld": "Rick Giles",
			"daysBetweenCommits": 10.48,
			"commitsBetweenForRepo": 123,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,127 +1,127 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n         Configuration config = null;\n         try {\n             config = ConfigurationLoader.loadConfiguration(\n                     line.getOptionValue(\"c\"), props);\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n         \n         //Load the set of package names\n-        String[] packageNames = null;\n+        ModuleFactory moduleFactory = null;\n         if (line.hasOption(\"n\")) {\n             try {\n-                packageNames = PackageNamesLoader.loadPackageNames(\n+                moduleFactory = PackageNamesLoader.loadModuleFactory(\n                     line.getOptionValue(\"n\"));\n             }\n             catch (CheckstyleException e) {\n                 System.out.println(\"Error loading package names file\");\n                 e.printStackTrace(System.out);\n                 System.exit(1);\n             }\n         }\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n         // create the appropriate listener\n         final String format =\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener = null;\n         if (\"xml\".equals(format)) {\n             listener = new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener = new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be 'plain' or 'xml'.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files = new LinkedList();\n         if (line.hasOption(\"r\")) {\n             final String[] values = line.getOptionValues(\"r\");\n             for (int i = 0; i < values.length; i++) {\n                 traverse(new File(values[i]), files);\n             }\n         }\n \n         final String[] remainingArgs = line.getArgs();\n         for (int i = 0; i < remainingArgs.length; i++) {\n             files.add(new File(remainingArgs[i]));\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n         // create the checker\n         Checker c = null;\n         try {\n             c = new Checker();\n-            c.setPackageNames(packageNames);\n+            c.setModuleFactory(moduleFactory);\n             c.configure(config);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final File[] processedFiles = new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs = c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"16ba5b35f9f346e7cea294afaad7f9211605ecaa": {
			"type": "Ybodychange",
			"commitMessage": "modified for config XML and mapping names to full class names - see\nposting to checkstyle-devel@lists.sourceforge.net\n",
			"commitDate": "2002-12-05, 11:54 AM",
			"commitName": "16ba5b35f9f346e7cea294afaad7f9211605ecaa",
			"commitAuthor": "Rick Giles",
			"commitDateOld": "2002-11-30, 11:29 AM",
			"commitNameOld": "6ffc8dd26075456b055ffcd35d3915c23049bfbb",
			"commitAuthorOld": "Lars Kühne",
			"daysBetweenCommits": 5.02,
			"commitsBetweenForRepo": 45,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,112 +1,127 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n         Configuration config = null;\n         try {\n             config = ConfigurationLoader.loadConfiguration(\n                     line.getOptionValue(\"c\"), props);\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n+        \n+        //Load the set of package names\n+        String[] packageNames = null;\n+        if (line.hasOption(\"n\")) {\n+            try {\n+                packageNames = PackageNamesLoader.loadPackageNames(\n+                    line.getOptionValue(\"n\"));\n+            }\n+            catch (CheckstyleException e) {\n+                System.out.println(\"Error loading package names file\");\n+                e.printStackTrace(System.out);\n+                System.exit(1);\n+            }\n+        }\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n         // create the appropriate listener\n         final String format =\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener = null;\n         if (\"xml\".equals(format)) {\n             listener = new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener = new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be 'plain' or 'xml'.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files = new LinkedList();\n         if (line.hasOption(\"r\")) {\n             final String[] values = line.getOptionValues(\"r\");\n             for (int i = 0; i < values.length; i++) {\n                 traverse(new File(values[i]), files);\n             }\n         }\n \n         final String[] remainingArgs = line.getArgs();\n         for (int i = 0; i < remainingArgs.length; i++) {\n             files.add(new File(remainingArgs[i]));\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n         // create the checker\n         Checker c = null;\n         try {\n             c = new Checker();\n+            c.setPackageNames(packageNames);\n             c.configure(config);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final File[] processedFiles = new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs = c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6ffc8dd26075456b055ffcd35d3915c23049bfbb": {
			"type": "Ybodychange",
			"commitMessage": "avalonization\n",
			"commitDate": "2002-11-30, 11:29 AM",
			"commitName": "6ffc8dd26075456b055ffcd35d3915c23049bfbb",
			"commitAuthor": "Lars Kühne",
			"commitDateOld": "2002-11-30, 9:58 AM",
			"commitNameOld": "085befb3adfaed30db6623bfc04fa7b1e8755d3a",
			"commitAuthorOld": "Rick Giles",
			"daysBetweenCommits": 0.06,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,138 +1,112 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n-//        CheckConfiguration[] checkConfigs = null;\n-//        try {\n-//            checkConfigs =\n-//                ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n-//        }\n-//        catch (CheckstyleException e) {\n-//            System.out.println(\"Error loading configuration file\");\n-//            e.printStackTrace(System.out);\n-//            System.exit(1);\n-//        }\n-\n-        // Load the config file\n         Configuration config = null;\n         try {\n-            config =\n-                ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"),\n-                                                      props);\n+            config = ConfigurationLoader.loadConfiguration(\n+                    line.getOptionValue(\"c\"), props);\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n         // create the appropriate listener\n         final String format =\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener = null;\n         if (\"xml\".equals(format)) {\n             listener = new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener = new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be 'plain' or 'xml'.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files = new LinkedList();\n         if (line.hasOption(\"r\")) {\n             final String[] values = line.getOptionValues(\"r\");\n             for (int i = 0; i < values.length; i++) {\n                 traverse(new File(values[i]), files);\n             }\n         }\n \n         final String[] remainingArgs = line.getArgs();\n         for (int i = 0; i < remainingArgs.length; i++) {\n             files.add(new File(remainingArgs[i]));\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n-//        // create the checker\n-//        Checker c = null;\n-//        try {\n-//            c = new Checker(new GlobalProperties(props, System.out),\n-//                            checkConfigs);\n-//            c.addListener(listener);\n-//        }\n-//        catch (Exception e) {\n-//            System.out.println(\"Unable to create Checker: \"\n-//                               + e.getMessage());\n-//            e.printStackTrace(System.out);\n-//            System.exit(1);\n-//        }\n-\n         // create the checker\n         Checker c = null;\n         try {\n-            c = new Checker(config);\n+            c = new Checker();\n+            c.configure(config);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final File[] processedFiles = new File[files.size()];\n         files.toArray(processedFiles);\n         final int numErrs = c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"822384a711290170148b43b5ae390dd4e8cfaf4f": {
			"type": "Ybodychange",
			"commitMessage": "Changed signature of Checker.process(String[]) to process(File[])\n\nThis is a step towards making TreeWalker a FileSetCheck, next some\nmethods need to be moved around.\n",
			"commitDate": "2002-11-16, 11:48 PM",
			"commitName": "822384a711290170148b43b5ae390dd4e8cfaf4f",
			"commitAuthor": "Lars Kühne",
			"commitDateOld": "2002-11-16, 12:38 PM",
			"commitNameOld": "2debda611fe487021711aa4acce56651799a778f",
			"commitAuthorOld": "Rick Giles",
			"daysBetweenCommits": 0.47,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,137 +1,138 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n //        CheckConfiguration[] checkConfigs = null;\n //        try {\n //            checkConfigs =\n //                ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n //        }\n //        catch (CheckstyleException e) {\n //            System.out.println(\"Error loading configuration file\");\n //            e.printStackTrace(System.out);\n //            System.exit(1);\n //        }\n \n         // Load the config file\n         Configuration config = null;\n         try {\n             config =\n                 ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"),\n                                                       props);\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n         // create the appropriate listener\n         final String format =\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener = null;\n         if (\"xml\".equals(format)) {\n             listener = new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener = new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be 'plain' or 'xml'.\");\n             usage();\n         }\n \n         // Get all the Java files\n-        final List files = new ArrayList();\n+        final List files = new LinkedList();\n         if (line.hasOption(\"r\")) {\n             final String[] values = line.getOptionValues(\"r\");\n             for (int i = 0; i < values.length; i++) {\n                 traverse(new File(values[i]), files);\n             }\n         }\n \n         final String[] remainingArgs = line.getArgs();\n         for (int i = 0; i < remainingArgs.length; i++) {\n-            files.add(remainingArgs[i]);\n+            files.add(new File(remainingArgs[i]));\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n //        // create the checker\n //        Checker c = null;\n //        try {\n //            c = new Checker(new GlobalProperties(props, System.out),\n //                            checkConfigs);\n //            c.addListener(listener);\n //        }\n //        catch (Exception e) {\n //            System.out.println(\"Unable to create Checker: \"\n //                               + e.getMessage());\n //            e.printStackTrace(System.out);\n //            System.exit(1);\n //        }\n \n         // create the checker\n         Checker c = null;\n         try {\n             c = new Checker(config);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n-        final int numErrs =\n-            c.process((String[]) files.toArray(new String[files.size()]));\n+        final File[] processedFiles = new File[files.size()];\n+        files.toArray(processedFiles);\n+        final int numErrs = c.process(processedFiles);\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2debda611fe487021711aa4acce56651799a778f": {
			"type": "Ybodychange",
			"commitMessage": "Added overriding global properties\nNeeds testing, especially in ant with CheckstyleTask.\n",
			"commitDate": "2002-11-16, 12:38 PM",
			"commitName": "2debda611fe487021711aa4acce56651799a778f",
			"commitAuthor": "Rick Giles",
			"commitDateOld": "2002-11-15, 11:18 AM",
			"commitNameOld": "3c0608f33a6c41cf96056c52ae99070cbe5062d5",
			"commitAuthorOld": "Rick Giles",
			"daysBetweenCommits": 1.06,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,136 +1,137 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n //        CheckConfiguration[] checkConfigs = null;\n //        try {\n //            checkConfigs =\n //                ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n //        }\n //        catch (CheckstyleException e) {\n //            System.out.println(\"Error loading configuration file\");\n //            e.printStackTrace(System.out);\n //            System.exit(1);\n //        }\n \n         // Load the config file\n         Configuration config = null;\n         try {\n             config =\n-                ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"));\n+                ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"),\n+                                                      props);\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n         // create the appropriate listener\n         final String format =\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener = null;\n         if (\"xml\".equals(format)) {\n             listener = new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener = new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be 'plain' or 'xml'.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files = new ArrayList();\n         if (line.hasOption(\"r\")) {\n             final String[] values = line.getOptionValues(\"r\");\n             for (int i = 0; i < values.length; i++) {\n                 traverse(new File(values[i]), files);\n             }\n         }\n \n         final String[] remainingArgs = line.getArgs();\n         for (int i = 0; i < remainingArgs.length; i++) {\n             files.add(remainingArgs[i]);\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n //        // create the checker\n //        Checker c = null;\n //        try {\n //            c = new Checker(new GlobalProperties(props, System.out),\n //                            checkConfigs);\n //            c.addListener(listener);\n //        }\n //        catch (Exception e) {\n //            System.out.println(\"Unable to create Checker: \"\n //                               + e.getMessage());\n //            e.printStackTrace(System.out);\n //            System.exit(1);\n //        }\n \n         // create the checker\n         Checker c = null;\n         try {\n             c = new Checker(config);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final int numErrs =\n             c.process((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3c0608f33a6c41cf96056c52ae99070cbe5062d5": {
			"type": "Ybodychange",
			"commitMessage": "Wrapped GlobalProperties and CheckConfiguration[] into a Configuration\nclass. TODO: Integrate with CheckStyleTask\n",
			"commitDate": "2002-11-15, 11:18 AM",
			"commitName": "3c0608f33a6c41cf96056c52ae99070cbe5062d5",
			"commitAuthor": "Rick Giles",
			"commitDateOld": "2002-11-14, 3:07 AM",
			"commitNameOld": "6f4247181beca3530b5c2dc762d9c5c6a018a06c",
			"commitAuthorOld": "Rick Giles",
			"daysBetweenCommits": 1.34,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,111 +1,136 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n-        CheckConfiguration[] checkConfigs = null;\n+//        CheckConfiguration[] checkConfigs = null;\n+//        try {\n+//            checkConfigs =\n+//                ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n+//        }\n+//        catch (CheckstyleException e) {\n+//            System.out.println(\"Error loading configuration file\");\n+//            e.printStackTrace(System.out);\n+//            System.exit(1);\n+//        }\n+\n+        // Load the config file\n+        Configuration config = null;\n         try {\n-            checkConfigs =\n-                ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n+            config =\n+                ConfigurationLoader.loadConfiguration(line.getOptionValue(\"c\"));\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n         // create the appropriate listener\n         final String format =\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener = null;\n         if (\"xml\".equals(format)) {\n             listener = new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener = new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be 'plain' or 'xml'.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files = new ArrayList();\n         if (line.hasOption(\"r\")) {\n             final String[] values = line.getOptionValues(\"r\");\n             for (int i = 0; i < values.length; i++) {\n                 traverse(new File(values[i]), files);\n             }\n         }\n \n         final String[] remainingArgs = line.getArgs();\n         for (int i = 0; i < remainingArgs.length; i++) {\n             files.add(remainingArgs[i]);\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n+//        // create the checker\n+//        Checker c = null;\n+//        try {\n+//            c = new Checker(new GlobalProperties(props, System.out),\n+//                            checkConfigs);\n+//            c.addListener(listener);\n+//        }\n+//        catch (Exception e) {\n+//            System.out.println(\"Unable to create Checker: \"\n+//                               + e.getMessage());\n+//            e.printStackTrace(System.out);\n+//            System.exit(1);\n+//        }\n+\n         // create the checker\n         Checker c = null;\n         try {\n-            c = new Checker(new GlobalProperties(props, System.out),\n-                            checkConfigs);\n+            c = new Checker(config);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final int numErrs =\n             c.process((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6f4247181beca3530b5c2dc762d9c5c6a018a06c": {
			"type": "Ybodychange",
			"commitMessage": "rename Configuration to GlobalProperties\n",
			"commitDate": "2002-11-14, 3:07 AM",
			"commitName": "6f4247181beca3530b5c2dc762d9c5c6a018a06c",
			"commitAuthor": "Rick Giles",
			"commitDateOld": "2002-11-12, 9:21 PM",
			"commitNameOld": "4cbd709c019cf1b69796858506d673f7b66d37c7",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 1.24,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,110 +1,111 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n \n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n \n         // Load the config file\n         CheckConfiguration[] checkConfigs = null;\n         try {\n             checkConfigs =\n                 ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n             final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n \n         // create the appropriate listener\n         final String format =\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n \n         AuditListener listener = null;\n         if (\"xml\".equals(format)) {\n             listener = new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener = new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be 'plain' or 'xml'.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files = new ArrayList();\n         if (line.hasOption(\"r\")) {\n             final String[] values = line.getOptionValues(\"r\");\n             for (int i = 0; i < values.length; i++) {\n                 traverse(new File(values[i]), files);\n             }\n         }\n \n         final String[] remainingArgs = line.getArgs();\n         for (int i = 0; i < remainingArgs.length; i++) {\n             files.add(remainingArgs[i]);\n         }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n         }\n \n         // create the checker\n         Checker c = null;\n         try {\n-            c = new Checker(new Configuration(props, System.out), checkConfigs);\n+            c = new Checker(new GlobalProperties(props, System.out),\n+                            checkConfigs);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final int numErrs =\n             c.process((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4cbd709c019cf1b69796858506d673f7b66d37c7": {
			"type": "Ybodychange",
			"commitMessage": "This is a really enjoyable commit to make. I have finally got to remove the\nugly Verifier class. The only remaining check are based on the new fileset\ncheck that Lars putting together. Magic. :-)\n",
			"commitDate": "2002-11-12, 9:21 PM",
			"commitName": "4cbd709c019cf1b69796858506d673f7b66d37c7",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2002-11-11, 2:52 PM",
			"commitNameOld": "1cea3765893e83e0d58ca110113e0d05b15a798a",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 1.27,
			"commitsBetweenForRepo": 11,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,110 +1,110 @@\n     public static void main(String[] aArgs)\n     {\n         // parse the parameters\n         final CommandLineParser clp = new PosixParser();\n         CommandLine line = null;\n         try {\n             line = clp.parse(OPTS, aArgs);\n         }\n         catch (ParseException e) {\n             e.printStackTrace();\n             usage();\n         }\n-        \n+\n         // setup the properties\n         final Properties props =\n             line.hasOption(\"p\")\n                 ? loadProperties(new File(line.getOptionValue(\"p\")))\n                 : System.getProperties();\n \n         // ensure a config file is specified\n         if (!line.hasOption(\"c\")) {\n             System.out.println(\"Must specify a config XML file.\");\n             usage();\n         }\n-        \n+\n         // Load the config file\n         CheckConfiguration[] checkConfigs = null;\n         try {\n             checkConfigs =\n                 ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         // setup the output stream\n         OutputStream out = null;\n         boolean closeOut = false;\n         if (line.hasOption(\"o\")) {\n-            final String fname = line.getOptionValue(\"o\"); \n+            final String fname = line.getOptionValue(\"o\");\n             try {\n                 out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n         else {\n             out = System.out;\n             closeOut = false;\n         }\n-        \n+\n         // create the appropriate listener\n         final String format =\n             line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n-        \n+\n         AuditListener listener = null;\n         if (\"xml\".equals(format)) {\n             listener = new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener = new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be 'plain' or 'xml'.\");\n             usage();\n         }\n \n         // Get all the Java files\n         final List files = new ArrayList();\n         if (line.hasOption(\"r\")) {\n             final String[] values = line.getOptionValues(\"r\");\n             for (int i = 0; i < values.length; i++) {\n                 traverse(new File(values[i]), files);\n             }\n         }\n- \n+\n         final String[] remainingArgs = line.getArgs();\n         for (int i = 0; i < remainingArgs.length; i++) {\n             files.add(remainingArgs[i]);\n-        } \n+        }\n \n         if (files.isEmpty()) {\n             System.out.println(\"Must specify files to process\");\n             usage();\n-        }         \n+        }\n \n         // create the checker\n         Checker c = null;\n         try {\n             c = new Checker(new Configuration(props, System.out), checkConfigs);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final int numErrs =\n-            c.processNEW((String[]) files.toArray(new String[files.size()]));\n+            c.process((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1cea3765893e83e0d58ca110113e0d05b15a798a": {
			"type": "Ybodychange",
			"commitMessage": "Refactoring the command line processing to use the new Jakarta Commons package\nhttp://jakarta.apache.org/commons/cli/. It is quite a nice package.\n",
			"commitDate": "2002-11-11, 2:52 PM",
			"commitName": "1cea3765893e83e0d58ca110113e0d05b15a798a",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2002-11-02, 5:22 AM",
			"commitNameOld": "3288a81e30ddea194f76bd74f3b509500b864163",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 9.4,
			"commitsBetweenForRepo": 85,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,92 +1,110 @@\n     public static void main(String[] aArgs)\n     {\n-        if (aArgs.length == 0) {\n+        // parse the parameters\n+        final CommandLineParser clp = new PosixParser();\n+        CommandLine line = null;\n+        try {\n+            line = clp.parse(OPTS, aArgs);\n+        }\n+        catch (ParseException e) {\n+            e.printStackTrace();\n             usage();\n         }\n+        \n+        // setup the properties\n+        final Properties props =\n+            line.hasOption(\"p\")\n+                ? loadProperties(new File(line.getOptionValue(\"p\")))\n+                : System.getProperties();\n \n-        // be brain dead about arguments parsing\n-        String format = \"plain\";\n-        String output = null;\n-        Properties props = System.getProperties();\n-        final List foundFiles = new ArrayList();\n-        final ArrayList files = new ArrayList();\n-        for (int i = 0; i < aArgs.length; i++) {\n-            if (\"-f\".equals(aArgs[i])) {\n-                format = aArgs[++i];\n-            }\n-            else if (\"-o\".equals(aArgs[i])) {\n-                output = aArgs[++i];\n-            }\n-            else if (\"-r\".equals(aArgs[i])) {\n-                traverse(new File(aArgs[++i]), foundFiles);\n-            }\n-            else if (\"-p\".equals(aArgs[i])) {\n-                props = loadProperties(new File(aArgs[++i]));\n-            }\n-            else {\n-                files.add(aArgs[i]);\n-            }\n+        // ensure a config file is specified\n+        if (!line.hasOption(\"c\")) {\n+            System.out.println(\"Must specify a config XML file.\");\n+            usage();\n+        }\n+        \n+        // Load the config file\n+        CheckConfiguration[] checkConfigs = null;\n+        try {\n+            checkConfigs =\n+                ConfigurationLoader.loadConfigs(line.getOptionValue(\"c\"));\n+        }\n+        catch (CheckstyleException e) {\n+            System.out.println(\"Error loading configuration file\");\n+            e.printStackTrace(System.out);\n+            System.exit(1);\n         }\n \n-        // create the appropriate listener\n-        OutputStream out = System.out;\n+        // setup the output stream\n+        OutputStream out = null;\n         boolean closeOut = false;\n-        if (output != null) {\n+        if (line.hasOption(\"o\")) {\n+            final String fname = line.getOptionValue(\"o\"); \n             try {\n-                out = new FileOutputStream(output);\n+                out = new FileOutputStream(fname);\n                 closeOut = true;\n             }\n             catch (FileNotFoundException e) {\n-                System.out.println(\"Could not find file: '\" + output + \"'\");\n+                System.out.println(\"Could not find file: '\" + fname + \"'\");\n                 System.exit(1);\n             }\n         }\n+        else {\n+            out = System.out;\n+            closeOut = false;\n+        }\n+        \n+        // create the appropriate listener\n+        final String format =\n+            line.hasOption(\"f\") ? line.getOptionValue(\"f\") : \"plain\";\n+        \n         AuditListener listener = null;\n         if (\"xml\".equals(format)) {\n             listener = new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener = new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be 'plain' or 'xml'.\");\n             usage();\n         }\n \n-        // Check that I have a config file\n+        // Get all the Java files\n+        final List files = new ArrayList();\n+        if (line.hasOption(\"r\")) {\n+            final String[] values = line.getOptionValues(\"r\");\n+            for (int i = 0; i < values.length; i++) {\n+                traverse(new File(values[i]), files);\n+            }\n+        }\n+ \n+        final String[] remainingArgs = line.getArgs();\n+        for (int i = 0; i < remainingArgs.length; i++) {\n+            files.add(remainingArgs[i]);\n+        } \n+\n         if (files.isEmpty()) {\n-            System.out.println(\"Need to specify a config file\");\n+            System.out.println(\"Must specify files to process\");\n             usage();\n-        }\n+        }         \n \n-        // Load the config file\n-        final String configFname = (String) files.remove(0);\n-        CheckConfiguration[] checkConfigs = null;\n-        try {\n-            checkConfigs = ConfigurationLoader.loadConfigs(configFname);\n-        }\n-        catch (CheckstyleException e) {\n-            System.out.println(\"Error loading configuration file\");\n-            e.printStackTrace(System.out);\n-            System.exit(1);\n-        }\n-\n+        // create the checker\n         Checker c = null;\n         try {\n             c = new Checker(new Configuration(props, System.out), checkConfigs);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n-        files.addAll(foundFiles);\n         final int numErrs =\n             c.processNEW((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3288a81e30ddea194f76bd74f3b509500b864163": {
			"type": "Ybodychange",
			"commitMessage": "Just converted over the Checkstyle ANT task to use the new framework. In\nprocess I had to fix numerous errors now being reported.\n\nThere are some bugs with the method checks, which I will now investigate.\n",
			"commitDate": "2002-11-02, 5:22 AM",
			"commitName": "3288a81e30ddea194f76bd74f3b509500b864163",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2002-10-31, 5:28 AM",
			"commitNameOld": "2effcfd0bcdfa7fc25bfff22e6f893ac6fb4478b",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 2,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,92 +1,92 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length == 0) {\n             usage();\n         }\n \n         // be brain dead about arguments parsing\n         String format = \"plain\";\n         String output = null;\n         Properties props = System.getProperties();\n         final List foundFiles = new ArrayList();\n         final ArrayList files = new ArrayList();\n         for (int i = 0; i < aArgs.length; i++) {\n             if (\"-f\".equals(aArgs[i])) {\n                 format = aArgs[++i];\n             }\n             else if (\"-o\".equals(aArgs[i])) {\n                 output = aArgs[++i];\n             }\n             else if (\"-r\".equals(aArgs[i])) {\n                 traverse(new File(aArgs[++i]), foundFiles);\n             }\n             else if (\"-p\".equals(aArgs[i])) {\n                 props = loadProperties(new File(aArgs[++i]));\n             }\n             else {\n                 files.add(aArgs[i]);\n             }\n         }\n \n         // create the appropriate listener\n         OutputStream out = System.out;\n         boolean closeOut = false;\n         if (output != null) {\n             try {\n                 out = new FileOutputStream(output);\n                 closeOut = true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + output + \"'\");\n                 System.exit(1);\n             }\n         }\n         AuditListener listener = null;\n         if (\"xml\".equals(format)) {\n             listener = new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener = new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be 'plain' or 'xml'.\");\n             usage();\n         }\n \n         // Check that I have a config file\n         if (files.isEmpty()) {\n             System.out.println(\"Need to specify a config file\");\n             usage();\n         }\n \n         // Load the config file\n         final String configFname = (String) files.remove(0);\n         CheckConfiguration[] checkConfigs = null;\n         try {\n-            checkConfigs = loadConfigs(configFname);\n+            checkConfigs = ConfigurationLoader.loadConfigs(configFname);\n         }\n         catch (CheckstyleException e) {\n             System.out.println(\"Error loading configuration file\");\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         Checker c = null;\n         try {\n             c = new Checker(new Configuration(props, System.out), checkConfigs);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         files.addAll(foundFiles);\n         final int numErrs =\n             c.processNEW((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2effcfd0bcdfa7fc25bfff22e6f893ac6fb4478b": {
			"type": "Ybodychange",
			"commitMessage": "Start of conversion to only supporting the new framework. Also refactored\nerror handling.\n",
			"commitDate": "2002-10-31, 5:28 AM",
			"commitName": "2effcfd0bcdfa7fc25bfff22e6f893ac6fb4478b",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2002-09-27, 12:41 AM",
			"commitNameOld": "d077a402da51bb238a7da99d5e2542437b145192",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 34.24,
			"commitsBetweenForRepo": 109,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,72 +1,92 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length == 0) {\n             usage();\n         }\n \n         // be brain dead about arguments parsing\n         String format = \"plain\";\n         String output = null;\n-        Properties properties = System.getProperties();\n+        Properties props = System.getProperties();\n+        final List foundFiles = new ArrayList();\n         final ArrayList files = new ArrayList();\n         for (int i = 0; i < aArgs.length; i++) {\n             if (\"-f\".equals(aArgs[i])) {\n                 format = aArgs[++i];\n             }\n             else if (\"-o\".equals(aArgs[i])) {\n                 output = aArgs[++i];\n             }\n             else if (\"-r\".equals(aArgs[i])) {\n-                traverse(new File(aArgs[++i]), files);\n+                traverse(new File(aArgs[++i]), foundFiles);\n             }\n             else if (\"-p\".equals(aArgs[i])) {\n-                properties = loadProperties(new File(aArgs[++i]));\n+                props = loadProperties(new File(aArgs[++i]));\n             }\n             else {\n                 files.add(aArgs[i]);\n             }\n         }\n \n         // create the appropriate listener\n         OutputStream out = System.out;\n         boolean closeOut = false;\n         if (output != null) {\n             try {\n                 out = new FileOutputStream(output);\n                 closeOut = true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + output + \"'\");\n                 System.exit(1);\n             }\n         }\n         AuditListener listener = null;\n         if (\"xml\".equals(format)) {\n             listener = new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener = new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be 'plain' or 'xml'.\");\n             usage();\n         }\n \n+        // Check that I have a config file\n+        if (files.isEmpty()) {\n+            System.out.println(\"Need to specify a config file\");\n+            usage();\n+        }\n+\n+        // Load the config file\n+        final String configFname = (String) files.remove(0);\n+        CheckConfiguration[] checkConfigs = null;\n+        try {\n+            checkConfigs = loadConfigs(configFname);\n+        }\n+        catch (CheckstyleException e) {\n+            System.out.println(\"Error loading configuration file\");\n+            e.printStackTrace(System.out);\n+            System.exit(1);\n+        }\n+\n         Checker c = null;\n         try {\n-            c = new Checker(new Configuration(properties, System.out));\n+            c = new Checker(new Configuration(props, System.out), checkConfigs);\n             c.addListener(listener);\n         }\n         catch (Exception e) {\n             System.out.println(\"Unable to create Checker: \"\n                                + e.getMessage());\n             e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n+        files.addAll(foundFiles);\n         final int numErrs =\n-            c.process((String[]) files.toArray(new String[files.size()]));\n+            c.processNEW((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b84b3fd04ad9c45e1466e35b707a2b59f5baf66b": {
			"type": "Ybodychange",
			"commitMessage": "Implemented a new version of Checker for that uses the Checks. The intent is\nto be able reuse the existing checker.\n\nOT: Due to ISP problems, I am unable to receive email at the moment.\n",
			"commitDate": "2002-09-24, 12:34 AM",
			"commitName": "b84b3fd04ad9c45e1466e35b707a2b59f5baf66b",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2002-07-02, 2:08 PM",
			"commitNameOld": "add2bdfb27494bff5fa9c305d9782f57c6170b18",
			"commitAuthorOld": "Lars Kühne",
			"daysBetweenCommits": 83.43,
			"commitsBetweenForRepo": 125,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,77 +1,72 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length == 0) {\n             usage();\n         }\n \n         // be brain dead about arguments parsing\n         String format = \"plain\";\n         String output = null;\n         Properties properties = System.getProperties();\n         final ArrayList files = new ArrayList();\n         for (int i = 0; i < aArgs.length; i++) {\n             if (\"-f\".equals(aArgs[i])) {\n                 format = aArgs[++i];\n             }\n             else if (\"-o\".equals(aArgs[i])) {\n                 output = aArgs[++i];\n             }\n             else if (\"-r\".equals(aArgs[i])) {\n                 traverse(new File(aArgs[++i]), files);\n             }\n             else if (\"-p\".equals(aArgs[i])) {\n                 properties = loadProperties(new File(aArgs[++i]));\n             }\n             else {\n                 files.add(aArgs[i]);\n             }\n         }\n \n         // create the appropriate listener\n         OutputStream out = System.out;\n         boolean closeOut = false;\n         if (output != null) {\n             try {\n                 out = new FileOutputStream(output);\n                 closeOut = true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + output + \"'\");\n                 System.exit(1);\n             }\n         }\n         AuditListener listener = null;\n         if (\"xml\".equals(format)) {\n             listener = new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n             listener = new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be 'plain' or 'xml'.\");\n             usage();\n         }\n \n         Checker c = null;\n         try {\n             c = new Checker(new Configuration(properties, System.out));\n             c.addListener(listener);\n         }\n-        catch (RESyntaxException rese) {\n-            System.out.println(\"Unable to create an regexp object: \"\n-                               + rese.getMessage());\n-            rese.printStackTrace(System.out);\n-            System.exit(1);\n-        }\n-        catch (IOException ex) {\n-            System.out.println(\"I/O error occurred: \" + ex.getMessage());\n-            ex.printStackTrace(System.out);\n+        catch (Exception e) {\n+            System.out.println(\"Unable to create Checker: \"\n+                               + e.getMessage());\n+            e.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final int numErrs =\n             c.process((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"add2bdfb27494bff5fa9c305d9782f57c6170b18": {
			"type": "Ybodychange",
			"commitMessage": "fixed bug 561616 (ant task should log errors, not infos)\n\nThis required a redesign of the AuditListener interface, the get/setOutputStream methoeds have been removed, as there might be listeners that have no or more than one OutputStream.\n\nThe DefaultLogger now differentiates between info messages (\"started checking file ...\", etc.) and error messages (style errors found by checkstyle) by writing the messages to two different OutputStreams.\n",
			"commitDate": "2002-07-02, 2:08 PM",
			"commitName": "add2bdfb27494bff5fa9c305d9782f57c6170b18",
			"commitAuthor": "Lars Kühne",
			"commitDateOld": "2002-05-28, 7:39 AM",
			"commitNameOld": "34770c3eaa9ad06297c13fd43a55739c02c7d67d",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 35.27,
			"commitsBetweenForRepo": 47,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,75 +1,77 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length == 0) {\n             usage();\n         }\n \n         // be brain dead about arguments parsing\n         String format = \"plain\";\n         String output = null;\n         Properties properties = System.getProperties();\n         final ArrayList files = new ArrayList();\n         for (int i = 0; i < aArgs.length; i++) {\n             if (\"-f\".equals(aArgs[i])) {\n                 format = aArgs[++i];\n             }\n             else if (\"-o\".equals(aArgs[i])) {\n                 output = aArgs[++i];\n             }\n             else if (\"-r\".equals(aArgs[i])) {\n                 traverse(new File(aArgs[++i]), files);\n             }\n             else if (\"-p\".equals(aArgs[i])) {\n                 properties = loadProperties(new File(aArgs[++i]));\n             }\n             else {\n                 files.add(aArgs[i]);\n             }\n         }\n \n         // create the appropriate listener\n         OutputStream out = System.out;\n+        boolean closeOut = false;\n         if (output != null) {\n             try {\n                 out = new FileOutputStream(output);\n+                closeOut = true;\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + output + \"'\");\n                 System.exit(1);\n             }\n         }\n         AuditListener listener = null;\n         if (\"xml\".equals(format)) {\n-            listener = new XMLLogger(out);\n+            listener = new XMLLogger(out, closeOut);\n         }\n         else if (\"plain\".equals(format)) {\n-            listener = new DefaultLogger(out);\n+            listener = new DefaultLogger(out, closeOut);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format\n                                + \"). Must be 'plain' or 'xml'.\");\n             usage();\n         }\n \n         Checker c = null;\n         try {\n             c = new Checker(new Configuration(properties, System.out));\n             c.addListener(listener);\n         }\n         catch (RESyntaxException rese) {\n             System.out.println(\"Unable to create an regexp object: \"\n                                + rese.getMessage());\n             rese.printStackTrace(System.out);\n             System.exit(1);\n         }\n         catch (IOException ex) {\n             System.out.println(\"I/O error occurred: \" + ex.getMessage());\n             ex.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final int numErrs =\n             c.process((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ef5716560b2b52a5fcd233ac9ad546a53749339f": {
			"type": "Ybodychange",
			"commitMessage": "RFE #557544, load properties from file on cmdline\n",
			"commitDate": "2002-05-19, 1:38 AM",
			"commitName": "ef5716560b2b52a5fcd233ac9ad546a53749339f",
			"commitAuthor": "Lars Kühne",
			"commitDateOld": "2002-04-17, 5:59 AM",
			"commitNameOld": "e200d9bf3d07b103e633d56215280e5e7d7a980b",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 31.82,
			"commitsBetweenForRepo": 44,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,72 +1,75 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length == 0) {\n             usage();\n         }\n \n         // be brain dead about arguments parsing\n         String format = \"plain\";\n         String output = null;\n+        Properties properties = System.getProperties();\n         final ArrayList files = new ArrayList();\n         for (int i = 0; i < aArgs.length; i++) {\n             if (\"-f\".equals(aArgs[i])) {\n                 format = aArgs[++i];\n             }\n             else if (\"-o\".equals(aArgs[i])) {\n                 output = aArgs[++i];\n             }\n             else if (\"-r\".equals(aArgs[i])) {\n                 traverse(new File(aArgs[++i]), files);\n             }\n+            else if (\"-p\".equals(aArgs[i])) {\n+                properties = loadProperties(new File(aArgs[++i]));\n+            }\n             else {\n                 files.add(aArgs[i]);\n             }\n         }\n \n         // create the appropriate listener\n         OutputStream out = System.out;\n         if (output != null) {\n             try {\n                 out = new FileOutputStream(output);\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + output + \"'\");\n                 System.exit(1);\n             }\n         }\n         AuditListener listener = null;\n         if (\"xml\".equals(format)) {\n             listener = new XMLLogger(out);\n         }\n         else if (\"plain\".equals(format)) {\n             listener = new DefaultLogger(out);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format +\n                                \"). Must be 'plain' or 'xml'.\");\n             usage();\n         }\n \n         Checker c = null;\n         try {\n-            c = new Checker(new Configuration(System.getProperties(),\n-                                              System.out));\n+            c = new Checker(new Configuration(properties, System.out));\n             c.addListener(listener);\n         }\n         catch (RESyntaxException rese) {\n             System.out.println(\"Unable to create an regexp object: \" +\n                                rese.getMessage());\n             rese.printStackTrace(System.out);\n             System.exit(1);\n         }\n         catch (IOException ex) {\n             System.out.println(\"I/O error occurred: \" + ex.getMessage());\n             ex.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final int numErrs =\n             c.process((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e200d9bf3d07b103e633d56215280e5e7d7a980b": {
			"type": "Ybodychange",
			"commitMessage": "545128: implemented \"-r\" recursive option and improved the argument handling\n",
			"commitDate": "2002-04-17, 5:59 AM",
			"commitName": "e200d9bf3d07b103e633d56215280e5e7d7a980b",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2002-02-04, 5:44 AM",
			"commitNameOld": "b779f3c1da7bacfe57900ccba7cd95de7ab54071",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 71.97,
			"commitsBetweenForRepo": 87,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,71 +1,72 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length == 0) {\n             usage();\n         }\n \n         // be brain dead about arguments parsing\n         String format = \"plain\";\n         String output = null;\n-        String[] files = null;\n+        final ArrayList files = new ArrayList();\n         for (int i = 0; i < aArgs.length; i++) {\n             if (\"-f\".equals(aArgs[i])) {\n                 format = aArgs[++i];\n             }\n             else if (\"-o\".equals(aArgs[i])) {\n                 output = aArgs[++i];\n             }\n+            else if (\"-r\".equals(aArgs[i])) {\n+                traverse(new File(aArgs[++i]), files);\n+            }\n             else {\n-                files = new String[aArgs.length - i];\n-                System.arraycopy(aArgs, i, files, 0, files.length);\n-                break;\n+                files.add(aArgs[i]);\n             }\n         }\n \n         // create the appropriate listener\n         OutputStream out = System.out;\n         if (output != null) {\n             try {\n                 out = new FileOutputStream(output);\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + output + \"'\");\n                 System.exit(1);\n             }\n         }\n         AuditListener listener = null;\n         if (\"xml\".equals(format)) {\n             listener = new XMLLogger(out);\n         }\n         else if (\"plain\".equals(format)) {\n             listener = new DefaultLogger(out);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format +\n                                \"). Must be 'plain' or 'xml'.\");\n             usage();\n         }\n \n         Checker c = null;\n         try {\n             c = new Checker(new Configuration(System.getProperties(),\n                                               System.out));\n             c.addListener(listener);\n         }\n         catch (RESyntaxException rese) {\n             System.out.println(\"Unable to create an regexp object: \" +\n                                rese.getMessage());\n             rese.printStackTrace(System.out);\n             System.exit(1);\n         }\n         catch (IOException ex) {\n             System.out.println(\"I/O error occurred: \" + ex.getMessage());\n             ex.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n-        final int numErrs = c.process(files);\n-\n+        final int numErrs =\n+            c.process((String[]) files.toArray(new String[files.size()]));\n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"15c7162ea43a4e7517227a281f6f34d4a2ecb5a5": {
			"type": "Ybodychange",
			"commitMessage": "Refactored Checker to not take a PrintStream. All errors are not logged to\nstandard output.\n",
			"commitDate": "2002-01-23, 5:28 AM",
			"commitName": "15c7162ea43a4e7517227a281f6f34d4a2ecb5a5",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2001-08-30, 10:13 AM",
			"commitNameOld": "0e3fe5643667a53079dbd114e5b1e9aa91fde083",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 145.84,
			"commitsBetweenForRepo": 89,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,72 +1,71 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length == 0) {\n             usage();\n         }\n \n         // be brain dead about arguments parsing\n         String format = \"plain\";\n         String output = null;\n         String[] files = null;\n         for (int i = 0; i < aArgs.length; i++) {\n             if (\"-f\".equals(aArgs[i])) {\n                 format = aArgs[++i];\n             }\n             else if (\"-o\".equals(aArgs[i])) {\n                 output = aArgs[++i];\n             }\n             else {\n                 files = new String[aArgs.length - i];\n                 System.arraycopy(aArgs, i, files, 0, files.length);\n                 break;\n             }\n         }\n \n         // create the appropriate listener\n         OutputStream out = System.out;\n         if (output != null) {\n             try {\n                 out = new FileOutputStream(output);\n             }\n             catch (FileNotFoundException e) {\n                 System.out.println(\"Could not find file: '\" + output + \"'\");\n                 System.exit(1);\n             }\n         }\n         AuditListener listener = null;\n         if (\"xml\".equals(format)) {\n             listener = new XMLLogger(out);\n         }\n         else if (\"plain\".equals(format)) {\n             listener = new DefaultLogger(out);\n         }\n         else {\n             System.out.println(\"Invalid format: (\" + format +\n                                \"). Must be 'plain' or 'xml'.\");\n             usage();\n         }\n \n         Checker c = null;\n         try {\n             c = new Checker(new Configuration(System.getProperties(),\n-                                              System.out),\n-                            System.out);\n+                                              System.out));\n             c.addListener(listener);\n         }\n         catch (RESyntaxException rese) {\n             System.out.println(\"Unable to create an regexp object: \" +\n                                rese.getMessage());\n             rese.printStackTrace(System.out);\n             System.exit(1);\n         }\n         catch (IOException ex) {\n             System.out.println(\"I/O error occurred: \" + ex.getMessage());\n             ex.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         final int numErrs = c.process(files);\n \n         c.destroy();\n         System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0e3fe5643667a53079dbd114e5b1e9aa91fde083": {
			"type": "Ybodychange",
			"commitMessage": "started to incorporate logging events\n",
			"commitDate": "2001-08-30, 10:13 AM",
			"commitName": "0e3fe5643667a53079dbd114e5b1e9aa91fde083",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2001-08-05, 8:12 AM",
			"commitNameOld": "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 25.08,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,32 +1,72 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length == 0) {\n             usage();\n         }\n \n+        // be brain dead about arguments parsing\n+        String format = \"plain\";\n+        String output = null;\n+        String[] files = null;\n+        for (int i = 0; i < aArgs.length; i++) {\n+            if (\"-f\".equals(aArgs[i])) {\n+                format = aArgs[++i];\n+            }\n+            else if (\"-o\".equals(aArgs[i])) {\n+                output = aArgs[++i];\n+            }\n+            else {\n+                files = new String[aArgs.length - i];\n+                System.arraycopy(aArgs, i, files, 0, files.length);\n+                break;\n+            }\n+        }\n+\n+        // create the appropriate listener\n+        OutputStream out = System.out;\n+        if (output != null) {\n+            try {\n+                out = new FileOutputStream(output);\n+            }\n+            catch (FileNotFoundException e) {\n+                System.out.println(\"Could not find file: '\" + output + \"'\");\n+                System.exit(1);\n+            }\n+        }\n+        AuditListener listener = null;\n+        if (\"xml\".equals(format)) {\n+            listener = new XMLLogger(out);\n+        }\n+        else if (\"plain\".equals(format)) {\n+            listener = new DefaultLogger(out);\n+        }\n+        else {\n+            System.out.println(\"Invalid format: (\" + format +\n+                               \"). Must be 'plain' or 'xml'.\");\n+            usage();\n+        }\n+\n         Checker c = null;\n         try {\n             c = new Checker(new Configuration(System.getProperties(),\n                                               System.out),\n                             System.out);\n+            c.addListener(listener);\n         }\n         catch (RESyntaxException rese) {\n             System.out.println(\"Unable to create an regexp object: \" +\n                                rese.getMessage());\n             rese.printStackTrace(System.out);\n             System.exit(1);\n         }\n         catch (IOException ex) {\n             System.out.println(\"I/O error occurred: \" + ex.getMessage());\n             ex.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n-        int numErrors = 0;\n-        for (int i = 0; i < aArgs.length; i++) {\n-            numErrors += c.process(aArgs[i]);\n-        }\n+        final int numErrs = c.process(files);\n \n         c.destroy();\n-        System.exit(numErrors);\n+        System.exit(numErrs);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7": {
			"type": "Ybodychange",
			"commitMessage": "added support for caching\n",
			"commitDate": "2001-08-05, 8:12 AM",
			"commitName": "6c304950f62f06cb3c72e46869c3fa3fbdc1e7d7",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2001-06-29, 1:21 AM",
			"commitNameOld": "69138e40225407ef560fd9d06d2903de37c83c2c",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 37.29,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,31 +1,32 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length == 0) {\n             usage();\n         }\n \n         Checker c = null;\n         try {\n             c = new Checker(new Configuration(System.getProperties(),\n                                               System.out),\n                             System.out);\n         }\n         catch (RESyntaxException rese) {\n             System.out.println(\"Unable to create an regexp object: \" +\n                                rese.getMessage());\n             rese.printStackTrace(System.out);\n             System.exit(1);\n         }\n         catch (IOException ex) {\n             System.out.println(\"I/O error occurred: \" + ex.getMessage());\n             ex.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         int numErrors = 0;\n         for (int i = 0; i < aArgs.length; i++) {\n             numErrors += c.process(aArgs[i]);\n         }\n \n+        c.destroy();\n         System.exit(numErrors);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"69138e40225407ef560fd9d06d2903de37c83c2c": {
			"type": "Ybodychange",
			"commitMessage": "refactored to use the new Configuration class.\n",
			"commitDate": "2001-06-29, 1:21 AM",
			"commitName": "69138e40225407ef560fd9d06d2903de37c83c2c",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2001-06-28, 7:10 AM",
			"commitNameOld": "f0f7f3e762ffef78dcf82bf1611c10da48b96cb9",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 0.76,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,24 +1,31 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length == 0) {\n             usage();\n         }\n \n         Checker c = null;\n         try {\n-            c = new Checker(System.getProperties(), System.out);\n+            c = new Checker(new Configuration(System.getProperties(),\n+                                              System.out),\n+                            System.out);\n         }\n         catch (RESyntaxException rese) {\n             System.out.println(\"Unable to create an regexp object: \" +\n                                rese.getMessage());\n             rese.printStackTrace(System.out);\n             System.exit(1);\n         }\n+        catch (IOException ex) {\n+            System.out.println(\"I/O error occurred: \" + ex.getMessage());\n+            ex.printStackTrace(System.out);\n+            System.exit(1);\n+        }\n \n         int numErrors = 0;\n         for (int i = 0; i < aArgs.length; i++) {\n             numErrors += c.process(aArgs[i]);\n         }\n \n         System.exit(numErrors);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f0f7f3e762ffef78dcf82bf1611c10da48b96cb9": {
			"type": "Ybodychange",
			"commitMessage": "changed for release 1.2\n",
			"commitDate": "2001-06-28, 7:10 AM",
			"commitName": "f0f7f3e762ffef78dcf82bf1611c10da48b96cb9",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2001-06-22, 7:24 AM",
			"commitNameOld": "0fd69594a4c3e82f92f93f0371791da66938f8c3",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 5.99,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,24 +1,24 @@\n     public static void main(String[] aArgs)\n     {\n         if (aArgs.length == 0) {\n             usage();\n         }\n \n         Checker c = null;\n         try {\n-            c = new Checker(System.getProperties(), System.err);\n+            c = new Checker(System.getProperties(), System.out);\n         }\n         catch (RESyntaxException rese) {\n-            System.err.println(\"Unable to create an regexp object: \" +\n+            System.out.println(\"Unable to create an regexp object: \" +\n                                rese.getMessage());\n-            rese.printStackTrace(System.err);\n+            rese.printStackTrace(System.out);\n             System.exit(1);\n         }\n \n         int numErrors = 0;\n         for (int i = 0; i < aArgs.length; i++) {\n             numErrors += c.process(aArgs[i]);\n         }\n \n         System.exit(numErrors);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0fd69594a4c3e82f92f93f0371791da66938f8c3": {
			"type": "Yintroduced",
			"commitMessage": "first cut\n",
			"commitDate": "2001-06-22, 7:24 AM",
			"commitName": "0fd69594a4c3e82f92f93f0371791da66938f8c3",
			"commitAuthor": "Oliver Burn"
		}
	},
	"sha": "119fd4fb33bef9f5c66fc950396669af842c21a3"
}