{
	"repo": "https://github.com/hibernate/hibernate-orm.git",
	"file": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java",
	"method": {
		"longName": "public RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager);",
		"startLine": 296,
		"methodName": "configure",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"9e063ffa2577f06d98a9e912bb16d20424df8d6d": {
			"type": "Ybodychange",
			"commitMessage": "HHH-9837 - Remove reliance during annotation binding on org.hibernate.internal.util.ClassLoaderHelper\nHHH-9841 - Redesign org.hibernate.property.PropertyAccessorFactory\n",
			"commitDate": "2015-06-04, 12:12 PM",
			"commitName": "9e063ffa2577f06d98a9e912bb16d20424df8d6d",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2015-05-18, 9:25 PM",
			"commitNameOld": "bd256e4783219f4a765219cf625bb658fcb5fde1",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 16.62,
			"commitsBetweenForRepo": 39,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,128 +1,143 @@\n \tpublic RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n \t\tboolean revisionEntityFound = false;\n \t\tRevisionInfoGenerator revisionInfoGenerator = null;\n \t\tClass<?> revisionInfoClass = null;\n \n \t\tfor ( PersistentClass persistentClass : metadata.getEntityBindings() ) {\n \t\t\t// Ensure we're in POJO, not dynamic model, mapping.\n \t\t\tif (persistentClass.getClassName() != null) {\n \t\t\t\tXClass clazz;\n \t\t\t\ttry {\n \t\t\t\t\tclazz = reflectionManager.classForName( persistentClass.getClassName() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassLoadingException e) {\n \t\t\t\t\tthrow new MappingException( e );\n \t\t\t\t}\n \n \t\t\t\tfinal RevisionEntity revisionEntity = clazz.getAnnotation( RevisionEntity.class );\n \t\t\t\tif ( revisionEntity != null ) {\n \t\t\t\t\tif (revisionEntityFound) {\n \t\t\t\t\t\tthrow new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n \t\t\t\t\t}\n \n \t\t\t\t\t// Checking if custom revision entity isn't audited\n \t\t\t\t\tif (clazz.getAnnotation(Audited.class) != null) {\n \t\t\t\t\t\tthrow new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n \t\t\t\t\t}\n \n \t\t\t\t\trevisionEntityFound = true;\n \n \t\t\t\t\tfinal MutableBoolean revisionNumberFound = new MutableBoolean();\n \t\t\t\t\tfinal MutableBoolean revisionTimestampFound = new MutableBoolean();\n \t\t\t\t\tfinal MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n \n \t\t\t\t\tsearchForRevisionInfoCfg(\n \t\t\t\t\t\t\tclazz,\n \t\t\t\t\t\t\treflectionManager,\n \t\t\t\t\t\t\trevisionNumberFound,\n \t\t\t\t\t\t\trevisionTimestampFound,\n \t\t\t\t\t\t\tmodifiedEntityNamesFound\n \t\t\t\t\t);\n \n \t\t\t\t\tif (!revisionNumberFound.isSet()) {\n \t\t\t\t\t\tthrow new MappingException(\n \t\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n \t\t\t\t\t\t\t\t\t\t\"with @RevisionNumber!\"\n \t\t\t\t\t\t);\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!revisionTimestampFound.isSet()) {\n \t\t\t\t\t\tthrow new MappingException(\n \t\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n \t\t\t\t\t\t\t\t\t\t\"with @RevisionTimestamp!\"\n \t\t\t\t\t\t);\n \t\t\t\t\t}\n \n \t\t\t\t\trevisionInfoEntityName = persistentClass.getEntityName();\n \t\t\t\t\trevisionInfoClass = persistentClass.getMappedClass();\n \t\t\t\t\tfinal Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(revisionEntity.value());\n \t\t\t\t\trevisionInfoTimestampType = persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n \t\t\t\t\tif (globalCfg.isTrackEntitiesChangedInRevision()\n \t\t\t\t\t\t\t|| (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t\t.isAssignableFrom(revisionInfoClass))\n \t\t\t\t\t\t\t|| (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t\t.isAssignableFrom(revisionInfoClass))\n \t\t\t\t\t\t\t|| modifiedEntityNamesFound.isSet()) {\n \t\t\t\t\t\t// If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n \t\t\t\t\t\t// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n \t\t\t\t\t\trevisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n \t\t\t\t\t\t\t\trevisionInfoEntityName,\n-\t\t\t\t\t\t\t\trevisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n-\t\t\t\t\t\t\t\tmodifiedEntityNamesData\n+\t\t\t\t\t\t\t\trevisionInfoClass,\n+\t\t\t\t\t\t\t\trevisionListenerClass,\n+\t\t\t\t\t\t\t\trevisionInfoTimestampData,\n+\t\t\t\t\t\t\t\tisTimestampAsDate(),\n+\t\t\t\t\t\t\t\tmodifiedEntityNamesData,\n+\t\t\t\t\t\t\t\tmetadata.getMetadataBuildingOptions().getServiceRegistry()\n \t\t\t\t\t\t);\n \t\t\t\t\t\tglobalCfg.setTrackEntitiesChangedInRevision(true);\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\trevisionInfoGenerator = new DefaultRevisionInfoGenerator(\n-\t\t\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n-\t\t\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n+\t\t\t\t\t\t\t\trevisionInfoEntityName,\n+\t\t\t\t\t\t\t\trevisionInfoClass,\n+\t\t\t\t\t\t\t\trevisionListenerClass,\n+\t\t\t\t\t\t\t\trevisionInfoTimestampData,\n+\t\t\t\t\t\t\t\tisTimestampAsDate(),\n+\t\t\t\t\t\t\t\tmetadata.getMetadataBuildingOptions().getServiceRegistry()\n \t\t\t\t\t\t);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// In case of a custom revision info generator, the mapping will be null.\n \t\tDocument revisionInfoXmlMapping = null;\n \n \t\tfinal Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass( RevisionListener.class );\n \n \t\tif ( revisionInfoGenerator == null ) {\n \t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision() ) {\n-\t\t\t\trevisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ?\n-\t\t\t\t\t\tDefaultTrackingModifiedEntitiesRevisionEntity.class\n-\t\t\t\t\t\t:\n-\t\t\t\t\t\tSequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n+\t\t\t\trevisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId()\n+\t\t\t\t\t\t? DefaultTrackingModifiedEntitiesRevisionEntity.class\n+\t\t\t\t\t\t: SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n \t\t\t\trevisionInfoEntityName = revisionInfoClass.getName();\n \t\t\t\trevisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n-\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n-\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData\n+\t\t\t\t\t\trevisionInfoEntityName,\n+\t\t\t\t\t\trevisionInfoClass,\n+\t\t\t\t\t\trevisionListenerClass,\n+\t\t\t\t\t\trevisionInfoTimestampData,\n+\t\t\t\t\t\tisTimestampAsDate(),\n+\t\t\t\t\t\tmodifiedEntityNamesData,\n+\t\t\t\t\t\tmetadata.getMetadataBuildingOptions().getServiceRegistry()\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n-\t\t\t\trevisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n+\t\t\t\trevisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId()\n+\t\t\t\t\t\t? DefaultRevisionEntity.class\n \t\t\t\t\t\t: SequenceIdRevisionEntity.class;\n \t\t\t\trevisionInfoGenerator = new DefaultRevisionInfoGenerator(\n-\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n-\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n+\t\t\t\t\t\trevisionInfoEntityName,\n+\t\t\t\t\t\trevisionInfoClass,\n+\t\t\t\t\t\trevisionListenerClass,\n+\t\t\t\t\t\trevisionInfoTimestampData,\n+\t\t\t\t\t\tisTimestampAsDate(),\n+\t\t\t\t\t\tmetadata.getMetadataBuildingOptions().getServiceRegistry()\n \t\t\t\t);\n \t\t\t}\n \t\t\trevisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n \t\t}\n \n \t\treturn new RevisionInfoConfigurationResult(\n \t\t\t\trevisionInfoGenerator, revisionInfoXmlMapping,\n \t\t\t\tnew RevisionInfoQueryCreator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoIdData.getName(),\n \t\t\t\t\t\trevisionInfoTimestampData.getName(), isTimestampAsDate()\n \t\t\t\t),\n \t\t\t\tgenerateRevisionInfoRelationMapping(),\n-\t\t\t\tnew RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData ),\n-\t\t\t\tglobalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(\n-\t\t\t\t\t\trevisionInfoClass,\n-\t\t\t\t\t\tmodifiedEntityNamesData\n-\t\t\t\t)\n+\t\t\t\tnew RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData, metadata.getMetadataBuildingOptions().getServiceRegistry() ),\n+\t\t\t\tglobalCfg.isTrackEntitiesChangedInRevision()\n+\t\t\t\t\t\t? new ModifiedEntityNamesReader( revisionInfoClass, modifiedEntityNamesData, metadata.getMetadataBuildingOptions().getServiceRegistry() )\n \t\t\t\t\t\t: null,\n \t\t\t\trevisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData\n \t\t);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"410a785dfe40ae030bec31c4c06a5a7998f1feeb": {
			"type": "Ybodychange",
			"commitMessage": "HHH-9680 updated OSGi quickstarts, added necessary contracts to Envers blueprint, corrected a few uses of ReflectionManager\n",
			"commitDate": "2015-03-30, 12:36 PM",
			"commitName": "410a785dfe40ae030bec31c4c06a5a7998f1feeb",
			"commitAuthor": "Brett Meyer",
			"commitDateOld": "2015-03-21, 10:30 PM",
			"commitNameOld": "b70bc0080e8e206f83debf8f456fe323caccc01b",
			"commitAuthorOld": "Brett Meyer",
			"daysBetweenCommits": 8.59,
			"commitsBetweenForRepo": 33,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,127 +1,127 @@\n \tpublic RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n \t\tboolean revisionEntityFound = false;\n \t\tRevisionInfoGenerator revisionInfoGenerator = null;\n \t\tClass<?> revisionInfoClass = null;\n \n \t\tfor ( PersistentClass persistentClass : metadata.getEntityBindings() ) {\n \t\t\t// Ensure we're in POJO, not dynamic model, mapping.\n \t\t\tif (persistentClass.getClassName() != null) {\n \t\t\t\tXClass clazz;\n \t\t\t\ttry {\n-\t\t\t\t\tclazz = reflectionManager.classForName( persistentClass.getClassName(), this.getClass() );\n+\t\t\t\t\tclazz = reflectionManager.classForName( persistentClass.getClassName() );\n \t\t\t\t}\n-\t\t\t\tcatch (ClassNotFoundException e) {\n+\t\t\t\tcatch (ClassLoadingException e) {\n \t\t\t\t\tthrow new MappingException( e );\n \t\t\t\t}\n \n \t\t\t\tfinal RevisionEntity revisionEntity = clazz.getAnnotation( RevisionEntity.class );\n \t\t\t\tif ( revisionEntity != null ) {\n \t\t\t\t\tif (revisionEntityFound) {\n \t\t\t\t\t\tthrow new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n \t\t\t\t\t}\n \n \t\t\t\t\t// Checking if custom revision entity isn't audited\n \t\t\t\t\tif (clazz.getAnnotation(Audited.class) != null) {\n \t\t\t\t\t\tthrow new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n \t\t\t\t\t}\n \n \t\t\t\t\trevisionEntityFound = true;\n \n \t\t\t\t\tfinal MutableBoolean revisionNumberFound = new MutableBoolean();\n \t\t\t\t\tfinal MutableBoolean revisionTimestampFound = new MutableBoolean();\n \t\t\t\t\tfinal MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n \n \t\t\t\t\tsearchForRevisionInfoCfg(\n \t\t\t\t\t\t\tclazz,\n \t\t\t\t\t\t\treflectionManager,\n \t\t\t\t\t\t\trevisionNumberFound,\n \t\t\t\t\t\t\trevisionTimestampFound,\n \t\t\t\t\t\t\tmodifiedEntityNamesFound\n \t\t\t\t\t);\n \n \t\t\t\t\tif (!revisionNumberFound.isSet()) {\n \t\t\t\t\t\tthrow new MappingException(\n \t\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n \t\t\t\t\t\t\t\t\t\t\"with @RevisionNumber!\"\n \t\t\t\t\t\t);\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!revisionTimestampFound.isSet()) {\n \t\t\t\t\t\tthrow new MappingException(\n \t\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n \t\t\t\t\t\t\t\t\t\t\"with @RevisionTimestamp!\"\n \t\t\t\t\t\t);\n \t\t\t\t\t}\n \n \t\t\t\t\trevisionInfoEntityName = persistentClass.getEntityName();\n \t\t\t\t\trevisionInfoClass = persistentClass.getMappedClass();\n \t\t\t\t\tfinal Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(revisionEntity.value());\n \t\t\t\t\trevisionInfoTimestampType = persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n \t\t\t\t\tif (globalCfg.isTrackEntitiesChangedInRevision()\n \t\t\t\t\t\t\t|| (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t\t.isAssignableFrom(revisionInfoClass))\n \t\t\t\t\t\t\t|| (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t\t.isAssignableFrom(revisionInfoClass))\n \t\t\t\t\t\t\t|| modifiedEntityNamesFound.isSet()) {\n \t\t\t\t\t\t// If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n \t\t\t\t\t\t// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n \t\t\t\t\t\trevisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n \t\t\t\t\t\t\t\trevisionInfoEntityName,\n \t\t\t\t\t\t\t\trevisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n \t\t\t\t\t\t\t\tmodifiedEntityNamesData\n \t\t\t\t\t\t);\n \t\t\t\t\t\tglobalCfg.setTrackEntitiesChangedInRevision(true);\n \t\t\t\t\t} else {\n \t\t\t\t\t\trevisionInfoGenerator = new DefaultRevisionInfoGenerator(\n \t\t\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n \t\t\t\t\t\t);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// In case of a custom revision info generator, the mapping will be null.\n \t\tDocument revisionInfoXmlMapping = null;\n \n \t\tfinal Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass( RevisionListener.class );\n \n \t\tif ( revisionInfoGenerator == null ) {\n \t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision() ) {\n \t\t\t\trevisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ?\n \t\t\t\t\t\tDefaultTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t:\n \t\t\t\t\t\tSequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n \t\t\t\trevisionInfoEntityName = revisionInfoClass.getName();\n \t\t\t\trevisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\trevisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n \t\t\t\t\t\t: SequenceIdRevisionEntity.class;\n \t\t\t\trevisionInfoGenerator = new DefaultRevisionInfoGenerator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n \t\t\t\t);\n \t\t\t}\n \t\t\trevisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n \t\t}\n \n \t\treturn new RevisionInfoConfigurationResult(\n \t\t\t\trevisionInfoGenerator, revisionInfoXmlMapping,\n \t\t\t\tnew RevisionInfoQueryCreator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoIdData.getName(),\n \t\t\t\t\t\trevisionInfoTimestampData.getName(), isTimestampAsDate()\n \t\t\t\t),\n \t\t\t\tgenerateRevisionInfoRelationMapping(),\n \t\t\t\tnew RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData ),\n \t\t\t\tglobalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(\n \t\t\t\t\t\trevisionInfoClass,\n \t\t\t\t\t\tmodifiedEntityNamesData\n \t\t\t\t)\n \t\t\t\t\t\t: null,\n \t\t\t\trevisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData\n \t\t);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b70bc0080e8e206f83debf8f456fe323caccc01b": {
			"type": "Ybodychange",
			"commitMessage": "HHH-8769 gracefully handle the lack of dynamic mode support in Envers\n",
			"commitDate": "2015-03-21, 10:30 PM",
			"commitName": "b70bc0080e8e206f83debf8f456fe323caccc01b",
			"commitAuthor": "Brett Meyer",
			"commitDateOld": "2015-03-18, 6:22 PM",
			"commitNameOld": "63a0f03c5ae773f96c92c02fba9d13133d02485b",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 3.17,
			"commitsBetweenForRepo": 23,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,125 +1,127 @@\n \tpublic RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n \t\tboolean revisionEntityFound = false;\n \t\tRevisionInfoGenerator revisionInfoGenerator = null;\n \t\tClass<?> revisionInfoClass = null;\n \n \t\tfor ( PersistentClass persistentClass : metadata.getEntityBindings() ) {\n-\t\t\tXClass clazz;\n-\t\t\ttry {\n-\t\t\t\tclazz = reflectionManager.classForName( persistentClass.getClassName(), this.getClass() );\n-\t\t\t}\n-\t\t\tcatch (ClassNotFoundException e) {\n-\t\t\t\tthrow new MappingException( e );\n-\t\t\t}\n-\n-\t\t\tfinal RevisionEntity revisionEntity = clazz.getAnnotation( RevisionEntity.class );\n-\t\t\tif ( revisionEntity != null ) {\n-\t\t\t\tif ( revisionEntityFound ) {\n-\t\t\t\t\tthrow new MappingException( \"Only one entity may be annotated with @RevisionEntity!\" );\n+\t\t\t// Ensure we're in POJO, not dynamic model, mapping.\n+\t\t\tif (persistentClass.getClassName() != null) {\n+\t\t\t\tXClass clazz;\n+\t\t\t\ttry {\n+\t\t\t\t\tclazz = reflectionManager.classForName( persistentClass.getClassName(), this.getClass() );\n+\t\t\t\t}\n+\t\t\t\tcatch (ClassNotFoundException e) {\n+\t\t\t\t\tthrow new MappingException( e );\n \t\t\t\t}\n \n-\t\t\t\t// Checking if custom revision entity isn't audited\n-\t\t\t\tif ( clazz.getAnnotation( Audited.class ) != null ) {\n-\t\t\t\t\tthrow new MappingException( \"An entity annotated with @RevisionEntity cannot be audited!\" );\n-\t\t\t\t}\n+\t\t\t\tfinal RevisionEntity revisionEntity = clazz.getAnnotation( RevisionEntity.class );\n+\t\t\t\tif ( revisionEntity != null ) {\n+\t\t\t\t\tif (revisionEntityFound) {\n+\t\t\t\t\t\tthrow new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n+\t\t\t\t\t}\n \n-\t\t\t\trevisionEntityFound = true;\n+\t\t\t\t\t// Checking if custom revision entity isn't audited\n+\t\t\t\t\tif (clazz.getAnnotation(Audited.class) != null) {\n+\t\t\t\t\t\tthrow new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n+\t\t\t\t\t}\n \n-\t\t\t\tfinal MutableBoolean revisionNumberFound = new MutableBoolean();\n-\t\t\t\tfinal MutableBoolean revisionTimestampFound = new MutableBoolean();\n-\t\t\t\tfinal MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n+\t\t\t\t\trevisionEntityFound = true;\n \n-\t\t\t\tsearchForRevisionInfoCfg(\n-\t\t\t\t\t\tclazz,\n-\t\t\t\t\t\treflectionManager,\n-\t\t\t\t\t\trevisionNumberFound,\n-\t\t\t\t\t\trevisionTimestampFound,\n-\t\t\t\t\t\tmodifiedEntityNamesFound\n-\t\t\t\t);\n+\t\t\t\t\tfinal MutableBoolean revisionNumberFound = new MutableBoolean();\n+\t\t\t\t\tfinal MutableBoolean revisionTimestampFound = new MutableBoolean();\n+\t\t\t\t\tfinal MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n \n-\t\t\t\tif ( !revisionNumberFound.isSet() ) {\n-\t\t\t\t\tthrow new MappingException(\n-\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n-\t\t\t\t\t\t\t\t\t\"with @RevisionNumber!\"\n+\t\t\t\t\tsearchForRevisionInfoCfg(\n+\t\t\t\t\t\t\tclazz,\n+\t\t\t\t\t\t\treflectionManager,\n+\t\t\t\t\t\t\trevisionNumberFound,\n+\t\t\t\t\t\t\trevisionTimestampFound,\n+\t\t\t\t\t\t\tmodifiedEntityNamesFound\n \t\t\t\t\t);\n-\t\t\t\t}\n \n-\t\t\t\tif ( !revisionTimestampFound.isSet() ) {\n-\t\t\t\t\tthrow new MappingException(\n-\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n-\t\t\t\t\t\t\t\t\t\"with @RevisionTimestamp!\"\n-\t\t\t\t\t);\n-\t\t\t\t}\n+\t\t\t\t\tif (!revisionNumberFound.isSet()) {\n+\t\t\t\t\t\tthrow new MappingException(\n+\t\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n+\t\t\t\t\t\t\t\t\t\t\"with @RevisionNumber!\"\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}\n \n-\t\t\t\trevisionInfoEntityName = persistentClass.getEntityName();\n-\t\t\t\trevisionInfoClass = persistentClass.getMappedClass();\n-\t\t\t\tfinal Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass( revisionEntity.value() );\n-\t\t\t\trevisionInfoTimestampType = persistentClass.getProperty( revisionInfoTimestampData.getName() ).getType();\n-\t\t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision()\n-\t\t\t\t\t\t|| (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class\n-\t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n-\t\t\t\t\t\t|| (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class\n-\t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n-\t\t\t\t\t\t|| modifiedEntityNamesFound.isSet() ) {\n-\t\t\t\t\t// If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n-\t\t\t\t\t// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n-\t\t\t\t\trevisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n-\t\t\t\t\t\t\trevisionInfoEntityName,\n-\t\t\t\t\t\t\trevisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n-\t\t\t\t\t\t\tmodifiedEntityNamesData\n-\t\t\t\t\t);\n-\t\t\t\t\tglobalCfg.setTrackEntitiesChangedInRevision( true );\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\trevisionInfoGenerator = new DefaultRevisionInfoGenerator(\n-\t\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n-\t\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n-\t\t\t\t\t);\n+\t\t\t\t\tif (!revisionTimestampFound.isSet()) {\n+\t\t\t\t\t\tthrow new MappingException(\n+\t\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n+\t\t\t\t\t\t\t\t\t\t\"with @RevisionTimestamp!\"\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\trevisionInfoEntityName = persistentClass.getEntityName();\n+\t\t\t\t\trevisionInfoClass = persistentClass.getMappedClass();\n+\t\t\t\t\tfinal Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(revisionEntity.value());\n+\t\t\t\t\trevisionInfoTimestampType = persistentClass.getProperty(revisionInfoTimestampData.getName()).getType();\n+\t\t\t\t\tif (globalCfg.isTrackEntitiesChangedInRevision()\n+\t\t\t\t\t\t\t|| (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class\n+\t\t\t\t\t\t\t.isAssignableFrom(revisionInfoClass))\n+\t\t\t\t\t\t\t|| (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class\n+\t\t\t\t\t\t\t.isAssignableFrom(revisionInfoClass))\n+\t\t\t\t\t\t\t|| modifiedEntityNamesFound.isSet()) {\n+\t\t\t\t\t\t// If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n+\t\t\t\t\t\t// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n+\t\t\t\t\t\trevisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n+\t\t\t\t\t\t\t\trevisionInfoEntityName,\n+\t\t\t\t\t\t\t\trevisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n+\t\t\t\t\t\t\t\tmodifiedEntityNamesData\n+\t\t\t\t\t\t);\n+\t\t\t\t\t\tglobalCfg.setTrackEntitiesChangedInRevision(true);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\trevisionInfoGenerator = new DefaultRevisionInfoGenerator(\n+\t\t\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n+\t\t\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// In case of a custom revision info generator, the mapping will be null.\n \t\tDocument revisionInfoXmlMapping = null;\n \n \t\tfinal Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass( RevisionListener.class );\n \n \t\tif ( revisionInfoGenerator == null ) {\n \t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision() ) {\n \t\t\t\trevisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ?\n \t\t\t\t\t\tDefaultTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t:\n \t\t\t\t\t\tSequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n \t\t\t\trevisionInfoEntityName = revisionInfoClass.getName();\n \t\t\t\trevisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\trevisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n \t\t\t\t\t\t: SequenceIdRevisionEntity.class;\n \t\t\t\trevisionInfoGenerator = new DefaultRevisionInfoGenerator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n \t\t\t\t);\n \t\t\t}\n \t\t\trevisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n \t\t}\n \n \t\treturn new RevisionInfoConfigurationResult(\n \t\t\t\trevisionInfoGenerator, revisionInfoXmlMapping,\n \t\t\t\tnew RevisionInfoQueryCreator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoIdData.getName(),\n \t\t\t\t\t\trevisionInfoTimestampData.getName(), isTimestampAsDate()\n \t\t\t\t),\n \t\t\t\tgenerateRevisionInfoRelationMapping(),\n \t\t\t\tnew RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData ),\n \t\t\t\tglobalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(\n \t\t\t\t\t\trevisionInfoClass,\n \t\t\t\t\t\tmodifiedEntityNamesData\n \t\t\t\t)\n \t\t\t\t\t\t: null,\n \t\t\t\trevisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData\n \t\t);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"63a0f03c5ae773f96c92c02fba9d13133d02485b": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "HHH-9654 - Adjust envers for 5.0 APIs + JAXB\n",
			"commitDate": "2015-03-18, 6:22 PM",
			"commitName": "63a0f03c5ae773f96c92c02fba9d13133d02485b",
			"commitAuthor": "Steve Ebersole",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "HHH-9654 - Adjust envers for 5.0 APIs + JAXB\n",
					"commitDate": "2015-03-18, 6:22 PM",
					"commitName": "63a0f03c5ae773f96c92c02fba9d13133d02485b",
					"commitAuthor": "Steve Ebersole",
					"commitDateOld": "2013-11-24, 7:44 AM",
					"commitNameOld": "cd590470c0059981537e558a5ff6d114fd24df61",
					"commitAuthorOld": "Steve Ebersole",
					"daysBetweenCommits": 479.4,
					"commitsBetweenForRepo": 421,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,127 +1,125 @@\n-\tpublic RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n+\tpublic RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n \t\tboolean revisionEntityFound = false;\n \t\tRevisionInfoGenerator revisionInfoGenerator = null;\n \t\tClass<?> revisionInfoClass = null;\n \n-\t\tfinal Iterator<PersistentClass> classes = cfg.getClassMappings();\n-\t\twhile ( classes.hasNext() ) {\n-\t\t\tPersistentClass pc = classes.next();\n+\t\tfor ( PersistentClass persistentClass : metadata.getEntityBindings() ) {\n \t\t\tXClass clazz;\n \t\t\ttry {\n-\t\t\t\tclazz = reflectionManager.classForName( pc.getClassName(), this.getClass() );\n+\t\t\t\tclazz = reflectionManager.classForName( persistentClass.getClassName(), this.getClass() );\n \t\t\t}\n \t\t\tcatch (ClassNotFoundException e) {\n \t\t\t\tthrow new MappingException( e );\n \t\t\t}\n \n \t\t\tfinal RevisionEntity revisionEntity = clazz.getAnnotation( RevisionEntity.class );\n \t\t\tif ( revisionEntity != null ) {\n \t\t\t\tif ( revisionEntityFound ) {\n \t\t\t\t\tthrow new MappingException( \"Only one entity may be annotated with @RevisionEntity!\" );\n \t\t\t\t}\n \n \t\t\t\t// Checking if custom revision entity isn't audited\n \t\t\t\tif ( clazz.getAnnotation( Audited.class ) != null ) {\n \t\t\t\t\tthrow new MappingException( \"An entity annotated with @RevisionEntity cannot be audited!\" );\n \t\t\t\t}\n \n \t\t\t\trevisionEntityFound = true;\n \n \t\t\t\tfinal MutableBoolean revisionNumberFound = new MutableBoolean();\n \t\t\t\tfinal MutableBoolean revisionTimestampFound = new MutableBoolean();\n \t\t\t\tfinal MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n \n \t\t\t\tsearchForRevisionInfoCfg(\n \t\t\t\t\t\tclazz,\n \t\t\t\t\t\treflectionManager,\n \t\t\t\t\t\trevisionNumberFound,\n \t\t\t\t\t\trevisionTimestampFound,\n \t\t\t\t\t\tmodifiedEntityNamesFound\n \t\t\t\t);\n \n \t\t\t\tif ( !revisionNumberFound.isSet() ) {\n \t\t\t\t\tthrow new MappingException(\n \t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n \t\t\t\t\t\t\t\t\t\"with @RevisionNumber!\"\n \t\t\t\t\t);\n \t\t\t\t}\n \n \t\t\t\tif ( !revisionTimestampFound.isSet() ) {\n \t\t\t\t\tthrow new MappingException(\n \t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n \t\t\t\t\t\t\t\t\t\"with @RevisionTimestamp!\"\n \t\t\t\t\t);\n \t\t\t\t}\n \n-\t\t\t\trevisionInfoEntityName = pc.getEntityName();\n-\t\t\t\trevisionInfoClass = pc.getMappedClass();\n+\t\t\t\trevisionInfoEntityName = persistentClass.getEntityName();\n+\t\t\t\trevisionInfoClass = persistentClass.getMappedClass();\n \t\t\t\tfinal Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass( revisionEntity.value() );\n-\t\t\t\trevisionInfoTimestampType = pc.getProperty( revisionInfoTimestampData.getName() ).getType();\n+\t\t\t\trevisionInfoTimestampType = persistentClass.getProperty( revisionInfoTimestampData.getName() ).getType();\n \t\t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision()\n \t\t\t\t\t\t|| (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n \t\t\t\t\t\t|| (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n \t\t\t\t\t\t|| modifiedEntityNamesFound.isSet() ) {\n \t\t\t\t\t// If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n \t\t\t\t\t// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n \t\t\t\t\trevisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n \t\t\t\t\t\t\trevisionInfoEntityName,\n \t\t\t\t\t\t\trevisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n \t\t\t\t\t\t\tmodifiedEntityNamesData\n \t\t\t\t\t);\n \t\t\t\t\tglobalCfg.setTrackEntitiesChangedInRevision( true );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\trevisionInfoGenerator = new DefaultRevisionInfoGenerator(\n \t\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// In case of a custom revision info generator, the mapping will be null.\n \t\tDocument revisionInfoXmlMapping = null;\n \n \t\tfinal Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass( RevisionListener.class );\n \n \t\tif ( revisionInfoGenerator == null ) {\n \t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision() ) {\n \t\t\t\trevisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ?\n \t\t\t\t\t\tDefaultTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t:\n \t\t\t\t\t\tSequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n \t\t\t\trevisionInfoEntityName = revisionInfoClass.getName();\n \t\t\t\trevisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\trevisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n \t\t\t\t\t\t: SequenceIdRevisionEntity.class;\n \t\t\t\trevisionInfoGenerator = new DefaultRevisionInfoGenerator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n \t\t\t\t);\n \t\t\t}\n \t\t\trevisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n \t\t}\n \n \t\treturn new RevisionInfoConfigurationResult(\n \t\t\t\trevisionInfoGenerator, revisionInfoXmlMapping,\n \t\t\t\tnew RevisionInfoQueryCreator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoIdData.getName(),\n \t\t\t\t\t\trevisionInfoTimestampData.getName(), isTimestampAsDate()\n \t\t\t\t),\n \t\t\t\tgenerateRevisionInfoRelationMapping(),\n \t\t\t\tnew RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData ),\n \t\t\t\tglobalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(\n \t\t\t\t\t\trevisionInfoClass,\n \t\t\t\t\t\tmodifiedEntityNamesData\n \t\t\t\t)\n \t\t\t\t\t\t: null,\n \t\t\t\trevisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData\n \t\t);\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[cfg-Configuration, reflectionManager-ReflectionManager]",
						"newValue": "[metadata-MetadataImplementor, reflectionManager-ReflectionManager]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "HHH-9654 - Adjust envers for 5.0 APIs + JAXB\n",
					"commitDate": "2015-03-18, 6:22 PM",
					"commitName": "63a0f03c5ae773f96c92c02fba9d13133d02485b",
					"commitAuthor": "Steve Ebersole",
					"commitDateOld": "2013-11-24, 7:44 AM",
					"commitNameOld": "cd590470c0059981537e558a5ff6d114fd24df61",
					"commitAuthorOld": "Steve Ebersole",
					"daysBetweenCommits": 479.4,
					"commitsBetweenForRepo": 421,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,127 +1,125 @@\n-\tpublic RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n+\tpublic RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {\n \t\tboolean revisionEntityFound = false;\n \t\tRevisionInfoGenerator revisionInfoGenerator = null;\n \t\tClass<?> revisionInfoClass = null;\n \n-\t\tfinal Iterator<PersistentClass> classes = cfg.getClassMappings();\n-\t\twhile ( classes.hasNext() ) {\n-\t\t\tPersistentClass pc = classes.next();\n+\t\tfor ( PersistentClass persistentClass : metadata.getEntityBindings() ) {\n \t\t\tXClass clazz;\n \t\t\ttry {\n-\t\t\t\tclazz = reflectionManager.classForName( pc.getClassName(), this.getClass() );\n+\t\t\t\tclazz = reflectionManager.classForName( persistentClass.getClassName(), this.getClass() );\n \t\t\t}\n \t\t\tcatch (ClassNotFoundException e) {\n \t\t\t\tthrow new MappingException( e );\n \t\t\t}\n \n \t\t\tfinal RevisionEntity revisionEntity = clazz.getAnnotation( RevisionEntity.class );\n \t\t\tif ( revisionEntity != null ) {\n \t\t\t\tif ( revisionEntityFound ) {\n \t\t\t\t\tthrow new MappingException( \"Only one entity may be annotated with @RevisionEntity!\" );\n \t\t\t\t}\n \n \t\t\t\t// Checking if custom revision entity isn't audited\n \t\t\t\tif ( clazz.getAnnotation( Audited.class ) != null ) {\n \t\t\t\t\tthrow new MappingException( \"An entity annotated with @RevisionEntity cannot be audited!\" );\n \t\t\t\t}\n \n \t\t\t\trevisionEntityFound = true;\n \n \t\t\t\tfinal MutableBoolean revisionNumberFound = new MutableBoolean();\n \t\t\t\tfinal MutableBoolean revisionTimestampFound = new MutableBoolean();\n \t\t\t\tfinal MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n \n \t\t\t\tsearchForRevisionInfoCfg(\n \t\t\t\t\t\tclazz,\n \t\t\t\t\t\treflectionManager,\n \t\t\t\t\t\trevisionNumberFound,\n \t\t\t\t\t\trevisionTimestampFound,\n \t\t\t\t\t\tmodifiedEntityNamesFound\n \t\t\t\t);\n \n \t\t\t\tif ( !revisionNumberFound.isSet() ) {\n \t\t\t\t\tthrow new MappingException(\n \t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n \t\t\t\t\t\t\t\t\t\"with @RevisionNumber!\"\n \t\t\t\t\t);\n \t\t\t\t}\n \n \t\t\t\tif ( !revisionTimestampFound.isSet() ) {\n \t\t\t\t\tthrow new MappingException(\n \t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n \t\t\t\t\t\t\t\t\t\"with @RevisionTimestamp!\"\n \t\t\t\t\t);\n \t\t\t\t}\n \n-\t\t\t\trevisionInfoEntityName = pc.getEntityName();\n-\t\t\t\trevisionInfoClass = pc.getMappedClass();\n+\t\t\t\trevisionInfoEntityName = persistentClass.getEntityName();\n+\t\t\t\trevisionInfoClass = persistentClass.getMappedClass();\n \t\t\t\tfinal Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass( revisionEntity.value() );\n-\t\t\t\trevisionInfoTimestampType = pc.getProperty( revisionInfoTimestampData.getName() ).getType();\n+\t\t\t\trevisionInfoTimestampType = persistentClass.getProperty( revisionInfoTimestampData.getName() ).getType();\n \t\t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision()\n \t\t\t\t\t\t|| (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n \t\t\t\t\t\t|| (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n \t\t\t\t\t\t|| modifiedEntityNamesFound.isSet() ) {\n \t\t\t\t\t// If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n \t\t\t\t\t// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n \t\t\t\t\trevisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n \t\t\t\t\t\t\trevisionInfoEntityName,\n \t\t\t\t\t\t\trevisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n \t\t\t\t\t\t\tmodifiedEntityNamesData\n \t\t\t\t\t);\n \t\t\t\t\tglobalCfg.setTrackEntitiesChangedInRevision( true );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\trevisionInfoGenerator = new DefaultRevisionInfoGenerator(\n \t\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// In case of a custom revision info generator, the mapping will be null.\n \t\tDocument revisionInfoXmlMapping = null;\n \n \t\tfinal Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass( RevisionListener.class );\n \n \t\tif ( revisionInfoGenerator == null ) {\n \t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision() ) {\n \t\t\t\trevisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ?\n \t\t\t\t\t\tDefaultTrackingModifiedEntitiesRevisionEntity.class\n \t\t\t\t\t\t:\n \t\t\t\t\t\tSequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n \t\t\t\trevisionInfoEntityName = revisionInfoClass.getName();\n \t\t\t\trevisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\trevisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n \t\t\t\t\t\t: SequenceIdRevisionEntity.class;\n \t\t\t\trevisionInfoGenerator = new DefaultRevisionInfoGenerator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n \t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n \t\t\t\t);\n \t\t\t}\n \t\t\trevisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n \t\t}\n \n \t\treturn new RevisionInfoConfigurationResult(\n \t\t\t\trevisionInfoGenerator, revisionInfoXmlMapping,\n \t\t\t\tnew RevisionInfoQueryCreator(\n \t\t\t\t\t\trevisionInfoEntityName, revisionInfoIdData.getName(),\n \t\t\t\t\t\trevisionInfoTimestampData.getName(), isTimestampAsDate()\n \t\t\t\t),\n \t\t\t\tgenerateRevisionInfoRelationMapping(),\n \t\t\t\tnew RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData ),\n \t\t\t\tglobalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(\n \t\t\t\t\t\trevisionInfoClass,\n \t\t\t\t\t\tmodifiedEntityNamesData\n \t\t\t\t)\n \t\t\t\t\t\t: null,\n \t\t\t\trevisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData\n \t\t);\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"364a47f2c746a5eeb1642102580a9daa8bc27fc9": {
			"type": "Ybodychange",
			"commitMessage": "HHH-8159 - Apply fixups indicated by analysis tools\n",
			"commitDate": "2013-05-02, 8:01 AM",
			"commitName": "364a47f2c746a5eeb1642102580a9daa8bc27fc9",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2013-04-08, 5:43 AM",
			"commitNameOld": "5cc051e1dfeb5664d8d1eb9a289097d7f9bfb0e2",
			"commitAuthorOld": "Lukasz Antoniak",
			"daysBetweenCommits": 24.1,
			"commitsBetweenForRepo": 124,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,97 +1,127 @@\n-    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n-        Iterator<PersistentClass> classes = cfg.getClassMappings();\n-        boolean revisionEntityFound = false;\n-        RevisionInfoGenerator revisionInfoGenerator = null;\n+\tpublic RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n+\t\tboolean revisionEntityFound = false;\n+\t\tRevisionInfoGenerator revisionInfoGenerator = null;\n+\t\tClass<?> revisionInfoClass = null;\n \n-        Class<?> revisionInfoClass = null;\n+\t\tfinal Iterator<PersistentClass> classes = cfg.getClassMappings();\n+\t\twhile ( classes.hasNext() ) {\n+\t\t\tPersistentClass pc = classes.next();\n+\t\t\tXClass clazz;\n+\t\t\ttry {\n+\t\t\t\tclazz = reflectionManager.classForName( pc.getClassName(), this.getClass() );\n+\t\t\t}\n+\t\t\tcatch (ClassNotFoundException e) {\n+\t\t\t\tthrow new MappingException( e );\n+\t\t\t}\n \n-        while (classes.hasNext()) {\n-            PersistentClass pc = classes.next();\n-            XClass clazz;\n-            try {\n-                clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n-            } catch (ClassNotFoundException e) {\n-                throw new MappingException(e);\n-            }\n+\t\t\tfinal RevisionEntity revisionEntity = clazz.getAnnotation( RevisionEntity.class );\n+\t\t\tif ( revisionEntity != null ) {\n+\t\t\t\tif ( revisionEntityFound ) {\n+\t\t\t\t\tthrow new MappingException( \"Only one entity may be annotated with @RevisionEntity!\" );\n+\t\t\t\t}\n \n-            RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n-            if (revisionEntity != null) {\n-                if (revisionEntityFound) {\n-                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n-                }\n+\t\t\t\t// Checking if custom revision entity isn't audited\n+\t\t\t\tif ( clazz.getAnnotation( Audited.class ) != null ) {\n+\t\t\t\t\tthrow new MappingException( \"An entity annotated with @RevisionEntity cannot be audited!\" );\n+\t\t\t\t}\n \n-                // Checking if custom revision entity isn't audited\n-                if (clazz.getAnnotation(Audited.class) != null) {\n-                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n-                }\n+\t\t\t\trevisionEntityFound = true;\n \n-                revisionEntityFound = true;\n+\t\t\t\tfinal MutableBoolean revisionNumberFound = new MutableBoolean();\n+\t\t\t\tfinal MutableBoolean revisionTimestampFound = new MutableBoolean();\n+\t\t\t\tfinal MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n \n-                MutableBoolean revisionNumberFound = new MutableBoolean();\n-                MutableBoolean revisionTimestampFound = new MutableBoolean();\n-                MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n+\t\t\t\tsearchForRevisionInfoCfg(\n+\t\t\t\t\t\tclazz,\n+\t\t\t\t\t\treflectionManager,\n+\t\t\t\t\t\trevisionNumberFound,\n+\t\t\t\t\t\trevisionTimestampFound,\n+\t\t\t\t\t\tmodifiedEntityNamesFound\n+\t\t\t\t);\n \n-                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n+\t\t\t\tif ( !revisionNumberFound.isSet() ) {\n+\t\t\t\t\tthrow new MappingException(\n+\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n+\t\t\t\t\t\t\t\t\t\"with @RevisionNumber!\"\n+\t\t\t\t\t);\n+\t\t\t\t}\n \n-                if (!revisionNumberFound.isSet()) {\n-                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n-                            \"with @RevisionNumber!\");\n-                }\n+\t\t\t\tif ( !revisionTimestampFound.isSet() ) {\n+\t\t\t\t\tthrow new MappingException(\n+\t\t\t\t\t\t\t\"An entity annotated with @RevisionEntity must have a field annotated \" +\n+\t\t\t\t\t\t\t\t\t\"with @RevisionTimestamp!\"\n+\t\t\t\t\t);\n+\t\t\t\t}\n \n-                if (!revisionTimestampFound.isSet()) {\n-                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n-                            \"with @RevisionTimestamp!\");\n-                }\n+\t\t\t\trevisionInfoEntityName = pc.getEntityName();\n+\t\t\t\trevisionInfoClass = pc.getMappedClass();\n+\t\t\t\tfinal Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass( revisionEntity.value() );\n+\t\t\t\trevisionInfoTimestampType = pc.getProperty( revisionInfoTimestampData.getName() ).getType();\n+\t\t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision()\n+\t\t\t\t\t\t|| (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class\n+\t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n+\t\t\t\t\t\t|| (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class\n+\t\t\t\t\t\t.isAssignableFrom( revisionInfoClass ))\n+\t\t\t\t\t\t|| modifiedEntityNamesFound.isSet() ) {\n+\t\t\t\t\t// If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n+\t\t\t\t\t// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n+\t\t\t\t\trevisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n+\t\t\t\t\t\t\trevisionInfoEntityName,\n+\t\t\t\t\t\t\trevisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n+\t\t\t\t\t\t\tmodifiedEntityNamesData\n+\t\t\t\t\t);\n+\t\t\t\t\tglobalCfg.setTrackEntitiesChangedInRevision( true );\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\trevisionInfoGenerator = new DefaultRevisionInfoGenerator(\n+\t\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n+\t\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n+\t\t\t\t\t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n-                revisionInfoEntityName = pc.getEntityName();\n-                revisionInfoClass = pc.getMappedClass();\n-                Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(revisionEntity.value());\n-                revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n-                if (globalCfg.isTrackEntitiesChangedInRevision()\n-                        || (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n-                        || (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n-                        || modifiedEntityNamesFound.isSet()) {\n-                    // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n-                    // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n-                    revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n-                            revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n-                            modifiedEntityNamesData);\n-                    globalCfg.setTrackEntitiesChangedInRevision(true);\n-                } else {\n-                    revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                            revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n-                }\n-            }\n-        }\n+\t\t// In case of a custom revision info generator, the mapping will be null.\n+\t\tDocument revisionInfoXmlMapping = null;\n \n-        // In case of a custom revision info generator, the mapping will be null.\n-        Document revisionInfoXmlMapping = null;\n+\t\tfinal Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass( RevisionListener.class );\n \n-        Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(RevisionListener.class);\n+\t\tif ( revisionInfoGenerator == null ) {\n+\t\t\tif ( globalCfg.isTrackEntitiesChangedInRevision() ) {\n+\t\t\t\trevisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ?\n+\t\t\t\t\t\tDefaultTrackingModifiedEntitiesRevisionEntity.class\n+\t\t\t\t\t\t:\n+\t\t\t\t\t\tSequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n+\t\t\t\trevisionInfoEntityName = revisionInfoClass.getName();\n+\t\t\t\trevisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(\n+\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n+\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData\n+\t\t\t\t);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\trevisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n+\t\t\t\t\t\t: SequenceIdRevisionEntity.class;\n+\t\t\t\trevisionInfoGenerator = new DefaultRevisionInfoGenerator(\n+\t\t\t\t\t\trevisionInfoEntityName, revisionInfoClass,\n+\t\t\t\t\t\trevisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()\n+\t\t\t\t);\n+\t\t\t}\n+\t\t\trevisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n+\t\t}\n \n-        if (revisionInfoGenerator == null) {\n-            if (globalCfg.isTrackEntitiesChangedInRevision()) {\n-                revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class\n-                                                                                : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n-                revisionInfoEntityName = revisionInfoClass.getName();\n-                revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                        revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n-            } else {\n-                revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n-                                                                                : SequenceIdRevisionEntity.class;\n-                revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                        revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n-            }\n-            revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n-        }\n-\n-        return new RevisionInfoConfigurationResult(\n-                revisionInfoGenerator, revisionInfoXmlMapping,\n-                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n-                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n-                generateRevisionInfoRelationMapping(),\n-                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n-                globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n-                                                             : null,\n-                revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n-    }\n\\ No newline at end of file\n+\t\treturn new RevisionInfoConfigurationResult(\n+\t\t\t\trevisionInfoGenerator, revisionInfoXmlMapping,\n+\t\t\t\tnew RevisionInfoQueryCreator(\n+\t\t\t\t\t\trevisionInfoEntityName, revisionInfoIdData.getName(),\n+\t\t\t\t\t\trevisionInfoTimestampData.getName(), isTimestampAsDate()\n+\t\t\t\t),\n+\t\t\t\tgenerateRevisionInfoRelationMapping(),\n+\t\t\t\tnew RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData ),\n+\t\t\t\tglobalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(\n+\t\t\t\t\t\trevisionInfoClass,\n+\t\t\t\t\t\tmodifiedEntityNamesData\n+\t\t\t\t)\n+\t\t\t\t\t\t: null,\n+\t\t\t\trevisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData\n+\t\t);\n+\t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5cc051e1dfeb5664d8d1eb9a289097d7f9bfb0e2": {
			"type": "Ymultichange(Yfilerename,Ybodychange)",
			"commitMessage": "HHH-7944 - Separation of Envers API, SPI and internal packages\n",
			"commitDate": "2013-04-08, 5:43 AM",
			"commitName": "5cc051e1dfeb5664d8d1eb9a289097d7f9bfb0e2",
			"commitAuthor": "Lukasz Antoniak",
			"subchanges": [
				{
					"type": "Yfilerename",
					"commitMessage": "HHH-7944 - Separation of Envers API, SPI and internal packages\n",
					"commitDate": "2013-04-08, 5:43 AM",
					"commitName": "5cc051e1dfeb5664d8d1eb9a289097d7f9bfb0e2",
					"commitAuthor": "Lukasz Antoniak",
					"commitDateOld": "2013-04-05, 1:15 PM",
					"commitNameOld": "2b2f333593c1989624d332d47b1358afd1999a91",
					"commitAuthorOld": "Steve Ebersole",
					"daysBetweenCommits": 2.69,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,97 +1,97 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't audited\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n                 MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n                 revisionInfoClass = pc.getMappedClass();\n                 Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(revisionEntity.value());\n                 revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n-                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()\n+                if (globalCfg.isTrackEntitiesChangedInRevision()\n                         || (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                         || (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                         || modifiedEntityNamesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                     // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                     revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n                             revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n                             modifiedEntityNamesData);\n-                    globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n+                    globalCfg.setTrackEntitiesChangedInRevision(true);\n                 } else {\n                     revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(RevisionListener.class);\n \n         if (revisionInfoGenerator == null) {\n-            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n+            if (globalCfg.isTrackEntitiesChangedInRevision()) {\n                 revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class\n                                                                                 : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n                 revisionInfoEntityName = revisionInfoClass.getName();\n                 revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n             } else {\n                 revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n                                                                                 : SequenceIdRevisionEntity.class;\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n-                globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n-                                                                    : null,\n+                globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n+                                                             : null,\n                 revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldPath": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
						"newPath": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "HHH-7944 - Separation of Envers API, SPI and internal packages\n",
					"commitDate": "2013-04-08, 5:43 AM",
					"commitName": "5cc051e1dfeb5664d8d1eb9a289097d7f9bfb0e2",
					"commitAuthor": "Lukasz Antoniak",
					"commitDateOld": "2013-04-05, 1:15 PM",
					"commitNameOld": "2b2f333593c1989624d332d47b1358afd1999a91",
					"commitAuthorOld": "Steve Ebersole",
					"daysBetweenCommits": 2.69,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,97 +1,97 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't audited\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n                 MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n                 revisionInfoClass = pc.getMappedClass();\n                 Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(revisionEntity.value());\n                 revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n-                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()\n+                if (globalCfg.isTrackEntitiesChangedInRevision()\n                         || (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                         || (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                         || modifiedEntityNamesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                     // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                     revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n                             revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n                             modifiedEntityNamesData);\n-                    globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n+                    globalCfg.setTrackEntitiesChangedInRevision(true);\n                 } else {\n                     revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(RevisionListener.class);\n \n         if (revisionInfoGenerator == null) {\n-            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n+            if (globalCfg.isTrackEntitiesChangedInRevision()) {\n                 revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class\n                                                                                 : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n                 revisionInfoEntityName = revisionInfoClass.getName();\n                 revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n             } else {\n                 revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n                                                                                 : SequenceIdRevisionEntity.class;\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n-                globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n-                                                                    : null,\n+                globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n+                                                             : null,\n                 revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"6c6df695350f917fe707b4f830e29c8c52c3f5d0": {
			"type": "Ybodychange",
			"commitMessage": "refactor, remove redundant type cast\n",
			"commitDate": "2012-12-25, 3:25 AM",
			"commitName": "6c6df695350f917fe707b4f830e29c8c52c3f5d0",
			"commitAuthor": "Strong Liu",
			"commitDateOld": "2012-11-19, 10:03 AM",
			"commitNameOld": "c01dd40a6566b62e3ae85f6c0024c147cf2d78ff",
			"commitAuthorOld": "Lukasz Antoniak",
			"daysBetweenCommits": 35.72,
			"commitsBetweenForRepo": 60,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,97 +1,97 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n-        Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n+        Iterator<PersistentClass> classes = cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't audited\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n                 MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n                 revisionInfoClass = pc.getMappedClass();\n                 Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(revisionEntity.value());\n                 revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()\n                         || (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                         || (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                         || modifiedEntityNamesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                     // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                     revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n                             revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n                             modifiedEntityNamesData);\n                     globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                 } else {\n                     revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(RevisionListener.class);\n \n         if (revisionInfoGenerator == null) {\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                 revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class\n                                                                                 : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n                 revisionInfoEntityName = revisionInfoClass.getName();\n                 revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n             } else {\n                 revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n                                                                                 : SequenceIdRevisionEntity.class;\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n                 globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n                                                                     : null,\n                 revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"95ec3457af961c4116015509180dcca04967604f": {
			"type": "Ybodychange",
			"commitMessage": "HHH-7187 - Renaming and documenting enhanced revision entity\n",
			"commitDate": "2012-04-19, 2:49 PM",
			"commitName": "95ec3457af961c4116015509180dcca04967604f",
			"commitAuthor": "Lukasz Antoniak",
			"commitDateOld": "2012-04-19, 5:15 AM",
			"commitNameOld": "c4822556c19a6ea2d7be93b505548e834c83d955",
			"commitAuthorOld": "Lukasz Antoniak",
			"daysBetweenCommits": 0.4,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,97 +1,97 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't audited\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n                 MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n                 revisionInfoClass = pc.getMappedClass();\n                 Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(revisionEntity.value());\n                 revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()\n-                        || (!globalCfg.isUseEnhancedRevisionEntity() && DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n-                        || (globalCfg.isUseEnhancedRevisionEntity() && org.hibernate.envers.enhanced.DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n+                        || (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n+                        || (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n                         || modifiedEntityNamesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                     // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                     revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n                             revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n                             modifiedEntityNamesData);\n                     globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                 } else {\n                     revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(RevisionListener.class);\n \n         if (revisionInfoGenerator == null) {\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n-                revisionInfoClass = globalCfg.isUseEnhancedRevisionEntity() ? org.hibernate.envers.enhanced.DefaultTrackingModifiedEntitiesRevisionEntity.class\n-                                                                            : DefaultTrackingModifiedEntitiesRevisionEntity.class;\n+                revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultTrackingModifiedEntitiesRevisionEntity.class\n+                                                                                : SequenceIdTrackingModifiedEntitiesRevisionEntity.class;\n                 revisionInfoEntityName = revisionInfoClass.getName();\n                 revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n             } else {\n-                revisionInfoClass = globalCfg.isUseEnhancedRevisionEntity() ? org.hibernate.envers.enhanced.DefaultRevisionEntity.class\n-                                                                            : DefaultRevisionEntity.class;\n+                revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class\n+                                                                                : SequenceIdRevisionEntity.class;\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n                 globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n                                                                     : null,\n                 revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c4822556c19a6ea2d7be93b505548e834c83d955": {
			"type": "Ybodychange",
			"commitMessage": "HHH-7187 - Enhanced default revision entity\n",
			"commitDate": "2012-04-19, 5:15 AM",
			"commitName": "c4822556c19a6ea2d7be93b505548e834c83d955",
			"commitAuthor": "Lukasz Antoniak",
			"commitDateOld": "2012-01-28, 2:27 PM",
			"commitNameOld": "46b7a0d38e59e91d3c6b6b1e6a0200dd3118a1a6",
			"commitAuthorOld": "Lukasz Antoniak",
			"daysBetweenCommits": 81.58,
			"commitsBetweenForRepo": 214,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,94 +1,97 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't audited\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n                 MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n                 revisionInfoClass = pc.getMappedClass();\n                 Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(revisionEntity.value());\n                 revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n-                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n-                        DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n-                        modifiedEntityNamesFound.isSet()) {\n+                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()\n+                        || (!globalCfg.isUseEnhancedRevisionEntity() && DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n+                        || (globalCfg.isUseEnhancedRevisionEntity() && org.hibernate.envers.enhanced.DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass))\n+                        || modifiedEntityNamesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                     // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                     revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n                             revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n                             modifiedEntityNamesData);\n                     globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                 } else {\n                     revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(RevisionListener.class);\n \n         if (revisionInfoGenerator == null) {\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n-                revisionInfoClass = DefaultTrackingModifiedEntitiesRevisionEntity.class;\n-                revisionInfoEntityName = DefaultTrackingModifiedEntitiesRevisionEntity.class.getName();\n+                revisionInfoClass = globalCfg.isUseEnhancedRevisionEntity() ? org.hibernate.envers.enhanced.DefaultTrackingModifiedEntitiesRevisionEntity.class\n+                                                                            : DefaultTrackingModifiedEntitiesRevisionEntity.class;\n+                revisionInfoEntityName = revisionInfoClass.getName();\n                 revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n             } else {\n-                revisionInfoClass = DefaultRevisionEntity.class;\n+                revisionInfoClass = globalCfg.isUseEnhancedRevisionEntity() ? org.hibernate.envers.enhanced.DefaultRevisionEntity.class\n+                                                                            : DefaultRevisionEntity.class;\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n                 globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n                                                                     : null,\n                 revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"45f3ced6daf96f1a697f350e134512562b48d3fd": {
			"type": "Ybodychange",
			"commitMessage": "HHH-6696 - RevisionListener class configuration parameter\n",
			"commitDate": "2011-09-29, 11:50 AM",
			"commitName": "45f3ced6daf96f1a697f350e134512562b48d3fd",
			"commitAuthor": "Lukasz Antoniak",
			"commitDateOld": "2011-06-12, 4:55 AM",
			"commitNameOld": "13c9fd4f9d177fb7d022c72d674f1a23b909c443",
			"commitAuthorOld": "Lukasz Antoniak",
			"daysBetweenCommits": 109.29,
			"commitsBetweenForRepo": 345,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,92 +1,94 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't audited\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n                 MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n-\n                 revisionInfoClass = pc.getMappedClass();\n+                Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(revisionEntity.value());\n                 revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n                         DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n                         modifiedEntityNamesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                     // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                     revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n-                            revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(),\n+                            revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),\n                             modifiedEntityNamesData);\n                     globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                 } else {\n                     revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                            revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n+                            revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n+        Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass(RevisionListener.class);\n+\n         if (revisionInfoGenerator == null) {\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                 revisionInfoClass = DefaultTrackingModifiedEntitiesRevisionEntity.class;\n                 revisionInfoEntityName = DefaultTrackingModifiedEntitiesRevisionEntity.class.getName();\n                 revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n+                        revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n             } else {\n                 revisionInfoClass = DefaultRevisionEntity.class;\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n+                        revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n                 globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n                                                                     : null,\n                 revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"13c9fd4f9d177fb7d022c72d674f1a23b909c443": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5580 - Persisting entity name by default\n",
			"commitDate": "2011-06-12, 4:55 AM",
			"commitName": "13c9fd4f9d177fb7d022c72d674f1a23b909c443",
			"commitAuthor": "Lukasz Antoniak",
			"commitDateOld": "2011-05-28, 8:01 AM",
			"commitNameOld": "40225711963be4f38e961b2faef4a7ea545cba1a",
			"commitAuthorOld": "Lukasz Antoniak",
			"daysBetweenCommits": 14.87,
			"commitsBetweenForRepo": 67,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,92 +1,92 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't audited\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n-                MutableBoolean modifiedEntityTypesFound = new MutableBoolean();\n+                MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n \n-                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityTypesFound);\n+                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n \n                 revisionInfoClass = pc.getMappedClass();\n                 revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n-                        DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n-                        modifiedEntityTypesFound.isSet()) {\n+                        DefaultTrackingModifiedEntitiesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n+                        modifiedEntityNamesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n-                    // of DefaultTrackingModifiedTypesRevisionEntity class, or @ModifiedEntityTypes annotation is used.\n-                    revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName,\n+                    // of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n+                    revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName,\n                             revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(),\n-                            modifiedEntityTypesData);\n+                            modifiedEntityNamesData);\n                     globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                 } else {\n                     revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         if (revisionInfoGenerator == null) {\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n-                revisionInfoClass = DefaultTrackingModifiedTypesRevisionEntity.class;\n-                revisionInfoEntityName = DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n-                revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n+                revisionInfoClass = DefaultTrackingModifiedEntitiesRevisionEntity.class;\n+                revisionInfoEntityName = DefaultTrackingModifiedEntitiesRevisionEntity.class.getName();\n+                revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n+                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n             } else {\n                 revisionInfoClass = DefaultRevisionEntity.class;\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n-                globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityTypesReader(revisionInfoClass, modifiedEntityTypesData)\n+                globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityNamesReader(revisionInfoClass, modifiedEntityNamesData)\n                                                                     : null,\n                 revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"403b15cae8d19f83c35c9490826d24b0bf5c2fa0": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5580 - Query refactoring\n",
			"commitDate": "2011-05-17, 2:14 PM",
			"commitName": "403b15cae8d19f83c35c9490826d24b0bf5c2fa0",
			"commitAuthor": "Lukasz Antoniak",
			"commitDateOld": "2011-05-16, 10:18 AM",
			"commitNameOld": "1878b238503f3b52a6e7b31f849d7253206c7465",
			"commitAuthorOld": "Lukasz Antoniak",
			"daysBetweenCommits": 1.16,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,90 +1,92 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't audited\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n                 MutableBoolean modifiedEntityTypesFound = new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityTypesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n \n                 revisionInfoClass = pc.getMappedClass();\n                 revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n                         DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n                         modifiedEntityTypesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                     // of DefaultTrackingModifiedTypesRevisionEntity class, or @ModifiedEntityTypes annotation is used.\n                     revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName,\n                             revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(),\n                             modifiedEntityTypesData);\n                     globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                 } else {\n                     revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         if (revisionInfoGenerator == null) {\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                 revisionInfoClass = DefaultTrackingModifiedTypesRevisionEntity.class;\n                 revisionInfoEntityName = DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n                 revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n             } else {\n                 revisionInfoClass = DefaultRevisionEntity.class;\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n-                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n-                revisionInfoClass, revisionInfoTimestampData);\n+                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData),\n+                globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? new ModifiedEntityTypesReader(revisionInfoClass, modifiedEntityTypesData)\n+                                                                    : null,\n+                revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1878b238503f3b52a6e7b31f849d7253206c7465": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5580 - Naming\n",
			"commitDate": "2011-05-16, 10:18 AM",
			"commitName": "1878b238503f3b52a6e7b31f849d7253206c7465",
			"commitAuthor": "Lukasz Antoniak",
			"commitDateOld": "2011-05-14, 3:46 PM",
			"commitNameOld": "dd55a99b00c447e53fe97bdbc423f3e6d7d59557",
			"commitAuthorOld": "Lukasz Antoniak",
			"daysBetweenCommits": 1.77,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,90 +1,90 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't audited\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n-                MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n+                MutableBoolean modifiedEntityTypesFound = new MutableBoolean();\n \n-                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n+                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityTypesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n \n                 revisionInfoClass = pc.getMappedClass();\n                 revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n                         DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n-                        modifiedEntityNamesFound.isSet()) {\n+                        modifiedEntityTypesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n-                    // of DefaultTrackingModifiedTypesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n+                    // of DefaultTrackingModifiedTypesRevisionEntity class, or @ModifiedEntityTypes annotation is used.\n                     revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName,\n                             revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(),\n-                            modifiedEntityNamesData);\n+                            modifiedEntityTypesData);\n                     globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                 } else {\n                     revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         if (revisionInfoGenerator == null) {\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                 revisionInfoClass = DefaultTrackingModifiedTypesRevisionEntity.class;\n                 revisionInfoEntityName = DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n                 revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n+                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityTypesData);\n             } else {\n                 revisionInfoClass = DefaultRevisionEntity.class;\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n                 revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dd55a99b00c447e53fe97bdbc423f3e6d7d59557": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5580 - Using Criteria API in RevisionInfoQueryCreator\n",
			"commitDate": "2011-05-14, 3:46 PM",
			"commitName": "dd55a99b00c447e53fe97bdbc423f3e6d7d59557",
			"commitAuthor": "Lukasz Antoniak",
			"commitDateOld": "2011-05-14, 2:47 PM",
			"commitNameOld": "b36b095c3ce32d2981f5780463bbea8d48105f5a",
			"commitAuthorOld": "Lukasz Antoniak",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,92 +1,90 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't audited\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n                 MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n \n                 revisionInfoClass = pc.getMappedClass();\n                 revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n                         DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n                         modifiedEntityNamesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                     // of DefaultTrackingModifiedTypesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                     revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName,\n                             revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(),\n                             modifiedEntityNamesData);\n                     globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                 } else {\n                     revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         if (revisionInfoGenerator == null) {\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                 revisionInfoClass = DefaultTrackingModifiedTypesRevisionEntity.class;\n                 revisionInfoEntityName = DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n                 revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n             } else {\n                 revisionInfoClass = DefaultRevisionEntity.class;\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n-                        revisionInfoTimestampData.getName(), isTimestampAsDate(),\n-                        globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? modifiedEntityNamesData.getName()\n-                                                                            : null),\n+                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n                 revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b36b095c3ce32d2981f5780463bbea8d48105f5a": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5580 - Refactoring\n",
			"commitDate": "2011-05-14, 2:47 PM",
			"commitName": "b36b095c3ce32d2981f5780463bbea8d48105f5a",
			"commitAuthor": "Lukasz Antoniak",
			"commitDateOld": "2011-05-07, 10:06 AM",
			"commitNameOld": "53699cecac7477d64ac3dff6c3a24d5658bfc789",
			"commitAuthorOld": "Lukasz Antoniak",
			"daysBetweenCommits": 7.2,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,90 +1,92 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't audited\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n                 MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n \n                 revisionInfoClass = pc.getMappedClass();\n                 revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n                         DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n                         modifiedEntityNamesFound.isSet()) {\n                     // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n                     // of DefaultTrackingModifiedTypesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n                     revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName,\n                             revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(),\n                             modifiedEntityNamesData);\n                     globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                 } else {\n                     revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         if (revisionInfoGenerator == null) {\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                 revisionInfoClass = DefaultTrackingModifiedTypesRevisionEntity.class;\n                 revisionInfoEntityName = DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n                 revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n             } else {\n                 revisionInfoClass = DefaultRevisionEntity.class;\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n-                        revisionInfoTimestampData.getName(), isTimestampAsDate(), modifiedEntityNamesData.getName()),\n+                        revisionInfoTimestampData.getName(), isTimestampAsDate(),\n+                        globalCfg.isTrackEntitiesChangedInRevisionEnabled() ? modifiedEntityNamesData.getName()\n+                                                                            : null),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n                 revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"53699cecac7477d64ac3dff6c3a24d5658bfc789": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5580 - Modified EntityTrackingRevisionListener interface\n",
			"commitDate": "2011-05-07, 10:06 AM",
			"commitName": "53699cecac7477d64ac3dff6c3a24d5658bfc789",
			"commitAuthor": "Lukasz Antoniak",
			"commitDateOld": "2011-04-27, 2:49 PM",
			"commitNameOld": "98342a7e2dd54df9b7fcb8e7b63ebd5441bd2217",
			"commitAuthorOld": "Lukasz Antoniak",
			"daysBetweenCommits": 9.8,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,86 +1,90 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't audited\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n                 MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n \n                 revisionInfoClass = pc.getMappedClass();\n                 revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n-                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n-                    // If modified entities tracking parameter is enabled, custom revision info class is a subtype of DefaultTrackingModifiedTypesRevisionEntity, or @ModifiedEntityNames annotation is used.\n-                    revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                            revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n+                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() ||\n+                        DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) ||\n+                        modifiedEntityNamesFound.isSet()) {\n+                    // If tracking modified entities parameter is enabled, custom revision info entity is a subtype\n+                    // of DefaultTrackingModifiedTypesRevisionEntity class, or @ModifiedEntityNames annotation is used.\n+                    revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName,\n+                            revisionInfoClass, revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(),\n+                            modifiedEntityNamesData);\n                     globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n                 } else {\n                     revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                             revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n                 }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         if (revisionInfoGenerator == null) {\n             if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n                 revisionInfoClass = DefaultTrackingModifiedTypesRevisionEntity.class;\n                 revisionInfoEntityName = DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n                 revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n             } else {\n                 revisionInfoClass = DefaultRevisionEntity.class;\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n             }\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate(), modifiedEntityNamesData.getName()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n                 revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"98342a7e2dd54df9b7fcb8e7b63ebd5441bd2217": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5580 - Tracking entity names in revision\n",
			"commitDate": "2011-04-27, 2:49 PM",
			"commitName": "98342a7e2dd54df9b7fcb8e7b63ebd5441bd2217",
			"commitAuthor": "Lukasz Antoniak",
			"commitDateOld": "2011-04-19, 10:19 AM",
			"commitNameOld": "86c15fd21234381e2cc713d07e9652f01078613d",
			"commitAuthorOld": "Lukasz Antoniak",
			"daysBetweenCommits": 8.19,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,71 +1,86 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't audited\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n+                MutableBoolean modifiedEntityNamesFound = new MutableBoolean();\n \n-                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n+                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound, modifiedEntityNamesFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n \n                 revisionInfoClass = pc.getMappedClass();\n                 revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n-                revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                        revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n+                if (globalCfg.isTrackEntitiesChangedInRevisionEnabled() || DefaultTrackingModifiedTypesRevisionEntity.class.isAssignableFrom(revisionInfoClass) || modifiedEntityNamesFound.isSet()) {\n+                    // If modified entities tracking parameter is enabled, custom revision info class is a subtype of DefaultTrackingModifiedTypesRevisionEntity, or @ModifiedEntityNames annotation is used.\n+                    revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n+                            revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n+                    globalCfg.setTrackEntitiesChangedInRevisionEnabled(true);\n+                } else {\n+                    revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n+                            revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n+                }\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         if (revisionInfoGenerator == null) {\n-            revisionInfoClass = DefaultRevisionEntity.class;\n-            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                    RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n+            if (globalCfg.isTrackEntitiesChangedInRevisionEnabled()) {\n+                revisionInfoClass = DefaultTrackingModifiedTypesRevisionEntity.class;\n+                revisionInfoEntityName = DefaultTrackingModifiedTypesRevisionEntity.class.getName();\n+                revisionInfoGenerator = new DefaultTrackingModifiedTypesRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n+                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData);\n+            } else {\n+                revisionInfoClass = DefaultRevisionEntity.class;\n+                revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n+                        RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n+            }\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n-                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n+                        revisionInfoTimestampData.getName(), isTimestampAsDate(), modifiedEntityNamesData.getName()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n                 revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"86c15fd21234381e2cc713d07e9652f01078613d": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5276 - Refactoring\n",
			"commitDate": "2011-04-19, 10:19 AM",
			"commitName": "86c15fd21234381e2cc713d07e9652f01078613d",
			"commitAuthor": "Lukasz Antoniak",
			"commitDateOld": "2011-04-19, 10:19 AM",
			"commitNameOld": "ac49a906e8566f29767927a0dd8dc6b9328115ab",
			"commitAuthorOld": "Lukasz Antoniak",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,71 +1,71 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't audited\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n \n                 revisionInfoClass = pc.getMappedClass();\n                 revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         if (revisionInfoGenerator == null) {\n             revisionInfoClass = DefaultRevisionEntity.class;\n             revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                     RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n-            revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping(cfg);\n+            revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n                 revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ac49a906e8566f29767927a0dd8dc6b9328115ab": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5276 - REVINFO in different database schema creation\n",
			"commitDate": "2011-04-19, 10:19 AM",
			"commitName": "ac49a906e8566f29767927a0dd8dc6b9328115ab",
			"commitAuthor": "Lukasz Antoniak",
			"commitDateOld": "2011-04-19, 8:27 AM",
			"commitNameOld": "d7cc102b008d1586b85f6f443dce90b531df3b71",
			"commitAuthorOld": "Lukasz Antoniak",
			"daysBetweenCommits": 0.08,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,71 +1,71 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't audited\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n \n                 revisionInfoClass = pc.getMappedClass();\n                 revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         if (revisionInfoGenerator == null) {\n             revisionInfoClass = DefaultRevisionEntity.class;\n             revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                     RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n-            revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n+            revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping(cfg);\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n-                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, \n+                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName,\n                 revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e21fed8304935dc8a1efeee115a4e720b9d2667b": {
			"type": "Yfilerename",
			"commitMessage": "HHH-5616 - Switch to Gradle for builds .. envers\n",
			"commitDate": "2010-10-11, 12:41 PM",
			"commitName": "e21fed8304935dc8a1efeee115a4e720b9d2667b",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2010-10-11, 12:41 PM",
			"commitNameOld": "89298608b0ba18049272fc0f2784fb3d251da905",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java",
				"newPath": "hibernate-envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java"
			}
		},
		"6c6e6ab193f48ed93d5b76f394e6bef78205921a": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5371 Support revend timestamp to enable audit table partioning by time\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20775 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-10-04, 11:11 AM",
			"commitName": "6c6e6ab193f48ed93d5b76f394e6bef78205921a",
			"commitAuthor": "Erik-Berndt Scheper",
			"commitDateOld": "2010-09-28, 4:50 PM",
			"commitNameOld": "558d9469e018962a2b3159561bcc0996ecfc62fc",
			"commitAuthorOld": "Erik-Berndt Scheper",
			"daysBetweenCommits": 5.76,
			"commitsBetweenForRepo": 19,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,70 +1,71 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't audited\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n \n                 revisionInfoClass = pc.getMappedClass();\n                 revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         if (revisionInfoGenerator == null) {\n             revisionInfoClass = DefaultRevisionEntity.class;\n             revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                     RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n-                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n+                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, \n+                revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"558d9469e018962a2b3159561bcc0996ecfc62fc": {
			"type": "Ybodychange",
			"commitMessage": "HHH5371 - Rollback until after 3.6.0 release as per Adam's request via IM\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20745 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-09-28, 4:50 PM",
			"commitName": "558d9469e018962a2b3159561bcc0996ecfc62fc",
			"commitAuthor": "Erik-Berndt Scheper",
			"commitDateOld": "2010-09-28, 3:23 PM",
			"commitNameOld": "8f8e0fbfe25cdfd78ff5a9853c2f0e1701aafa09",
			"commitAuthorOld": "Erik-Berndt Scheper",
			"daysBetweenCommits": 0.06,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,71 +1,70 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't audited\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n \n                 revisionInfoClass = pc.getMappedClass();\n                 revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         if (revisionInfoGenerator == null) {\n             revisionInfoClass = DefaultRevisionEntity.class;\n             revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                     RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n-                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, \n-                revisionInfoClass, revisionInfoTimestampData);\n+                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8f8e0fbfe25cdfd78ff5a9853c2f0e1701aafa09": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5371 - Add support for REVEND_TSTMP which will enable audit table partitioning\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20743 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-09-28, 3:23 PM",
			"commitName": "8f8e0fbfe25cdfd78ff5a9853c2f0e1701aafa09",
			"commitAuthor": "Erik-Berndt Scheper",
			"commitDateOld": "2009-12-07, 12:36 AM",
			"commitNameOld": "e9ff8cf3b6b7d10c13ad76de574047935373d38f",
			"commitAuthorOld": "Adam Warski",
			"daysBetweenCommits": 295.57,
			"commitsBetweenForRepo": 910,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,70 +1,71 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't audited\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n \n                 revisionInfoClass = pc.getMappedClass();\n                 revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         if (revisionInfoGenerator == null) {\n             revisionInfoClass = DefaultRevisionEntity.class;\n             revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                     RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n-                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n+                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName, \n+                revisionInfoClass, revisionInfoTimestampData);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f39550fff19a72faec27632409b50970d4d9d2da": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4540:\n- applying patch from Nicolas Rougé\n- the revision timestamp can now be a j.u.Date or a j.s.Date, and be mapped to a Date in the DB\n- test\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18032 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2009-11-24, 7:21 AM",
			"commitName": "f39550fff19a72faec27632409b50970d4d9d2da",
			"commitAuthor": "Adam Warski",
			"commitDateOld": "2009-04-29, 10:47 PM",
			"commitNameOld": "1553578808ee052e41595da94952ea63f19af038",
			"commitAuthorOld": "Adam Warski",
			"daysBetweenCommits": 208.4,
			"commitsBetweenForRepo": 366,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,69 +1,70 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't audited\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n \n                 revisionInfoClass = pc.getMappedClass();\n+                revisionInfoTimestampType = pc.getProperty(revisionInfoTimestampData.getName()).getType();\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                        revisionEntity.value(), revisionInfoTimestampData);\n+                        revisionEntity.value(), revisionInfoTimestampData, isTimestampAsDate());\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         if (revisionInfoGenerator == null) {\n             revisionInfoClass = DefaultRevisionEntity.class;\n             revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                    RevisionListener.class, revisionInfoTimestampData);\n+                    RevisionListener.class, revisionInfoTimestampData, isTimestampAsDate());\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n-                        revisionInfoTimestampData.getName()),\n+                        revisionInfoTimestampData.getName(), isTimestampAsDate()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4603c8a4dd267aab345ec915b932f736d404daa7": {
			"type": "Ybodychange",
			"commitMessage": "HHH-3570: more renaming\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15517 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2008-11-05, 1:13 AM",
			"commitName": "4603c8a4dd267aab345ec915b932f736d404daa7",
			"commitAuthor": "Adam Warski",
			"commitDateOld": "2008-11-05, 12:41 AM",
			"commitNameOld": "843d3c648f0d28ae921d701fd340656c27bb40f3",
			"commitAuthorOld": "Adam Warski",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,69 +1,69 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n-                // Checking if custom revision entity isn't versioned\n+                // Checking if custom revision entity isn't audited\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n \n                 revisionInfoClass = pc.getMappedClass();\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionEntity.value(), revisionInfoTimestampData);\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         if (revisionInfoGenerator == null) {\n             revisionInfoClass = DefaultRevisionEntity.class;\n             revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                     RevisionListener.class, revisionInfoTimestampData);\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n                         revisionInfoTimestampData.getName()),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cc03033e59af53aeb49dbba8dd58bdf1fe3a8578": {
			"type": "Ybodychange",
			"commitMessage": "HHH-3565: adding support for field and property access types; changed the way properties are read. Now, instead of a sole property name, a special \"PropertyData\" object is passed around which encapsulates the  property name and access type information.\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15481 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2008-11-03, 3:24 AM",
			"commitName": "cc03033e59af53aeb49dbba8dd58bdf1fe3a8578",
			"commitAuthor": "Adam Warski",
			"commitDateOld": "2008-10-31, 5:23 AM",
			"commitNameOld": "a94515206db0eee8867d399bee6a87aa9e8cb074",
			"commitAuthorOld": "Adam Warski",
			"daysBetweenCommits": 2.96,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,68 +1,69 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't versioned\n                 if (clazz.getAnnotation(Audited.class) != null) {\n-                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n+                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be audited!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n \n                 revisionInfoClass = pc.getMappedClass();\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                        revisionEntity.value(), revisionInfoTimestampName);\n+                        revisionEntity.value(), revisionInfoTimestampData);\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         if (revisionInfoGenerator == null) {\n             revisionInfoClass = DefaultRevisionEntity.class;\n             revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n-                    RevisionListener.class, revisionInfoTimestampName);\n+                    RevisionListener.class, revisionInfoTimestampData);\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n-                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName),\n+                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdData.getName(),\n+                        revisionInfoTimestampData.getName()),\n                 generateRevisionInfoRelationMapping(),\n-                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n+                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdData), revisionInfoEntityName);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a94515206db0eee8867d399bee6a87aa9e8cb074": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Removing unused Hiberntae 3.2.4.SP1 integration facilities (ReflectionManager)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15464 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2008-10-31, 5:23 AM",
			"commitName": "a94515206db0eee8867d399bee6a87aa9e8cb074",
			"commitAuthor": "Adam Warski",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Removing unused Hiberntae 3.2.4.SP1 integration facilities (ReflectionManager)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15464 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
					"commitDate": "2008-10-31, 5:23 AM",
					"commitName": "a94515206db0eee8867d399bee6a87aa9e8cb074",
					"commitAuthor": "Adam Warski",
					"commitDateOld": "2008-10-31, 4:42 AM",
					"commitNameOld": "90f70231c682e22693f85977497d2dc429ef29da",
					"commitAuthorOld": "Adam Warski",
					"daysBetweenCommits": 0.03,
					"commitsBetweenForRepo": 5,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,68 +1,68 @@\n-    public RevisionInfoConfigurationResult configure(Configuration cfg, YReflectionManager reflectionManager) {\n+    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n-            YClass clazz;\n+            XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't versioned\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n \n                 revisionInfoClass = pc.getMappedClass();\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionEntity.value(), revisionInfoTimestampName);\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         if (revisionInfoGenerator == null) {\n             revisionInfoClass = DefaultRevisionEntity.class;\n             revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                     RevisionListener.class, revisionInfoTimestampName);\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[cfg-Configuration, reflectionManager-YReflectionManager]",
						"newValue": "[cfg-Configuration, reflectionManager-ReflectionManager]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Removing unused Hiberntae 3.2.4.SP1 integration facilities (ReflectionManager)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15464 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
					"commitDate": "2008-10-31, 5:23 AM",
					"commitName": "a94515206db0eee8867d399bee6a87aa9e8cb074",
					"commitAuthor": "Adam Warski",
					"commitDateOld": "2008-10-31, 4:42 AM",
					"commitNameOld": "90f70231c682e22693f85977497d2dc429ef29da",
					"commitAuthorOld": "Adam Warski",
					"daysBetweenCommits": 0.03,
					"commitsBetweenForRepo": 5,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,68 +1,68 @@\n-    public RevisionInfoConfigurationResult configure(Configuration cfg, YReflectionManager reflectionManager) {\n+    public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n-            YClass clazz;\n+            XClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't versioned\n                 if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n \n                 revisionInfoClass = pc.getMappedClass();\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionEntity.value(), revisionInfoTimestampName);\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         if (revisionInfoGenerator == null) {\n             revisionInfoClass = DefaultRevisionEntity.class;\n             revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                     RevisionListener.class, revisionInfoTimestampName);\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"90f70231c682e22693f85977497d2dc429ef29da": {
			"type": "Ybodychange",
			"commitMessage": "HHH-3570: renaming versioned to audited\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15459 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2008-10-31, 4:42 AM",
			"commitName": "90f70231c682e22693f85977497d2dc429ef29da",
			"commitAuthor": "Adam Warski",
			"commitDateOld": "2008-10-29, 8:51 AM",
			"commitNameOld": "8cf6a823974ddfe74548da9913e0df7adf541ee8",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 1.83,
			"commitsBetweenForRepo": 10,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,68 +1,68 @@\n     public RevisionInfoConfigurationResult configure(Configuration cfg, YReflectionManager reflectionManager) {\n         Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n         boolean revisionEntityFound = false;\n         RevisionInfoGenerator revisionInfoGenerator = null;\n \n         Class<?> revisionInfoClass = null;\n \n         while (classes.hasNext()) {\n             PersistentClass pc = classes.next();\n             YClass clazz;\n             try {\n                 clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n             } catch (ClassNotFoundException e) {\n                 throw new MappingException(e);\n             }\n \n             RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n             if (revisionEntity != null) {\n                 if (revisionEntityFound) {\n                     throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n                 }\n \n                 // Checking if custom revision entity isn't versioned\n-                if (clazz.getAnnotation(Versioned.class) != null) {\n+                if (clazz.getAnnotation(Audited.class) != null) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n                 }\n \n                 revisionEntityFound = true;\n \n                 MutableBoolean revisionNumberFound = new MutableBoolean();\n                 MutableBoolean revisionTimestampFound = new MutableBoolean();\n \n                 searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n \n                 if (!revisionNumberFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionNumber!\");\n                 }\n \n                 if (!revisionTimestampFound.isSet()) {\n                     throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n                             \"with @RevisionTimestamp!\");\n                 }\n \n                 revisionInfoEntityName = pc.getEntityName();\n \n                 revisionInfoClass = pc.getMappedClass();\n                 revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                         revisionEntity.value(), revisionInfoTimestampName);\n             }\n         }\n \n         // In case of a custom revision info generator, the mapping will be null.\n         Document revisionInfoXmlMapping = null;\n \n         if (revisionInfoGenerator == null) {\n             revisionInfoClass = DefaultRevisionEntity.class;\n             revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n                     RevisionListener.class, revisionInfoTimestampName);\n             revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n         }\n \n         return new RevisionInfoConfigurationResult(\n                 revisionInfoGenerator, revisionInfoXmlMapping,\n                 new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName),\n                 generateRevisionInfoRelationMapping(),\n                 new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dd35cf7b1461fc883148b148e5c81731d9c08a35": {
			"type": "Yfilerename",
			"commitMessage": "HHH-3351 : import envers as core module\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15434 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2008-10-29, 8:17 AM",
			"commitName": "dd35cf7b1461fc883148b148e5c81731d9c08a35",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2008-10-29, 7:59 AM",
			"commitNameOld": "15ac9155d2798f5d797310a2fb5f67ef0809428e",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "envers/src/main/java/org/jboss/envers/configuration/RevisionInfoConfiguration.java",
				"newPath": "envers/src/main/java/org/hibernate/envers/configuration/RevisionInfoConfiguration.java"
			}
		},
		"78e5d9fd89aa571f8ad5cf5b8a5046b9b74cb09b": {
			"type": "Yintroduced",
			"commitMessage": "HHH-3351 : import envers as core module\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15406 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2008-10-27, 11:56 AM",
			"commitName": "78e5d9fd89aa571f8ad5cf5b8a5046b9b74cb09b",
			"commitAuthor": "Steve Ebersole",
			"diff": "@@ -0,0 +1,68 @@\n+    public RevisionInfoConfigurationResult configure(Configuration cfg, YReflectionManager reflectionManager) {\n+        Iterator<PersistentClass> classes = (Iterator<PersistentClass>) cfg.getClassMappings();\n+        boolean revisionEntityFound = false;\n+        RevisionInfoGenerator revisionInfoGenerator = null;\n+\n+        Class<?> revisionInfoClass = null;\n+\n+        while (classes.hasNext()) {\n+            PersistentClass pc = classes.next();\n+            YClass clazz;\n+            try {\n+                clazz = reflectionManager.classForName(pc.getClassName(), this.getClass());\n+            } catch (ClassNotFoundException e) {\n+                throw new MappingException(e);\n+            }\n+\n+            RevisionEntity revisionEntity = clazz.getAnnotation(RevisionEntity.class);\n+            if (revisionEntity != null) {\n+                if (revisionEntityFound) {\n+                    throw new MappingException(\"Only one entity may be annotated with @RevisionEntity!\");\n+                }\n+\n+                // Checking if custom revision entity isn't versioned\n+                if (clazz.getAnnotation(Versioned.class) != null) {\n+                    throw new MappingException(\"An entity annotated with @RevisionEntity cannot be versioned!\");\n+                }\n+\n+                revisionEntityFound = true;\n+\n+                MutableBoolean revisionNumberFound = new MutableBoolean();\n+                MutableBoolean revisionTimestampFound = new MutableBoolean();\n+\n+                searchForRevisionInfoCfg(clazz, reflectionManager, revisionNumberFound, revisionTimestampFound);\n+\n+                if (!revisionNumberFound.isSet()) {\n+                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n+                            \"with @RevisionNumber!\");\n+                }\n+\n+                if (!revisionTimestampFound.isSet()) {\n+                    throw new MappingException(\"An entity annotated with @RevisionEntity must have a field annotated \" +\n+                            \"with @RevisionTimestamp!\");\n+                }\n+\n+                revisionInfoEntityName = pc.getEntityName();\n+\n+                revisionInfoClass = pc.getMappedClass();\n+                revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n+                        revisionEntity.value(), revisionInfoTimestampName);\n+            }\n+        }\n+\n+        // In case of a custom revision info generator, the mapping will be null.\n+        Document revisionInfoXmlMapping = null;\n+\n+        if (revisionInfoGenerator == null) {\n+            revisionInfoClass = DefaultRevisionEntity.class;\n+            revisionInfoGenerator = new DefaultRevisionInfoGenerator(revisionInfoEntityName, revisionInfoClass,\n+                    RevisionListener.class, revisionInfoTimestampName);\n+            revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();\n+        }\n+\n+        return new RevisionInfoConfigurationResult(\n+                revisionInfoGenerator, revisionInfoXmlMapping,\n+                new RevisionInfoQueryCreator(revisionInfoEntityName, revisionInfoIdName, revisionInfoTimestampName),\n+                generateRevisionInfoRelationMapping(),\n+                new RevisionInfoNumberReader(revisionInfoClass, revisionInfoIdName), revisionInfoEntityName);\n+    }\n\\ No newline at end of file\n"
		}
	},
	"sha": "8bd79b29cfa7b2d539a746dc356d60b66e1e596b"
}