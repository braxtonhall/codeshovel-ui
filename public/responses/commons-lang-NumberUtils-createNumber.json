{
	"repo": "https://github.com/apache/commons-lang.git",
	"file": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
	"method": {
		"longName": "NumberUtils::createNumber(String str)",
		"startLine": 450,
		"methodName": "createNumber",
		"isStatic": true,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"b610707cd072f07efb816074a4844bb1b31e482c": {
			"type": "Ybodychange",
			"commitMessage": "removes unnecessary class reference of static method calls which are declared in the same class\n",
			"commitDate": "2018-06-20, 5:28 AM",
			"commitName": "b610707cd072f07efb816074a4844bb1b31e482c",
			"commitAuthor": "Igor Curdvanovschi",
			"commitDateOld": "2018-06-20, 4:05 AM",
			"commitNameOld": "214cc7fd596b575ed07a7d7c1006b46d5c75613d",
			"commitAuthorOld": "Igor Curdvanovschi",
			"daysBetweenCommits": 0.06,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,168 +1,168 @@\n     public static Number createNumber(final String str) {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen = 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen += pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             char firstSigDigit = 0; // strip leading zeroes\n             for(int i = pfxLen; i < str.length(); i++) {\n                 firstSigDigit = str.charAt(i);\n                 if (firstSigDigit == '0') { // count leading zeroes\n                     pfxLen++;\n                 } else {\n                     break;\n                 }\n             }\n             final int hexDigits = str.length() - pfxLen;\n             if (hexDigits > 16 || hexDigits == 16 && firstSigDigit > '7') { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits > 8 || hexDigits == 8 && firstSigDigit > '7') { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos = str.indexOf('.');\n         final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n         if (decPos > -1) { // there is a decimal point\n             if (expPos > -1) { // there is an exponent\n                 if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = getMantissa(str, decPos);\n         } else {\n             if (expPos > -1) {\n                 if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant = getMantissa(str, expPos);\n             } else {\n                 mant = getMantissa(str);\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             final String numeric = str.substring(0, str.length() - 1);\n             final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (!numeric.isEmpty() && numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n-                        final Float f = NumberUtils.createFloat(str);\n+                        final Float f = createFloat(str);\n                         if (!(f.isInfinite() || f.floatValue() == 0.0F && !allZeros)) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n-                        final Double d = NumberUtils.createDouble(str);\n+                        final Double d = createDouble(str);\n                         if (!(d.isInfinite() || d.floatValue() == 0.0D && !allZeros)) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn't have a preference on the return type, so let's start\n         //small and go from there...\n         if (expPos > -1 && expPos < str.length() - 1) {\n             exp = str.substring(expPos + 1, str.length());\n         } else {\n             exp = null;\n         }\n         if (dec == null && exp == null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n         try {\n             final Float f = createFloat(str);\n             final Double d = createDouble(str);\n             if (!f.isInfinite()\n                     && !(f.floatValue() == 0.0F && !allZeros)\n                     && f.toString().equals(d.toString())) {\n                 return f;\n             }\n             if (!d.isInfinite() && !(d.doubleValue() == 0.0D && !allZeros)) {\n                 final BigDecimal b = createBigDecimal(str);\n                 if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) == 0) {\n                     return d;\n                 }\n                 return b;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"214cc7fd596b575ed07a7d7c1006b46d5c75613d": {
			"type": "Ybodychange",
			"commitMessage": "replaces 'size() == 0' and 'length() == 0' with 'isEmpty()'\n",
			"commitDate": "2018-06-20, 4:05 AM",
			"commitName": "214cc7fd596b575ed07a7d7c1006b46d5c75613d",
			"commitAuthor": "Igor Curdvanovschi",
			"commitDateOld": "2018-06-20, 12:03 AM",
			"commitNameOld": "e767af7e7eb8ff7724d5f72709ee4bb7a72d2284",
			"commitAuthorOld": "Igor Curdvanovschi",
			"daysBetweenCommits": 0.17,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,168 +1,168 @@\n     public static Number createNumber(final String str) {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen = 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen += pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             char firstSigDigit = 0; // strip leading zeroes\n             for(int i = pfxLen; i < str.length(); i++) {\n                 firstSigDigit = str.charAt(i);\n                 if (firstSigDigit == '0') { // count leading zeroes\n                     pfxLen++;\n                 } else {\n                     break;\n                 }\n             }\n             final int hexDigits = str.length() - pfxLen;\n             if (hexDigits > 16 || hexDigits == 16 && firstSigDigit > '7') { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits > 8 || hexDigits == 8 && firstSigDigit > '7') { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos = str.indexOf('.');\n         final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n         if (decPos > -1) { // there is a decimal point\n             if (expPos > -1) { // there is an exponent\n                 if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = getMantissa(str, decPos);\n         } else {\n             if (expPos > -1) {\n                 if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant = getMantissa(str, expPos);\n             } else {\n                 mant = getMantissa(str);\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             final String numeric = str.substring(0, str.length() - 1);\n             final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && (numeric.length() > 0 && numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n+                        && (!numeric.isEmpty() && numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         final Float f = NumberUtils.createFloat(str);\n                         if (!(f.isInfinite() || f.floatValue() == 0.0F && !allZeros)) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         final Double d = NumberUtils.createDouble(str);\n                         if (!(d.isInfinite() || d.floatValue() == 0.0D && !allZeros)) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn't have a preference on the return type, so let's start\n         //small and go from there...\n         if (expPos > -1 && expPos < str.length() - 1) {\n             exp = str.substring(expPos + 1, str.length());\n         } else {\n             exp = null;\n         }\n         if (dec == null && exp == null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n         try {\n             final Float f = createFloat(str);\n             final Double d = createDouble(str);\n             if (!f.isInfinite()\n                     && !(f.floatValue() == 0.0F && !allZeros)\n                     && f.toString().equals(d.toString())) {\n                 return f;\n             }\n             if (!d.isInfinite() && !(d.doubleValue() == 0.0D && !allZeros)) {\n                 final BigDecimal b = createBigDecimal(str);\n                 if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) == 0) {\n                     return d;\n                 }\n                 return b;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e767af7e7eb8ff7724d5f72709ee4bb7a72d2284": {
			"type": "Yexceptionschange",
			"commitMessage": "removes unchecked exceptions declared in 'throws' clause\n",
			"commitDate": "2018-06-20, 12:03 AM",
			"commitName": "e767af7e7eb8ff7724d5f72709ee4bb7a72d2284",
			"commitAuthor": "Igor Curdvanovschi",
			"commitDateOld": "2018-03-10, 6:16 PM",
			"commitNameOld": "8b62c114cfc5fd347bd8cb5a391fdfa8cb539435",
			"commitAuthorOld": "Gary Gregory",
			"daysBetweenCommits": 101.2,
			"commitsBetweenForRepo": 50,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,168 +1,168 @@\n-    public static Number createNumber(final String str) throws NumberFormatException {\n+    public static Number createNumber(final String str) {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen = 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen += pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             char firstSigDigit = 0; // strip leading zeroes\n             for(int i = pfxLen; i < str.length(); i++) {\n                 firstSigDigit = str.charAt(i);\n                 if (firstSigDigit == '0') { // count leading zeroes\n                     pfxLen++;\n                 } else {\n                     break;\n                 }\n             }\n             final int hexDigits = str.length() - pfxLen;\n             if (hexDigits > 16 || hexDigits == 16 && firstSigDigit > '7') { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits > 8 || hexDigits == 8 && firstSigDigit > '7') { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos = str.indexOf('.');\n         final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n         if (decPos > -1) { // there is a decimal point\n             if (expPos > -1) { // there is an exponent\n                 if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = getMantissa(str, decPos);\n         } else {\n             if (expPos > -1) {\n                 if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant = getMantissa(str, expPos);\n             } else {\n                 mant = getMantissa(str);\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             final String numeric = str.substring(0, str.length() - 1);\n             final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (numeric.length() > 0 && numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         final Float f = NumberUtils.createFloat(str);\n                         if (!(f.isInfinite() || f.floatValue() == 0.0F && !allZeros)) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         final Double d = NumberUtils.createDouble(str);\n                         if (!(d.isInfinite() || d.floatValue() == 0.0D && !allZeros)) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn't have a preference on the return type, so let's start\n         //small and go from there...\n         if (expPos > -1 && expPos < str.length() - 1) {\n             exp = str.substring(expPos + 1, str.length());\n         } else {\n             exp = null;\n         }\n         if (dec == null && exp == null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n         try {\n             final Float f = createFloat(str);\n             final Double d = createDouble(str);\n             if (!f.isInfinite()\n                     && !(f.floatValue() == 0.0F && !allZeros)\n                     && f.toString().equals(d.toString())) {\n                 return f;\n             }\n             if (!d.isInfinite() && !(d.doubleValue() == 0.0D && !allZeros)) {\n                 final BigDecimal b = createBigDecimal(str);\n                 if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) == 0) {\n                     return d;\n                 }\n                 return b;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[NumberFormatException]",
				"newValue": "[]"
			}
		},
		"8b62c114cfc5fd347bd8cb5a391fdfa8cb539435": {
			"type": "Ybodychange",
			"commitMessage": "[LANG-1385] NumberUtils.createNumber() throws\nStringIndexOutOfBoundsException instead of NumberFormatException.",
			"commitDate": "2018-03-10, 6:16 PM",
			"commitName": "8b62c114cfc5fd347bd8cb5a391fdfa8cb539435",
			"commitAuthor": "Gary Gregory",
			"commitDateOld": "2018-02-11, 4:08 AM",
			"commitNameOld": "c8e61afdb89c58ea8ffaf04593da41ff0888d30e",
			"commitAuthorOld": "Piotr Kosmala",
			"daysBetweenCommits": 27.59,
			"commitsBetweenForRepo": 17,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,168 +1,168 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen = 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen += pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             char firstSigDigit = 0; // strip leading zeroes\n             for(int i = pfxLen; i < str.length(); i++) {\n                 firstSigDigit = str.charAt(i);\n                 if (firstSigDigit == '0') { // count leading zeroes\n                     pfxLen++;\n                 } else {\n                     break;\n                 }\n             }\n             final int hexDigits = str.length() - pfxLen;\n             if (hexDigits > 16 || hexDigits == 16 && firstSigDigit > '7') { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits > 8 || hexDigits == 8 && firstSigDigit > '7') { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos = str.indexOf('.');\n         final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n         if (decPos > -1) { // there is a decimal point\n             if (expPos > -1) { // there is an exponent\n                 if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = getMantissa(str, decPos);\n         } else {\n             if (expPos > -1) {\n                 if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant = getMantissa(str, expPos);\n             } else {\n                 mant = getMantissa(str);\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             final String numeric = str.substring(0, str.length() - 1);\n             final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n+                        && (numeric.length() > 0 && numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         final Float f = NumberUtils.createFloat(str);\n                         if (!(f.isInfinite() || f.floatValue() == 0.0F && !allZeros)) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         final Double d = NumberUtils.createDouble(str);\n                         if (!(d.isInfinite() || d.floatValue() == 0.0D && !allZeros)) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn't have a preference on the return type, so let's start\n         //small and go from there...\n         if (expPos > -1 && expPos < str.length() - 1) {\n             exp = str.substring(expPos + 1, str.length());\n         } else {\n             exp = null;\n         }\n         if (dec == null && exp == null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n         try {\n             final Float f = createFloat(str);\n             final Double d = createDouble(str);\n             if (!f.isInfinite()\n                     && !(f.floatValue() == 0.0F && !allZeros)\n                     && f.toString().equals(d.toString())) {\n                 return f;\n             }\n             if (!d.isInfinite() && !(d.doubleValue() == 0.0D && !allZeros)) {\n                 final BigDecimal b = createBigDecimal(str);\n                 if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) == 0) {\n                     return d;\n                 }\n                 return b;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dfd69e038cc7035031d1807c4ade870d2a7e2ece": {
			"type": "Ybodychange",
			"commitMessage": "Fix unbox warning. Show when we are unboxing.",
			"commitDate": "2016-11-18, 2:38 PM",
			"commitName": "dfd69e038cc7035031d1807c4ade870d2a7e2ece",
			"commitAuthor": "Gary Gregory",
			"commitDateOld": "2016-10-23, 11:55 AM",
			"commitNameOld": "aadb9a31ed969fc72cc87d486ec02383faa5bd06",
			"commitAuthorOld": "Gary Gregory",
			"daysBetweenCommits": 26.16,
			"commitsBetweenForRepo": 63,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,168 +1,168 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen = 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen += pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             char firstSigDigit = 0; // strip leading zeroes\n             for(int i = pfxLen; i < str.length(); i++) {\n                 firstSigDigit = str.charAt(i);\n                 if (firstSigDigit == '0') { // count leading zeroes\n                     pfxLen++;\n                 } else {\n                     break;\n                 }\n             }\n             final int hexDigits = str.length() - pfxLen;\n             if (hexDigits > 16 || hexDigits == 16 && firstSigDigit > '7') { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits > 8 || hexDigits == 8 && firstSigDigit > '7') { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos = str.indexOf('.');\n         final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n         if (decPos > -1) { // there is a decimal point\n             if (expPos > -1) { // there is an exponent\n                 if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = getMantissa(str, decPos);\n         } else {\n             if (expPos > -1) {\n                 if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant = getMantissa(str, expPos);\n             } else {\n                 mant = getMantissa(str);\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             final String numeric = str.substring(0, str.length() - 1);\n             final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         final Float f = NumberUtils.createFloat(str);\n                         if (!(f.isInfinite() || f.floatValue() == 0.0F && !allZeros)) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         final Double d = NumberUtils.createDouble(str);\n                         if (!(d.isInfinite() || d.floatValue() == 0.0D && !allZeros)) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn't have a preference on the return type, so let's start\n         //small and go from there...\n         if (expPos > -1 && expPos < str.length() - 1) {\n             exp = str.substring(expPos + 1, str.length());\n         } else {\n             exp = null;\n         }\n         if (dec == null && exp == null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n         try {\n             final Float f = createFloat(str);\n             final Double d = createDouble(str);\n             if (!f.isInfinite()\n                     && !(f.floatValue() == 0.0F && !allZeros)\n                     && f.toString().equals(d.toString())) {\n                 return f;\n             }\n             if (!d.isInfinite() && !(d.doubleValue() == 0.0D && !allZeros)) {\n                 final BigDecimal b = createBigDecimal(str);\n-                if (b.compareTo(BigDecimal.valueOf(d)) == 0) {\n+                if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) == 0) {\n                     return d;\n                 }\n                 return b;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9c5b6cdc7108eb071785b0c4edd205650cdf1ca4": {
			"type": "Ybodychange",
			"commitMessage": "PMD: Remove useless parentheses\n",
			"commitDate": "2016-09-19, 5:56 AM",
			"commitName": "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4",
			"commitAuthor": "Benedikt Ritter",
			"commitDateOld": "2016-09-11, 11:00 AM",
			"commitNameOld": "e64b51c70fa9f5e2795e91e6729ebd895f7f3c01",
			"commitAuthorOld": "Rob Tompkins",
			"daysBetweenCommits": 7.79,
			"commitsBetweenForRepo": 24,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,168 +1,168 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen = 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen += pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             char firstSigDigit = 0; // strip leading zeroes\n             for(int i = pfxLen; i < str.length(); i++) {\n                 firstSigDigit = str.charAt(i);\n                 if (firstSigDigit == '0') { // count leading zeroes\n                     pfxLen++;\n                 } else {\n                     break;\n                 }\n             }\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long\n+            if (hexDigits > 16 || hexDigits == 16 && firstSigDigit > '7') { // too many for Long\n                 return createBigInteger(str);\n             }\n-            if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int\n+            if (hexDigits > 8 || hexDigits == 8 && firstSigDigit > '7') { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos = str.indexOf('.');\n         final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n         if (decPos > -1) { // there is a decimal point\n             if (expPos > -1) { // there is an exponent\n                 if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = getMantissa(str, decPos);\n         } else {\n             if (expPos > -1) {\n                 if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant = getMantissa(str, expPos);\n             } else {\n                 mant = getMantissa(str);\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             final String numeric = str.substring(0, str.length() - 1);\n             final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         final Float f = NumberUtils.createFloat(str);\n-                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n+                        if (!(f.isInfinite() || f.floatValue() == 0.0F && !allZeros)) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         final Double d = NumberUtils.createDouble(str);\n-                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n+                        if (!(d.isInfinite() || d.floatValue() == 0.0D && !allZeros)) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn't have a preference on the return type, so let's start\n         //small and go from there...\n         if (expPos > -1 && expPos < str.length() - 1) {\n             exp = str.substring(expPos + 1, str.length());\n         } else {\n             exp = null;\n         }\n         if (dec == null && exp == null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n         try {\n             final Float f = createFloat(str);\n             final Double d = createDouble(str);\n             if (!f.isInfinite()\n                     && !(f.floatValue() == 0.0F && !allZeros)\n                     && f.toString().equals(d.toString())) {\n                 return f;\n             }\n             if (!d.isInfinite() && !(d.doubleValue() == 0.0D && !allZeros)) {\n                 final BigDecimal b = createBigDecimal(str);\n                 if (b.compareTo(BigDecimal.valueOf(d)) == 0) {\n                     return d;\n                 }\n                 return b;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8d6bc0ca625f3a1a98b486541fa613b2fac4b41c": {
			"type": "Ybodychange",
			"commitMessage": "LANG-1018: Fix precision loss on NumberUtils.createNumber(String) (closes #156)\n",
			"commitDate": "2016-06-12, 5:23 AM",
			"commitName": "8d6bc0ca625f3a1a98b486541fa613b2fac4b41c",
			"commitAuthor": "Nick Manley",
			"commitDateOld": "2016-06-03, 9:07 AM",
			"commitNameOld": "faeaa303b903139f36c15751c8e48ef982222842",
			"commitAuthorOld": "Eric Wannemacher",
			"daysBetweenCommits": 8.84,
			"commitsBetweenForRepo": 20,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,174 +1,168 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen = 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen += pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             char firstSigDigit = 0; // strip leading zeroes\n             for(int i = pfxLen; i < str.length(); i++) {\n                 firstSigDigit = str.charAt(i);\n                 if (firstSigDigit == '0') { // count leading zeroes\n                     pfxLen++;\n                 } else {\n                     break;\n                 }\n             }\n             final int hexDigits = str.length() - pfxLen;\n             if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos = str.indexOf('.');\n         final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n-        int numDecimals = 0; // Check required precision (LANG-693)\n         if (decPos > -1) { // there is a decimal point\n-\n             if (expPos > -1) { // there is an exponent\n                 if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = getMantissa(str, decPos);\n-            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n         } else {\n             if (expPos > -1) {\n                 if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant = getMantissa(str, expPos);\n             } else {\n                 mant = getMantissa(str);\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             final String numeric = str.substring(0, str.length() - 1);\n             final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         final Float f = NumberUtils.createFloat(str);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         final Double d = NumberUtils.createDouble(str);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn't have a preference on the return type, so let's start\n         //small and go from there...\n         if (expPos > -1 && expPos < str.length() - 1) {\n             exp = str.substring(expPos + 1, str.length());\n         } else {\n             exp = null;\n         }\n         if (dec == null && exp == null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n         try {\n-            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float\n-                final Float f = createFloat(str);\n-                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n-                    return f;\n-                }\n+            final Float f = createFloat(str);\n+            final Double d = createDouble(str);\n+            if (!f.isInfinite()\n+                    && !(f.floatValue() == 0.0F && !allZeros)\n+                    && f.toString().equals(d.toString())) {\n+                return f;\n             }\n-        } catch (final NumberFormatException nfe) { // NOPMD\n-            // ignore the bad number\n-        }\n-        try {\n-            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n-                final Double d = createDouble(str);\n-                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n+            if (!d.isInfinite() && !(d.doubleValue() == 0.0D && !allZeros)) {\n+                final BigDecimal b = createBigDecimal(str);\n+                if (b.compareTo(BigDecimal.valueOf(d)) == 0) {\n                     return d;\n                 }\n+                return b;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n-\n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b877fb9abef4a19eec9cc7329acbd433648b8f7b": {
			"type": "Ybodychange",
			"commitMessage": "LANG-1205: NumberUtils.createNumber() behaves inconsistently with NumberUtils.isNumber()\nThis closes github #87 thanks to pbrose\n",
			"commitDate": "2016-04-23, 9:35 PM",
			"commitName": "b877fb9abef4a19eec9cc7329acbd433648b8f7b",
			"commitAuthor": "Chas Honton",
			"commitDateOld": "2016-02-25, 9:52 PM",
			"commitNameOld": "69e97c8b42b9ad0880618132a613466f4e4779d3",
			"commitAuthorOld": "Hen",
			"daysBetweenCommits": 57.95,
			"commitsBetweenForRepo": 29,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,174 +1,174 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen = 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen += pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             char firstSigDigit = 0; // strip leading zeroes\n             for(int i = pfxLen; i < str.length(); i++) {\n                 firstSigDigit = str.charAt(i);\n                 if (firstSigDigit == '0') { // count leading zeroes\n                     pfxLen++;\n                 } else {\n                     break;\n                 }\n             }\n             final int hexDigits = str.length() - pfxLen;\n             if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos = str.indexOf('.');\n         final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n         int numDecimals = 0; // Check required precision (LANG-693)\n         if (decPos > -1) { // there is a decimal point\n \n             if (expPos > -1) { // there is an exponent\n                 if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = getMantissa(str, decPos);\n             numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n         } else {\n             if (expPos > -1) {\n                 if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant = getMantissa(str, expPos);\n             } else {\n                 mant = getMantissa(str);\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             final String numeric = str.substring(0, str.length() - 1);\n             final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n-                        final Float f = NumberUtils.createFloat(numeric);\n+                        final Float f = NumberUtils.createFloat(str);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n-                        final Double d = NumberUtils.createDouble(numeric);\n+                        final Double d = NumberUtils.createDouble(str);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn't have a preference on the return type, so let's start\n         //small and go from there...\n         if (expPos > -1 && expPos < str.length() - 1) {\n             exp = str.substring(expPos + 1, str.length());\n         } else {\n             exp = null;\n         }\n         if (dec == null && exp == null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n         try {\n             if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float\n                 final Float f = createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                     return f;\n                 }\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         try {\n             if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n                 final Double d = createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                     return d;\n                 }\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n \n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"45a6467088a08e447d7f2983551021b91c70ab49": {
			"type": "Ybodychange",
			"commitMessage": "LANG-1087: NumberUtils#createNumber() returns positive BigDecimal when negative Float is expected. Thanks to Renat Zhilkibaev.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1663129 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2015-03-01, 9:48 AM",
			"commitName": "45a6467088a08e447d7f2983551021b91c70ab49",
			"commitAuthor": "Benedikt Ritter",
			"commitDateOld": "2014-12-12, 2:15 PM",
			"commitNameOld": "05763470e5a067eb153533d47baa73174ad9bd46",
			"commitAuthorOld": "Matthew Jason Benson",
			"daysBetweenCommits": 78.81,
			"commitsBetweenForRepo": 42,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,174 +1,174 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen = 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen += pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             char firstSigDigit = 0; // strip leading zeroes\n             for(int i = pfxLen; i < str.length(); i++) {\n                 firstSigDigit = str.charAt(i);\n                 if (firstSigDigit == '0') { // count leading zeroes\n                     pfxLen++;\n                 } else {\n                     break;\n                 }\n             }\n             final int hexDigits = str.length() - pfxLen;\n             if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos = str.indexOf('.');\n         final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n         int numDecimals = 0; // Check required precision (LANG-693)\n         if (decPos > -1) { // there is a decimal point\n \n             if (expPos > -1) { // there is an exponent\n                 if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n-            mant = str.substring(0, decPos);\n+            mant = getMantissa(str, decPos);\n             numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n         } else {\n             if (expPos > -1) {\n                 if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n-                mant = str.substring(0, expPos);\n+                mant = getMantissa(str, expPos);\n             } else {\n-                mant = str;\n+                mant = getMantissa(str);\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             final String numeric = str.substring(0, str.length() - 1);\n             final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         final Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         final Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn't have a preference on the return type, so let's start\n         //small and go from there...\n         if (expPos > -1 && expPos < str.length() - 1) {\n             exp = str.substring(expPos + 1, str.length());\n         } else {\n             exp = null;\n         }\n         if (dec == null && exp == null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n         try {\n             if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float\n                 final Float f = createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                     return f;\n                 }\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         try {\n             if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n                 final Double d = createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                     return d;\n                 }\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n \n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d1a45e9738de5b3e299bb51e987565dcce55fee6": {
			"type": "Ybodychange",
			"commitMessage": "LANG-747 NumberUtils does not handle Long Hex numbers\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1507169 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-07-25, 7:03 PM",
			"commitName": "d1a45e9738de5b3e299bb51e987565dcce55fee6",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2013-05-19, 4:22 AM",
			"commitNameOld": "8a1042959df80c06dbfa83896594caa8e20ff9d6",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 67.61,
			"commitsBetweenForRepo": 17,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,165 +1,174 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen = 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen += pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n+            char firstSigDigit = 0; // strip leading zeroes\n+            for(int i = pfxLen; i < str.length(); i++) {\n+                firstSigDigit = str.charAt(i);\n+                if (firstSigDigit == '0') { // count leading zeroes\n+                    pfxLen++;\n+                } else {\n+                    break;\n+                }\n+            }\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n+            if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long\n                 return createBigInteger(str);\n             }\n-            if (hexDigits > 8) { // too many for an int\n+            if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos = str.indexOf('.');\n         final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n         int numDecimals = 0; // Check required precision (LANG-693)\n         if (decPos > -1) { // there is a decimal point\n \n             if (expPos > -1) { // there is an exponent\n                 if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n             numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n         } else {\n             if (expPos > -1) {\n                 if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             final String numeric = str.substring(0, str.length() - 1);\n             final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         final Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         final Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn't have a preference on the return type, so let's start\n         //small and go from there...\n         if (expPos > -1 && expPos < str.length() - 1) {\n             exp = str.substring(expPos + 1, str.length());\n         } else {\n             exp = null;\n         }\n         if (dec == null && exp == null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n         try {\n             if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float\n                 final Float f = createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                     return f;\n                 }\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         try {\n             if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n                 final Double d = createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                     return d;\n                 }\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n \n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8a1042959df80c06dbfa83896594caa8e20ff9d6": {
			"type": "Ybodychange",
			"commitMessage": "LANG-693 Method createNumber from NumberUtils doesn't work for floating point numbers other than Float\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1484263 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-05-19, 4:22 AM",
			"commitName": "8a1042959df80c06dbfa83896594caa8e20ff9d6",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2013-03-27, 10:29 AM",
			"commitNameOld": "d80be57d6eecc99411a77ab9575e1991bb616abc",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 52.74,
			"commitsBetweenForRepo": 32,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,159 +1,165 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen = 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen += pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n             if (hexDigits > 16) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits > 8) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos = str.indexOf('.');\n         final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n+        int numDecimals = 0; // Check required precision (LANG-693)\n         if (decPos > -1) { // there is a decimal point\n \n             if (expPos > -1) { // there is an exponent\n                 if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n+            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n         } else {\n             if (expPos > -1) {\n                 if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             final String numeric = str.substring(0, str.length() - 1);\n             final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         final Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         final Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn't have a preference on the return type, so let's start\n         //small and go from there...\n         if (expPos > -1 && expPos < str.length() - 1) {\n             exp = str.substring(expPos + 1, str.length());\n         } else {\n             exp = null;\n         }\n         if (dec == null && exp == null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n         try {\n-            final Float f = createFloat(str);\n-            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n-                return f;\n+            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float\n+                final Float f = createFloat(str);\n+                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n+                    return f;\n+                }\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         try {\n-            final Double d = createDouble(str);\n-            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n-                return d;\n+            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n+                final Double d = createDouble(str);\n+                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n+                    return d;\n+                }\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n \n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d80be57d6eecc99411a77ab9575e1991bb616abc": {
			"type": "Ybodychange",
			"commitMessage": "Document why double exponent (e and E) seems to work even though the index will be wrong\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1461697 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-03-27, 10:29 AM",
			"commitName": "d80be57d6eecc99411a77ab9575e1991bb616abc",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2013-03-27, 9:52 AM",
			"commitNameOld": "b3db6ed9efd0b8ed8a940f2735abb156030d10f9",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,157 +1,159 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen = 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen += pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n             if (hexDigits > 16) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits > 8) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos = str.indexOf('.');\n-        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // TODO assumes both not present\n+        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n+        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n+        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n         if (decPos > -1) { // there is a decimal point\n \n             if (expPos > -1) { // there is an exponent\n-                if (expPos < decPos || expPos > str.length()) {\n+                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n-                if (expPos > str.length()) {\n+                if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             final String numeric = str.substring(0, str.length() - 1);\n             final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         final Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         final Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn't have a preference on the return type, so let's start\n         //small and go from there...\n         if (expPos > -1 && expPos < str.length() - 1) {\n             exp = str.substring(expPos + 1, str.length());\n         } else {\n             exp = null;\n         }\n         if (dec == null && exp == null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n         try {\n             final Float f = createFloat(str);\n             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                 return f;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         try {\n             final Double d = createDouble(str);\n             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                 return d;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n \n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b3db6ed9efd0b8ed8a940f2735abb156030d10f9": {
			"type": "Ybodychange",
			"commitMessage": "LANG-881 NumberUtils.createNumber() Javadoc says it does not work for octal numbers\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1461671 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-03-27, 9:52 AM",
			"commitName": "b3db6ed9efd0b8ed8a940f2735abb156030d10f9",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2013-03-27, 7:04 AM",
			"commitNameOld": "ad43a49dabd5cc14e8ff4b91dbb03477063c1314",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 0.12,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,157 +1,157 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen = 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen += pfx.length();\n                 break;\n             }\n         }\n-        if (pfxLen > 0) {\n+        if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n             if (hexDigits > 16) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits > 8) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos = str.indexOf('.');\n-        final int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n+        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // TODO assumes both not present\n \n-        if (decPos > -1) {\n+        if (decPos > -1) { // there is a decimal point\n \n-            if (expPos > -1) {\n+            if (expPos > -1) { // there is an exponent\n                 if (expPos < decPos || expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n                 if (expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             final String numeric = str.substring(0, str.length() - 1);\n             final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         final Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         final Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn't have a preference on the return type, so let's start\n         //small and go from there...\n         if (expPos > -1 && expPos < str.length() - 1) {\n             exp = str.substring(expPos + 1, str.length());\n         } else {\n             exp = null;\n         }\n-        if (dec == null && exp == null) {\n-            //Must be an int,long,bigint\n+        if (dec == null && exp == null) { // no decimal point and no exponent\n+            //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n-\n         }\n-        //Must be a float,double,BigDec\n+\n+        //Must be a Float, Double, BigDecimal\n         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n         try {\n             final Float f = createFloat(str);\n             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                 return f;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         try {\n             final Double d = createDouble(str);\n             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                 return d;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n \n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ad43a49dabd5cc14e8ff4b91dbb03477063c1314": {
			"type": "Ybodychange",
			"commitMessage": "Statements unnecessarily nested within else clauses.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1461559 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-03-27, 7:04 AM",
			"commitName": "ad43a49dabd5cc14e8ff4b91dbb03477063c1314",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2013-02-20, 9:47 AM",
			"commitNameOld": "99ff604efaee6c501efa62a910c0284f00761bec",
			"commitAuthorOld": "Thomas Neidhart",
			"daysBetweenCommits": 34.85,
			"commitsBetweenForRepo": 29,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,160 +1,157 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen = 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen += pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen > 0) {\n             final int hexDigits = str.length() - pfxLen;\n             if (hexDigits > 16) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits > 8) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos = str.indexOf('.');\n         final int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n                 if (expPos < decPos || expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n                 if (expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             final String numeric = str.substring(0, str.length() - 1);\n             final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         final Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         final Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n-        } else {\n-            //User doesn't have a preference on the return type, so let's start\n-            //small and go from there...\n-            if (expPos > -1 && expPos < str.length() - 1) {\n-                exp = str.substring(expPos + 1, str.length());\n-            } else {\n-                exp = null;\n-            }\n-            if (dec == null && exp == null) {\n-                //Must be an int,long,bigint\n-                try {\n-                    return createInteger(str);\n-                } catch (final NumberFormatException nfe) { // NOPMD\n-                    // ignore the bad number\n-                }\n-                try {\n-                    return createLong(str);\n-                } catch (final NumberFormatException nfe) { // NOPMD\n-                    // ignore the bad number\n-                }\n-                return createBigInteger(str);\n-\n-            } else {\n-                //Must be a float,double,BigDec\n-                final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n-                try {\n-                    final Float f = createFloat(str);\n-                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n-                        return f;\n-                    }\n-                } catch (final NumberFormatException nfe) { // NOPMD\n-                    // ignore the bad number\n-                }\n-                try {\n-                    final Double d = createDouble(str);\n-                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n-                        return d;\n-                    }\n-                } catch (final NumberFormatException nfe) { // NOPMD\n-                    // ignore the bad number\n-                }\n-\n-                return createBigDecimal(str);\n-\n-            }\n         }\n+        //User doesn't have a preference on the return type, so let's start\n+        //small and go from there...\n+        if (expPos > -1 && expPos < str.length() - 1) {\n+            exp = str.substring(expPos + 1, str.length());\n+        } else {\n+            exp = null;\n+        }\n+        if (dec == null && exp == null) {\n+            //Must be an int,long,bigint\n+            try {\n+                return createInteger(str);\n+            } catch (final NumberFormatException nfe) { // NOPMD\n+                // ignore the bad number\n+            }\n+            try {\n+                return createLong(str);\n+            } catch (final NumberFormatException nfe) { // NOPMD\n+                // ignore the bad number\n+            }\n+            return createBigInteger(str);\n+\n+        }\n+        //Must be a float,double,BigDec\n+        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n+        try {\n+            final Float f = createFloat(str);\n+            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n+                return f;\n+            }\n+        } catch (final NumberFormatException nfe) { // NOPMD\n+            // ignore the bad number\n+        }\n+        try {\n+            final Double d = createDouble(str);\n+            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n+                return d;\n+            }\n+        } catch (final NumberFormatException nfe) { // NOPMD\n+            // ignore the bad number\n+        }\n+\n+        return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5292526e476ffbb19c6613a98464054236c86ace": {
			"type": "Ybodychange",
			"commitMessage": "Add final modifier to local variables.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436770 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-01-22, 12:09 AM",
			"commitName": "5292526e476ffbb19c6613a98464054236c86ace",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2013-01-22, 12:07 AM",
			"commitNameOld": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,160 +1,160 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen = 0;\n-        for(String pfx : hex_prefixes) {\n+        for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen += pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen > 0) {\n-            int hexDigits = str.length() - pfxLen;\n+            final int hexDigits = str.length() - pfxLen;\n             if (hexDigits > 16) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits > 8) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n-        char lastChar = str.charAt(str.length() - 1);\n+        final char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n-        int decPos = str.indexOf('.');\n-        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n+        final int decPos = str.indexOf('.');\n+        final int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n                 if (expPos < decPos || expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n                 if (expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n-            String numeric = str.substring(0, str.length() - 1);\n-            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n+            final String numeric = str.substring(0, str.length() - 1);\n+            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n-                        } catch (NumberFormatException nfe) { // NOPMD\n+                        } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n-                        Float f = NumberUtils.createFloat(numeric);\n+                        final Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n-                    } catch (NumberFormatException nfe) { // NOPMD\n+                    } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n-                        Double d = NumberUtils.createDouble(numeric);\n+                        final Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n-                    } catch (NumberFormatException nfe) { // NOPMD\n+                    } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n-                    } catch (NumberFormatException e) { // NOPMD\n+                    } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn't have a preference on the return type, so let's start\n             //small and go from there...\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length());\n             } else {\n                 exp = null;\n             }\n             if (dec == null && exp == null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n-                } catch (NumberFormatException nfe) { // NOPMD\n+                } catch (final NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n-                } catch (NumberFormatException nfe) { // NOPMD\n+                } catch (final NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n-                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n+                final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                 try {\n-                    Float f = createFloat(str);\n+                    final Float f = createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                         return f;\n                     }\n-                } catch (NumberFormatException nfe) { // NOPMD\n+                } catch (final NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n-                    Double d = createDouble(str);\n+                    final Double d = createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                         return d;\n                     }\n-                } catch (NumberFormatException nfe) { // NOPMD\n+                } catch (final NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5bd622dab027ef37001a630a7c825c5b8c19d1db": {
			"type": "Yparametermetachange",
			"commitMessage": "Add final modifier to method parameters.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436768 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-01-22, 12:07 AM",
			"commitName": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2012-11-13, 6:21 AM",
			"commitNameOld": "f5a83bb90cf7b318ac72823e6b99d01d060abe41",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 69.74,
			"commitsBetweenForRepo": 18,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,160 +1,160 @@\n-    public static Number createNumber(String str) throws NumberFormatException {\n+    public static Number createNumber(final String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen = 0;\n         for(String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen += pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen > 0) {\n             int hexDigits = str.length() - pfxLen;\n             if (hexDigits > 16) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits > 8) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos = str.indexOf('.');\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n                 if (expPos < decPos || expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n                 if (expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             String numeric = str.substring(0, str.length() - 1);\n             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn't have a preference on the return type, so let's start\n             //small and go from there...\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length());\n             } else {\n                 exp = null;\n             }\n             if (dec == null && exp == null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                 try {\n                     Float f = createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     Double d = createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[str-String]",
				"newValue": "[str-String(modifiers-final)]"
			}
		},
		"d844d1eb5e5b530a82b77302f1f284fd2f924be3": {
			"type": "Ybodychange",
			"commitMessage": "LANG-854 NumberUtils#createNumber - does not allow for hex numbers to be larger than Long\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1408537 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2012-11-12, 6:39 PM",
			"commitName": "d844d1eb5e5b530a82b77302f1f284fd2f924be3",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2012-11-12, 5:59 PM",
			"commitNameOld": "c1f9320476ab9e5f262fdf8a5b3e1ff70199aed8",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,151 +1,160 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n-        }  \n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n-            int hexDigits = str.length() - 2; // drop 0x\n-            if (str.startsWith(\"-\")) { // drop -\n-                hexDigits--;\n+        }\n+        // Need to deal with all possible hex prefixes here\n+        final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n+        int pfxLen = 0;\n+        for(String pfx : hex_prefixes) {\n+            if (str.startsWith(pfx)) {\n+                pfxLen += pfx.length();\n+                break;\n+            }\n+        }\n+        if (pfxLen > 0) {\n+            int hexDigits = str.length() - pfxLen;\n+            if (hexDigits > 16) { // too many for Long\n+                return createBigInteger(str);\n             }\n             if (hexDigits > 8) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n-        }   \n+        }\n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos = str.indexOf('.');\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n                 if (expPos < decPos || expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n                 if (expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             String numeric = str.substring(0, str.length() - 1);\n             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn't have a preference on the return type, so let's start\n             //small and go from there...\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length());\n             } else {\n                 exp = null;\n             }\n             if (dec == null && exp == null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                 try {\n                     Float f = createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     Double d = createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"350cf8c2da08ccde6b4d71b19bb3df97256ea368": {
			"type": "Ybodychange",
			"commitMessage": "LANG-822: NumberUtils#createNumber - bad behaviour for leading \"--\" \n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1407973 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2012-11-11, 6:16 AM",
			"commitName": "350cf8c2da08ccde6b4d71b19bb3df97256ea368",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2012-11-11, 6:00 AM",
			"commitNameOld": "a7b467a74cbe1160d676dc070a19d19764e132a3",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,158 +1,151 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n-        if (str.startsWith(\"--\")) {\n-            // this is protection for poorness in java.lang.BigDecimal.\n-            // it accepts this as a legal value, but it does not appear \n-            // to be in specification of class. OS X Java parses it to \n-            // a wrong value.\n-            return null;\n-        }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             int hexDigits = str.length() - 2; // drop 0x\n             if (str.startsWith(\"-\")) { // drop -\n                 hexDigits--;\n             }\n             if (hexDigits > 8) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos = str.indexOf('.');\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n                 if (expPos < decPos || expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n                 if (expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             String numeric = str.substring(0, str.length() - 1);\n             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn't have a preference on the return type, so let's start\n             //small and go from there...\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length());\n             } else {\n                 exp = null;\n             }\n             if (dec == null && exp == null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                 try {\n                     Float f = createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     Double d = createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c7adc7e86f118a92ac4eee5a3c6775eec11af115": {
			"type": "Ybodychange",
			"commitMessage": "LANG-747 NumberUtils does not handle Long Hex numbers\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1384126 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2012-09-12, 3:10 PM",
			"commitName": "c7adc7e86f118a92ac4eee5a3c6775eec11af115",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2011-11-09, 9:11 AM",
			"commitNameOld": "163731256b63f03cd2b676baac88fe7ad61b2a6f",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 308.21,
			"commitsBetweenForRepo": 112,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,151 +1,158 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n+            int hexDigits = str.length() - 2; // drop 0x\n+            if (str.startsWith(\"-\")) { // drop -\n+                hexDigits--;\n+            }\n+            if (hexDigits > 8) { // too many for an int\n+                return createLong(str);\n+            }\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos = str.indexOf('.');\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n                 if (expPos < decPos || expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n                 if (expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             String numeric = str.substring(0, str.length() - 1);\n             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn't have a preference on the return type, so let's start\n             //small and go from there...\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length());\n             } else {\n                 exp = null;\n             }\n             if (dec == null && exp == null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                 try {\n                     Float f = createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     Double d = createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"41326bf5266ecc6472bab28481b77cecd6f7fb5c": {
			"type": "Ybodychange",
			"commitMessage": "LANG-746 NumberUtils does not handle upper-case hex: 0X and -0X\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1160660 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2011-08-23, 6:32 AM",
			"commitName": "41326bf5266ecc6472bab28481b77cecd6f7fb5c",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2011-08-03, 7:53 AM",
			"commitNameOld": "f5026c122d042e316fe1ee6314de6e8cab2708c5",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 19.94,
			"commitsBetweenForRepo": 67,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,151 +1,151 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos = str.indexOf('.');\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n                 if (expPos < decPos || expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n                 if (expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             String numeric = str.substring(0, str.length() - 1);\n             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn't have a preference on the return type, so let's start\n             //small and go from there...\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length());\n             } else {\n                 exp = null;\n             }\n             if (dec == null && exp == null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                 try {\n                     Float f = createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     Double d = createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d6fe7f67896642373a9c1fe3e2d75076d29b8e0c": {
			"type": "Ybodychange",
			"commitMessage": "Adding NOPMD tags for various empty catch blocks\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1089736 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2011-04-06, 10:39 PM",
			"commitName": "d6fe7f67896642373a9c1fe3e2d75076d29b8e0c",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2011-04-04, 11:31 PM",
			"commitNameOld": "3a0c152c22b6e96fc809fdee2d6ea5b816a139e6",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 1.96,
			"commitsBetweenForRepo": 15,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,151 +1,151 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos = str.indexOf('.');\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n                 if (expPos < decPos || expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n                 if (expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             String numeric = str.substring(0, str.length() - 1);\n             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n-                        } catch (NumberFormatException nfe) {\n-                            //Too big for a long\n+                        } catch (NumberFormatException nfe) { // NOPMD\n+                            // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n-                    } catch (NumberFormatException nfe) {\n+                    } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n-                    } catch (NumberFormatException nfe) {\n+                    } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n-                    } catch (NumberFormatException e) {\n+                    } catch (NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn't have a preference on the return type, so let's start\n             //small and go from there...\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length());\n             } else {\n                 exp = null;\n             }\n             if (dec == null && exp == null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n-                } catch (NumberFormatException nfe) {\n+                } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n-                } catch (NumberFormatException nfe) {\n+                } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                 try {\n                     Float f = createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                         return f;\n                     }\n-                } catch (NumberFormatException nfe) {\n+                } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     Double d = createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                         return d;\n                     }\n-                } catch (NumberFormatException nfe) {\n+                } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"50c1fdecb4ed33ec1bb0d449f294c299d5369701": {
			"type": "Ybodychange",
			"commitMessage": "Making it so that NumberUtils.createNumber throws a NumberFormatException instead of a StringIndexOutOfBoundsException when Strings such as 1eE are passed in. Thanks to Ingo Heinrich's report and patch in LANG-638\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@981736 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-08-02, 10:41 PM",
			"commitName": "50c1fdecb4ed33ec1bb0d449f294c299d5369701",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2010-02-24, 6:28 PM",
			"commitNameOld": "43fca0d7499c99f9e82e0ee2e52b81acdc954f2c",
			"commitAuthorOld": "Niall Pemberton",
			"daysBetweenCommits": 159.13,
			"commitsBetweenForRepo": 154,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,148 +1,151 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos = str.indexOf('.');\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+                if (expPos < decPos || expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n+                if (expPos > str.length()) {\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n+                }\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             String numeric = str.substring(0, str.length() - 1);\n             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn't have a preference on the return type, so let's start\n             //small and go from there...\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length());\n             } else {\n                 exp = null;\n             }\n             if (dec == null && exp == null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                 try {\n                     Float f = createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 try {\n                     Double d = createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fc5c081e22a61bb5a6810af302be3f22f7966df4": {
			"type": "Yfilerename",
			"commitMessage": "Move main source to src/main/java\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@895322 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-01-02, 7:11 PM",
			"commitName": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
			"commitAuthor": "Paul C. Benedict Jr",
			"commitDateOld": "2010-01-02, 7:09 PM",
			"commitNameOld": "6b32246f5f9f77c74b32a5290cdbdd4e0f5c71c6",
			"commitAuthorOld": "Paul C. Benedict Jr",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/java/org/apache/commons/lang3/math/NumberUtils.java",
				"newPath": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java"
			}
		},
		"26bc3fe010d5154d3ccac526ec22c429fc3af499": {
			"type": "Ybodychange",
			"commitMessage": "isNumber(String) and createNumber(String) both modified to support \"2.\". LANG-521\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@893088 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2009-12-21, 11:52 PM",
			"commitName": "26bc3fe010d5154d3ccac526ec22c429fc3af499",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2009-12-10, 4:56 AM",
			"commitNameOld": "c6e8f706dc7a236cc2a49f979d857ee92d0abd7c",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 11.79,
			"commitsBetweenForRepo": 37,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,148 +1,148 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos = str.indexOf('.');\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n                 if (expPos < decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n-        if (!Character.isDigit(lastChar)) {\n+        if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             String numeric = str.substring(0, str.length() - 1);\n             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn't have a preference on the return type, so let's start\n             //small and go from there...\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length());\n             } else {\n                 exp = null;\n             }\n             if (dec == null && exp == null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                 try {\n                     Float f = createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 try {\n                     Double d = createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"debc02c6d9b94c717b4182ae4dd7a97d47293a52": {
			"type": "Yfilerename",
			"commitMessage": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@889202 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2009-12-10, 4:33 AM",
			"commitName": "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2009-12-10, 4:31 AM",
			"commitNameOld": "375d7d0954cae60c4c7292cc65abbc972178857c",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/java/org/apache/commons/lang/math/NumberUtils.java",
				"newPath": "src/java/org/apache/commons/lang3/math/NumberUtils.java"
			}
		},
		"5beb105d6b4188e6babefd89e19b06df1d71886c": {
			"type": "Ybodychange",
			"commitMessage": "Use Eclipse comment-style to suppress drop-thru warning\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@819700 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2009-09-28, 2:07 PM",
			"commitName": "5beb105d6b4188e6babefd89e19b06df1d71886c",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2009-06-25, 1:09 AM",
			"commitNameOld": "f3ac86a292acd3fc57a2100978f3d9d2705238d2",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 95.54,
			"commitsBetweenForRepo": 59,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,148 +1,148 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos = str.indexOf('.');\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n                 if (expPos < decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar)) {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             String numeric = str.substring(0, str.length() - 1);\n             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n                         // ignore the bad number\n                     }\n-                    //Fall through\n+                    //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n                         // ignore the bad number\n                     }\n-                    //Fall through\n+                    //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn't have a preference on the return type, so let's start\n             //small and go from there...\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length());\n             } else {\n                 exp = null;\n             }\n             if (dec == null && exp == null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                 try {\n                     Float f = createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 try {\n                     Double d = createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"15360774099b2a7230e020751acdf6979b6e3f58": {
			"type": "Ybodychange",
			"commitMessage": "Fixing LANG-300 (reported by Jeremy Lemaire) - 1L to 9L incorrectly throw exceptions when passed into NumberUtils.createNumber. Fixed in both the math.NumbersUtils and the deprecated NumberUtils classes. \n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@488819 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2006-12-19, 2:50 PM",
			"commitName": "15360774099b2a7230e020751acdf6979b6e3f58",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2006-11-05, 9:02 PM",
			"commitNameOld": "d8a6e05b5f23458ddd57ad838f43936520689ff7",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 43.74,
			"commitsBetweenForRepo": 16,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,149 +1,148 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos = str.indexOf('.');\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n                 if (expPos < decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar)) {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             String numeric = str.substring(0, str.length() - 1);\n             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n                         // ignore the bad number\n                     }\n                     //Fall through\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n                         // ignore the bad number\n                     }\n                     //Fall through\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn't have a preference on the return type, so let's start\n             //small and go from there...\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length());\n             } else {\n                 exp = null;\n             }\n             if (dec == null && exp == null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                 try {\n                     Float f = createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 try {\n                     Double d = createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"073222372614fcff2f4824d46a817c44e4b03d09": {
			"type": "Ybodychange",
			"commitMessage": "removed empty statement from catch block that takes no action, using comment only to denote no action;\nadded super to empty constructors\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@209373 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2005-07-05, 7:15 PM",
			"commitName": "073222372614fcff2f4824d46a817c44e4b03d09",
			"commitAuthor": "Steven Caswell",
			"commitDateOld": "2005-06-27, 2:24 PM",
			"commitNameOld": "12431fdb8fccfd0474c2a0d7666dcd2c0eed6e5f",
			"commitAuthorOld": "Steven Caswell",
			"daysBetweenCommits": 8.2,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,149 +1,149 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos = str.indexOf('.');\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n                 if (expPos < decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar)) {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             String numeric = str.substring(0, str.length() - 1);\n             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && isDigits(numeric.substring(1))\n                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n-                            ; //Too big for a long\n+                            //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n-                      ; // empty catch\n+                        // ignore the bad number\n                     }\n                     //Fall through\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n-                      ; // empty constructor\n+                        // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n-                      ; // empty constructor\n+                        // ignore the bad number\n                     }\n                     //Fall through\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn't have a preference on the return type, so let's start\n             //small and go from there...\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length());\n             } else {\n                 exp = null;\n             }\n             if (dec == null && exp == null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n-                  ; // empty contructor\n+                    // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) {\n-                  ; // empty constructor\n+                    // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                 try {\n                     Float f = createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n-                  ; // empty constructor\n+                    // ignore the bad number\n                 }\n                 try {\n                     Double d = createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n-                  ; // empty constructor\n+                    // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"12431fdb8fccfd0474c2a0d7666dcd2c0eed6e5f": {
			"type": "Ybodychange",
			"commitMessage": "added empty statement to empty catch blocks\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@202043 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2005-06-27, 2:24 PM",
			"commitName": "12431fdb8fccfd0474c2a0d7666dcd2c0eed6e5f",
			"commitAuthor": "Steven Caswell",
			"commitDateOld": "2005-06-26, 11:45 AM",
			"commitNameOld": "b73111983b7916b3944e2178d079f1326cd8df06",
			"commitAuthorOld": "Steven Caswell",
			"daysBetweenCommits": 1.11,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,149 +1,149 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos = str.indexOf('.');\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n                 if (expPos < decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar)) {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             String numeric = str.substring(0, str.length() - 1);\n             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && isDigits(numeric.substring(1))\n                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n-                            //Too big for a long\n+                            ; //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n                       ; // empty catch\n                     }\n                     //Fall through\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n                       ; // empty constructor\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n                       ; // empty constructor\n                     }\n                     //Fall through\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn't have a preference on the return type, so let's start\n             //small and go from there...\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length());\n             } else {\n                 exp = null;\n             }\n             if (dec == null && exp == null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n                   ; // empty contructor\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) {\n                   ; // empty constructor\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                 try {\n                     Float f = createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                   ; // empty constructor\n                 }\n                 try {\n                     Double d = createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                   ; // empty constructor\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b73111983b7916b3944e2178d079f1326cd8df06": {
			"type": "Ybodychange",
			"commitMessage": "corrected style issues (mostly empty blocks and missing javadocs)\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@201882 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2005-06-26, 11:45 AM",
			"commitName": "b73111983b7916b3944e2178d079f1326cd8df06",
			"commitAuthor": "Steven Caswell",
			"commitDateOld": "2005-04-13, 10:30 PM",
			"commitNameOld": "4f69e5183a56d6a38a76ebafcb12637c0ecb8f4c",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 73.55,
			"commitsBetweenForRepo": 61,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,142 +1,149 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos = str.indexOf('.');\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n                 if (expPos < decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar)) {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             String numeric = str.substring(0, str.length() - 1);\n             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && isDigits(numeric.substring(1))\n                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n+                      ; // empty catch\n                     }\n                     //Fall through\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n+                      ; // empty constructor\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n+                      ; // empty constructor\n                     }\n                     //Fall through\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn't have a preference on the return type, so let's start\n             //small and go from there...\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length());\n             } else {\n                 exp = null;\n             }\n             if (dec == null && exp == null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n+                  ; // empty contructor\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) {\n+                  ; // empty constructor\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                 try {\n                     Float f = createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n+                  ; // empty constructor\n                 }\n                 try {\n                     Double d = createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n+                  ; // empty constructor\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fd3bd5bdd2ef9f6dd184a2d3c587d1a73e19334c": {
			"type": "Ybodychange",
			"commitMessage": "Fixed typos in javadoc and some inline comments.\nPr #22908.\nPatch submitted by Janek Bogucki.\nReviewed by Phil Steitz.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137666 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2003-09-07, 8:32 AM",
			"commitName": "fd3bd5bdd2ef9f6dd184a2d3c587d1a73e19334c",
			"commitAuthor": "Phil Steitz",
			"commitDateOld": "2003-09-05, 9:55 AM",
			"commitNameOld": "69b8f445d74f22ba99a75c47a38d97d5e85248cc",
			"commitAuthorOld": "Phil Steitz",
			"daysBetweenCommits": 1.94,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,142 +1,142 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos = str.indexOf('.');\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n                 if (expPos < decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar)) {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             String numeric = str.substring(0, str.length() - 1);\n             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && isDigits(numeric.substring(1))\n                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n-                            //has non-zeros in it, then float doens't have the presision we want\n+                            //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n                     }\n                     //Fall through\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n                     }\n                     //Fall through\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn't have a preference on the return type, so let's start\n             //small and go from there...\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length());\n             } else {\n                 exp = null;\n             }\n             if (dec == null && exp == null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) {\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                 try {\n                     Float f = createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     Double d = createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4f1528447ccc588f9ff6dbcf98ff3bd587c91c25": {
			"type": "Ybodychange",
			"commitMessage": "Redo null/empty string checking for performance\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137522 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2003-07-28, 3:37 PM",
			"commitName": "4f1528447ccc588f9ff6dbcf98ff3bd587c91c25",
			"commitAuthor": "Stephen Colebourne",
			"commitDateOld": "2003-07-26, 1:12 PM",
			"commitNameOld": "3b19309d76817dfacb40299b474ecbc27a471e11",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 2.1,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,139 +1,142 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n-        if (!validateNumber(str)) {\n+        if (str == null) {\n             return null;\n         }\n+        if (StringUtils.isBlank(str)) {\n+            throw new NumberFormatException(\"A blank string is not a valid number\");\n+        }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos = str.indexOf('.');\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n                 if (expPos < decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar)) {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             String numeric = str.substring(0, str.length() - 1);\n             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && isDigits(numeric.substring(1))\n                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float doens't have the presision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n                     }\n                     //Fall through\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n                     }\n                     //Fall through\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn't have a preference on the return type, so let's start\n             //small and go from there...\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length());\n             } else {\n                 exp = null;\n             }\n             if (dec == null && exp == null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) {\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                 try {\n                     Float f = createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     Double d = createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3b19309d76817dfacb40299b474ecbc27a471e11": {
			"type": "Ybodychange",
			"commitMessage": "Fix http://nagoya.apache.org/bugzilla/show_bug.cgi?id=21904 as suggested (but with the guard clause factored in a method.)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137520 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2003-07-26, 1:12 PM",
			"commitName": "3b19309d76817dfacb40299b474ecbc27a471e11",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2003-07-26, 9:39 AM",
			"commitNameOld": "9410b31864bc0bddb53779883dfb15763abb5ade",
			"commitAuthorOld": "Stephen Colebourne",
			"daysBetweenCommits": 0.15,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,142 +1,139 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n-        if (str == null) {\n+        if (!validateNumber(str)) {\n             return null;\n         }\n-        if (str.length() == 0) {\n-            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n-        }\n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos = str.indexOf('.');\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n                 if (expPos < decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n             }\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar)) {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n             String numeric = str.substring(0, str.length() - 1);\n             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && isDigits(numeric.substring(1))\n                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float doens't have the presision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n                     }\n                     //Fall through\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n                     }\n                     //Fall through\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn't have a preference on the return type, so let's start\n             //small and go from there...\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length());\n             } else {\n                 exp = null;\n             }\n             if (dec == null && exp == null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) {\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                 try {\n                     Float f = createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     Double d = createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"af6aba957f4dc4d19d5f295172b4ddc941ca1681": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Update null handling behaviour and documentation\nbug 21734, from Phil Steiz\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137476 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2003-07-20, 10:03 AM",
			"commitName": "af6aba957f4dc4d19d5f295172b4ddc941ca1681",
			"commitAuthor": "Stephen Colebourne",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Update null handling behaviour and documentation\nbug 21734, from Phil Steiz\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137476 13f79535-47bb-0310-9956-ffa450edef68\n",
					"commitDate": "2003-07-20, 10:03 AM",
					"commitName": "af6aba957f4dc4d19d5f295172b4ddc941ca1681",
					"commitAuthor": "Stephen Colebourne",
					"commitDateOld": "2003-07-14, 4:25 PM",
					"commitNameOld": "eadb45d1a7b8b16164171c7caa171fd9f911a414",
					"commitAuthorOld": "Henri Yandell",
					"daysBetweenCommits": 5.73,
					"commitsBetweenForRepo": 59,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,142 +1,142 @@\n-    public static Number createNumber(String val) throws NumberFormatException {\n-        if (val == null) {\n+    public static Number createNumber(String str) throws NumberFormatException {\n+        if (str == null) {\n             return null;\n         }\n-        if (val.length() == 0) {\n+        if (str.length() == 0) {\n             throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n         }\n-        if (val.startsWith(\"--\")) {\n+        if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n-            return createInteger(val);\n+        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+            return createInteger(str);\n         }   \n-        char lastChar = val.charAt(val.length() - 1);\n+        char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n-        int decPos = val.indexOf('.');\n-        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n+        int decPos = str.indexOf('.');\n+        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n                 if (expPos < decPos) {\n-                    throw new NumberFormatException(val + \" is not a valid number.\");\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n-                dec = val.substring(decPos + 1, expPos);\n+                dec = str.substring(decPos + 1, expPos);\n             } else {\n-                dec = val.substring(decPos + 1);\n+                dec = str.substring(decPos + 1);\n             }\n-            mant = val.substring(0, decPos);\n+            mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n-                mant = val.substring(0, expPos);\n+                mant = str.substring(0, expPos);\n             } else {\n-                mant = val;\n+                mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar)) {\n-            if (expPos > -1 && expPos < val.length() - 1) {\n-                exp = val.substring(expPos + 1, val.length() - 1);\n+            if (expPos > -1 && expPos < str.length() - 1) {\n+                exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n-            String numeric = val.substring(0, val.length() - 1);\n+            String numeric = str.substring(0, str.length() - 1);\n             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && isDigits(numeric.substring(1))\n                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n-                    throw new NumberFormatException(val + \" is not a valid number.\");\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float doens't have the presision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n                     }\n                     //Fall through\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n                     }\n                     //Fall through\n                 default :\n-                    throw new NumberFormatException(val + \" is not a valid number.\");\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn't have a preference on the return type, so let's start\n             //small and go from there...\n-            if (expPos > -1 && expPos < val.length() - 1) {\n-                exp = val.substring(expPos + 1, val.length());\n+            if (expPos > -1 && expPos < str.length() - 1) {\n+                exp = str.substring(expPos + 1, str.length());\n             } else {\n                 exp = null;\n             }\n             if (dec == null && exp == null) {\n                 //Must be an int,long,bigint\n                 try {\n-                    return createInteger(val);\n+                    return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n-                    return createLong(val);\n+                    return createLong(str);\n                 } catch (NumberFormatException nfe) {\n                 }\n-                return createBigInteger(val);\n+                return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                 try {\n-                    Float f = createFloat(val);\n+                    Float f = createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n-                    Double d = createDouble(val);\n+                    Double d = createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n \n-                return createBigDecimal(val);\n+                return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[val-String]",
						"newValue": "[str-String]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Update null handling behaviour and documentation\nbug 21734, from Phil Steiz\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137476 13f79535-47bb-0310-9956-ffa450edef68\n",
					"commitDate": "2003-07-20, 10:03 AM",
					"commitName": "af6aba957f4dc4d19d5f295172b4ddc941ca1681",
					"commitAuthor": "Stephen Colebourne",
					"commitDateOld": "2003-07-14, 4:25 PM",
					"commitNameOld": "eadb45d1a7b8b16164171c7caa171fd9f911a414",
					"commitAuthorOld": "Henri Yandell",
					"daysBetweenCommits": 5.73,
					"commitsBetweenForRepo": 59,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,142 +1,142 @@\n-    public static Number createNumber(String val) throws NumberFormatException {\n-        if (val == null) {\n+    public static Number createNumber(String str) throws NumberFormatException {\n+        if (str == null) {\n             return null;\n         }\n-        if (val.length() == 0) {\n+        if (str.length() == 0) {\n             throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n         }\n-        if (val.startsWith(\"--\")) {\n+        if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n-            return createInteger(val);\n+        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+            return createInteger(str);\n         }   \n-        char lastChar = val.charAt(val.length() - 1);\n+        char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n-        int decPos = val.indexOf('.');\n-        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n+        int decPos = str.indexOf('.');\n+        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n                 if (expPos < decPos) {\n-                    throw new NumberFormatException(val + \" is not a valid number.\");\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n-                dec = val.substring(decPos + 1, expPos);\n+                dec = str.substring(decPos + 1, expPos);\n             } else {\n-                dec = val.substring(decPos + 1);\n+                dec = str.substring(decPos + 1);\n             }\n-            mant = val.substring(0, decPos);\n+            mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n-                mant = val.substring(0, expPos);\n+                mant = str.substring(0, expPos);\n             } else {\n-                mant = val;\n+                mant = str;\n             }\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar)) {\n-            if (expPos > -1 && expPos < val.length() - 1) {\n-                exp = val.substring(expPos + 1, val.length() - 1);\n+            if (expPos > -1 && expPos < str.length() - 1) {\n+                exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n             //Requesting a specific type..\n-            String numeric = val.substring(0, val.length() - 1);\n+            String numeric = str.substring(0, str.length() - 1);\n             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                         && isDigits(numeric.substring(1))\n                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n-                    throw new NumberFormatException(val + \" is not a valid number.\");\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float doens't have the presision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n                     }\n                     //Fall through\n                 case 'd' :\n                 case 'D' :\n                     try {\n                         Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n                     }\n                     //Fall through\n                 default :\n-                    throw new NumberFormatException(val + \" is not a valid number.\");\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn't have a preference on the return type, so let's start\n             //small and go from there...\n-            if (expPos > -1 && expPos < val.length() - 1) {\n-                exp = val.substring(expPos + 1, val.length());\n+            if (expPos > -1 && expPos < str.length() - 1) {\n+                exp = str.substring(expPos + 1, str.length());\n             } else {\n                 exp = null;\n             }\n             if (dec == null && exp == null) {\n                 //Must be an int,long,bigint\n                 try {\n-                    return createInteger(val);\n+                    return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n-                    return createLong(val);\n+                    return createLong(str);\n                 } catch (NumberFormatException nfe) {\n                 }\n-                return createBigInteger(val);\n+                return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                 try {\n-                    Float f = createFloat(val);\n+                    Float f = createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n-                    Double d = createDouble(val);\n+                    Double d = createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n \n-                return createBigDecimal(val);\n+                return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"2d06a7ce861432fc702168fd4c94bc00ddfc39eb": {
			"type": "Yintroduced",
			"commitMessage": "NumberUtils moved to math subpackage\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137379 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2003-06-24, 3:14 PM",
			"commitName": "2d06a7ce861432fc702168fd4c94bc00ddfc39eb",
			"commitAuthor": "Stephen Colebourne"
		}
	},
	"sha": "a36c903d4f1065bc59f5e6d2bb0f9d92a5e71d83"
}