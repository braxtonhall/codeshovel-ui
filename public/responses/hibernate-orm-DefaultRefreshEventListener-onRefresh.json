{
	"repo": "https://github.com/hibernate/hibernate-orm.git",
	"file": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
	"method": {
		"longName": "DefaultRefreshEventListener::onRefresh(RefreshEvent event, Map refreshedAlready)",
		"startLine": 56,
		"methodName": "onRefresh",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"12b79a59383d1b647c9957815ef53861f0752dad": {
			"type": "Ybodychange",
			"commitMessage": "HHH-12257 - Refreshing an entity clears the lock mode returned from EntityManager.getLockMode\n",
			"commitDate": "2018-04-26, 12:46 PM",
			"commitName": "12b79a59383d1b647c9957815ef53861f0752dad",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2018-04-26, 12:46 PM",
			"commitNameOld": "a286232da374cbccefddbf406830dbb598b6c824",
			"commitAuthorOld": "Gail Badner",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,140 +1,174 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \t\tboolean isTransient;\n \t\tif ( event.getEntityName() != null ) {\n \t\t\tisTransient = !source.contains( event.getEntityName(), event.getObject() );\n \t\t}\n \t\telse {\n \t\t\tisTransient = !source.contains( event.getObject() );\n \t\t}\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tCascade.cascade(\n \t\t\t\tCascadingActions.REFRESH,\n \t\t\t\tCascadePoint.BEFORE_REFRESH,\n \t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e != null ) {\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n \t\t\t\tnew EvictVisitor( source, object ).process( object, persister );\n \t\t\t}\n \t\t}\n \n \t\tif ( persister.canWriteToCache() ) {\n \t\t\tObject previousVersion = null;\n \t\t\tif ( persister.isVersionPropertyGenerated() ) {\n \t\t\t\t// we need to grab the version value from the entity, otherwise\n \t\t\t\t// we have issues with generated-version entities that may have\n \t\t\t\t// multiple actions queued during the same flush\n \t\t\t\tpreviousVersion = persister.getVersion( object );\n \t\t\t}\n \t\t\tfinal EntityDataAccess cache = persister.getCacheAccessStrategy();\n \t\t\tfinal Object ck = cache.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister,\n \t\t\t\t\tsource.getFactory(),\n \t\t\t\t\tsource.getTenantIdentifier()\n \t\t\t);\n \t\t\tfinal SoftLock lock = cache.lockItem( source, ck, previousVersion );\n \t\t\tcache.remove( source, ck );\n \t\t\tsource.getActionQueue().registerProcess( (success, session) -> cache.unlockItem( session, ck, lock ) );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source );\n \n \t\tString previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \n-\t\t// Use the entity's current LockMode if it is greater than event.getLockMode()\n-\t\tfinal LockMode currentLockMode = e == null ? null : e.getLockMode();\n+\n+\t\t// Handle the requested lock-mode (if one) in relation to the entry's (if one) current lock-mode\n+\n \t\tLockOptions lockOptionsToUse = event.getLockOptions();\n-\t\tif ( currentLockMode != null && currentLockMode.greaterThan( event.getLockMode() ) ) {\n-\t\t\tlockOptionsToUse = LockOptions.copy( event.getLockOptions(), new LockOptions() );\n-\t\t\tlockOptionsToUse.setLockMode( currentLockMode );\n+\n+\t\tfinal LockMode requestedLockMode = lockOptionsToUse.getLockMode();\n+\t\tLockMode postRefreshLockMode = null;\n+\n+\t\tif ( e != null ) {\n+\t\t\tfinal LockMode currentLockMode = e.getLockMode();\n+\t\t\tif ( currentLockMode.greaterThan( requestedLockMode ) ) {\n+\t\t\t\t// the requested lock-mode is less restrictive than the current one\n+\t\t\t\t//\t\t- pass along the current lock-mode (after accounting for WRITE)\n+\t\t\t\tlockOptionsToUse = LockOptions.copy( event.getLockOptions(), new LockOptions() );\n+\t\t\t\tif ( currentLockMode == LockMode.WRITE ) {\n+\t\t\t\t\t// our transaction should already hold the exclusive lock on\n+\t\t\t\t\t// the underlying row - so READ should be sufficient.\n+\t\t\t\t\t//\n+\t\t\t\t\t// in fact, this really holds true for any current lock-mode that indicates we\n+\t\t\t\t\t// hold an exclusive lock on the underlying row - but we *need* to handle\n+\t\t\t\t\t// WRITE specially because the Loader/Locker mechanism does not allow for WRITE\n+\t\t\t\t\t// locks\n+\t\t\t\t\tlockOptionsToUse.setLockMode( LockMode.READ );\n+\n+\t\t\t\t\t// and prepare to reset the entry lock-mode to WRITE after the refresh completes\n+\t\t\t\t\tpostRefreshLockMode = LockMode.WRITE;\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tlockOptionsToUse.setLockMode( currentLockMode );\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n-\t\tObject result = persister.load( id, object, lockOptionsToUse, source );\n-\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n-\t\t// If it was transient, then set it to the default for the source.\n+\n+\t\tfinal Object result = persister.load( id, object, lockOptionsToUse, source );\n+\n \t\tif ( result != null ) {\n+\t\t\t// apply `postRefreshLockMode`, if needed\n+\t\t\tif ( postRefreshLockMode != null ) {\n+\t\t\t\t// if we get here, there was a previous entry and we need to re-set its lock-mode\n+\t\t\t\t//\t\t- however, the refresh operation actually creates a new entry, so get it\n+\t\t\t\tsource.getPersistenceContext().getEntry( result ).setLockMode( postRefreshLockMode );\n+\t\t\t}\n+\n+\t\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n+\t\t\t// If it was transient, then set it to the default for the source.\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a286232da374cbccefddbf406830dbb598b6c824": {
			"type": "Ybodychange",
			"commitMessage": "HHH-12257 : Refreshing an entity clears the lock mode\n",
			"commitDate": "2018-04-26, 12:46 PM",
			"commitName": "a286232da374cbccefddbf406830dbb598b6c824",
			"commitAuthor": "Gail Badner",
			"commitDateOld": "2018-03-22, 12:25 PM",
			"commitNameOld": "f432ecea687ce606144c8fca1f4fc7f1937e1c2a",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 35.01,
			"commitsBetweenForRepo": 136,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,132 +1,140 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \t\tboolean isTransient;\n \t\tif ( event.getEntityName() != null ) {\n \t\t\tisTransient = !source.contains( event.getEntityName(), event.getObject() );\n \t\t}\n \t\telse {\n \t\t\tisTransient = !source.contains( event.getObject() );\n \t\t}\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tCascade.cascade(\n \t\t\t\tCascadingActions.REFRESH,\n \t\t\t\tCascadePoint.BEFORE_REFRESH,\n \t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e != null ) {\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n \t\t\t\tnew EvictVisitor( source, object ).process( object, persister );\n \t\t\t}\n \t\t}\n \n \t\tif ( persister.canWriteToCache() ) {\n \t\t\tObject previousVersion = null;\n \t\t\tif ( persister.isVersionPropertyGenerated() ) {\n \t\t\t\t// we need to grab the version value from the entity, otherwise\n \t\t\t\t// we have issues with generated-version entities that may have\n \t\t\t\t// multiple actions queued during the same flush\n \t\t\t\tpreviousVersion = persister.getVersion( object );\n \t\t\t}\n \t\t\tfinal EntityDataAccess cache = persister.getCacheAccessStrategy();\n \t\t\tfinal Object ck = cache.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister,\n \t\t\t\t\tsource.getFactory(),\n \t\t\t\t\tsource.getTenantIdentifier()\n \t\t\t);\n \t\t\tfinal SoftLock lock = cache.lockItem( source, ck, previousVersion );\n \t\t\tcache.remove( source, ck );\n \t\t\tsource.getActionQueue().registerProcess( (success, session) -> cache.unlockItem( session, ck, lock ) );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source );\n \n \t\tString previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n-\t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n+\n+\t\t// Use the entity's current LockMode if it is greater than event.getLockMode()\n+\t\tfinal LockMode currentLockMode = e == null ? null : e.getLockMode();\n+\t\tLockOptions lockOptionsToUse = event.getLockOptions();\n+\t\tif ( currentLockMode != null && currentLockMode.greaterThan( event.getLockMode() ) ) {\n+\t\t\tlockOptionsToUse = LockOptions.copy( event.getLockOptions(), new LockOptions() );\n+\t\t\tlockOptionsToUse.setLockMode( currentLockMode );\n+\t\t}\n+\t\tObject result = persister.load( id, object, lockOptionsToUse, source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f432ecea687ce606144c8fca1f4fc7f1937e1c2a": {
			"type": "Ybodychange",
			"commitMessage": "HHH-11356 - Adjust the 2nd-Cache SPIs to better reflect supported uses\nHHH-12323 - Update Statistics API and SPI based on changes to 2nd level caching changes\n",
			"commitDate": "2018-03-22, 12:25 PM",
			"commitName": "f432ecea687ce606144c8fca1f4fc7f1937e1c2a",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2018-02-21, 1:32 AM",
			"commitNameOld": "684cfe6383e100b8eefcc7a5439f0d9ce700ea4b",
			"commitAuthorOld": "Jonathan Bregler",
			"daysBetweenCommits": 29.41,
			"commitsBetweenForRepo": 106,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,137 +1,132 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \t\tboolean isTransient;\n \t\tif ( event.getEntityName() != null ) {\n \t\t\tisTransient = !source.contains( event.getEntityName(), event.getObject() );\n \t\t}\n \t\telse {\n \t\t\tisTransient = !source.contains( event.getObject() );\n \t\t}\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tCascade.cascade(\n \t\t\t\tCascadingActions.REFRESH,\n \t\t\t\tCascadePoint.BEFORE_REFRESH,\n \t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e != null ) {\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n \t\t\t\tnew EvictVisitor( source, object ).process( object, persister );\n \t\t\t}\n \t\t}\n \n \t\tif ( persister.canWriteToCache() ) {\n \t\t\tObject previousVersion = null;\n \t\t\tif ( persister.isVersionPropertyGenerated() ) {\n \t\t\t\t// we need to grab the version value from the entity, otherwise\n \t\t\t\t// we have issues with generated-version entities that may have\n \t\t\t\t// multiple actions queued during the same flush\n \t\t\t\tpreviousVersion = persister.getVersion( object );\n \t\t\t}\n-\t\t\tfinal EntityRegionAccessStrategy cache = persister.getCacheAccessStrategy();\n+\t\t\tfinal EntityDataAccess cache = persister.getCacheAccessStrategy();\n \t\t\tfinal Object ck = cache.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister,\n \t\t\t\t\tsource.getFactory(),\n \t\t\t\t\tsource.getTenantIdentifier()\n \t\t\t);\n \t\t\tfinal SoftLock lock = cache.lockItem( source, ck, previousVersion );\n-\t\t\tsource.getActionQueue().registerProcess( new AfterTransactionCompletionProcess() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n-\t\t\t\t\tcache.unlockItem( session, ck, lock );\n-\t\t\t\t}\n-\t\t\t} );\n \t\t\tcache.remove( source, ck );\n+\t\t\tsource.getActionQueue().registerProcess( (success, session) -> cache.unlockItem( session, ck, lock ) );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source );\n \n \t\tString previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"684cfe6383e100b8eefcc7a5439f0d9ce700ea4b": {
			"type": "Ybodychange",
			"commitMessage": "HHH-12260: refactor org.hibernate.event.internal.EvictVisitor#evictCollection\n",
			"commitDate": "2018-02-21, 1:32 AM",
			"commitName": "684cfe6383e100b8eefcc7a5439f0d9ce700ea4b",
			"commitAuthor": "Jonathan Bregler",
			"commitDateOld": "2017-12-13, 5:19 AM",
			"commitNameOld": "59c3baae3271247bed516fe50952b65be1a27e5b",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 69.84,
			"commitsBetweenForRepo": 201,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,137 +1,137 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \t\tboolean isTransient;\n \t\tif ( event.getEntityName() != null ) {\n \t\t\tisTransient = !source.contains( event.getEntityName(), event.getObject() );\n \t\t}\n \t\telse {\n \t\t\tisTransient = !source.contains( event.getObject() );\n \t\t}\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tCascade.cascade(\n \t\t\t\tCascadingActions.REFRESH,\n \t\t\t\tCascadePoint.BEFORE_REFRESH,\n \t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e != null ) {\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n-\t\t\t\tnew EvictVisitor( source ).process( object, persister );\n+\t\t\t\tnew EvictVisitor( source, object ).process( object, persister );\n \t\t\t}\n \t\t}\n \n \t\tif ( persister.canWriteToCache() ) {\n \t\t\tObject previousVersion = null;\n \t\t\tif ( persister.isVersionPropertyGenerated() ) {\n \t\t\t\t// we need to grab the version value from the entity, otherwise\n \t\t\t\t// we have issues with generated-version entities that may have\n \t\t\t\t// multiple actions queued during the same flush\n \t\t\t\tpreviousVersion = persister.getVersion( object );\n \t\t\t}\n \t\t\tfinal EntityRegionAccessStrategy cache = persister.getCacheAccessStrategy();\n \t\t\tfinal Object ck = cache.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister,\n \t\t\t\t\tsource.getFactory(),\n \t\t\t\t\tsource.getTenantIdentifier()\n \t\t\t);\n \t\t\tfinal SoftLock lock = cache.lockItem( source, ck, previousVersion );\n \t\t\tsource.getActionQueue().registerProcess( new AfterTransactionCompletionProcess() {\n \t\t\t\t@Override\n \t\t\t\tpublic void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n \t\t\t\t\tcache.unlockItem( session, ck, lock );\n \t\t\t\t}\n \t\t\t} );\n \t\t\tcache.remove( source, ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source );\n \n \t\tString previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"59c3baae3271247bed516fe50952b65be1a27e5b": {
			"type": "Ybodychange",
			"commitMessage": "HHH-12146  - Support enabling caching at any level within a mapped hierarchy\n",
			"commitDate": "2017-12-13, 5:19 AM",
			"commitName": "59c3baae3271247bed516fe50952b65be1a27e5b",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2017-05-03, 2:54 AM",
			"commitNameOld": "3a813dcbb4b5cf5b13571c63ff0c66b94a83b53c",
			"commitAuthorOld": "Richard Bradley",
			"daysBetweenCommits": 224.14,
			"commitsBetweenForRepo": 421,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,137 +1,137 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \t\tboolean isTransient;\n \t\tif ( event.getEntityName() != null ) {\n \t\t\tisTransient = !source.contains( event.getEntityName(), event.getObject() );\n \t\t}\n \t\telse {\n \t\t\tisTransient = !source.contains( event.getObject() );\n \t\t}\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tCascade.cascade(\n \t\t\t\tCascadingActions.REFRESH,\n \t\t\t\tCascadePoint.BEFORE_REFRESH,\n \t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e != null ) {\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n \t\t\t\tnew EvictVisitor( source ).process( object, persister );\n \t\t\t}\n \t\t}\n \n-\t\tif ( persister.hasCache() ) {\n+\t\tif ( persister.canWriteToCache() ) {\n \t\t\tObject previousVersion = null;\n \t\t\tif ( persister.isVersionPropertyGenerated() ) {\n \t\t\t\t// we need to grab the version value from the entity, otherwise\n \t\t\t\t// we have issues with generated-version entities that may have\n \t\t\t\t// multiple actions queued during the same flush\n \t\t\t\tpreviousVersion = persister.getVersion( object );\n \t\t\t}\n \t\t\tfinal EntityRegionAccessStrategy cache = persister.getCacheAccessStrategy();\n \t\t\tfinal Object ck = cache.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister,\n \t\t\t\t\tsource.getFactory(),\n \t\t\t\t\tsource.getTenantIdentifier()\n \t\t\t);\n \t\t\tfinal SoftLock lock = cache.lockItem( source, ck, previousVersion );\n \t\t\tsource.getActionQueue().registerProcess( new AfterTransactionCompletionProcess() {\n \t\t\t\t@Override\n \t\t\t\tpublic void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n \t\t\t\t\tcache.unlockItem( session, ck, lock );\n \t\t\t\t}\n \t\t\t} );\n \t\t\tcache.remove( source, ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source );\n \n \t\tString previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cc5a13a3f007fad6067945e0bb011d902ba9b6f4": {
			"type": "Ybodychange",
			"commitMessage": "HHH-11217 - SessionImpl.refresh() throws IllegalArgumentException, 'not an Entity' when using custom entity name\n",
			"commitDate": "2016-11-23, 7:52 AM",
			"commitName": "cc5a13a3f007fad6067945e0bb011d902ba9b6f4",
			"commitAuthor": "Andrea Boriero",
			"commitDateOld": "2016-05-06, 12:27 PM",
			"commitNameOld": "8c9152040c469a096cd78b18234a66c973d5e07e",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 200.85,
			"commitsBetweenForRepo": 579,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,132 +1,137 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n-\n-\t\tboolean isTransient = !source.contains( event.getObject() );\n+\t\tboolean isTransient;\n+\t\tif ( event.getEntityName() != null ) {\n+\t\t\tisTransient = !source.contains( event.getEntityName(), event.getObject() );\n+\t\t}\n+\t\telse {\n+\t\t\tisTransient = !source.contains( event.getObject() );\n+\t\t}\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tCascade.cascade(\n \t\t\t\tCascadingActions.REFRESH,\n \t\t\t\tCascadePoint.BEFORE_REFRESH,\n \t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e != null ) {\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n \t\t\t\tnew EvictVisitor( source ).process( object, persister );\n \t\t\t}\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tObject previousVersion = null;\n \t\t\tif ( persister.isVersionPropertyGenerated() ) {\n \t\t\t\t// we need to grab the version value from the entity, otherwise\n \t\t\t\t// we have issues with generated-version entities that may have\n \t\t\t\t// multiple actions queued during the same flush\n \t\t\t\tpreviousVersion = persister.getVersion( object );\n \t\t\t}\n \t\t\tfinal EntityRegionAccessStrategy cache = persister.getCacheAccessStrategy();\n \t\t\tfinal Object ck = cache.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister,\n \t\t\t\t\tsource.getFactory(),\n \t\t\t\t\tsource.getTenantIdentifier()\n \t\t\t);\n \t\t\tfinal SoftLock lock = cache.lockItem( source, ck, previousVersion );\n \t\t\tsource.getActionQueue().registerProcess( new AfterTransactionCompletionProcess() {\n \t\t\t\t@Override\n \t\t\t\tpublic void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n \t\t\t\t\tcache.unlockItem( session, ck, lock );\n \t\t\t\t}\n \t\t\t} );\n \t\t\tcache.remove( source, ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source );\n \n \t\tString previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had beforeQuery refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8c9152040c469a096cd78b18234a66c973d5e07e": {
			"type": "Ybodychange",
			"commitMessage": "HHH-10664 - Prep 5.2 feature branch\n",
			"commitDate": "2016-05-06, 12:27 PM",
			"commitName": "8c9152040c469a096cd78b18234a66c973d5e07e",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2016-05-06, 12:12 PM",
			"commitNameOld": "87e3f0fd28d7229b0a35032292ff32f542c22010",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 91,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,132 +1,132 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \n \t\tboolean isTransient = !source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tCascade.cascade(\n \t\t\t\tCascadingActions.REFRESH,\n \t\t\t\tCascadePoint.BEFORE_REFRESH,\n \t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e != null ) {\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n \t\t\t\tnew EvictVisitor( source ).process( object, persister );\n \t\t\t}\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tObject previousVersion = null;\n \t\t\tif ( persister.isVersionPropertyGenerated() ) {\n \t\t\t\t// we need to grab the version value from the entity, otherwise\n \t\t\t\t// we have issues with generated-version entities that may have\n \t\t\t\t// multiple actions queued during the same flush\n \t\t\t\tpreviousVersion = persister.getVersion( object );\n \t\t\t}\n \t\t\tfinal EntityRegionAccessStrategy cache = persister.getCacheAccessStrategy();\n \t\t\tfinal Object ck = cache.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister,\n \t\t\t\t\tsource.getFactory(),\n \t\t\t\t\tsource.getTenantIdentifier()\n \t\t\t);\n \t\t\tfinal SoftLock lock = cache.lockItem( source, ck, previousVersion );\n \t\t\tsource.getActionQueue().registerProcess( new AfterTransactionCompletionProcess() {\n \t\t\t\t@Override\n-\t\t\t\tpublic void doAfterTransactionCompletion(boolean success, SessionImplementor session) {\n+\t\t\t\tpublic void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n \t\t\t\t\tcache.unlockItem( session, ck, lock );\n \t\t\t\t}\n \t\t\t} );\n \t\t\tcache.remove( source, ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source );\n \n \t\tString previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had beforeQuery refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cbdab9d87f05b4255c7930a32fe995f87f0f3e0b": {
			"type": "Ybodychange",
			"commitMessage": "HHH-10649 - When 2LC enabled, flush session and then refresh entity cause dirty read in another session / transaction\n",
			"commitDate": "2016-04-06, 3:40 AM",
			"commitName": "cbdab9d87f05b4255c7930a32fe995f87f0f3e0b",
			"commitAuthor": "Zhenlei Huang",
			"commitDateOld": "2015-07-01, 4:14 PM",
			"commitNameOld": "cffe71aeba38977f526b5ce7e870609ea419471c",
			"commitAuthorOld": "Radim Vansa",
			"daysBetweenCommits": 279.48,
			"commitsBetweenForRepo": 728,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,118 +1,132 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \n \t\tboolean isTransient = !source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tCascade.cascade(\n \t\t\t\tCascadingActions.REFRESH,\n \t\t\t\tCascadePoint.BEFORE_REFRESH,\n \t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e != null ) {\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n \t\t\t\tnew EvictVisitor( source ).process( object, persister );\n \t\t\t}\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n+\t\t\tObject previousVersion = null;\n+\t\t\tif ( persister.isVersionPropertyGenerated() ) {\n+\t\t\t\t// we need to grab the version value from the entity, otherwise\n+\t\t\t\t// we have issues with generated-version entities that may have\n+\t\t\t\t// multiple actions queued during the same flush\n+\t\t\t\tpreviousVersion = persister.getVersion( object );\n+\t\t\t}\n \t\t\tfinal EntityRegionAccessStrategy cache = persister.getCacheAccessStrategy();\n-\t\t\tObject ck = cache.generateCacheKey(\n+\t\t\tfinal Object ck = cache.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister,\n \t\t\t\t\tsource.getFactory(),\n \t\t\t\t\tsource.getTenantIdentifier()\n \t\t\t);\n-\t\t\tcache.evict( ck );\n+\t\t\tfinal SoftLock lock = cache.lockItem( source, ck, previousVersion );\n+\t\t\tsource.getActionQueue().registerProcess( new AfterTransactionCompletionProcess() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void doAfterTransactionCompletion(boolean success, SessionImplementor session) {\n+\t\t\t\t\tcache.unlockItem( session, ck, lock );\n+\t\t\t\t}\n+\t\t\t} );\n+\t\t\tcache.remove( source, ck );\n \t\t}\n \n-\t\tevictCachedCollections( persister, id, source.getFactory() );\n+\t\tevictCachedCollections( persister, id, source );\n \n \t\tString previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cffe71aeba38977f526b5ce7e870609ea419471c": {
			"type": "Ybodychange",
			"commitMessage": "HHH-9840 Change all kinds of CacheKey contract to a raw Object\n\n* Replaced all CacheKey with Object\n* Because of statistics, added unwrap operation to all AccessStrategies\n",
			"commitDate": "2015-07-01, 4:14 PM",
			"commitName": "cffe71aeba38977f526b5ce7e870609ea419471c",
			"commitAuthor": "Radim Vansa",
			"commitDateOld": "2015-07-01, 1:42 PM",
			"commitNameOld": "16ae00a53a9c58c841eb1dea8eb36354d5f3ff0f",
			"commitAuthorOld": "Sanne Grinovero",
			"daysBetweenCommits": 0.11,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,118 +1,118 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \n \t\tboolean isTransient = !source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tCascade.cascade(\n \t\t\t\tCascadingActions.REFRESH,\n \t\t\t\tCascadePoint.BEFORE_REFRESH,\n \t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e != null ) {\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n \t\t\t\tnew EvictVisitor( source ).process( object, persister );\n \t\t\t}\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal EntityRegionAccessStrategy cache = persister.getCacheAccessStrategy();\n-\t\t\tEntityCacheKey ck = cache.generateCacheKey(\n+\t\t\tObject ck = cache.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister,\n \t\t\t\t\tsource.getFactory(),\n \t\t\t\t\tsource.getTenantIdentifier()\n \t\t\t);\n \t\t\tcache.evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"16ae00a53a9c58c841eb1dea8eb36354d5f3ff0f": {
			"type": "Ybodychange",
			"commitMessage": "HHH-9840 Allow 2nd level cache implementations to customize the various key implementations\n",
			"commitDate": "2015-07-01, 1:42 PM",
			"commitName": "16ae00a53a9c58c841eb1dea8eb36354d5f3ff0f",
			"commitAuthor": "Sanne Grinovero",
			"commitDateOld": "2015-05-18, 10:25 PM",
			"commitNameOld": "bd256e4783219f4a765219cf625bb658fcb5fde1",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 43.64,
			"commitsBetweenForRepo": 67,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,116 +1,118 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \n \t\tboolean isTransient = !source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tCascade.cascade(\n \t\t\t\tCascadingActions.REFRESH,\n \t\t\t\tCascadePoint.BEFORE_REFRESH,\n \t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e != null ) {\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n \t\t\t\tnew EvictVisitor( source ).process( object, persister );\n \t\t\t}\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n-\t\t\tfinal CacheKey ck = source.generateCacheKey(\n+\t\t\tfinal EntityRegionAccessStrategy cache = persister.getCacheAccessStrategy();\n+\t\t\tEntityCacheKey ck = cache.generateCacheKey(\n \t\t\t\t\tid,\n-\t\t\t\t\tpersister.getIdentifierType(),\n-\t\t\t\t\tpersister.getRootEntityName()\n+\t\t\t\t\tpersister,\n+\t\t\t\t\tsource.getFactory(),\n+\t\t\t\t\tsource.getTenantIdentifier()\n \t\t\t);\n-\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n+\t\t\tcache.evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fb15ee548ca1c8fb80f77497271931404f54c19e": {
			"type": "Ybodychange",
			"commitMessage": "HHH-9328 Avoids creation of Cascade objects at all\nby converting all methods of the Cascade class into\nstatic methods.\n",
			"commitDate": "2014-11-27, 12:43 PM",
			"commitName": "fb15ee548ca1c8fb80f77497271931404f54c19e",
			"commitAuthor": "Andrej Golovnin",
			"commitDateOld": "2013-11-23, 9:06 AM",
			"commitNameOld": "241868e1dd4e9b31a0d03d2e0de2b8684b4f80fc",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 369.15,
			"commitsBetweenForRepo": 357,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,113 +1,116 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \n \t\tboolean isTransient = !source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n-\t\tnew Cascade( CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source ).cascade(\n+\t\tCascade.cascade(\n+\t\t\t\tCascadingActions.REFRESH,\n+\t\t\t\tCascadePoint.BEFORE_REFRESH,\n+\t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e != null ) {\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n \t\t\t\tnew EvictVisitor( source ).process( object, persister );\n \t\t\t}\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck = source.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"241868e1dd4e9b31a0d03d2e0de2b8684b4f80fc": {
			"type": "Ybodychange",
			"commitMessage": "HHH-8741 - More checkstyle cleanups\n",
			"commitDate": "2013-11-23, 9:06 AM",
			"commitName": "241868e1dd4e9b31a0d03d2e0de2b8684b4f80fc",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2013-10-07, 1:20 PM",
			"commitNameOld": "4428464d096c6a1fff3023cb707a2384ab6c0ffb",
			"commitAuthorOld": "Scott Marlow",
			"daysBetweenCommits": 46.87,
			"commitsBetweenForRepo": 320,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,93 +1,113 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \n-\t\tboolean isTransient = ! source.contains( event.getObject() );\n+\t\tboolean isTransient = !source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n-\t\tif ( refreshedAlready.containsKey(object) ) {\n+\t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e == null ) {\n-\t\t\tpersister = source.getEntityPersister(event.getEntityName(), object); //refresh() does not pass an entityName\n+\t\t\tpersister = source.getEntityPersister(\n+\t\t\t\t\tevent.getEntityName(),\n+\t\t\t\t\tobject\n+\t\t\t); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n-\t\t\t\tLOG.tracev( \"Refreshing transient {0}\", MessageHelper.infoString( persister, id, source.getFactory() ) );\n+\t\t\t\tLOG.tracev(\n+\t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n+\t\t\t\t\t\tpersister,\n+\t\t\t\t\t\tid,\n+\t\t\t\t\t\tsource.getFactory()\n+\t\t\t\t)\n+\t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n-\t\t\tif ( source.getPersistenceContext().getEntry(key) != null ) {\n+\t\t\tif ( source.getPersistenceContext().getEntry( key ) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n-\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n-\t\t\t\t\t);\n+\t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n+\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n-\t\t\t\tLOG.tracev( \"Refreshing \", MessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory() ) );\n+\t\t\t\tLOG.tracev(\n+\t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n+\t\t\t\t\t\te.getPersister(),\n+\t\t\t\t\t\te.getId(),\n+\t\t\t\t\t\tsource.getFactory()\n+\t\t\t\t)\n+\t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n-\t\t\t\tthrow new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\" );\n+\t\t\t\tthrow new UnresolvableObjectException(\n+\t\t\t\t\t\te.getId(),\n+\t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n+\t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tnew Cascade( CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source ).cascade(\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e != null ) {\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n-\t\t\tsource.getPersistenceContext().removeEntity(key);\n-\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n+\t\t\tsource.getPersistenceContext().removeEntity( key );\n+\t\t\tif ( persister.hasCollections() ) {\n+\t\t\t\tnew EvictVisitor( source ).process( object, persister );\n+\t\t\t}\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck = source.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n-\t\t\tif ( ! persister.isMutable() ) {\n+\t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n-\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n+\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4428464d096c6a1fff3023cb707a2384ab6c0ffb": {
			"type": "Ybodychange",
			"commitMessage": "HHH-8593 EntityManager.refresh should throw EntityNotFoundException if the entity no longer exists in the database\n",
			"commitDate": "2013-10-07, 1:20 PM",
			"commitName": "4428464d096c6a1fff3023cb707a2384ab6c0ffb",
			"commitAuthor": "Scott Marlow",
			"commitDateOld": "2013-04-26, 11:30 AM",
			"commitNameOld": "fc02da1c12f6a7487b56e76cf817dc72da8314e6",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 164.08,
			"commitsBetweenForRepo": 376,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,93 +1,93 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \n \t\tboolean isTransient = ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(event.getEntityName(), object); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev( \"Refreshing transient {0}\", MessageHelper.infoString( persister, id, source.getFactory() ) );\n \t\t\t}\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev( \"Refreshing \", MessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory() ) );\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n-\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n+\t\t\t\tthrow new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tnew Cascade( CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source ).cascade(\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e != null ) {\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck = source.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n \t\t\tif ( ! persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fc02da1c12f6a7487b56e76cf817dc72da8314e6": {
			"type": "Ybodychange",
			"commitMessage": "HHH-8159 - Apply fixups indicated by analysis tools\n",
			"commitDate": "2013-04-26, 11:30 AM",
			"commitName": "fc02da1c12f6a7487b56e76cf817dc72da8314e6",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2012-08-16, 1:21 PM",
			"commitNameOld": "6b5a428b3fed930227ae6a17e3b876c07745d5a3",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 252.92,
			"commitsBetweenForRepo": 561,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,90 +1,93 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \n \t\tboolean isTransient = ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(event.getEntityName(), object); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev( \"Refreshing transient {0}\", MessageHelper.infoString( persister, id, source.getFactory() ) );\n \t\t\t}\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev( \"Refreshing \", MessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory() ) );\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n-\t\trefreshedAlready.put(object, object);\n-\t\tnew Cascade( CascadingActions.REFRESH, Cascade.BEFORE_REFRESH, source)\n-\t\t\t\t.cascade( persister, object, refreshedAlready );\n+\t\trefreshedAlready.put( object, object );\n+\t\tnew Cascade( CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source ).cascade(\n+\t\t\t\tpersister,\n+\t\t\t\tobject,\n+\t\t\t\trefreshedAlready\n+\t\t);\n \n \t\tif ( e != null ) {\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck = source.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n \t\t\tif ( ! persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6b5a428b3fed930227ae6a17e3b876c07745d5a3": {
			"type": "Ybodychange",
			"commitMessage": "HHH-7527 - OSGI manifests for hibernate-orm : clean up org.hibernate.engine.spi package duplication between hem and core\n",
			"commitDate": "2012-08-16, 1:21 PM",
			"commitName": "6b5a428b3fed930227ae6a17e3b876c07745d5a3",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2012-03-26, 2:17 AM",
			"commitNameOld": "d3b640cb755e20db84d5d528b03e1ae474bb68e7",
			"commitAuthorOld": "Strong Liu",
			"daysBetweenCommits": 143.46,
			"commitsBetweenForRepo": 263,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,90 +1,90 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \n \t\tboolean isTransient = ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(event.getEntityName(), object); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev( \"Refreshing transient {0}\", MessageHelper.infoString( persister, id, source.getFactory() ) );\n \t\t\t}\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev( \"Refreshing \", MessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory() ) );\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n-\t\tnew Cascade( CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n+\t\tnew Cascade( CascadingActions.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e != null ) {\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck = source.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n \t\t\tif ( ! persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"129c0f13482b99e2705f0e234b6bc0572a95c271": {
			"type": "Ybodychange",
			"commitMessage": "HHH-6732 more logging trace statements are missing guards against unneeded string creation\n",
			"commitDate": "2011-10-26, 4:24 PM",
			"commitName": "129c0f13482b99e2705f0e234b6bc0572a95c271",
			"commitAuthor": "Sanne Grinovero",
			"commitDateOld": "2011-10-24, 2:26 AM",
			"commitNameOld": "bdba5898c90ef7667e7c5df35e72d2e993e32556",
			"commitAuthorOld": "Strong Liu",
			"daysBetweenCommits": 2.58,
			"commitsBetweenForRepo": 26,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,88 +1,90 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \n \t\tboolean isTransient = ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n-            LOG.trace(\"Already refreshed\");\n+\t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(event.getEntityName(), object); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n-            if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing transient \"\n-                                                + MessageHelper.infoString(persister, id, source.getFactory()));\n+\t\t\tif ( LOG.isTraceEnabled() ) {\n+\t\t\t\tLOG.tracev( \"Refreshing transient {0}\", MessageHelper.infoString( persister, id, source.getFactory() ) );\n+\t\t\t}\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n-            if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing \"\n-                                                + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n+\t\t\tif ( LOG.isTraceEnabled() ) {\n+\t\t\t\tLOG.tracev( \"Refreshing \", MessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory() ) );\n+\t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade( CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e != null ) {\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck = source.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n \t\t\tif ( ! persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"625d781af1ec2ae0c03d3db5b4f4832a8c61d8e9": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4489 need method \"refresh(String entityName, Object obj)\"\n",
			"commitDate": "2011-05-31, 12:53 AM",
			"commitName": "625d781af1ec2ae0c03d3db5b4f4832a8c61d8e9",
			"commitAuthor": "Strong Liu",
			"commitDateOld": "2011-05-31, 12:53 AM",
			"commitNameOld": "eb5bc1609d28dc740a249e622850a3b3b15b5ace",
			"commitAuthorOld": "Strong Liu",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,88 +1,88 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \n \t\tboolean isTransient = ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n             LOG.trace(\"Already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e == null ) {\n-\t\t\tpersister = source.getEntityPersister(null, object); //refresh() does not pass an entityName\n+\t\t\tpersister = source.getEntityPersister(event.getEntityName(), object); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n             if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing transient \"\n                                                 + MessageHelper.infoString(persister, id, source.getFactory()));\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n             if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing \"\n                                                 + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade( CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e != null ) {\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck = source.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n \t\t\tif ( ! persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"eb5bc1609d28dc740a249e622850a3b3b15b5ace": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4489 need method \"refresh(String entityName, Object obj)\"\n",
			"commitDate": "2011-05-31, 12:53 AM",
			"commitName": "eb5bc1609d28dc740a249e622850a3b3b15b5ace",
			"commitAuthor": "Strong Liu",
			"commitDateOld": "2011-05-04, 5:20 PM",
			"commitNameOld": "4ee0d4237d9c5cb2d160a29bfc717dd9c2015173",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 26.31,
			"commitsBetweenForRepo": 108,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,88 +1,88 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \n \t\tboolean isTransient = ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n             LOG.trace(\"Already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(null, object); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n             if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing transient \"\n                                                 + MessageHelper.infoString(persister, id, source.getFactory()));\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n             if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing \"\n                                                 + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade( CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e != null ) {\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck = source.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n-\t\tString previousFetchProfile = source.getFetchProfile();\n-\t\tsource.setFetchProfile(\"refresh\");\n+\t\tString previousFetchProfile = source.getLoadQueryInfluencers().getInternalFetchProfile();\n+\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n \t\t\tif ( ! persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n-\t\tsource.setFetchProfile(previousFetchProfile);\n+\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4ee0d4237d9c5cb2d160a29bfc717dd9c2015173": {
			"type": "Yfilerename",
			"commitMessage": "HHH-6198 - Split org.hibernate.event package into api/spi/internal\n",
			"commitDate": "2011-05-04, 5:20 PM",
			"commitName": "4ee0d4237d9c5cb2d160a29bfc717dd9c2015173",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2011-05-04, 4:15 PM",
			"commitNameOld": "fb44ad936d8d54d311ecbaea1633683a8d809d04",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 0.05,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "hibernate-core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
				"newPath": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java"
			}
		},
		"47abaf12fa6be50e95b2a3b8b3d424611c873d66": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5697 - Support for multi-tenancy\n",
			"commitDate": "2011-03-26, 9:50 AM",
			"commitName": "47abaf12fa6be50e95b2a3b8b3d424611c873d66",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2011-03-26, 8:11 AM",
			"commitNameOld": "fe8c7183d172946a03818be2cec1c9c2fc819316",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 0.07,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,90 +1,88 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \n \t\tboolean isTransient = ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n             LOG.trace(\"Already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(null, object); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n             if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing transient \"\n                                                 + MessageHelper.infoString(persister, id, source.getFactory()));\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n             if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing \"\n                                                 + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e != null ) {\n \t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n-\t\t\tfinal CacheKey ck = new CacheKey(\n+\t\t\tfinal CacheKey ck = source.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n-\t\t\t\t\tpersister.getRootEntityName(),\n-\t\t\t\t\tsource.getEntityMode(),\n-\t\t\t\t\tsource.getFactory()\n+\t\t\t\t\tpersister.getRootEntityName()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile = source.getFetchProfile();\n \t\tsource.setFetchProfile(\"refresh\");\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n \t\t\tif ( ! persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.setFetchProfile(previousFetchProfile);\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fe8c7183d172946a03818be2cec1c9c2fc819316": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5697 - Support for multi-tenancy\n",
			"commitDate": "2011-03-26, 8:11 AM",
			"commitName": "fe8c7183d172946a03818be2cec1c9c2fc819316",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2011-03-08, 3:19 PM",
			"commitNameOld": "346418c4ef7b9a21dc659af43ff614d5db2343f9",
			"commitAuthorOld": "",
			"daysBetweenCommits": 17.66,
			"commitsBetweenForRepo": 82,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,90 +1,90 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \n \t\tboolean isTransient = ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n             LOG.trace(\"Already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(null, object); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n             if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing transient \"\n                                                 + MessageHelper.infoString(persister, id, source.getFactory()));\n-\t\t\tEntityKey key = new EntityKey( id, persister, source.getEntityMode() );\n+\t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n             if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing \"\n                                                 + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e != null ) {\n-\t\t\tEntityKey key = new EntityKey( id, persister, source.getEntityMode() );\n+\t\t\tfinal EntityKey key = source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck = new CacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName(),\n \t\t\t\t\tsource.getEntityMode(),\n \t\t\t\t\tsource.getFactory()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile = source.getFetchProfile();\n \t\tsource.setFetchProfile(\"refresh\");\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n \t\t\tif ( ! persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.setFetchProfile(previousFetchProfile);\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d": {
			"type": "Ybodychange",
			"commitMessage": "Give each project a single logger\n",
			"commitDate": "2011-01-18, 3:00 PM",
			"commitName": "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d",
			"commitAuthor": "JPAV",
			"commitDateOld": "2011-01-18, 2:35 PM",
			"commitNameOld": "a9b1425f3f07021dae556e710b2bdfdc3812661b",
			"commitAuthorOld": "JPAV",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,88 +1,90 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \n \t\tboolean isTransient = ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n-            LOG.alreadyRefreshed();\n+            LOG.trace(\"Already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(null, object); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n-            if (LOG.isTraceEnabled()) LOG.refreshingTransient(MessageHelper.infoString(persister, id, source.getFactory()));\n+            if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing transient \"\n+                                                + MessageHelper.infoString(persister, id, source.getFactory()));\n \t\t\tEntityKey key = new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n-            if (LOG.isTraceEnabled()) LOG.refreshing(MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n+            if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing \"\n+                                                + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e != null ) {\n \t\t\tEntityKey key = new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck = new CacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName(),\n \t\t\t\t\tsource.getEntityMode(),\n \t\t\t\t\tsource.getFactory()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile = source.getFetchProfile();\n \t\tsource.setFetchProfile(\"refresh\");\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n \t\t\tif ( ! persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.setFetchProfile(previousFetchProfile);\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a9b1425f3f07021dae556e710b2bdfdc3812661b": {
			"type": "Ybodychange",
			"commitMessage": "Replaced references to slf4j with references to new jboss.logging.Logger implementations and i18n'd where it was clear how to do so.\n",
			"commitDate": "2011-01-18, 2:35 PM",
			"commitName": "a9b1425f3f07021dae556e710b2bdfdc3812661b",
			"commitAuthor": "JPAV",
			"commitDateOld": "2010-10-11, 1:41 PM",
			"commitNameOld": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 99.08,
			"commitsBetweenForRepo": 193,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,98 +1,88 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n-\t\t\n+\n \t\tboolean isTransient = ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n-\t\t\tlog.trace(\"already refreshed\");\n+            LOG.alreadyRefreshed();\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n-\t\t\n+\n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(null, object); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n-\t\t\tif ( log.isTraceEnabled() ) {\n-\t\t\t\tlog.trace(\n-\t\t\t\t\t\t\"refreshing transient \" +\n-\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n-\t\t\t\t\t);\n-\t\t\t}\n+            if (LOG.isTraceEnabled()) LOG.refreshingTransient(MessageHelper.infoString(persister, id, source.getFactory()));\n \t\t\tEntityKey key = new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n-\t\t\tif ( log.isTraceEnabled() ) {\n-\t\t\t\tlog.trace(\n-\t\t\t\t\t\t\"refreshing \" +\n-\t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n-\t\t\t\t\t);\n-\t\t\t}\n+            if (LOG.isTraceEnabled()) LOG.refreshing(MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e != null ) {\n \t\t\tEntityKey key = new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck = new CacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName(),\n-\t\t\t\t\tsource.getEntityMode(), \n+\t\t\t\t\tsource.getEntityMode(),\n \t\t\t\t\tsource.getFactory()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n-\t\t\n+\n \t\tevictCachedCollections( persister, id, source.getFactory() );\n-\t\t\n+\n \t\tString previousFetchProfile = source.getFetchProfile();\n \t\tsource.setFetchProfile(\"refresh\");\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n \t\t\tif ( ! persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.setFetchProfile(previousFetchProfile);\n-\t\t\n+\n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"34c2839dccef33a8f3abb4eaf3192c1e1d9e1814": {
			"type": "Yfilerename",
			"commitMessage": "HHH-5616 - Switch to Gradle for builds\n",
			"commitDate": "2010-10-11, 1:41 PM",
			"commitName": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2010-10-11, 12:51 PM",
			"commitNameOld": "0bfe7869e41076fd0846ca7592740710876f2427",
			"commitAuthorOld": "Gail Badner",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
				"newPath": "hibernate-core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java"
			}
		},
		"14bdaec5e75bded557e8410d818a7b77308dd80b": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5207 : Unexpected exception occurs during refresh of a detached immutable entity\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@19451 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-05-10, 12:34 PM",
			"commitName": "14bdaec5e75bded557e8410d818a7b77308dd80b",
			"commitAuthor": "Gail Badner",
			"commitDateOld": "2010-02-08, 12:27 PM",
			"commitNameOld": "839e23458aa0c50e1dc0d8f1a1bed87dbff49f3b",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 90.96,
			"commitsBetweenForRepo": 285,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,92 +1,98 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \t\t\n \t\tboolean isTransient = ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n \t\t\tlog.trace(\"already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \t\t\n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(null, object); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing transient \" +\n \t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tEntityKey key = new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing \" +\n \t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e != null ) {\n \t\t\tEntityKey key = new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck = new CacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName(),\n \t\t\t\t\tsource.getEntityMode(), \n \t\t\t\t\tsource.getFactory()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \t\t\n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \t\t\n \t\tString previousFetchProfile = source.getFetchProfile();\n \t\tsource.setFetchProfile(\"refresh\");\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n-\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n+\t\t\tif ( ! persister.isMutable() ) {\n+\t\t\t\t// this is probably redundant; it should already be read-only\n+\t\t\t\tsource.setReadOnly( result, true );\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n+\t\t\t}\n \t\t}\n \t\tsource.setFetchProfile(previousFetchProfile);\n \t\t\n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"839e23458aa0c50e1dc0d8f1a1bed87dbff49f3b": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4704 - Pass session into EntityTuplizer#setIdentifier\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18733 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-02-08, 12:27 PM",
			"commitName": "839e23458aa0c50e1dc0d8f1a1bed87dbff49f3b",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2010-02-04, 11:25 PM",
			"commitNameOld": "c18a9306b9f8995331240b66c01fea304e01d06f",
			"commitAuthorOld": "Gail Badner",
			"daysBetweenCommits": 3.54,
			"commitsBetweenForRepo": 14,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,92 +1,92 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \t\t\n \t\tboolean isTransient = ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n \t\t\tlog.trace(\"already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \t\t\n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(null, object); //refresh() does not pass an entityName\n-\t\t\tid = persister.getIdentifier( object, event.getSession().getEntityMode() );\n+\t\t\tid = persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing transient \" +\n \t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tEntityKey key = new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing \" +\n \t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e != null ) {\n \t\t\tEntityKey key = new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck = new CacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName(),\n \t\t\t\t\tsource.getEntityMode(), \n \t\t\t\t\tsource.getFactory()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \t\t\n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \t\t\n \t\tString previousFetchProfile = source.getFetchProfile();\n \t\tsource.setFetchProfile(\"refresh\");\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result != null ) {\n \t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t}\n \t\tsource.setFetchProfile(previousFetchProfile);\n \t\t\n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c18a9306b9f8995331240b66c01fea304e01d06f": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4880 : EntityManager.refresh does not throw EntityNotFoundException for removed entity\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18700 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-02-04, 11:25 PM",
			"commitName": "c18a9306b9f8995331240b66c01fea304e01d06f",
			"commitAuthor": "Gail Badner",
			"commitDateOld": "2010-01-27, 2:26 AM",
			"commitNameOld": "b40cfb58dbe4606609c3fa2b1e5e210466c593df",
			"commitAuthorOld": "Gail Badner",
			"daysBetweenCommits": 8.87,
			"commitsBetweenForRepo": 35,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,90 +1,92 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \t\t\n \t\tboolean isTransient = ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n \t\t\tlog.trace(\"already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \t\t\n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(null, object); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession().getEntityMode() );\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing transient \" +\n \t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tEntityKey key = new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing \" +\n \t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e != null ) {\n \t\t\tEntityKey key = new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck = new CacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName(),\n \t\t\t\t\tsource.getEntityMode(), \n \t\t\t\t\tsource.getFactory()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \t\t\n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \t\t\n \t\tString previousFetchProfile = source.getFetchProfile();\n \t\tsource.setFetchProfile(\"refresh\");\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n-\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n+\t\tif ( result != null ) {\n+\t\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n+\t\t}\n \t\tsource.setFetchProfile(previousFetchProfile);\n \t\t\n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b40cfb58dbe4606609c3fa2b1e5e210466c593df": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4781 : Read-only entities changed to modifiable on refresh\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18643 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-01-27, 2:26 AM",
			"commitName": "b40cfb58dbe4606609c3fa2b1e5e210466c593df",
			"commitAuthor": "Gail Badner",
			"commitDateOld": "2009-11-24, 4:59 PM",
			"commitNameOld": "ceaea5a2a382e57fdded1ad717510d2e3e5bbf49",
			"commitAuthorOld": "Scott Marlow",
			"daysBetweenCommits": 63.39,
			"commitsBetweenForRepo": 262,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,81 +1,90 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \t\t\n-\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) return;\n+\t\tboolean isTransient = ! source.contains( event.getObject() );\n+\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n+\t\t\tif ( isTransient ) {\n+\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n \t\t\tlog.trace(\"already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \t\t\n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(null, object); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession().getEntityMode() );\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing transient \" +\n \t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tEntityKey key = new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing \" +\n \t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e != null ) {\n \t\t\tEntityKey key = new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck = new CacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName(),\n \t\t\t\t\tsource.getEntityMode(), \n \t\t\t\t\tsource.getFactory()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \t\t\n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \t\t\n \t\tString previousFetchProfile = source.getFetchProfile();\n \t\tsource.setFetchProfile(\"refresh\");\n \t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n+\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n+\t\t// If it was transient, then set it to the default for the source.\n+\t\tsource.setReadOnly( result, ( e == null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\tsource.setFetchProfile(previousFetchProfile);\n \t\t\n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ceaea5a2a382e57fdded1ad717510d2e3e5bbf49": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4546 add JPA 2.0 locking.  Introduce LockOptions as the wrapper and session.buildLockRequest() (replaces session.lock()).\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18053 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2009-11-24, 4:59 PM",
			"commitName": "ceaea5a2a382e57fdded1ad717510d2e3e5bbf49",
			"commitAuthor": "Scott Marlow",
			"commitDateOld": "2009-11-20, 7:51 AM",
			"commitNameOld": "35ca4c35635f26b9a86b260ad974ba7da429950b",
			"commitAuthorOld": "Scott Marlow",
			"daysBetweenCommits": 4.38,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,81 +1,81 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \t\t\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) return;\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n \t\t\tlog.trace(\"already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \t\t\n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(null, object); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession().getEntityMode() );\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing transient \" +\n \t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tEntityKey key = new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing \" +\n \t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e != null ) {\n \t\t\tEntityKey key = new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck = new CacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName(),\n \t\t\t\t\tsource.getEntityMode(), \n \t\t\t\t\tsource.getFactory()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \t\t\n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \t\t\n \t\tString previousFetchProfile = source.getFetchProfile();\n \t\tsource.setFetchProfile(\"refresh\");\n-\t\tObject result = persister.load( id, object, event.getLockRequest(), source );\n+\t\tObject result = persister.load( id, object, event.getLockOptions(), source );\n \t\tsource.setFetchProfile(previousFetchProfile);\n \t\t\n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"35ca4c35635f26b9a86b260ad974ba7da429950b": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4546 add JPA 2.0 locking.  Still need more LockRequest support in AbstractEntityPersister.getAppropriateLoader(), may need to refactor.\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18016 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2009-11-20, 7:51 AM",
			"commitName": "35ca4c35635f26b9a86b260ad974ba7da429950b",
			"commitAuthor": "Scott Marlow",
			"commitDateOld": "2008-07-30, 10:46 AM",
			"commitNameOld": "0d464c2be26dda9d44613dea80f3f32e2e9ef011",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 477.92,
			"commitsBetweenForRepo": 628,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,81 +1,81 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source = event.getSession();\n \t\t\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) return;\n \n \t\tfinal Object object = source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n \t\t\tlog.trace(\"already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e = source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \t\t\n \t\tif ( e == null ) {\n \t\t\tpersister = source.getEntityPersister(null, object); //refresh() does not pass an entityName\n \t\t\tid = persister.getIdentifier( object, event.getSession().getEntityMode() );\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing transient \" +\n \t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tEntityKey key = new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) != null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing \" +\n \t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister = e.getPersister();\n \t\t\tid = e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e != null ) {\n \t\t\tEntityKey key = new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck = new CacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName(),\n \t\t\t\t\tsource.getEntityMode(), \n \t\t\t\t\tsource.getFactory()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \t\t\n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \t\t\n \t\tString previousFetchProfile = source.getFetchProfile();\n \t\tsource.setFetchProfile(\"refresh\");\n-\t\tObject result = persister.load( id, object, event.getLockMode(), source );\n+\t\tObject result = persister.load( id, object, event.getLockRequest(), source );\n \t\tsource.setFetchProfile(previousFetchProfile);\n \t\t\n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a797998927e2cbba9ec34ca7dc31b42a192fa2f1": {
			"type": "Yfilerename",
			"commitMessage": "splitting code back out into individual modules (found better way to isolate documentation)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@12771 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2007-07-16, 9:15 PM",
			"commitName": "a797998927e2cbba9ec34ca7dc31b42a192fa2f1",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2007-07-15, 10:18 PM",
			"commitNameOld": "9fda5ffa294695f1a1a2e349232f64d80ef26250",
			"commitAuthorOld": "Diego Plentz",
			"daysBetweenCommits": 0.96,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "code/core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
				"newPath": "core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java"
			}
		},
		"d8d6d82e30960e0c255950eaf875ad48831b12b0": {
			"type": "Yintroduced",
			"commitMessage": "SVN layout migration for core/trunk\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@11722 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2007-06-29, 1:23 PM",
			"commitName": "d8d6d82e30960e0c255950eaf875ad48831b12b0",
			"commitAuthor": "Steve Ebersole"
		}
	},
	"sha": "8bd79b29cfa7b2d539a746dc356d60b66e1e596b"
}