{
	"repo": "https://github.com/javaparser/javaparser.git",
	"file": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
	"method": {
		"longName": "Difference::apply()",
		"startLine": 115,
		"methodName": "apply",
		"isStatic": false,
		"isAbstract": false,
		"visibility": ""
	},
	"history": {
		"2d3f5e219af9d1ba916f1dc21a6169a41a254632": {
			"type": "Ybodychange",
			"commitMessage": "built RemovedGroup into Difference class to be able to handle indentations better for removed elements\n",
			"commitDate": "2018-06-07, 2:54 PM",
			"commitName": "2d3f5e219af9d1ba916f1dc21a6169a41a254632",
			"commitAuthor": "Thomas Leu",
			"commitDateOld": "2018-06-07, 2:54 PM",
			"commitNameOld": "996b78486d0db86dece4457a7faa9b314dc3b847",
			"commitAuthorOld": "Thomas Leu",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,54 +1,30 @@\n     void apply() {\n         extractReshuffledDiffElements(diffElements);\n+        Map<Removed, RemovedGroup> removedGroups = combineRemovedElementsToRemovedGroups();\n \n         do {\n-            if (diffIndex < diffElements.size() && originalIndex >= originalElements.size()) {\n-                DifferenceElement diffElement = diffElements.get(diffIndex);\n-                if (diffElement instanceof Kept) {\n-                    Kept kept = (Kept) diffElement;\n+            boolean isLeftOverDiffElement = applyLeftOverDiffElements();\n+            boolean isLeftOverOriginalElement = applyLeftOverOriginalElements();\n \n-                    if (kept.isWhiteSpaceOrComment() || kept.isIndent() || kept.isUnindent()) {\n-                        diffIndex++;\n-                    } else {\n-                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n-                                + nodeText + \". Difference: \" + this);\n-                    }\n-                } else if (diffElement instanceof Added) {\n-                    Added addedElement = (Added) diffElement;\n-\n-                    nodeText.addElement(originalIndex, addedElement.toTextElement());\n-                    originalIndex++;\n-                    diffIndex++;\n-                } else {\n-                    throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n-                }\n-            } else if (diffIndex >= diffElements.size() && originalIndex < originalElements.size()) {\n-                TextElement originalElement = originalElements.get(originalIndex);\n-\n-                if (originalElement.isWhiteSpaceOrComment()) {\n-                    originalIndex++;\n-                } else {\n-                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n-                            + this + \" \" + originalElement);\n-                }\n-            } else {\n+            if (!isLeftOverDiffElement && !isLeftOverOriginalElement){\n                 DifferenceElement diffElement = diffElements.get(diffIndex);\n \n                 if (diffElement instanceof Added) {\n                     applyAddedDiffElement((Added) diffElement);\n                 } else {\n                     TextElement originalElement = originalElements.get(originalIndex);\n                     boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof Kept) {\n                         applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                     } else if (diffElement instanceof Removed) {\n-                        applyRemovedDiffElement((Removed) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n+                        Removed removed = (Removed) diffElement;\n+                        applyRemovedDiffElement(removedGroups.get(removed), removed, originalElement, originalElementIsChild, originalElementIsToken);\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex < diffElements.size() || originalIndex < originalElements.size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"996b78486d0db86dece4457a7faa9b314dc3b847": {
			"type": "Ybodychange",
			"commitMessage": "moved extraction of reshuffled diffElements out of the loop with the rest\n",
			"commitDate": "2018-06-07, 2:54 PM",
			"commitName": "996b78486d0db86dece4457a7faa9b314dc3b847",
			"commitAuthor": "Thomas Leu",
			"commitDateOld": "2018-05-29, 12:28 AM",
			"commitNameOld": "0a54807d59a9f39be0d222ae45697413d6765516",
			"commitAuthorOld": "Jooyung Han",
			"daysBetweenCommits": 9.6,
			"commitsBetweenForRepo": 16,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,54 +1,54 @@\n     void apply() {\n+        extractReshuffledDiffElements(diffElements);\n+\n         do {\n             if (diffIndex < diffElements.size() && originalIndex >= originalElements.size()) {\n                 DifferenceElement diffElement = diffElements.get(diffIndex);\n                 if (diffElement instanceof Kept) {\n                     Kept kept = (Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment() || kept.isIndent() || kept.isUnindent()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof Added) {\n                     Added addedElement = (Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= diffElements.size() && originalIndex < originalElements.size()) {\n                 TextElement originalElement = originalElements.get(originalIndex);\n \n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n                 DifferenceElement diffElement = diffElements.get(diffIndex);\n \n                 if (diffElement instanceof Added) {\n                     applyAddedDiffElement((Added) diffElement);\n                 } else {\n                     TextElement originalElement = originalElements.get(originalIndex);\n                     boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof Kept) {\n                         applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                     } else if (diffElement instanceof Removed) {\n                         applyRemovedDiffElement((Removed) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n-                    } else if (diffElement instanceof Reshuffled) {\n-                        applyReshuffledDiffElement((Reshuffled) diffElement);\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex < diffElements.size() || originalIndex < originalElements.size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0a54807d59a9f39be0d222ae45697413d6765516": {
			"type": "Ybodychange",
			"commitMessage": "Fix Difference.apply() with redundant Unindent\n\nRedundant unindent may be discarded just like other whitespaces\n",
			"commitDate": "2018-05-29, 12:28 AM",
			"commitName": "0a54807d59a9f39be0d222ae45697413d6765516",
			"commitAuthor": "Jooyung Han",
			"commitDateOld": "2018-05-19, 10:42 AM",
			"commitNameOld": "8718d4a587fe7951b4767c6bcc52d7979d9b8795",
			"commitAuthorOld": "Thomas Leu",
			"daysBetweenCommits": 9.57,
			"commitsBetweenForRepo": 20,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,54 +1,54 @@\n     void apply() {\n         do {\n             if (diffIndex < diffElements.size() && originalIndex >= originalElements.size()) {\n                 DifferenceElement diffElement = diffElements.get(diffIndex);\n                 if (diffElement instanceof Kept) {\n                     Kept kept = (Kept) diffElement;\n \n-                    if (kept.isWhiteSpaceOrComment()) {\n+                    if (kept.isWhiteSpaceOrComment() || kept.isIndent() || kept.isUnindent()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof Added) {\n                     Added addedElement = (Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= diffElements.size() && originalIndex < originalElements.size()) {\n                 TextElement originalElement = originalElements.get(originalIndex);\n \n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n                 DifferenceElement diffElement = diffElements.get(diffIndex);\n \n                 if (diffElement instanceof Added) {\n                     applyAddedDiffElement((Added) diffElement);\n                 } else {\n                     TextElement originalElement = originalElements.get(originalIndex);\n                     boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof Kept) {\n                         applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                     } else if (diffElement instanceof Removed) {\n                         applyRemovedDiffElement((Removed) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                     } else if (diffElement instanceof Reshuffled) {\n                         applyReshuffledDiffElement((Reshuffled) diffElement);\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex < diffElements.size() || originalIndex < originalElements.size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b7bd15d12e107c85e29912960f7b4e48aac4dc38": {
			"type": "Ybodychange",
			"commitMessage": "Reduced cognitive complexity by extracting some methods\n",
			"commitDate": "2018-05-18, 7:34 PM",
			"commitName": "b7bd15d12e107c85e29912960f7b4e48aac4dc38",
			"commitAuthor": "Thomas Leu",
			"commitDateOld": "2018-05-18, 7:23 PM",
			"commitNameOld": "c35fbac21da07f996f017169288b748764488c20",
			"commitAuthorOld": "Thomas Leu",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,294 +1,54 @@\n     void apply() {\n         do {\n             if (diffIndex < diffElements.size() && originalIndex >= originalElements.size()) {\n                 DifferenceElement diffElement = diffElements.get(diffIndex);\n                 if (diffElement instanceof Kept) {\n                     Kept kept = (Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof Added) {\n                     Added addedElement = (Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= diffElements.size() && originalIndex < originalElements.size()) {\n                 TextElement originalElement = originalElements.get(originalIndex);\n \n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n                 DifferenceElement diffElement = diffElements.get(diffIndex);\n \n                 if (diffElement instanceof Added) {\n-                    Added addedElement = (Added) diffElement;\n-\n-                    if (addedElement.isIndent()) {\n-                        for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n-                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n-                        }\n-                        addedIndentation = true;\n-                        diffIndex++;\n-                        continue;\n-                    }\n-                    if (addedElement.isUnindent()) {\n-                        for (int i = 0; i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty(); i++){\n-                            indentation.remove(indentation.size() - 1);\n-                        }\n-                        addedIndentation = false;\n-                        diffIndex++;\n-                        continue;\n-                    }\n-\n-                    TextElement addedTextElement = addedElement.toTextElement();\n-                    boolean used = false;\n-                    if (originalIndex > 0 && originalElements.get(originalIndex - 1).isNewline()) {\n-                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n-                            nodeText.addElement(originalIndex++, e);\n-                        }\n-                    } else if (isAfterLBrace(nodeText, originalIndex) && !isAReplacement(diffIndex)) {\n-                        if (addedTextElement.isNewline()) {\n-                            used = true;\n-                        }\n-                        nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n-                        // This remove the space in \"{ }\" when adding a new line\n-                        while (originalElements.get(originalIndex).isSpaceOrTab()) {\n-                            originalElements.remove(originalIndex);\n-                        }\n-                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n-                            nodeText.addElement(originalIndex++, e);\n-                        }\n-                        // Indentation is painful...\n-                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n-                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n-                        // not there, so when adding new elements we force it. However if the indentation has been\n-                        // inserted by us in this transformation we do not want to insert it again\n-                        if (!addedIndentation) {\n-                            for (TextElement e : indentationBlock()) {\n-                                nodeText.addElement(originalIndex++, e);\n-                            }\n-                        }\n-                    }\n-\n-                    if (!used) {\n-                        nodeText.addElement(originalIndex, addedTextElement);\n-                        originalIndex++;\n-                    }\n-\n-                    if (addedTextElement.isNewline()) {\n-                        boolean followedByUnindent = isFollowedByUnindent(diffElements, diffIndex);\n-                        originalIndex = adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* && !addedIndentation*/);\n-                    }\n-\n-                    diffIndex++;\n+                    applyAddedDiffElement((Added) diffElement);\n                 } else {\n                     TextElement originalElement = originalElements.get(originalIndex);\n                     boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof Kept) {\n-                        Kept kept = (Kept)diffElement;\n-\n-                        if (originalElement.isComment()) {\n-                            originalIndex++;\n-                        } else if (kept.isChild() && originalElementIsChild) {\n-                            diffIndex++;\n-                            originalIndex++;\n-                        } else if (kept.isChild() && originalElementIsToken) {\n-                            if (originalElement.isWhiteSpaceOrComment()) {\n-                                originalIndex++;\n-                            } else {\n-                                if (kept.isPrimitiveType()) {\n-                                    originalIndex++;\n-                                    diffIndex++;\n-                                } else {\n-                                    throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n-                                }\n-                            }\n-                        } else if (kept.isToken() && originalElementIsToken) {\n-                            TokenTextElement originalTextToken = (TokenTextElement) originalElement;\n-\n-                            if (kept.getTokenType() == originalTextToken.getTokenKind()) {\n-                                originalIndex++;\n-                                diffIndex++;\n-                            } else if (kept.isWhiteSpaceOrComment()) {\n-                                diffIndex++;\n-                            } else if (originalTextToken.isWhiteSpaceOrComment()) {\n-                                originalIndex++;\n-                            } else {\n-                                throw new UnsupportedOperationException(\"Csm token \" + kept.getElement() + \" NodeText TOKEN \" + originalTextToken);\n-                            }\n-                        } else if (kept.isWhiteSpace()) {\n-                            diffIndex++;\n-                        } else if (kept.isIndent()) {\n-                            diffIndex++;\n-                        } else if (kept.isUnindent()) {\n-                            // Nothing to do, beside considering indentation\n-                            diffIndex++;\n-                            for (int i = 0; i < STANDARD_INDENTATION_SIZE && originalIndex >= 1 && nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n-                                nodeText.removeElement(--originalIndex);\n-                            }\n-                        } else {\n-                            throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n-                        }\n+                        applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                     } else if (diffElement instanceof Removed) {\n-                        Removed removed = (Removed)diffElement;\n-\n-                        if (removed.isChild() && originalElementIsChild) {\n-                            ChildTextElement originalElementChild = (ChildTextElement)originalElement;\n-                            if (originalElementChild.isComment()) {\n-                                // We expected to remove a proper node but we found a comment in between.\n-                                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n-                                Comment comment = (Comment)originalElementChild.getChild();\n-                                if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(removed.getChild())) {\n-                                    nodeText.removeElement(originalIndex);\n-                                } else {\n-                                    originalIndex++;\n-                                }\n-                            } else {\n-                                nodeText.removeElement(originalIndex);\n-                                if (originalIndex < originalElements.size() && originalElements.get(originalIndex).isNewline()) {\n-                                    originalIndex = considerCleaningTheLine(nodeText, originalIndex);\n-                                } else {\n-                                    if (diffIndex + 1 >= diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added)) {\n-                                        originalIndex = considerEnforcingIndentation(nodeText, originalIndex);\n-                                    }\n-                                    // If in front we have one space and before also we had space let's drop one space\n-                                    if (originalElements.size() > originalIndex && originalIndex > 0) {\n-                                        if (originalElements.get(originalIndex).isWhiteSpace()\n-                                                && originalElements.get(originalIndex - 1).isWhiteSpace()) {\n-                                            // However we do not want to do that when we are about to adding or removing elements\n-                                            if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n-                                                originalElements.remove(originalIndex--);\n-                                            }\n-                                        }\n-                                    }\n-                                }\n-                                diffIndex++;\n-                            }\n-                        } else if (removed.isToken() && originalElementIsToken\n-                                && (removed.getTokenType() == ((TokenTextElement)originalElement).getTokenKind())) {\n-                            nodeText.removeElement(originalIndex);\n-                            diffIndex++;\n-                        } else if (originalElementIsToken && originalElement.isWhiteSpaceOrComment()) {\n-                            originalIndex++;\n-                        } else if (removed.isPrimitiveType()) {\n-                            if (isPrimitiveType(originalElement)) {\n-                                nodeText.removeElement(originalIndex);\n-                                diffIndex++;\n-                            } else {\n-                                throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n-                            }\n-                        } else if (removed.isWhiteSpace()) {\n-                            diffIndex++;\n-                        } else if (originalElement.isWhiteSpace()) {\n-                            originalIndex++;\n-                        } else {\n-                            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n-                        }\n+                        applyRemovedDiffElement((Removed) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                     } else if (diffElement instanceof Reshuffled) {\n-                        // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n-                        Reshuffled reshuffled = (Reshuffled)diffElement;\n-                        CsmMix elementsFromPreviousOrder = reshuffled.getPreviousOrder();\n-                        CsmMix elementsFromNextOrder = reshuffled.getNextOrder();\n-\n-                        // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n-                        Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n-\n-                        // We now find out which Node Text elements corresponds to the elements in the original CSM\n-                        List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n-\n-                        Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n-                        for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n-                            int value = nodeTextIndexOfPreviousElements.get(i);\n-                            if (value != -1) {\n-                                nodeTextIndexToPreviousCSMIndex.put(value, i);\n-                            }\n-                        }\n-                        int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n-\n-                        // Elements to be added at the end\n-                        List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n-                        List<CsmElement> nextOrderElements = elementsFromNextOrder.getElements();\n-\n-                        Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n-                        for (int ni = 0; ni< nextOrderElements.size(); ni++) {\n-                            // If it has a mapping, then it is kept\n-                            if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n-                                // Ok, it is something new. Where to put it? Let's see what is the first following\n-                                // element that has a mapping\n-                                int originalCsmIndex = -1;\n-                                for (int nj = ni + 1; nj< nextOrderElements.size() && originalCsmIndex==-1; nj++) {\n-                                    if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n-                                        originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n-                                        if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n-                                            elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n-                                        }\n-                                        elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n-                                    }\n-                                }\n-                                // it does not preceed anything, so it goes at the end\n-                                if (originalCsmIndex == -1) {\n-                                    elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n-                                }\n-                            }\n-                        }\n-\n-                        // We go over the original node text elements, in the order they appear in the NodeText.\n-                        // Considering an original node text element (ONE)\n-                        // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n-                        //   we find the correspond OCE (Original CSM Element)\n-                        // * we first add new elements that are marked to be added before OCE\n-                        // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n-                        //   otherwise we add a removed element\n-\n-                        diffElements.remove(diffIndex);\n-\n-                        int diffElIterator = diffIndex;\n-                        if (lastNodeTextIndex != -1) {\n-                            for (int ntIndex = originalIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n-\n-                                if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n-                                    int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n-                                    if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n-                                        for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n-                                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n-                                        }\n-                                    }\n-\n-                                    CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n-                                    boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n-                                    if (toBeKept) {\n-                                        diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n-                                    } else {\n-                                        diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n-                                    }\n-                                }\n-                                // else we have a simple node text element, without associated csm element, just keep ignore it\n-                            }\n-                        }\n-\n-                        // Finally we look for the remaining new elements that were not yet added and\n-                        // add all of them\n-                        for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n-                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n-                        }\n+                        applyReshuffledDiffElement((Reshuffled) diffElement);\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex < diffElements.size() || originalIndex < originalElements.size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c35fbac21da07f996f017169288b748764488c20": {
			"type": "Ybodychange",
			"commitMessage": "Changed local indentaton variables to fields\n",
			"commitDate": "2018-05-18, 7:23 PM",
			"commitName": "c35fbac21da07f996f017169288b748764488c20",
			"commitAuthor": "Thomas Leu",
			"commitDateOld": "2018-05-18, 7:15 PM",
			"commitNameOld": "a25f53f8871fd178b6791d1194d7358b55d1ba37",
			"commitAuthorOld": "Thomas Leu",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,297 +1,294 @@\n     void apply() {\n-        boolean addedIndentation = false;\n-        List<TokenTextElement> indentation = LexicalPreservingPrinter.findIndentation(node);\n-\n         do {\n             if (diffIndex < diffElements.size() && originalIndex >= originalElements.size()) {\n                 DifferenceElement diffElement = diffElements.get(diffIndex);\n                 if (diffElement instanceof Kept) {\n                     Kept kept = (Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof Added) {\n                     Added addedElement = (Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= diffElements.size() && originalIndex < originalElements.size()) {\n                 TextElement originalElement = originalElements.get(originalIndex);\n \n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n                 DifferenceElement diffElement = diffElements.get(diffIndex);\n \n                 if (diffElement instanceof Added) {\n                     Added addedElement = (Added) diffElement;\n \n                     if (addedElement.isIndent()) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement.isUnindent()) {\n-                        for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n+                        for (int i = 0; i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty(); i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n \n                     TextElement addedTextElement = addedElement.toTextElement();\n                     boolean used = false;\n                     if (originalIndex > 0 && originalElements.get(originalIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, originalIndex) && !isAReplacement(diffIndex)) {\n                         if (addedTextElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                             originalElements.remove(originalIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(originalIndex++, e);\n                             }\n                         }\n                     }\n \n                     if (!used) {\n                         nodeText.addElement(originalIndex, addedTextElement);\n                         originalIndex++;\n                     }\n \n                     if (addedTextElement.isNewline()) {\n                         boolean followedByUnindent = isFollowedByUnindent(diffElements, diffIndex);\n                         originalIndex = adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n \n                     diffIndex++;\n                 } else {\n                     TextElement originalElement = originalElements.get(originalIndex);\n                     boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof Kept) {\n                         Kept kept = (Kept)diffElement;\n \n                         if (originalElement.isComment()) {\n                             originalIndex++;\n                         } else if (kept.isChild() && originalElementIsChild) {\n                             diffIndex++;\n                             originalIndex++;\n                         } else if (kept.isChild() && originalElementIsToken) {\n                             if (originalElement.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 if (kept.isPrimitiveType()) {\n                                     originalIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                                 }\n                             }\n                         } else if (kept.isToken() && originalElementIsToken) {\n                             TokenTextElement originalTextToken = (TokenTextElement) originalElement;\n \n                             if (kept.getTokenType() == originalTextToken.getTokenKind()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else if (kept.isWhiteSpaceOrComment()) {\n                                 diffIndex++;\n                             } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"Csm token \" + kept.getElement() + \" NodeText TOKEN \" + originalTextToken);\n                             }\n                         } else if (kept.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (kept.isIndent()) {\n                             diffIndex++;\n                         } else if (kept.isUnindent()) {\n                             // Nothing to do, beside considering indentation\n                             diffIndex++;\n                             for (int i = 0; i < STANDARD_INDENTATION_SIZE && originalIndex >= 1 && nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                 nodeText.removeElement(--originalIndex);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof Removed) {\n                         Removed removed = (Removed)diffElement;\n \n                         if (removed.isChild() && originalElementIsChild) {\n                             ChildTextElement originalElementChild = (ChildTextElement)originalElement;\n                             if (originalElementChild.isComment()) {\n                                 // We expected to remove a proper node but we found a comment in between.\n                                 // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                 Comment comment = (Comment)originalElementChild.getChild();\n                                 if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(removed.getChild())) {\n                                     nodeText.removeElement(originalIndex);\n                                 } else {\n                                     originalIndex++;\n                                 }\n                             } else {\n                                 nodeText.removeElement(originalIndex);\n                                 if (originalIndex < originalElements.size() && originalElements.get(originalIndex).isNewline()) {\n                                     originalIndex = considerCleaningTheLine(nodeText, originalIndex);\n                                 } else {\n                                     if (diffIndex + 1 >= diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added)) {\n                                         originalIndex = considerEnforcingIndentation(nodeText, originalIndex);\n                                     }\n                                     // If in front we have one space and before also we had space let's drop one space\n                                     if (originalElements.size() > originalIndex && originalIndex > 0) {\n                                         if (originalElements.get(originalIndex).isWhiteSpace()\n                                                 && originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                             // However we do not want to do that when we are about to adding or removing elements\n                                             if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                                 originalElements.remove(originalIndex--);\n                                             }\n                                         }\n                                     }\n                                 }\n                                 diffIndex++;\n                             }\n                         } else if (removed.isToken() && originalElementIsToken\n                                 && (removed.getTokenType() == ((TokenTextElement)originalElement).getTokenKind())) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else if (originalElementIsToken && originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else if (removed.isPrimitiveType()) {\n                             if (isPrimitiveType(originalElement)) {\n                                 nodeText.removeElement(originalIndex);\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n                             }\n                         } else if (removed.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (originalElement.isWhiteSpace()) {\n                             originalIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof Reshuffled) {\n                         // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                         Reshuffled reshuffled = (Reshuffled)diffElement;\n                         CsmMix elementsFromPreviousOrder = reshuffled.getPreviousOrder();\n                         CsmMix elementsFromNextOrder = reshuffled.getNextOrder();\n \n                         // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                         Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n \n                         // We now find out which Node Text elements corresponds to the elements in the original CSM\n                         List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n \n                         Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                         for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                             int value = nodeTextIndexOfPreviousElements.get(i);\n                             if (value != -1) {\n                                 nodeTextIndexToPreviousCSMIndex.put(value, i);\n                             }\n                         }\n                         int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                         // Elements to be added at the end\n                         List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                         List<CsmElement> nextOrderElements = elementsFromNextOrder.getElements();\n \n                         Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                         for (int ni = 0; ni< nextOrderElements.size(); ni++) {\n                             // If it has a mapping, then it is kept\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                 // Ok, it is something new. Where to put it? Let's see what is the first following\n                                 // element that has a mapping\n                                 int originalCsmIndex = -1;\n                                 for (int nj = ni + 1; nj< nextOrderElements.size() && originalCsmIndex==-1; nj++) {\n                                     if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                         originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                         if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                             elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                         }\n                                         elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                     }\n                                 }\n                                 // it does not preceed anything, so it goes at the end\n                                 if (originalCsmIndex == -1) {\n                                     elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                 }\n                             }\n                         }\n \n                         // We go over the original node text elements, in the order they appear in the NodeText.\n                         // Considering an original node text element (ONE)\n                         // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                         //   we find the correspond OCE (Original CSM Element)\n                         // * we first add new elements that are marked to be added before OCE\n                         // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                         //   otherwise we add a removed element\n \n                         diffElements.remove(diffIndex);\n \n                         int diffElIterator = diffIndex;\n                         if (lastNodeTextIndex != -1) {\n                             for (int ntIndex = originalIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                                 if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                     int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                     if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                         for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                             diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                         }\n                                     }\n \n                                     CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                     boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                     if (toBeKept) {\n                                         diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                     } else {\n                                         diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                     }\n                                 }\n                                 // else we have a simple node text element, without associated csm element, just keep ignore it\n                             }\n                         }\n \n                         // Finally we look for the remaining new elements that were not yet added and\n                         // add all of them\n                         for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                             diffElements.add(diffElIterator++, new Added(elementToAdd));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex < diffElements.size() || originalIndex < originalElements.size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a25f53f8871fd178b6791d1194d7358b55d1ba37": {
			"type": "Ybodychange",
			"commitMessage": "Moved DifferenceElement classes to their own files\n",
			"commitDate": "2018-05-18, 7:15 PM",
			"commitName": "a25f53f8871fd178b6791d1194d7358b55d1ba37",
			"commitAuthor": "Thomas Leu",
			"commitDateOld": "2018-05-18, 6:49 PM",
			"commitNameOld": "29a9b8bcb552dc691cc57c85b8eb017092c960ad",
			"commitAuthorOld": "Thomas Leu",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,297 +1,297 @@\n     void apply() {\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = LexicalPreservingPrinter.findIndentation(node);\n \n         do {\n             if (diffIndex < diffElements.size() && originalIndex >= originalElements.size()) {\n-                DifferenceElementCalculator.DifferenceElement diffElement = diffElements.get(diffIndex);\n-                if (diffElement instanceof DifferenceElementCalculator.Kept) {\n-                    DifferenceElementCalculator.Kept kept = (DifferenceElementCalculator.Kept) diffElement;\n+                DifferenceElement diffElement = diffElements.get(diffIndex);\n+                if (diffElement instanceof Kept) {\n+                    Kept kept = (Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n-                } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n-                    DifferenceElementCalculator.Added addedElement = (DifferenceElementCalculator.Added) diffElement;\n+                } else if (diffElement instanceof Added) {\n+                    Added addedElement = (Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= diffElements.size() && originalIndex < originalElements.size()) {\n                 TextElement originalElement = originalElements.get(originalIndex);\n \n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n-                DifferenceElementCalculator.DifferenceElement diffElement = diffElements.get(diffIndex);\n+                DifferenceElement diffElement = diffElements.get(diffIndex);\n \n-                if (diffElement instanceof DifferenceElementCalculator.Added) {\n-                    DifferenceElementCalculator.Added addedElement = (DifferenceElementCalculator.Added) diffElement;\n+                if (diffElement instanceof Added) {\n+                    Added addedElement = (Added) diffElement;\n \n                     if (addedElement.isIndent()) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement.isUnindent()) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n \n                     TextElement addedTextElement = addedElement.toTextElement();\n                     boolean used = false;\n                     if (originalIndex > 0 && originalElements.get(originalIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, originalIndex) && !isAReplacement(diffIndex)) {\n                         if (addedTextElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                             originalElements.remove(originalIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(originalIndex++, e);\n                             }\n                         }\n                     }\n \n                     if (!used) {\n                         nodeText.addElement(originalIndex, addedTextElement);\n                         originalIndex++;\n                     }\n \n                     if (addedTextElement.isNewline()) {\n                         boolean followedByUnindent = isFollowedByUnindent(diffElements, diffIndex);\n                         originalIndex = adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n \n                     diffIndex++;\n                 } else {\n                     TextElement originalElement = originalElements.get(originalIndex);\n                     boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n \n-                    if (diffElement instanceof DifferenceElementCalculator.Kept) {\n-                        DifferenceElementCalculator.Kept kept = (DifferenceElementCalculator.Kept)diffElement;\n+                    if (diffElement instanceof Kept) {\n+                        Kept kept = (Kept)diffElement;\n \n                         if (originalElement.isComment()) {\n                             originalIndex++;\n                         } else if (kept.isChild() && originalElementIsChild) {\n                             diffIndex++;\n                             originalIndex++;\n                         } else if (kept.isChild() && originalElementIsToken) {\n                             if (originalElement.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 if (kept.isPrimitiveType()) {\n                                     originalIndex++;\n                                     diffIndex++;\n                                 } else {\n-                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n+                                    throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                                 }\n                             }\n                         } else if (kept.isToken() && originalElementIsToken) {\n                             TokenTextElement originalTextToken = (TokenTextElement) originalElement;\n \n                             if (kept.getTokenType() == originalTextToken.getTokenKind()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else if (kept.isWhiteSpaceOrComment()) {\n                                 diffIndex++;\n                             } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n-                                throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n+                                throw new UnsupportedOperationException(\"Csm token \" + kept.getElement() + \" NodeText TOKEN \" + originalTextToken);\n                             }\n                         } else if (kept.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (kept.isIndent()) {\n                             diffIndex++;\n                         } else if (kept.isUnindent()) {\n                             // Nothing to do, beside considering indentation\n                             diffIndex++;\n                             for (int i = 0; i < STANDARD_INDENTATION_SIZE && originalIndex >= 1 && nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                 nodeText.removeElement(--originalIndex);\n                             }\n                         } else {\n-                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n+                            throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                         }\n-                    } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n-                        DifferenceElementCalculator.Removed removed = (DifferenceElementCalculator.Removed)diffElement;\n+                    } else if (diffElement instanceof Removed) {\n+                        Removed removed = (Removed)diffElement;\n \n                         if (removed.isChild() && originalElementIsChild) {\n                             ChildTextElement originalElementChild = (ChildTextElement)originalElement;\n                             if (originalElementChild.isComment()) {\n                                 // We expected to remove a proper node but we found a comment in between.\n                                 // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                 Comment comment = (Comment)originalElementChild.getChild();\n                                 if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(removed.getChild())) {\n                                     nodeText.removeElement(originalIndex);\n                                 } else {\n                                     originalIndex++;\n                                 }\n                             } else {\n                                 nodeText.removeElement(originalIndex);\n                                 if (originalIndex < originalElements.size() && originalElements.get(originalIndex).isNewline()) {\n                                     originalIndex = considerCleaningTheLine(nodeText, originalIndex);\n                                 } else {\n-                                    if (diffIndex + 1 >= diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n+                                    if (diffIndex + 1 >= diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added)) {\n                                         originalIndex = considerEnforcingIndentation(nodeText, originalIndex);\n                                     }\n                                     // If in front we have one space and before also we had space let's drop one space\n                                     if (originalElements.size() > originalIndex && originalIndex > 0) {\n                                         if (originalElements.get(originalIndex).isWhiteSpace()\n                                                 && originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                             // However we do not want to do that when we are about to adding or removing elements\n-                                            if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n+                                            if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                                 originalElements.remove(originalIndex--);\n                                             }\n                                         }\n                                     }\n                                 }\n                                 diffIndex++;\n                             }\n                         } else if (removed.isToken() && originalElementIsToken\n                                 && (removed.getTokenType() == ((TokenTextElement)originalElement).getTokenKind())) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else if (originalElementIsToken && originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else if (removed.isPrimitiveType()) {\n                             if (isPrimitiveType(originalElement)) {\n                                 nodeText.removeElement(originalIndex);\n                                 diffIndex++;\n                             } else {\n-                                throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n+                                throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n                             }\n                         } else if (removed.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (originalElement.isWhiteSpace()) {\n                             originalIndex++;\n                         } else {\n-                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n+                            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n                         }\n-                    } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n+                    } else if (diffElement instanceof Reshuffled) {\n                         // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n-                        DifferenceElementCalculator.Reshuffled reshuffled = (DifferenceElementCalculator.Reshuffled)diffElement;\n-                        CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n-                        CsmMix elementsFromNextOrder = reshuffled.element;\n+                        Reshuffled reshuffled = (Reshuffled)diffElement;\n+                        CsmMix elementsFromPreviousOrder = reshuffled.getPreviousOrder();\n+                        CsmMix elementsFromNextOrder = reshuffled.getNextOrder();\n \n                         // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                         Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n \n                         // We now find out which Node Text elements corresponds to the elements in the original CSM\n                         List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n \n                         Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                         for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                             int value = nodeTextIndexOfPreviousElements.get(i);\n                             if (value != -1) {\n                                 nodeTextIndexToPreviousCSMIndex.put(value, i);\n                             }\n                         }\n                         int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                         // Elements to be added at the end\n                         List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                         List<CsmElement> nextOrderElements = elementsFromNextOrder.getElements();\n \n                         Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                         for (int ni = 0; ni< nextOrderElements.size(); ni++) {\n                             // If it has a mapping, then it is kept\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                 // Ok, it is something new. Where to put it? Let's see what is the first following\n                                 // element that has a mapping\n                                 int originalCsmIndex = -1;\n                                 for (int nj = ni + 1; nj< nextOrderElements.size() && originalCsmIndex==-1; nj++) {\n                                     if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                         originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                         if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                             elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                         }\n                                         elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                     }\n                                 }\n                                 // it does not preceed anything, so it goes at the end\n                                 if (originalCsmIndex == -1) {\n                                     elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                 }\n                             }\n                         }\n \n                         // We go over the original node text elements, in the order they appear in the NodeText.\n                         // Considering an original node text element (ONE)\n                         // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                         //   we find the correspond OCE (Original CSM Element)\n                         // * we first add new elements that are marked to be added before OCE\n                         // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                         //   otherwise we add a removed element\n \n                         diffElements.remove(diffIndex);\n \n                         int diffElIterator = diffIndex;\n                         if (lastNodeTextIndex != -1) {\n                             for (int ntIndex = originalIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                                 if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                     int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                     if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                         for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n-                                            diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n+                                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                         }\n                                     }\n \n                                     CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                     boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                     if (toBeKept) {\n-                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n+                                        diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                     } else {\n-                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n+                                        diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                     }\n                                 }\n                                 // else we have a simple node text element, without associated csm element, just keep ignore it\n                             }\n                         }\n \n                         // Finally we look for the remaining new elements that were not yet added and\n                         // add all of them\n                         for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n-                            diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n+                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex < diffElements.size() || originalIndex < originalElements.size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"29a9b8bcb552dc691cc57c85b8eb017092c960ad": {
			"type": "Ybodychange",
			"commitMessage": "Changed some local variables to instance variables\n",
			"commitDate": "2018-05-18, 6:49 PM",
			"commitName": "29a9b8bcb552dc691cc57c85b8eb017092c960ad",
			"commitAuthor": "Thomas Leu",
			"commitDateOld": "2018-05-18, 6:42 PM",
			"commitNameOld": "04f28d4024daa5798f3c627170bfe2a96bce8e55",
			"commitAuthorOld": "Thomas Leu",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,304 +1,297 @@\n     void apply() {\n-        if (nodeText == null) {\n-            throw new NullPointerException();\n-        }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = LexicalPreservingPrinter.findIndentation(node);\n \n-        List<TextElement> originalElements = nodeText.getElements();\n-        int originalIndex = 0;\n-\n-        int diffIndex = 0;\n         do {\n             if (diffIndex < diffElements.size() && originalIndex >= originalElements.size()) {\n                 DifferenceElementCalculator.DifferenceElement diffElement = diffElements.get(diffIndex);\n                 if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                     DifferenceElementCalculator.Kept kept = (DifferenceElementCalculator.Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                     DifferenceElementCalculator.Added addedElement = (DifferenceElementCalculator.Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= diffElements.size() && originalIndex < originalElements.size()) {\n                 TextElement originalElement = originalElements.get(originalIndex);\n \n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n                 DifferenceElementCalculator.DifferenceElement diffElement = diffElements.get(diffIndex);\n \n                 if (diffElement instanceof DifferenceElementCalculator.Added) {\n                     DifferenceElementCalculator.Added addedElement = (DifferenceElementCalculator.Added) diffElement;\n \n                     if (addedElement.isIndent()) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement.isUnindent()) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n \n                     TextElement addedTextElement = addedElement.toTextElement();\n                     boolean used = false;\n                     if (originalIndex > 0 && originalElements.get(originalIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, originalIndex) && !isAReplacement(diffIndex)) {\n                         if (addedTextElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                             originalElements.remove(originalIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(originalIndex++, e);\n                             }\n                         }\n                     }\n \n                     if (!used) {\n                         nodeText.addElement(originalIndex, addedTextElement);\n                         originalIndex++;\n                     }\n \n                     if (addedTextElement.isNewline()) {\n                         boolean followedByUnindent = isFollowedByUnindent(diffElements, diffIndex);\n                         originalIndex = adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n \n                     diffIndex++;\n                 } else {\n                     TextElement originalElement = originalElements.get(originalIndex);\n                     boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                         DifferenceElementCalculator.Kept kept = (DifferenceElementCalculator.Kept)diffElement;\n \n                         if (originalElement.isComment()) {\n                             originalIndex++;\n                         } else if (kept.isChild() && originalElementIsChild) {\n                             diffIndex++;\n                             originalIndex++;\n                         } else if (kept.isChild() && originalElementIsToken) {\n                             if (originalElement.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 if (kept.isPrimitiveType()) {\n                                     originalIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                                 }\n                             }\n                         } else if (kept.isToken() && originalElementIsToken) {\n                             TokenTextElement originalTextToken = (TokenTextElement) originalElement;\n \n                             if (kept.getTokenType() == originalTextToken.getTokenKind()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else if (kept.isWhiteSpaceOrComment()) {\n                                 diffIndex++;\n                             } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                             }\n                         } else if (kept.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (kept.isIndent()) {\n                             diffIndex++;\n                         } else if (kept.isUnindent()) {\n                             // Nothing to do, beside considering indentation\n                             diffIndex++;\n                             for (int i = 0; i < STANDARD_INDENTATION_SIZE && originalIndex >= 1 && nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                 nodeText.removeElement(--originalIndex);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                         DifferenceElementCalculator.Removed removed = (DifferenceElementCalculator.Removed)diffElement;\n \n                         if (removed.isChild() && originalElementIsChild) {\n                             ChildTextElement originalElementChild = (ChildTextElement)originalElement;\n                             if (originalElementChild.isComment()) {\n                                 // We expected to remove a proper node but we found a comment in between.\n                                 // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                 Comment comment = (Comment)originalElementChild.getChild();\n                                 if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(removed.getChild())) {\n                                     nodeText.removeElement(originalIndex);\n                                 } else {\n                                     originalIndex++;\n                                 }\n                             } else {\n                                 nodeText.removeElement(originalIndex);\n                                 if (originalIndex < originalElements.size() && originalElements.get(originalIndex).isNewline()) {\n                                     originalIndex = considerCleaningTheLine(nodeText, originalIndex);\n                                 } else {\n                                     if (diffIndex + 1 >= diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                         originalIndex = considerEnforcingIndentation(nodeText, originalIndex);\n                                     }\n                                     // If in front we have one space and before also we had space let's drop one space\n                                     if (originalElements.size() > originalIndex && originalIndex > 0) {\n                                         if (originalElements.get(originalIndex).isWhiteSpace()\n                                                 && originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                             // However we do not want to do that when we are about to adding or removing elements\n                                             if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                                 originalElements.remove(originalIndex--);\n                                             }\n                                         }\n                                     }\n                                 }\n                                 diffIndex++;\n                             }\n                         } else if (removed.isToken() && originalElementIsToken\n                                 && (removed.getTokenType() == ((TokenTextElement)originalElement).getTokenKind())) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else if (originalElementIsToken && originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else if (removed.isPrimitiveType()) {\n                             if (isPrimitiveType(originalElement)) {\n                                 nodeText.removeElement(originalIndex);\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                             }\n                         } else if (removed.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (originalElement.isWhiteSpace()) {\n                             originalIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                         // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                         DifferenceElementCalculator.Reshuffled reshuffled = (DifferenceElementCalculator.Reshuffled)diffElement;\n                         CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n                         CsmMix elementsFromNextOrder = reshuffled.element;\n \n                         // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                         Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n \n                         // We now find out which Node Text elements corresponds to the elements in the original CSM\n                         List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n \n                         Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                         for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                             int value = nodeTextIndexOfPreviousElements.get(i);\n                             if (value != -1) {\n                                 nodeTextIndexToPreviousCSMIndex.put(value, i);\n                             }\n                         }\n                         int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                         // Elements to be added at the end\n                         List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                         List<CsmElement> nextOrderElements = elementsFromNextOrder.getElements();\n \n                         Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                         for (int ni = 0; ni< nextOrderElements.size(); ni++) {\n                             // If it has a mapping, then it is kept\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                 // Ok, it is something new. Where to put it? Let's see what is the first following\n                                 // element that has a mapping\n                                 int originalCsmIndex = -1;\n                                 for (int nj = ni + 1; nj< nextOrderElements.size() && originalCsmIndex==-1; nj++) {\n                                     if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                         originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                         if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                             elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                         }\n                                         elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                     }\n                                 }\n                                 // it does not preceed anything, so it goes at the end\n                                 if (originalCsmIndex == -1) {\n                                     elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                 }\n                             }\n                         }\n \n                         // We go over the original node text elements, in the order they appear in the NodeText.\n                         // Considering an original node text element (ONE)\n                         // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                         //   we find the correspond OCE (Original CSM Element)\n                         // * we first add new elements that are marked to be added before OCE\n                         // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                         //   otherwise we add a removed element\n \n                         diffElements.remove(diffIndex);\n \n                         int diffElIterator = diffIndex;\n                         if (lastNodeTextIndex != -1) {\n                             for (int ntIndex = originalIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                                 if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                     int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                     if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                         for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                             diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                         }\n                                     }\n \n                                     CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                     boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                     if (toBeKept) {\n                                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                     } else {\n                                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                     }\n                                 }\n                                 // else we have a simple node text element, without associated csm element, just keep ignore it\n                             }\n                         }\n \n                         // Finally we look for the remaining new elements that were not yet added and\n                         // add all of them\n                         for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                             diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex < diffElements.size() || originalIndex < originalElements.size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"04f28d4024daa5798f3c627170bfe2a96bce8e55": {
			"type": "Ybodychange",
			"commitMessage": "Removed getElements method\n",
			"commitDate": "2018-05-18, 6:42 PM",
			"commitName": "04f28d4024daa5798f3c627170bfe2a96bce8e55",
			"commitAuthor": "Thomas Leu",
			"commitDateOld": "2018-05-18, 6:36 PM",
			"commitNameOld": "b9976c5e33bf1419231e3a5ef8392d18da1e1b0c",
			"commitAuthorOld": "Thomas Leu",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,305 +1,304 @@\n     void apply() {\n-        if (this.nodeText == null) {\n+        if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n-        List<TokenTextElement> indentation = LexicalPreservingPrinter.findIndentation(this.node);\n+        List<TokenTextElement> indentation = LexicalPreservingPrinter.findIndentation(node);\n \n         List<TextElement> originalElements = nodeText.getElements();\n         int originalIndex = 0;\n \n-        List<DifferenceElementCalculator.DifferenceElement> diffElements = getElements();\n         int diffIndex = 0;\n         do {\n             if (diffIndex < diffElements.size() && originalIndex >= originalElements.size()) {\n                 DifferenceElementCalculator.DifferenceElement diffElement = diffElements.get(diffIndex);\n                 if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                     DifferenceElementCalculator.Kept kept = (DifferenceElementCalculator.Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                     DifferenceElementCalculator.Added addedElement = (DifferenceElementCalculator.Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= diffElements.size() && originalIndex < originalElements.size()) {\n                 TextElement originalElement = originalElements.get(originalIndex);\n \n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n                 DifferenceElementCalculator.DifferenceElement diffElement = diffElements.get(diffIndex);\n \n                 if (diffElement instanceof DifferenceElementCalculator.Added) {\n                     DifferenceElementCalculator.Added addedElement = (DifferenceElementCalculator.Added) diffElement;\n \n                     if (addedElement.isIndent()) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement.isUnindent()) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n \n                     TextElement addedTextElement = addedElement.toTextElement();\n                     boolean used = false;\n                     if (originalIndex > 0 && originalElements.get(originalIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, originalIndex) && !isAReplacement(diffIndex)) {\n                         if (addedTextElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                             originalElements.remove(originalIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(originalIndex++, e);\n                             }\n                         }\n                     }\n \n                     if (!used) {\n                         nodeText.addElement(originalIndex, addedTextElement);\n                         originalIndex++;\n                     }\n \n                     if (addedTextElement.isNewline()) {\n                         boolean followedByUnindent = isFollowedByUnindent(diffElements, diffIndex);\n                         originalIndex = adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n \n                     diffIndex++;\n                 } else {\n                     TextElement originalElement = originalElements.get(originalIndex);\n                     boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                         DifferenceElementCalculator.Kept kept = (DifferenceElementCalculator.Kept)diffElement;\n \n                         if (originalElement.isComment()) {\n                             originalIndex++;\n                         } else if (kept.isChild() && originalElementIsChild) {\n                             diffIndex++;\n                             originalIndex++;\n                         } else if (kept.isChild() && originalElementIsToken) {\n                             if (originalElement.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 if (kept.isPrimitiveType()) {\n                                     originalIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                                 }\n                             }\n                         } else if (kept.isToken() && originalElementIsToken) {\n                             TokenTextElement originalTextToken = (TokenTextElement) originalElement;\n \n                             if (kept.getTokenType() == originalTextToken.getTokenKind()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else if (kept.isWhiteSpaceOrComment()) {\n                                 diffIndex++;\n                             } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                             }\n                         } else if (kept.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (kept.isIndent()) {\n                             diffIndex++;\n                         } else if (kept.isUnindent()) {\n                             // Nothing to do, beside considering indentation\n                             diffIndex++;\n                             for (int i = 0; i < STANDARD_INDENTATION_SIZE && originalIndex >= 1 && nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                 nodeText.removeElement(--originalIndex);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                         DifferenceElementCalculator.Removed removed = (DifferenceElementCalculator.Removed)diffElement;\n \n                         if (removed.isChild() && originalElementIsChild) {\n                             ChildTextElement originalElementChild = (ChildTextElement)originalElement;\n                             if (originalElementChild.isComment()) {\n                                 // We expected to remove a proper node but we found a comment in between.\n                                 // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                 Comment comment = (Comment)originalElementChild.getChild();\n                                 if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(removed.getChild())) {\n                                     nodeText.removeElement(originalIndex);\n                                 } else {\n                                     originalIndex++;\n                                 }\n                             } else {\n                                 nodeText.removeElement(originalIndex);\n                                 if (originalIndex < originalElements.size() && originalElements.get(originalIndex).isNewline()) {\n                                     originalIndex = considerCleaningTheLine(nodeText, originalIndex);\n                                 } else {\n-                                    if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n+                                    if (diffIndex + 1 >= diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                         originalIndex = considerEnforcingIndentation(nodeText, originalIndex);\n                                     }\n                                     // If in front we have one space and before also we had space let's drop one space\n                                     if (originalElements.size() > originalIndex && originalIndex > 0) {\n                                         if (originalElements.get(originalIndex).isWhiteSpace()\n                                                 && originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                             // However we do not want to do that when we are about to adding or removing elements\n                                             if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                                 originalElements.remove(originalIndex--);\n                                             }\n                                         }\n                                     }\n                                 }\n                                 diffIndex++;\n                             }\n                         } else if (removed.isToken() && originalElementIsToken\n                                 && (removed.getTokenType() == ((TokenTextElement)originalElement).getTokenKind())) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else if (originalElementIsToken && originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else if (removed.isPrimitiveType()) {\n                             if (isPrimitiveType(originalElement)) {\n                                 nodeText.removeElement(originalIndex);\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                             }\n                         } else if (removed.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (originalElement.isWhiteSpace()) {\n                             originalIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                         // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                         DifferenceElementCalculator.Reshuffled reshuffled = (DifferenceElementCalculator.Reshuffled)diffElement;\n                         CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n                         CsmMix elementsFromNextOrder = reshuffled.element;\n \n                         // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                         Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n \n                         // We now find out which Node Text elements corresponds to the elements in the original CSM\n                         List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n \n                         Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                         for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                             int value = nodeTextIndexOfPreviousElements.get(i);\n                             if (value != -1) {\n                                 nodeTextIndexToPreviousCSMIndex.put(value, i);\n                             }\n                         }\n                         int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                         // Elements to be added at the end\n                         List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                         List<CsmElement> nextOrderElements = elementsFromNextOrder.getElements();\n \n                         Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                         for (int ni = 0; ni< nextOrderElements.size(); ni++) {\n                             // If it has a mapping, then it is kept\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                 // Ok, it is something new. Where to put it? Let's see what is the first following\n                                 // element that has a mapping\n                                 int originalCsmIndex = -1;\n                                 for (int nj = ni + 1; nj< nextOrderElements.size() && originalCsmIndex==-1; nj++) {\n                                     if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                         originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                         if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                             elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                         }\n                                         elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                     }\n                                 }\n                                 // it does not preceed anything, so it goes at the end\n                                 if (originalCsmIndex == -1) {\n                                     elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                 }\n                             }\n                         }\n \n                         // We go over the original node text elements, in the order they appear in the NodeText.\n                         // Considering an original node text element (ONE)\n                         // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                         //   we find the correspond OCE (Original CSM Element)\n                         // * we first add new elements that are marked to be added before OCE\n                         // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                         //   otherwise we add a removed element\n \n                         diffElements.remove(diffIndex);\n \n                         int diffElIterator = diffIndex;\n                         if (lastNodeTextIndex != -1) {\n                             for (int ntIndex = originalIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                                 if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                     int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                     if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                         for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                             diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                         }\n                                     }\n \n                                     CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                     boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                     if (toBeKept) {\n                                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                     } else {\n                                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                     }\n                                 }\n                                 // else we have a simple node text element, without associated csm element, just keep ignore it\n                             }\n                         }\n \n                         // Finally we look for the remaining new elements that were not yet added and\n                         // add all of them\n                         for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                             diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex < diffElements.size() || originalIndex < originalElements.size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b9976c5e33bf1419231e3a5ef8392d18da1e1b0c": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Moved method parameters from Difference.apply to its constructor as instance variables\n",
			"commitDate": "2018-05-18, 6:36 PM",
			"commitName": "b9976c5e33bf1419231e3a5ef8392d18da1e1b0c",
			"commitAuthor": "Thomas Leu",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Moved method parameters from Difference.apply to its constructor as instance variables\n",
					"commitDate": "2018-05-18, 6:36 PM",
					"commitName": "b9976c5e33bf1419231e3a5ef8392d18da1e1b0c",
					"commitAuthor": "Thomas Leu",
					"commitDateOld": "2018-05-18, 5:51 PM",
					"commitNameOld": "40f6fef078275d3ca43f02918200a2d6076fef9d",
					"commitAuthorOld": "Thomas Leu",
					"daysBetweenCommits": 0.03,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,305 +1,305 @@\n-    void apply(NodeText nodeText, Node node) {\n-        if (nodeText == null) {\n+    void apply() {\n+        if (this.nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n-        List<TokenTextElement> indentation = LexicalPreservingPrinter.findIndentation(node);\n+        List<TokenTextElement> indentation = LexicalPreservingPrinter.findIndentation(this.node);\n \n         List<TextElement> originalElements = nodeText.getElements();\n         int originalIndex = 0;\n \n         List<DifferenceElementCalculator.DifferenceElement> diffElements = getElements();\n         int diffIndex = 0;\n         do {\n             if (diffIndex < diffElements.size() && originalIndex >= originalElements.size()) {\n                 DifferenceElementCalculator.DifferenceElement diffElement = diffElements.get(diffIndex);\n                 if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                     DifferenceElementCalculator.Kept kept = (DifferenceElementCalculator.Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                     DifferenceElementCalculator.Added addedElement = (DifferenceElementCalculator.Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= diffElements.size() && originalIndex < originalElements.size()) {\n                 TextElement originalElement = originalElements.get(originalIndex);\n \n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n                 DifferenceElementCalculator.DifferenceElement diffElement = diffElements.get(diffIndex);\n \n                 if (diffElement instanceof DifferenceElementCalculator.Added) {\n                     DifferenceElementCalculator.Added addedElement = (DifferenceElementCalculator.Added) diffElement;\n \n                     if (addedElement.isIndent()) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement.isUnindent()) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n \n                     TextElement addedTextElement = addedElement.toTextElement();\n                     boolean used = false;\n                     if (originalIndex > 0 && originalElements.get(originalIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, originalIndex) && !isAReplacement(diffIndex)) {\n                         if (addedTextElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                             originalElements.remove(originalIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(originalIndex++, e);\n                             }\n                         }\n                     }\n \n                     if (!used) {\n                         nodeText.addElement(originalIndex, addedTextElement);\n                         originalIndex++;\n                     }\n \n                     if (addedTextElement.isNewline()) {\n                         boolean followedByUnindent = isFollowedByUnindent(diffElements, diffIndex);\n                         originalIndex = adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n \n                     diffIndex++;\n                 } else {\n                     TextElement originalElement = originalElements.get(originalIndex);\n                     boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                         DifferenceElementCalculator.Kept kept = (DifferenceElementCalculator.Kept)diffElement;\n \n                         if (originalElement.isComment()) {\n                             originalIndex++;\n                         } else if (kept.isChild() && originalElementIsChild) {\n                             diffIndex++;\n                             originalIndex++;\n                         } else if (kept.isChild() && originalElementIsToken) {\n                             if (originalElement.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 if (kept.isPrimitiveType()) {\n                                     originalIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                                 }\n                             }\n                         } else if (kept.isToken() && originalElementIsToken) {\n                             TokenTextElement originalTextToken = (TokenTextElement) originalElement;\n \n                             if (kept.getTokenType() == originalTextToken.getTokenKind()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else if (kept.isWhiteSpaceOrComment()) {\n                                 diffIndex++;\n                             } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                             }\n                         } else if (kept.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (kept.isIndent()) {\n                             diffIndex++;\n                         } else if (kept.isUnindent()) {\n                             // Nothing to do, beside considering indentation\n                             diffIndex++;\n                             for (int i = 0; i < STANDARD_INDENTATION_SIZE && originalIndex >= 1 && nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                 nodeText.removeElement(--originalIndex);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                         DifferenceElementCalculator.Removed removed = (DifferenceElementCalculator.Removed)diffElement;\n \n                         if (removed.isChild() && originalElementIsChild) {\n                             ChildTextElement originalElementChild = (ChildTextElement)originalElement;\n                             if (originalElementChild.isComment()) {\n                                 // We expected to remove a proper node but we found a comment in between.\n                                 // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                 Comment comment = (Comment)originalElementChild.getChild();\n                                 if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(removed.getChild())) {\n                                     nodeText.removeElement(originalIndex);\n                                 } else {\n                                     originalIndex++;\n                                 }\n                             } else {\n                                 nodeText.removeElement(originalIndex);\n                                 if (originalIndex < originalElements.size() && originalElements.get(originalIndex).isNewline()) {\n                                     originalIndex = considerCleaningTheLine(nodeText, originalIndex);\n                                 } else {\n                                     if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                         originalIndex = considerEnforcingIndentation(nodeText, originalIndex);\n                                     }\n                                     // If in front we have one space and before also we had space let's drop one space\n                                     if (originalElements.size() > originalIndex && originalIndex > 0) {\n                                         if (originalElements.get(originalIndex).isWhiteSpace()\n                                                 && originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                             // However we do not want to do that when we are about to adding or removing elements\n                                             if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                                 originalElements.remove(originalIndex--);\n                                             }\n                                         }\n                                     }\n                                 }\n                                 diffIndex++;\n                             }\n                         } else if (removed.isToken() && originalElementIsToken\n                                 && (removed.getTokenType() == ((TokenTextElement)originalElement).getTokenKind())) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else if (originalElementIsToken && originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else if (removed.isPrimitiveType()) {\n                             if (isPrimitiveType(originalElement)) {\n                                 nodeText.removeElement(originalIndex);\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                             }\n                         } else if (removed.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (originalElement.isWhiteSpace()) {\n                             originalIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                         // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                         DifferenceElementCalculator.Reshuffled reshuffled = (DifferenceElementCalculator.Reshuffled)diffElement;\n                         CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n                         CsmMix elementsFromNextOrder = reshuffled.element;\n \n                         // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                         Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n \n                         // We now find out which Node Text elements corresponds to the elements in the original CSM\n                         List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n \n                         Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                         for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                             int value = nodeTextIndexOfPreviousElements.get(i);\n                             if (value != -1) {\n                                 nodeTextIndexToPreviousCSMIndex.put(value, i);\n                             }\n                         }\n                         int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                         // Elements to be added at the end\n                         List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                         List<CsmElement> nextOrderElements = elementsFromNextOrder.getElements();\n \n                         Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                         for (int ni = 0; ni< nextOrderElements.size(); ni++) {\n                             // If it has a mapping, then it is kept\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                 // Ok, it is something new. Where to put it? Let's see what is the first following\n                                 // element that has a mapping\n                                 int originalCsmIndex = -1;\n                                 for (int nj = ni + 1; nj< nextOrderElements.size() && originalCsmIndex==-1; nj++) {\n                                     if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                         originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                         if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                             elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                         }\n                                         elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                     }\n                                 }\n                                 // it does not preceed anything, so it goes at the end\n                                 if (originalCsmIndex == -1) {\n                                     elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                 }\n                             }\n                         }\n \n                         // We go over the original node text elements, in the order they appear in the NodeText.\n                         // Considering an original node text element (ONE)\n                         // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                         //   we find the correspond OCE (Original CSM Element)\n                         // * we first add new elements that are marked to be added before OCE\n                         // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                         //   otherwise we add a removed element\n \n                         diffElements.remove(diffIndex);\n \n                         int diffElIterator = diffIndex;\n                         if (lastNodeTextIndex != -1) {\n                             for (int ntIndex = originalIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                                 if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                     int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                     if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                         for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                             diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                         }\n                                     }\n \n                                     CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                     boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                     if (toBeKept) {\n                                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                     } else {\n                                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                     }\n                                 }\n                                 // else we have a simple node text element, without associated csm element, just keep ignore it\n                             }\n                         }\n \n                         // Finally we look for the remaining new elements that were not yet added and\n                         // add all of them\n                         for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                             diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex < diffElements.size() || originalIndex < originalElements.size());\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[nodeText-NodeText, node-Node]",
						"newValue": "[]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Moved method parameters from Difference.apply to its constructor as instance variables\n",
					"commitDate": "2018-05-18, 6:36 PM",
					"commitName": "b9976c5e33bf1419231e3a5ef8392d18da1e1b0c",
					"commitAuthor": "Thomas Leu",
					"commitDateOld": "2018-05-18, 5:51 PM",
					"commitNameOld": "40f6fef078275d3ca43f02918200a2d6076fef9d",
					"commitAuthorOld": "Thomas Leu",
					"daysBetweenCommits": 0.03,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,305 +1,305 @@\n-    void apply(NodeText nodeText, Node node) {\n-        if (nodeText == null) {\n+    void apply() {\n+        if (this.nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n-        List<TokenTextElement> indentation = LexicalPreservingPrinter.findIndentation(node);\n+        List<TokenTextElement> indentation = LexicalPreservingPrinter.findIndentation(this.node);\n \n         List<TextElement> originalElements = nodeText.getElements();\n         int originalIndex = 0;\n \n         List<DifferenceElementCalculator.DifferenceElement> diffElements = getElements();\n         int diffIndex = 0;\n         do {\n             if (diffIndex < diffElements.size() && originalIndex >= originalElements.size()) {\n                 DifferenceElementCalculator.DifferenceElement diffElement = diffElements.get(diffIndex);\n                 if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                     DifferenceElementCalculator.Kept kept = (DifferenceElementCalculator.Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n                     DifferenceElementCalculator.Added addedElement = (DifferenceElementCalculator.Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= diffElements.size() && originalIndex < originalElements.size()) {\n                 TextElement originalElement = originalElements.get(originalIndex);\n \n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n                 DifferenceElementCalculator.DifferenceElement diffElement = diffElements.get(diffIndex);\n \n                 if (diffElement instanceof DifferenceElementCalculator.Added) {\n                     DifferenceElementCalculator.Added addedElement = (DifferenceElementCalculator.Added) diffElement;\n \n                     if (addedElement.isIndent()) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement.isUnindent()) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n \n                     TextElement addedTextElement = addedElement.toTextElement();\n                     boolean used = false;\n                     if (originalIndex > 0 && originalElements.get(originalIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, originalIndex) && !isAReplacement(diffIndex)) {\n                         if (addedTextElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                             originalElements.remove(originalIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(originalIndex++, e);\n                             }\n                         }\n                     }\n \n                     if (!used) {\n                         nodeText.addElement(originalIndex, addedTextElement);\n                         originalIndex++;\n                     }\n \n                     if (addedTextElement.isNewline()) {\n                         boolean followedByUnindent = isFollowedByUnindent(diffElements, diffIndex);\n                         originalIndex = adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n \n                     diffIndex++;\n                 } else {\n                     TextElement originalElement = originalElements.get(originalIndex);\n                     boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof DifferenceElementCalculator.Kept) {\n                         DifferenceElementCalculator.Kept kept = (DifferenceElementCalculator.Kept)diffElement;\n \n                         if (originalElement.isComment()) {\n                             originalIndex++;\n                         } else if (kept.isChild() && originalElementIsChild) {\n                             diffIndex++;\n                             originalIndex++;\n                         } else if (kept.isChild() && originalElementIsToken) {\n                             if (originalElement.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 if (kept.isPrimitiveType()) {\n                                     originalIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                                 }\n                             }\n                         } else if (kept.isToken() && originalElementIsToken) {\n                             TokenTextElement originalTextToken = (TokenTextElement) originalElement;\n \n                             if (kept.getTokenType() == originalTextToken.getTokenKind()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else if (kept.isWhiteSpaceOrComment()) {\n                                 diffIndex++;\n                             } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                             }\n                         } else if (kept.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (kept.isIndent()) {\n                             diffIndex++;\n                         } else if (kept.isUnindent()) {\n                             // Nothing to do, beside considering indentation\n                             diffIndex++;\n                             for (int i = 0; i < STANDARD_INDENTATION_SIZE && originalIndex >= 1 && nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                 nodeText.removeElement(--originalIndex);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n                         DifferenceElementCalculator.Removed removed = (DifferenceElementCalculator.Removed)diffElement;\n \n                         if (removed.isChild() && originalElementIsChild) {\n                             ChildTextElement originalElementChild = (ChildTextElement)originalElement;\n                             if (originalElementChild.isComment()) {\n                                 // We expected to remove a proper node but we found a comment in between.\n                                 // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                 Comment comment = (Comment)originalElementChild.getChild();\n                                 if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(removed.getChild())) {\n                                     nodeText.removeElement(originalIndex);\n                                 } else {\n                                     originalIndex++;\n                                 }\n                             } else {\n                                 nodeText.removeElement(originalIndex);\n                                 if (originalIndex < originalElements.size() && originalElements.get(originalIndex).isNewline()) {\n                                     originalIndex = considerCleaningTheLine(nodeText, originalIndex);\n                                 } else {\n                                     if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                         originalIndex = considerEnforcingIndentation(nodeText, originalIndex);\n                                     }\n                                     // If in front we have one space and before also we had space let's drop one space\n                                     if (originalElements.size() > originalIndex && originalIndex > 0) {\n                                         if (originalElements.get(originalIndex).isWhiteSpace()\n                                                 && originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                             // However we do not want to do that when we are about to adding or removing elements\n                                             if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                                 originalElements.remove(originalIndex--);\n                                             }\n                                         }\n                                     }\n                                 }\n                                 diffIndex++;\n                             }\n                         } else if (removed.isToken() && originalElementIsToken\n                                 && (removed.getTokenType() == ((TokenTextElement)originalElement).getTokenKind())) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else if (originalElementIsToken && originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else if (removed.isPrimitiveType()) {\n                             if (isPrimitiveType(originalElement)) {\n                                 nodeText.removeElement(originalIndex);\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                             }\n                         } else if (removed.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (originalElement.isWhiteSpace()) {\n                             originalIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                         // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                         DifferenceElementCalculator.Reshuffled reshuffled = (DifferenceElementCalculator.Reshuffled)diffElement;\n                         CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n                         CsmMix elementsFromNextOrder = reshuffled.element;\n \n                         // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                         Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n \n                         // We now find out which Node Text elements corresponds to the elements in the original CSM\n                         List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n \n                         Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                         for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                             int value = nodeTextIndexOfPreviousElements.get(i);\n                             if (value != -1) {\n                                 nodeTextIndexToPreviousCSMIndex.put(value, i);\n                             }\n                         }\n                         int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                         // Elements to be added at the end\n                         List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                         List<CsmElement> nextOrderElements = elementsFromNextOrder.getElements();\n \n                         Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                         for (int ni = 0; ni< nextOrderElements.size(); ni++) {\n                             // If it has a mapping, then it is kept\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                 // Ok, it is something new. Where to put it? Let's see what is the first following\n                                 // element that has a mapping\n                                 int originalCsmIndex = -1;\n                                 for (int nj = ni + 1; nj< nextOrderElements.size() && originalCsmIndex==-1; nj++) {\n                                     if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                         originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                         if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                             elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                         }\n                                         elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                     }\n                                 }\n                                 // it does not preceed anything, so it goes at the end\n                                 if (originalCsmIndex == -1) {\n                                     elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                 }\n                             }\n                         }\n \n                         // We go over the original node text elements, in the order they appear in the NodeText.\n                         // Considering an original node text element (ONE)\n                         // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                         //   we find the correspond OCE (Original CSM Element)\n                         // * we first add new elements that are marked to be added before OCE\n                         // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                         //   otherwise we add a removed element\n \n                         diffElements.remove(diffIndex);\n \n                         int diffElIterator = diffIndex;\n                         if (lastNodeTextIndex != -1) {\n                             for (int ntIndex = originalIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                                 if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                     int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                     if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                         for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                             diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                         }\n                                     }\n \n                                     CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                     boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                     if (toBeKept) {\n                                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                     } else {\n                                         diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                     }\n                                 }\n                                 // else we have a simple node text element, without associated csm element, just keep ignore it\n                             }\n                         }\n \n                         // Finally we look for the remaining new elements that were not yet added and\n                         // add all of them\n                         for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                             diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex < diffElements.size() || originalIndex < originalElements.size());\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"40f6fef078275d3ca43f02918200a2d6076fef9d": {
			"type": "Ybodychange",
			"commitMessage": "Moved DifferenceElement classes and static methods to new class DifferenceElementCalculator\n",
			"commitDate": "2018-05-18, 5:51 PM",
			"commitName": "40f6fef078275d3ca43f02918200a2d6076fef9d",
			"commitAuthor": "Thomas Leu",
			"commitDateOld": "2018-05-18, 5:26 PM",
			"commitNameOld": "c4bbfa7060e136038d49a7ecfc35ec960153ac06",
			"commitAuthorOld": "Thomas Leu",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,305 +1,305 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = LexicalPreservingPrinter.findIndentation(node);\n \n         List<TextElement> originalElements = nodeText.getElements();\n         int originalIndex = 0;\n \n-        List<DifferenceElement> diffElements = getElements();\n+        List<DifferenceElementCalculator.DifferenceElement> diffElements = getElements();\n         int diffIndex = 0;\n         do {\n             if (diffIndex < diffElements.size() && originalIndex >= originalElements.size()) {\n-                DifferenceElement diffElement = diffElements.get(diffIndex);\n-                if (diffElement instanceof Kept) {\n-                    Kept kept = (Kept) diffElement;\n+                DifferenceElementCalculator.DifferenceElement diffElement = diffElements.get(diffIndex);\n+                if (diffElement instanceof DifferenceElementCalculator.Kept) {\n+                    DifferenceElementCalculator.Kept kept = (DifferenceElementCalculator.Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n-                } else if (diffElement instanceof Added) {\n-                    Added addedElement = (Added) diffElement;\n+                } else if (diffElement instanceof DifferenceElementCalculator.Added) {\n+                    DifferenceElementCalculator.Added addedElement = (DifferenceElementCalculator.Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= diffElements.size() && originalIndex < originalElements.size()) {\n                 TextElement originalElement = originalElements.get(originalIndex);\n \n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n-                DifferenceElement diffElement = diffElements.get(diffIndex);\n+                DifferenceElementCalculator.DifferenceElement diffElement = diffElements.get(diffIndex);\n \n-                if (diffElement instanceof Added) {\n-                    Added addedElement = (Added) diffElement;\n+                if (diffElement instanceof DifferenceElementCalculator.Added) {\n+                    DifferenceElementCalculator.Added addedElement = (DifferenceElementCalculator.Added) diffElement;\n \n                     if (addedElement.isIndent()) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement.isUnindent()) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n \n                     TextElement addedTextElement = addedElement.toTextElement();\n                     boolean used = false;\n                     if (originalIndex > 0 && originalElements.get(originalIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, originalIndex) && !isAReplacement(diffIndex)) {\n                         if (addedTextElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                             originalElements.remove(originalIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(originalIndex++, e);\n                             }\n                         }\n                     }\n \n                     if (!used) {\n                         nodeText.addElement(originalIndex, addedTextElement);\n                         originalIndex++;\n                     }\n \n                     if (addedTextElement.isNewline()) {\n                         boolean followedByUnindent = isFollowedByUnindent(diffElements, diffIndex);\n                         originalIndex = adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n \n                     diffIndex++;\n                 } else {\n                     TextElement originalElement = originalElements.get(originalIndex);\n                     boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n \n-                    if (diffElement instanceof Kept) {\n-                        Kept kept = (Kept)diffElement;\n+                    if (diffElement instanceof DifferenceElementCalculator.Kept) {\n+                        DifferenceElementCalculator.Kept kept = (DifferenceElementCalculator.Kept)diffElement;\n \n                         if (originalElement.isComment()) {\n                             originalIndex++;\n                         } else if (kept.isChild() && originalElementIsChild) {\n                             diffIndex++;\n                             originalIndex++;\n                         } else if (kept.isChild() && originalElementIsToken) {\n                             if (originalElement.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 if (kept.isPrimitiveType()) {\n                                     originalIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                                 }\n                             }\n                         } else if (kept.isToken() && originalElementIsToken) {\n                             TokenTextElement originalTextToken = (TokenTextElement) originalElement;\n \n                             if (kept.getTokenType() == originalTextToken.getTokenKind()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else if (kept.isWhiteSpaceOrComment()) {\n                                 diffIndex++;\n                             } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                             }\n                         } else if (kept.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (kept.isIndent()) {\n                             diffIndex++;\n                         } else if (kept.isUnindent()) {\n                             // Nothing to do, beside considering indentation\n                             diffIndex++;\n                             for (int i = 0; i < STANDARD_INDENTATION_SIZE && originalIndex >= 1 && nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                 nodeText.removeElement(--originalIndex);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                         }\n-                    } else if (diffElement instanceof Removed) {\n-                        Removed removed = (Removed)diffElement;\n+                    } else if (diffElement instanceof DifferenceElementCalculator.Removed) {\n+                        DifferenceElementCalculator.Removed removed = (DifferenceElementCalculator.Removed)diffElement;\n \n                         if (removed.isChild() && originalElementIsChild) {\n                             ChildTextElement originalElementChild = (ChildTextElement)originalElement;\n                             if (originalElementChild.isComment()) {\n                                 // We expected to remove a proper node but we found a comment in between.\n                                 // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                 Comment comment = (Comment)originalElementChild.getChild();\n                                 if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(removed.getChild())) {\n                                     nodeText.removeElement(originalIndex);\n                                 } else {\n                                     originalIndex++;\n                                 }\n                             } else {\n                                 nodeText.removeElement(originalIndex);\n                                 if (originalIndex < originalElements.size() && originalElements.get(originalIndex).isNewline()) {\n                                     originalIndex = considerCleaningTheLine(nodeText, originalIndex);\n                                 } else {\n-                                    if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n+                                    if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof DifferenceElementCalculator.Added)) {\n                                         originalIndex = considerEnforcingIndentation(nodeText, originalIndex);\n                                     }\n                                     // If in front we have one space and before also we had space let's drop one space\n                                     if (originalElements.size() > originalIndex && originalIndex > 0) {\n                                         if (originalElements.get(originalIndex).isWhiteSpace()\n                                                 && originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                             // However we do not want to do that when we are about to adding or removing elements\n-                                            if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n+                                            if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1) instanceof DifferenceElementCalculator.Kept)) {\n                                                 originalElements.remove(originalIndex--);\n                                             }\n                                         }\n                                     }\n                                 }\n                                 diffIndex++;\n                             }\n                         } else if (removed.isToken() && originalElementIsToken\n                                 && (removed.getTokenType() == ((TokenTextElement)originalElement).getTokenKind())) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else if (originalElementIsToken && originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else if (removed.isPrimitiveType()) {\n                             if (isPrimitiveType(originalElement)) {\n                                 nodeText.removeElement(originalIndex);\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                             }\n                         } else if (removed.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (originalElement.isWhiteSpace()) {\n                             originalIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                         }\n-                    } else if (diffElement instanceof Reshuffled) {\n+                    } else if (diffElement instanceof DifferenceElementCalculator.Reshuffled) {\n                         // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n-                        Reshuffled reshuffled = (Reshuffled)diffElement;\n+                        DifferenceElementCalculator.Reshuffled reshuffled = (DifferenceElementCalculator.Reshuffled)diffElement;\n                         CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n                         CsmMix elementsFromNextOrder = reshuffled.element;\n \n                         // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                         Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n \n                         // We now find out which Node Text elements corresponds to the elements in the original CSM\n                         List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n \n                         Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                         for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                             int value = nodeTextIndexOfPreviousElements.get(i);\n                             if (value != -1) {\n                                 nodeTextIndexToPreviousCSMIndex.put(value, i);\n                             }\n                         }\n                         int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                         // Elements to be added at the end\n                         List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                         List<CsmElement> nextOrderElements = elementsFromNextOrder.getElements();\n \n                         Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                         for (int ni = 0; ni< nextOrderElements.size(); ni++) {\n                             // If it has a mapping, then it is kept\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                 // Ok, it is something new. Where to put it? Let's see what is the first following\n                                 // element that has a mapping\n                                 int originalCsmIndex = -1;\n                                 for (int nj = ni + 1; nj< nextOrderElements.size() && originalCsmIndex==-1; nj++) {\n                                     if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                         originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                         if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                             elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                         }\n                                         elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                     }\n                                 }\n                                 // it does not preceed anything, so it goes at the end\n                                 if (originalCsmIndex == -1) {\n                                     elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                 }\n                             }\n                         }\n \n                         // We go over the original node text elements, in the order they appear in the NodeText.\n                         // Considering an original node text element (ONE)\n                         // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                         //   we find the correspond OCE (Original CSM Element)\n                         // * we first add new elements that are marked to be added before OCE\n                         // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                         //   otherwise we add a removed element\n \n                         diffElements.remove(diffIndex);\n \n                         int diffElIterator = diffIndex;\n                         if (lastNodeTextIndex != -1) {\n                             for (int ntIndex = originalIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                                 if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                     int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                     if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                         for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n-                                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n+                                            diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                                         }\n                                     }\n \n                                     CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                     boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                     if (toBeKept) {\n-                                        diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n+                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Kept(originalCSMElement));\n                                     } else {\n-                                        diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n+                                        diffElements.add(diffElIterator++, new DifferenceElementCalculator.Removed(originalCSMElement));\n                                     }\n                                 }\n                                 // else we have a simple node text element, without associated csm element, just keep ignore it\n                             }\n                         }\n \n                         // Finally we look for the remaining new elements that were not yet added and\n                         // add all of them\n                         for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n-                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n+                            diffElements.add(diffElIterator++, new DifferenceElementCalculator.Added(elementToAdd));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex < diffElements.size() || originalIndex < originalElements.size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7f177dcaadbccb2076a2a41aa1000696a9a8a10e": {
			"type": "Ybodychange",
			"commitMessage": "Extracted some methods and renamed some variables\n",
			"commitDate": "2018-05-18, 3:48 PM",
			"commitName": "7f177dcaadbccb2076a2a41aa1000696a9a8a10e",
			"commitAuthor": "Thomas Leu",
			"commitDateOld": "2018-05-18, 2:05 PM",
			"commitNameOld": "2ae6f779cc175b3cd82d915419f378e53ff4b056",
			"commitAuthorOld": "Thomas Leu",
			"daysBetweenCommits": 0.07,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,313 +1,305 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = LexicalPreservingPrinter.findIndentation(node);\n \n         List<TextElement> originalElements = nodeText.getElements();\n         int originalIndex = 0;\n \n-        List<DifferenceElement> diffElements = this.elements;\n+        List<DifferenceElement> diffElements = getElements();\n         int diffIndex = 0;\n         do {\n             if (diffIndex < diffElements.size() && originalIndex >= originalElements.size()) {\n                 DifferenceElement diffElement = diffElements.get(diffIndex);\n                 if (diffElement instanceof Kept) {\n                     Kept kept = (Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof Added) {\n                     Added addedElement = (Added) diffElement;\n \n                     nodeText.addElement(originalIndex, addedElement.toTextElement());\n                     originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= diffElements.size() && originalIndex < originalElements.size()) {\n                 TextElement originalElement = originalElements.get(originalIndex);\n+\n                 if (originalElement.isWhiteSpaceOrComment()) {\n                     originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + originalElement);\n                 }\n             } else {\n                 DifferenceElement diffElement = diffElements.get(diffIndex);\n \n                 if (diffElement instanceof Added) {\n                     Added addedElement = (Added) diffElement;\n \n                     if (addedElement.isIndent()) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement.isUnindent()) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n-                    TextElement textElement = addedElement.toTextElement();\n+\n+                    TextElement addedTextElement = addedElement.toTextElement();\n                     boolean used = false;\n                     if (originalIndex > 0 && originalElements.get(originalIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, originalIndex) && !isAReplacement(diffIndex)) {\n-                        if (textElement.isNewline()) {\n+                        if (addedTextElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (originalElements.get(originalIndex).isSpaceOrTab()) {\n                             originalElements.remove(originalIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                             nodeText.addElement(originalIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(originalIndex++, e);\n                             }\n                         }\n                     }\n+\n                     if (!used) {\n-                        nodeText.addElement(originalIndex, textElement);\n+                        nodeText.addElement(originalIndex, addedTextElement);\n                         originalIndex++;\n                     }\n-                    if (textElement.isNewline()) {\n-                        boolean followedByUnindent = (diffIndex + 1) < diffElements.size()\n-                                && diffElements.get(diffIndex + 1).isAdded()\n-                                && diffElements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n+\n+                    if (addedTextElement.isNewline()) {\n+                        boolean followedByUnindent = isFollowedByUnindent(diffElements, diffIndex);\n                         originalIndex = adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n+\n                     diffIndex++;\n                 } else {\n                     TextElement originalElement = originalElements.get(originalIndex);\n                     boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n                     boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof Kept) {\n                         Kept kept = (Kept)diffElement;\n+\n                         if (originalElement.isComment()) {\n                             originalIndex++;\n                         } else if (kept.isChild() && originalElementIsChild) {\n                             diffIndex++;\n                             originalIndex++;\n                         } else if (kept.isChild() && originalElementIsToken) {\n                             if (originalElement.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n                                 if (kept.isPrimitiveType()) {\n                                     originalIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                                 }\n                             }\n                         } else if (kept.isToken() && originalElementIsToken) {\n-                            CsmToken csmToken = (CsmToken) kept.element;\n-                            TokenTextElement nodeTextToken = (TokenTextElement) originalElement;\n-                            if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n+                            TokenTextElement originalTextToken = (TokenTextElement) originalElement;\n+\n+                            if (kept.getTokenType() == originalTextToken.getTokenKind()) {\n                                 originalIndex++;\n                                 diffIndex++;\n                             } else if (kept.isWhiteSpaceOrComment()) {\n                                 diffIndex++;\n-                            } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n+                            } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                                 originalIndex++;\n                             } else {\n-                                throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n+                                throw new UnsupportedOperationException(\"Csm token \" + kept.element + \" NodeText TOKEN \" + originalTextToken);\n                             }\n-                        } else if (kept.isToken() && ((CsmToken) kept.element).isWhiteSpace()) {\n+                        } else if (kept.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (kept.isIndent()) {\n-                            // Nothing to do\n                             diffIndex++;\n                         } else if (kept.isUnindent()) {\n                             // Nothing to do, beside considering indentation\n                             diffIndex++;\n                             for (int i = 0; i < STANDARD_INDENTATION_SIZE && originalIndex >= 1 && nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n                                 nodeText.removeElement(--originalIndex);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof Removed) {\n                         Removed removed = (Removed)diffElement;\n+\n                         if (removed.isChild() && originalElementIsChild) {\n-                            ChildTextElement actualChild = (ChildTextElement)originalElement;\n-                            if (actualChild.isComment()) {\n-                                CsmChild csmChild = (CsmChild)removed.element;\n+                            ChildTextElement originalElementChild = (ChildTextElement)originalElement;\n+                            if (originalElementChild.isComment()) {\n                                 // We expected to remove a proper node but we found a comment in between.\n                                 // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n-                                Comment comment = (Comment)actualChild.getChild();\n-                                if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(csmChild.getChild())) {\n+                                Comment comment = (Comment)originalElementChild.getChild();\n+                                if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(removed.getChild())) {\n                                     nodeText.removeElement(originalIndex);\n                                 } else {\n                                     originalIndex++;\n                                 }\n                             } else {\n                                 nodeText.removeElement(originalIndex);\n                                 if (originalIndex < originalElements.size() && originalElements.get(originalIndex).isNewline()) {\n                                     originalIndex = considerCleaningTheLine(nodeText, originalIndex);\n                                 } else {\n                                     if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                         originalIndex = considerEnforcingIndentation(nodeText, originalIndex);\n                                     }\n                                     // If in front we have one space and before also we had space let's drop one space\n                                     if (originalElements.size() > originalIndex && originalIndex > 0) {\n                                         if (originalElements.get(originalIndex).isWhiteSpace()\n                                                 && originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                             // However we do not want to do that when we are about to adding or removing elements\n                                             if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                                 originalElements.remove(originalIndex--);\n                                             }\n                                         }\n                                     }\n                                 }\n                                 diffIndex++;\n                             }\n                         } else if (removed.isToken() && originalElementIsToken\n-                                && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)originalElement).getTokenKind()) {\n+                                && (removed.getTokenType() == ((TokenTextElement)originalElement).getTokenKind())) {\n                             nodeText.removeElement(originalIndex);\n                             diffIndex++;\n                         } else if (originalElementIsToken && originalElement.isWhiteSpaceOrComment()) {\n                             originalIndex++;\n                         } else if (removed.isPrimitiveType()) {\n                             if (isPrimitiveType(originalElement)) {\n                                 nodeText.removeElement(originalIndex);\n                                 diffIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                             }\n                         } else if (removed.isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (originalElement.isWhiteSpace()) {\n                             originalIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof Reshuffled) {\n-\n                         // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                         Reshuffled reshuffled = (Reshuffled)diffElement;\n                         CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n                         CsmMix elementsFromNextOrder = reshuffled.element;\n \n                         // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n-                        Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n-\n-                        for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n-                            boolean found = false;\n-                            CsmElement ne = elementsFromNextOrder.getElements().get(ni);\n-                            for (int pi=0;pi<elementsFromPreviousOrder.getElements().size() && !found;pi++) {\n-                                CsmElement pe = elementsFromPreviousOrder.getElements().get(pi);\n-                                if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n-                                        && matching(ne, pe)) {\n-                                    found = true;\n-                                    correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n-                                }\n-                            }\n-                        }\n+                        Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n \n                         // We now find out which Node Text elements corresponds to the elements in the original CSM\n                         List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n \n                         Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                         for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                             int value = nodeTextIndexOfPreviousElements.get(i);\n                             if (value != -1) {\n                                 nodeTextIndexToPreviousCSMIndex.put(value, i);\n                             }\n                         }\n                         int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                         // Elements to be added at the end\n                         List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n+                        List<CsmElement> nextOrderElements = elementsFromNextOrder.getElements();\n+\n                         Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n-                        for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n+                        for (int ni = 0; ni< nextOrderElements.size(); ni++) {\n                             // If it has a mapping, then it is kept\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                 // Ok, it is something new. Where to put it? Let's see what is the first following\n                                 // element that has a mapping\n                                 int originalCsmIndex = -1;\n-                                for (int nj=ni + 1;nj<elementsFromNextOrder.getElements().size() && originalCsmIndex==-1;nj++) {\n+                                for (int nj = ni + 1; nj< nextOrderElements.size() && originalCsmIndex==-1; nj++) {\n                                     if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                         originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                         if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                             elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                         }\n-                                        elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n+                                        elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                                     }\n                                 }\n                                 // it does not preceed anything, so it goes at the end\n                                 if (originalCsmIndex == -1) {\n-                                    elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n+                                    elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                                 }\n                             }\n                         }\n \n                         // We go over the original node text elements, in the order they appear in the NodeText.\n                         // Considering an original node text element (ONE)\n                         // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                         //   we find the correspond OCE (Original CSM Element)\n                         // * we first add new elements that are marked to be added before OCE\n                         // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                         //   otherwise we add a removed element\n \n-                        this.getElements().remove(diffIndex);\n+                        diffElements.remove(diffIndex);\n+\n                         int diffElIterator = diffIndex;\n                         if (lastNodeTextIndex != -1) {\n                             for (int ntIndex = originalIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                                 if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                     int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                     if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                         for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                             diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                         }\n                                     }\n \n                                     CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                     boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                     if (toBeKept) {\n                                         diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                     } else {\n                                         diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                     }\n                                 }\n                                 // else we have a simple node text element, without associated csm element, just keep ignore it\n                             }\n                         }\n \n                         // Finally we look for the remaining new elements that were not yet added and\n                         // add all of them\n                         for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                             diffElements.add(diffElIterator++, new Added(elementToAdd));\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n         } while (diffIndex < diffElements.size() || originalIndex < originalElements.size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2ae6f779cc175b3cd82d915419f378e53ff4b056": {
			"type": "Ybodychange",
			"commitMessage": "Renamed given to original\n",
			"commitDate": "2018-05-18, 2:05 PM",
			"commitName": "2ae6f779cc175b3cd82d915419f378e53ff4b056",
			"commitAuthor": "Thomas Leu",
			"commitDateOld": "2018-05-17, 4:47 PM",
			"commitNameOld": "de5c17c37f15a1c134f518ed2754974cc4b9aa15",
			"commitAuthorOld": "Thomas Leu",
			"daysBetweenCommits": 0.89,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,313 +1,313 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = LexicalPreservingPrinter.findIndentation(node);\n \n-        List<TextElement> givenElements = nodeText.getElements();\n-        int givenIndex = 0;\n+        List<TextElement> originalElements = nodeText.getElements();\n+        int originalIndex = 0;\n \n         List<DifferenceElement> diffElements = this.elements;\n         int diffIndex = 0;\n         do {\n-            if (diffIndex < diffElements.size() && givenIndex >= givenElements.size()) {\n+            if (diffIndex < diffElements.size() && originalIndex >= originalElements.size()) {\n                 DifferenceElement diffElement = diffElements.get(diffIndex);\n                 if (diffElement instanceof Kept) {\n                     Kept kept = (Kept) diffElement;\n \n                     if (kept.isWhiteSpaceOrComment()) {\n                         diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof Added) {\n                     Added addedElement = (Added) diffElement;\n \n-                    nodeText.addElement(givenIndex, addedElement.toTextElement());\n-                    givenIndex++;\n+                    nodeText.addElement(originalIndex, addedElement.toTextElement());\n+                    originalIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n-            } else if (diffIndex >= diffElements.size() && givenIndex < givenElements.size()) {\n-                TextElement givenElement = givenElements.get(givenIndex);\n-                if (givenElement.isWhiteSpaceOrComment()) {\n-                    givenIndex++;\n+            } else if (diffIndex >= diffElements.size() && originalIndex < originalElements.size()) {\n+                TextElement originalElement = originalElements.get(originalIndex);\n+                if (originalElement.isWhiteSpaceOrComment()) {\n+                    originalIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n-                            + this + \" \" + givenElement);\n+                            + this + \" \" + originalElement);\n                 }\n             } else {\n                 DifferenceElement diffElement = diffElements.get(diffIndex);\n \n                 if (diffElement instanceof Added) {\n                     Added addedElement = (Added) diffElement;\n \n                     if (addedElement.isIndent()) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement.isUnindent()) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement = addedElement.toTextElement();\n                     boolean used = false;\n-                    if (givenIndex > 0 && givenElements.get(givenIndex - 1).isNewline()) {\n-                        for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n-                            nodeText.addElement(givenIndex++, e);\n+                    if (originalIndex > 0 && originalElements.get(originalIndex - 1).isNewline()) {\n+                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n+                            nodeText.addElement(originalIndex++, e);\n                         }\n-                    } else if (isAfterLBrace(nodeText, givenIndex) && !isAReplacement(diffIndex)) {\n+                    } else if (isAfterLBrace(nodeText, originalIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n-                        nodeText.addElement(givenIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n+                        nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n-                        while (givenElements.get(givenIndex).isSpaceOrTab()) {\n-                            givenElements.remove(givenIndex);\n+                        while (originalElements.get(originalIndex).isSpaceOrTab()) {\n+                            originalElements.remove(originalIndex);\n                         }\n-                        for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n-                            nodeText.addElement(givenIndex++, e);\n+                        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n+                            nodeText.addElement(originalIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n-                                nodeText.addElement(givenIndex++, e);\n+                                nodeText.addElement(originalIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n-                        nodeText.addElement(givenIndex, textElement);\n-                        givenIndex++;\n+                        nodeText.addElement(originalIndex, textElement);\n+                        originalIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent = (diffIndex + 1) < diffElements.size()\n                                 && diffElements.get(diffIndex + 1).isAdded()\n                                 && diffElements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n-                        givenIndex = adjustIndentation(indentation, nodeText, givenIndex, followedByUnindent/* && !addedIndentation*/);\n+                        originalIndex = adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else {\n-                    TextElement givenElement = givenElements.get(givenIndex);\n-                    boolean givenElementIsChild = givenElement instanceof ChildTextElement;\n-                    boolean givenElementIsToken = givenElement instanceof TokenTextElement;\n+                    TextElement originalElement = originalElements.get(originalIndex);\n+                    boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n+                    boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n \n                     if (diffElement instanceof Kept) {\n                         Kept kept = (Kept)diffElement;\n-                        if (givenElement.isComment()) {\n-                            givenIndex++;\n-                        } else if (kept.isChild() && givenElementIsChild) {\n+                        if (originalElement.isComment()) {\n+                            originalIndex++;\n+                        } else if (kept.isChild() && originalElementIsChild) {\n                             diffIndex++;\n-                            givenIndex++;\n-                        } else if (kept.isChild() && givenElementIsToken) {\n-                            if (givenElement.isWhiteSpaceOrComment()) {\n-                                givenIndex++;\n+                            originalIndex++;\n+                        } else if (kept.isChild() && originalElementIsToken) {\n+                            if (originalElement.isWhiteSpaceOrComment()) {\n+                                originalIndex++;\n                             } else {\n                                 if (kept.isPrimitiveType()) {\n-                                    givenIndex++;\n+                                    originalIndex++;\n                                     diffIndex++;\n                                 } else {\n-                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n+                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                                 }\n                             }\n-                        } else if (kept.isToken() && givenElementIsToken) {\n+                        } else if (kept.isToken() && originalElementIsToken) {\n                             CsmToken csmToken = (CsmToken) kept.element;\n-                            TokenTextElement nodeTextToken = (TokenTextElement) givenElement;\n+                            TokenTextElement nodeTextToken = (TokenTextElement) originalElement;\n                             if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n-                                givenIndex++;\n+                                originalIndex++;\n                                 diffIndex++;\n                             } else if (kept.isWhiteSpaceOrComment()) {\n                                 diffIndex++;\n                             } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n-                                givenIndex++;\n+                                originalIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                             }\n                         } else if (kept.isToken() && ((CsmToken) kept.element).isWhiteSpace()) {\n                             diffIndex++;\n                         } else if (kept.isIndent()) {\n                             // Nothing to do\n                             diffIndex++;\n                         } else if (kept.isUnindent()) {\n                             // Nothing to do, beside considering indentation\n                             diffIndex++;\n-                            for (int i = 0; i < STANDARD_INDENTATION_SIZE && givenIndex >= 1 && nodeText.getTextElement(givenIndex - 1).isSpaceOrTab(); i++) {\n-                                nodeText.removeElement(--givenIndex);\n+                            for (int i = 0; i < STANDARD_INDENTATION_SIZE && originalIndex >= 1 && nodeText.getTextElement(originalIndex - 1).isSpaceOrTab(); i++) {\n+                                nodeText.removeElement(--originalIndex);\n                             }\n                         } else {\n-                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n+                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof Removed) {\n                         Removed removed = (Removed)diffElement;\n-                        if (removed.isChild() && givenElementIsChild) {\n-                            ChildTextElement actualChild = (ChildTextElement)givenElement;\n+                        if (removed.isChild() && originalElementIsChild) {\n+                            ChildTextElement actualChild = (ChildTextElement)originalElement;\n                             if (actualChild.isComment()) {\n                                 CsmChild csmChild = (CsmChild)removed.element;\n                                 // We expected to remove a proper node but we found a comment in between.\n                                 // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                                 Comment comment = (Comment)actualChild.getChild();\n                                 if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(csmChild.getChild())) {\n-                                    nodeText.removeElement(givenIndex);\n+                                    nodeText.removeElement(originalIndex);\n                                 } else {\n-                                    givenIndex++;\n+                                    originalIndex++;\n                                 }\n                             } else {\n-                                nodeText.removeElement(givenIndex);\n-                                if (givenIndex < givenElements.size() && givenElements.get(givenIndex).isNewline()) {\n-                                    givenIndex = considerCleaningTheLine(nodeText, givenIndex);\n+                                nodeText.removeElement(originalIndex);\n+                                if (originalIndex < originalElements.size() && originalElements.get(originalIndex).isNewline()) {\n+                                    originalIndex = considerCleaningTheLine(nodeText, originalIndex);\n                                 } else {\n                                     if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n-                                        givenIndex = considerEnforcingIndentation(nodeText, givenIndex);\n+                                        originalIndex = considerEnforcingIndentation(nodeText, originalIndex);\n                                     }\n                                     // If in front we have one space and before also we had space let's drop one space\n-                                    if (givenElements.size() > givenIndex && givenIndex > 0) {\n-                                        if (givenElements.get(givenIndex).isWhiteSpace()\n-                                                && givenElements.get(givenIndex - 1).isWhiteSpace()) {\n+                                    if (originalElements.size() > originalIndex && originalIndex > 0) {\n+                                        if (originalElements.get(originalIndex).isWhiteSpace()\n+                                                && originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                                             // However we do not want to do that when we are about to adding or removing elements\n                                             if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n-                                                givenElements.remove(givenIndex--);\n+                                                originalElements.remove(originalIndex--);\n                                             }\n                                         }\n                                     }\n                                 }\n                                 diffIndex++;\n                             }\n-                        } else if (removed.isToken() && givenElementIsToken\n-                                && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)givenElement).getTokenKind()) {\n-                            nodeText.removeElement(givenIndex);\n+                        } else if (removed.isToken() && originalElementIsToken\n+                                && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)originalElement).getTokenKind()) {\n+                            nodeText.removeElement(originalIndex);\n                             diffIndex++;\n-                        } else if (givenElementIsToken && givenElement.isWhiteSpaceOrComment()) {\n-                            givenIndex++;\n+                        } else if (originalElementIsToken && originalElement.isWhiteSpaceOrComment()) {\n+                            originalIndex++;\n                         } else if (removed.isPrimitiveType()) {\n-                            if (isPrimitiveType(givenElement)) {\n-                                nodeText.removeElement(givenIndex);\n+                            if (isPrimitiveType(originalElement)) {\n+                                nodeText.removeElement(originalIndex);\n                                 diffIndex++;\n                             } else {\n-                                throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n+                                throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                             }\n                         } else if (removed.isWhiteSpace()) {\n                             diffIndex++;\n-                        } else if (givenElement.isWhiteSpace()) {\n-                            givenIndex++;\n+                        } else if (originalElement.isWhiteSpace()) {\n+                            originalIndex++;\n                         } else {\n-                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n+                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + originalElement);\n                         }\n                     } else if (diffElement instanceof Reshuffled) {\n \n                         // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                         Reshuffled reshuffled = (Reshuffled)diffElement;\n                         CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n                         CsmMix elementsFromNextOrder = reshuffled.element;\n \n                         // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                         Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n \n                         for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                             boolean found = false;\n                             CsmElement ne = elementsFromNextOrder.getElements().get(ni);\n                             for (int pi=0;pi<elementsFromPreviousOrder.getElements().size() && !found;pi++) {\n                                 CsmElement pe = elementsFromPreviousOrder.getElements().get(pi);\n                                 if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                         && matching(ne, pe)) {\n                                     found = true;\n                                     correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                                 }\n                             }\n                         }\n \n                         // We now find out which Node Text elements corresponds to the elements in the original CSM\n-                        List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, givenIndex, node);\n+                        List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n \n                         Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                         for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                             int value = nodeTextIndexOfPreviousElements.get(i);\n                             if (value != -1) {\n                                 nodeTextIndexToPreviousCSMIndex.put(value, i);\n                             }\n                         }\n                         int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                         // Elements to be added at the end\n                         List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                         Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                         for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                             // If it has a mapping, then it is kept\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                                 // Ok, it is something new. Where to put it? Let's see what is the first following\n                                 // element that has a mapping\n                                 int originalCsmIndex = -1;\n                                 for (int nj=ni + 1;nj<elementsFromNextOrder.getElements().size() && originalCsmIndex==-1;nj++) {\n                                     if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                         originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                         if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                             elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                         }\n                                         elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                     }\n                                 }\n                                 // it does not preceed anything, so it goes at the end\n                                 if (originalCsmIndex == -1) {\n                                     elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                         }\n \n                         // We go over the original node text elements, in the order they appear in the NodeText.\n                         // Considering an original node text element (ONE)\n                         // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                         //   we find the correspond OCE (Original CSM Element)\n                         // * we first add new elements that are marked to be added before OCE\n                         // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                         //   otherwise we add a removed element\n \n                         this.getElements().remove(diffIndex);\n                         int diffElIterator = diffIndex;\n                         if (lastNodeTextIndex != -1) {\n-                            for (int ntIndex = givenIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n+                            for (int ntIndex = originalIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                                 if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                     int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                     if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                         for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                             diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                         }\n                                     }\n \n                                     CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                     boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                     if (toBeKept) {\n                                         diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                     } else {\n                                         diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                     }\n                                 }\n                                 // else we have a simple node text element, without associated csm element, just keep ignore it\n                             }\n                         }\n \n                         // Finally we look for the remaining new elements that were not yet added and\n                         // add all of them\n                         for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                             diffElements.add(diffElIterator++, new Added(elementToAdd));\n                         }\n                     } else {\n-                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + givenElement);\n+                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                     }\n                 }\n             }\n-        } while (diffIndex < diffElements.size() || givenIndex < givenElements.size());\n+        } while (diffIndex < diffElements.size() || originalIndex < originalElements.size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"de5c17c37f15a1c134f518ed2754974cc4b9aa15": {
			"type": "Ybodychange",
			"commitMessage": "Moved some logic to DifferenceElement objects and some renamings etc.\n",
			"commitDate": "2018-05-17, 4:47 PM",
			"commitName": "de5c17c37f15a1c134f518ed2754974cc4b9aa15",
			"commitAuthor": "Thomas Leu",
			"commitDateOld": "2018-05-17, 3:24 PM",
			"commitNameOld": "fb8daf1673c35798aeb7cca8033dd9c9b2e5c4fc",
			"commitAuthorOld": "Thomas Leu",
			"daysBetweenCommits": 0.06,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,317 +1,313 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = LexicalPreservingPrinter.findIndentation(node);\n \n         List<TextElement> givenElements = nodeText.getElements();\n         int givenIndex = 0;\n \n         List<DifferenceElement> diffElements = this.elements;\n         int diffIndex = 0;\n         do {\n             if (diffIndex < diffElements.size() && givenIndex >= givenElements.size()) {\n                 DifferenceElement diffElement = diffElements.get(diffIndex);\n                 if (diffElement instanceof Kept) {\n                     Kept kept = (Kept) diffElement;\n-                    if (kept.element instanceof CsmToken) {\n-                        CsmToken csmToken = (CsmToken) kept.element;\n-                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n-                            diffIndex++;\n-                        } else {\n-                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n-                                    + nodeText + \". Difference: \" + this);\n-                        }\n+\n+                    if (kept.isWhiteSpaceOrComment()) {\n+                        diffIndex++;\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffElement instanceof Added) {\n-                    nodeText.addElement(givenIndex, toTextElement(((Added) diffElement).element));\n+                    Added addedElement = (Added) diffElement;\n+\n+                    nodeText.addElement(givenIndex, addedElement.toTextElement());\n                     givenIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= diffElements.size() && givenIndex < givenElements.size()) {\n                 TextElement givenElement = givenElements.get(givenIndex);\n                 if (givenElement.isWhiteSpaceOrComment()) {\n                     givenIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + givenElement);\n                 }\n             } else {\n                 DifferenceElement diffElement = diffElements.get(diffIndex);\n-                TextElement givenElement = givenElements.get(givenIndex);\n+\n                 if (diffElement instanceof Added) {\n-                    CsmElement addedElement = ((Added) diffElement).element;\n-                    if (addedElement instanceof CsmIndent) {\n+                    Added addedElement = (Added) diffElement;\n+\n+                    if (addedElement.isIndent()) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n-                    if (addedElement instanceof CsmUnindent) {\n+                    if (addedElement.isUnindent()) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n-                    TextElement textElement = toTextElement(addedElement);\n+                    TextElement textElement = addedElement.toTextElement();\n                     boolean used = false;\n                     if (givenIndex > 0 && givenElements.get(givenIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n                             nodeText.addElement(givenIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, givenIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(givenIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (givenElements.get(givenIndex).isSpaceOrTab()) {\n                             givenElements.remove(givenIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n                             nodeText.addElement(givenIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(givenIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(givenIndex, textElement);\n                         givenIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent = (diffIndex + 1) < diffElements.size()\n                                 && diffElements.get(diffIndex + 1).isAdded()\n                                 && diffElements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         givenIndex = adjustIndentation(indentation, nodeText, givenIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n                     diffIndex++;\n-                } else if (diffElement instanceof Kept) {\n-                    Kept kept = (Kept)diffElement;\n-                    if (givenElement.isComment()) {\n-                        givenIndex++;\n-                    } else if ((kept.element instanceof CsmChild) && givenElement instanceof ChildTextElement) {\n-                        diffIndex++;\n-                        givenIndex++;\n-                    } else if ((kept.element instanceof CsmChild) && givenElement instanceof TokenTextElement) {\n-                        if (givenElement.isWhiteSpaceOrComment()) {\n+                } else {\n+                    TextElement givenElement = givenElements.get(givenIndex);\n+                    boolean givenElementIsChild = givenElement instanceof ChildTextElement;\n+                    boolean givenElementIsToken = givenElement instanceof TokenTextElement;\n+\n+                    if (diffElement instanceof Kept) {\n+                        Kept kept = (Kept)diffElement;\n+                        if (givenElement.isComment()) {\n                             givenIndex++;\n-                        } else {\n-                            if (kept.element instanceof CsmChild) {\n-                                CsmChild keptChild = (CsmChild)kept.element;\n-                                if (keptChild.getChild() instanceof PrimitiveType) {\n+                        } else if (kept.isChild() && givenElementIsChild) {\n+                            diffIndex++;\n+                            givenIndex++;\n+                        } else if (kept.isChild() && givenElementIsToken) {\n+                            if (givenElement.isWhiteSpaceOrComment()) {\n+                                givenIndex++;\n+                            } else {\n+                                if (kept.isPrimitiveType()) {\n                                     givenIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                                 }\n-                            } else {\n-                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                             }\n-                        }\n-                    } else if ((kept.element instanceof CsmToken) && givenElement instanceof TokenTextElement) {\n-                        CsmToken csmToken = (CsmToken) kept.element;\n-                        TokenTextElement nodeTextToken = (TokenTextElement) givenElement;\n-                        if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n-                            givenIndex++;\n-                            diffIndex++;\n-                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n-                            diffIndex++;\n-                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n-                            givenIndex++;\n-                        } else {\n-                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n-                        }\n-                    } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n-                        diffIndex++;\n-                    } else if (kept.element instanceof CsmIndent) {\n-                        // Nothing to do\n-                        diffIndex++;\n-                    } else if (kept.element instanceof CsmUnindent) {\n-                        // Nothing to do, beside considering indentation\n-                        diffIndex++;\n-                        for (int i = 0; i < STANDARD_INDENTATION_SIZE && givenIndex >= 1 && nodeText.getTextElement(givenIndex - 1).isSpaceOrTab(); i++) {\n-                            nodeText.removeElement(--givenIndex);\n-                        }\n-                    } else {\n-                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n-                    }\n-                } else if (diffElement instanceof Removed) {\n-                    Removed removed = (Removed)diffElement;\n-                    if ((removed.element instanceof CsmChild) && givenElement instanceof ChildTextElement) {\n-                        ChildTextElement actualChild = (ChildTextElement)givenElement;\n-                        if (actualChild.isComment()) {\n-                            CsmChild csmChild = (CsmChild)removed.element;\n-                            // We expected to remove a proper node but we found a comment in between.\n-                            // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n-                            Comment comment = (Comment)actualChild.getChild();\n-                            if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(csmChild.getChild())) {\n-                                nodeText.removeElement(givenIndex);\n-                            } else {\n+                        } else if (kept.isToken() && givenElementIsToken) {\n+                            CsmToken csmToken = (CsmToken) kept.element;\n+                            TokenTextElement nodeTextToken = (TokenTextElement) givenElement;\n+                            if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                                 givenIndex++;\n+                                diffIndex++;\n+                            } else if (kept.isWhiteSpaceOrComment()) {\n+                                diffIndex++;\n+                            } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n+                                givenIndex++;\n+                            } else {\n+                                throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n+                            }\n+                        } else if (kept.isToken() && ((CsmToken) kept.element).isWhiteSpace()) {\n+                            diffIndex++;\n+                        } else if (kept.isIndent()) {\n+                            // Nothing to do\n+                            diffIndex++;\n+                        } else if (kept.isUnindent()) {\n+                            // Nothing to do, beside considering indentation\n+                            diffIndex++;\n+                            for (int i = 0; i < STANDARD_INDENTATION_SIZE && givenIndex >= 1 && nodeText.getTextElement(givenIndex - 1).isSpaceOrTab(); i++) {\n+                                nodeText.removeElement(--givenIndex);\n                             }\n                         } else {\n-                            nodeText.removeElement(givenIndex);\n-                            if (givenIndex < givenElements.size() && givenElements.get(givenIndex).isNewline()) {\n-                                givenIndex = considerCleaningTheLine(nodeText, givenIndex);\n-                            } else {\n-                                if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n-                                    givenIndex = considerEnforcingIndentation(nodeText, givenIndex);\n+                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n+                        }\n+                    } else if (diffElement instanceof Removed) {\n+                        Removed removed = (Removed)diffElement;\n+                        if (removed.isChild() && givenElementIsChild) {\n+                            ChildTextElement actualChild = (ChildTextElement)givenElement;\n+                            if (actualChild.isComment()) {\n+                                CsmChild csmChild = (CsmChild)removed.element;\n+                                // We expected to remove a proper node but we found a comment in between.\n+                                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n+                                Comment comment = (Comment)actualChild.getChild();\n+                                if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(csmChild.getChild())) {\n+                                    nodeText.removeElement(givenIndex);\n+                                } else {\n+                                    givenIndex++;\n                                 }\n-                                // If in front we have one space and before also we had space let's drop one space\n-                                if (givenElements.size() > givenIndex && givenIndex > 0) {\n-                                    if (givenElements.get(givenIndex).isWhiteSpace()\n-                                            && givenElements.get(givenIndex - 1).isWhiteSpace()) {\n-                                        // However we do not want to do that when we are about to adding or removing elements\n-                                        if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n-                                            givenElements.remove(givenIndex--);\n+                            } else {\n+                                nodeText.removeElement(givenIndex);\n+                                if (givenIndex < givenElements.size() && givenElements.get(givenIndex).isNewline()) {\n+                                    givenIndex = considerCleaningTheLine(nodeText, givenIndex);\n+                                } else {\n+                                    if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n+                                        givenIndex = considerEnforcingIndentation(nodeText, givenIndex);\n+                                    }\n+                                    // If in front we have one space and before also we had space let's drop one space\n+                                    if (givenElements.size() > givenIndex && givenIndex > 0) {\n+                                        if (givenElements.get(givenIndex).isWhiteSpace()\n+                                                && givenElements.get(givenIndex - 1).isWhiteSpace()) {\n+                                            // However we do not want to do that when we are about to adding or removing elements\n+                                            if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n+                                                givenElements.remove(givenIndex--);\n+                                            }\n                                         }\n                                     }\n                                 }\n+                                diffIndex++;\n                             }\n-                            diffIndex++;\n-                        }\n-                    } else if ((removed.element instanceof CsmToken) && givenElement instanceof TokenTextElement\n-                            && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)givenElement).getTokenKind()) {\n-                        nodeText.removeElement(givenIndex);\n-                        diffIndex++;\n-                    } else if (givenElement instanceof TokenTextElement\n-                            && givenElement.isWhiteSpaceOrComment()) {\n-                        givenIndex++;\n-                    } else if (removed.element instanceof CsmChild\n-                            && ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n-                        if (isPrimitiveType(givenElement)) {\n+                        } else if (removed.isToken() && givenElementIsToken\n+                                && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)givenElement).getTokenKind()) {\n                             nodeText.removeElement(givenIndex);\n                             diffIndex++;\n+                        } else if (givenElementIsToken && givenElement.isWhiteSpaceOrComment()) {\n+                            givenIndex++;\n+                        } else if (removed.isPrimitiveType()) {\n+                            if (isPrimitiveType(givenElement)) {\n+                                nodeText.removeElement(givenIndex);\n+                                diffIndex++;\n+                            } else {\n+                                throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n+                            }\n+                        } else if (removed.isWhiteSpace()) {\n+                            diffIndex++;\n+                        } else if (givenElement.isWhiteSpace()) {\n+                            givenIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n                         }\n-                    } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n-                        diffIndex++;\n-                    } else if (givenElement.isWhiteSpace()) {\n-                        givenIndex++;\n+                    } else if (diffElement instanceof Reshuffled) {\n+\n+                        // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n+                        Reshuffled reshuffled = (Reshuffled)diffElement;\n+                        CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n+                        CsmMix elementsFromNextOrder = reshuffled.element;\n+\n+                        // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n+                        Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n+\n+                        for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n+                            boolean found = false;\n+                            CsmElement ne = elementsFromNextOrder.getElements().get(ni);\n+                            for (int pi=0;pi<elementsFromPreviousOrder.getElements().size() && !found;pi++) {\n+                                CsmElement pe = elementsFromPreviousOrder.getElements().get(pi);\n+                                if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n+                                        && matching(ne, pe)) {\n+                                    found = true;\n+                                    correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n+                                }\n+                            }\n+                        }\n+\n+                        // We now find out which Node Text elements corresponds to the elements in the original CSM\n+                        List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, givenIndex, node);\n+\n+                        Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n+                        for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n+                            int value = nodeTextIndexOfPreviousElements.get(i);\n+                            if (value != -1) {\n+                                nodeTextIndexToPreviousCSMIndex.put(value, i);\n+                            }\n+                        }\n+                        int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n+\n+                        // Elements to be added at the end\n+                        List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n+                        Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n+                        for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n+                            // If it has a mapping, then it is kept\n+                            if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n+                                // Ok, it is something new. Where to put it? Let's see what is the first following\n+                                // element that has a mapping\n+                                int originalCsmIndex = -1;\n+                                for (int nj=ni + 1;nj<elementsFromNextOrder.getElements().size() && originalCsmIndex==-1;nj++) {\n+                                    if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n+                                        originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n+                                        if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n+                                            elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n+                                        }\n+                                        elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n+                                    }\n+                                }\n+                                // it does not preceed anything, so it goes at the end\n+                                if (originalCsmIndex == -1) {\n+                                    elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n+                                }\n+                            }\n+                        }\n+\n+                        // We go over the original node text elements, in the order they appear in the NodeText.\n+                        // Considering an original node text element (ONE)\n+                        // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n+                        //   we find the correspond OCE (Original CSM Element)\n+                        // * we first add new elements that are marked to be added before OCE\n+                        // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n+                        //   otherwise we add a removed element\n+\n+                        this.getElements().remove(diffIndex);\n+                        int diffElIterator = diffIndex;\n+                        if (lastNodeTextIndex != -1) {\n+                            for (int ntIndex = givenIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n+\n+                                if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n+                                    int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n+                                    if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n+                                        for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n+                                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n+                                        }\n+                                    }\n+\n+                                    CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n+                                    boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n+                                    if (toBeKept) {\n+                                        diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n+                                    } else {\n+                                        diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n+                                    }\n+                                }\n+                                // else we have a simple node text element, without associated csm element, just keep ignore it\n+                            }\n+                        }\n+\n+                        // Finally we look for the remaining new elements that were not yet added and\n+                        // add all of them\n+                        for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n+                            diffElements.add(diffElIterator++, new Added(elementToAdd));\n+                        }\n                     } else {\n-                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n+                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + givenElement);\n                     }\n-                } else if (diffElement instanceof Reshuffled) {\n-\n-                    // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n-                    Reshuffled reshuffled = (Reshuffled)diffElement;\n-                    CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n-                    CsmMix elementsFromNextOrder = reshuffled.element;\n-\n-                    // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n-                    Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n-\n-                    for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n-                        boolean found = false;\n-                        CsmElement ne = elementsFromNextOrder.getElements().get(ni);\n-                        for (int pi=0;pi<elementsFromPreviousOrder.getElements().size() && !found;pi++) {\n-                            CsmElement pe = elementsFromPreviousOrder.getElements().get(pi);\n-                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n-                                    && matching(ne, pe)) {\n-                                found = true;\n-                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n-                            }\n-                        }\n-                    }\n-\n-                    // We now find out which Node Text elements corresponds to the elements in the original CSM\n-                    final int startNodeTextIndex = givenIndex;\n-                    List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, startNodeTextIndex, node);\n-\n-                    Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n-                    for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n-                        int value = nodeTextIndexOfPreviousElements.get(i);\n-                        if (value != -1) {\n-                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n-                        }\n-                    }\n-                    int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n-\n-                    // Elements to be added at the end\n-                    List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n-                    Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n-                    for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n-                        // If it has a mapping, then it is kept\n-                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n-                            // Ok, it is something new. Where to put it? Let's see what is the first following\n-                            // element that has a mapping\n-                            int originalCsmIndex = -1;\n-                            for (int nj=ni + 1;nj<elementsFromNextOrder.getElements().size() && originalCsmIndex==-1;nj++) {\n-                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n-                                    originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n-                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n-                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n-                                    }\n-                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n-                                }\n-                            }\n-                            // it does not preceed anything, so it goes at the end\n-                            if (originalCsmIndex == -1) {\n-                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n-                            }\n-                        }\n-                    }\n-\n-                    // We go over the original node text elements, in the order they appear in the NodeText.\n-                    // Considering an original node text element (ONE)\n-                    // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n-                    //   we find the correspond OCE (Original CSM Element)\n-                    // * we first add new elements that are marked to be added before OCE\n-                    // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n-                    //   otherwise we add a removed element\n-\n-                    this.getElements().remove(diffIndex);\n-                    int diffElIterator = diffIndex;\n-                    if (lastNodeTextIndex != -1) {\n-                        for (int ntIndex = startNodeTextIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n-\n-                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n-                                int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n-                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n-                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n-                                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n-                                    }\n-                                }\n-\n-                                CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n-                                boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n-                                if (toBeKept) {\n-                                    diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n-                                } else {\n-                                    diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n-                                }\n-                            }\n-                            // else we have a simple node text element, without associated csm element, just keep ignore it\n-                        }\n-                    }\n-\n-                    // Finally we look for the remaining new elements that were not yet added and\n-                    // add all of them\n-                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n-                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n-                    }\n-                } else {\n-                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + givenElement);\n                 }\n             }\n         } while (diffIndex < diffElements.size() || givenIndex < givenElements.size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fb8daf1673c35798aeb7cca8033dd9c9b2e5c4fc": {
			"type": "Ybodychange",
			"commitMessage": "Renamings\n",
			"commitDate": "2018-05-17, 3:24 PM",
			"commitName": "fb8daf1673c35798aeb7cca8033dd9c9b2e5c4fc",
			"commitAuthor": "Thomas Leu",
			"commitDateOld": "2018-05-11, 10:03 AM",
			"commitNameOld": "ae539a6fa91b4a3695df754a8f9e33180f9c466e",
			"commitAuthorOld": "Thomas Leu",
			"daysBetweenCommits": 6.22,
			"commitsBetweenForRepo": 27,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,313 +1,317 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = LexicalPreservingPrinter.findIndentation(node);\n+\n+        List<TextElement> givenElements = nodeText.getElements();\n+        int givenIndex = 0;\n+\n+        List<DifferenceElement> diffElements = this.elements;\n         int diffIndex = 0;\n-        int nodeTextIndex = 0;\n         do {\n-            if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n-                DifferenceElement diffEl = elements.get(diffIndex);\n-                if (diffEl instanceof Kept) {\n-                    Kept kept = (Kept) diffEl;\n+            if (diffIndex < diffElements.size() && givenIndex >= givenElements.size()) {\n+                DifferenceElement diffElement = diffElements.get(diffIndex);\n+                if (diffElement instanceof Kept) {\n+                    Kept kept = (Kept) diffElement;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n-                } else if (diffEl instanceof Added) {\n-                    nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n-                    nodeTextIndex++;\n+                } else if (diffElement instanceof Added) {\n+                    nodeText.addElement(givenIndex, toTextElement(((Added) diffElement).element));\n+                    givenIndex++;\n                     diffIndex++;\n                 } else {\n-                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n+                    throw new UnsupportedOperationException(diffElement.getClass().getSimpleName());\n                 }\n-            } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n-                TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n-                if (nodeTextEl.isWhiteSpaceOrComment()) {\n-                    nodeTextIndex++;\n+            } else if (diffIndex >= diffElements.size() && givenIndex < givenElements.size()) {\n+                TextElement givenElement = givenElements.get(givenIndex);\n+                if (givenElement.isWhiteSpaceOrComment()) {\n+                    givenIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n-                            + this + \" \" + nodeTextEl);\n+                            + this + \" \" + givenElement);\n                 }\n             } else {\n-                DifferenceElement diffEl = elements.get(diffIndex);\n-                TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n-                if (diffEl instanceof Added) {\n-                    CsmElement addedElement = ((Added) diffEl).element;\n+                DifferenceElement diffElement = diffElements.get(diffIndex);\n+                TextElement givenElement = givenElements.get(givenIndex);\n+                if (diffElement instanceof Added) {\n+                    CsmElement addedElement = ((Added) diffElement).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement = toTextElement(addedElement);\n                     boolean used = false;\n-                    if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n-                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n-                            nodeText.addElement(nodeTextIndex++, e);\n+                    if (givenIndex > 0 && givenElements.get(givenIndex - 1).isNewline()) {\n+                        for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n+                            nodeText.addElement(givenIndex++, e);\n                         }\n-                    } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n+                    } else if (isAfterLBrace(nodeText, givenIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n-                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n+                        nodeText.addElement(givenIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n-                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n-                            nodeText.getElements().remove(nodeTextIndex);\n+                        while (givenElements.get(givenIndex).isSpaceOrTab()) {\n+                            givenElements.remove(givenIndex);\n                         }\n-                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n-                            nodeText.addElement(nodeTextIndex++, e);\n+                        for (TextElement e : processIndentation(indentation, givenElements.subList(0, givenIndex - 1))) {\n+                            nodeText.addElement(givenIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n-                                nodeText.addElement(nodeTextIndex++, e);\n+                                nodeText.addElement(givenIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n-                        nodeText.addElement(nodeTextIndex, textElement);\n-                        nodeTextIndex++;\n+                        nodeText.addElement(givenIndex, textElement);\n+                        givenIndex++;\n                     }\n                     if (textElement.isNewline()) {\n-                        boolean followedByUnindent = (diffIndex + 1) < elements.size()\n-                                && elements.get(diffIndex + 1).isAdded()\n-                                && elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n-                        nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* && !addedIndentation*/);\n+                        boolean followedByUnindent = (diffIndex + 1) < diffElements.size()\n+                                && diffElements.get(diffIndex + 1).isAdded()\n+                                && diffElements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n+                        givenIndex = adjustIndentation(indentation, nodeText, givenIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n                     diffIndex++;\n-                } else if (diffEl instanceof Kept) {\n-                    Kept kept = (Kept)diffEl;\n-                    if (nodeTextEl.isComment()) {\n-                        nodeTextIndex++;\n-                    } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n+                } else if (diffElement instanceof Kept) {\n+                    Kept kept = (Kept)diffElement;\n+                    if (givenElement.isComment()) {\n+                        givenIndex++;\n+                    } else if ((kept.element instanceof CsmChild) && givenElement instanceof ChildTextElement) {\n                         diffIndex++;\n-                        nodeTextIndex++;\n-                    } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof TokenTextElement) {\n-                        if (nodeTextEl.isWhiteSpaceOrComment()) {\n-                            nodeTextIndex++;\n+                        givenIndex++;\n+                    } else if ((kept.element instanceof CsmChild) && givenElement instanceof TokenTextElement) {\n+                        if (givenElement.isWhiteSpaceOrComment()) {\n+                            givenIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild = (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n-                                    nodeTextIndex++;\n+                                    givenIndex++;\n                                     diffIndex++;\n                                 } else {\n-                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                                 }\n                             } else {\n-                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                             }\n                         }\n-                    } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n+                    } else if ((kept.element instanceof CsmToken) && givenElement instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n-                        TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n+                        TokenTextElement nodeTextToken = (TokenTextElement) givenElement;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n-                            nodeTextIndex++;\n+                            givenIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n-                            nodeTextIndex++;\n+                            givenIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do, beside considering indentation\n                         diffIndex++;\n-                        for (int i = 0; i < STANDARD_INDENTATION_SIZE && nodeTextIndex >= 1 && nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n-                            nodeText.removeElement(--nodeTextIndex);\n+                        for (int i = 0; i < STANDARD_INDENTATION_SIZE && givenIndex >= 1 && nodeText.getTextElement(givenIndex - 1).isSpaceOrTab(); i++) {\n+                            nodeText.removeElement(--givenIndex);\n                         }\n                     } else {\n-                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + givenElement);\n                     }\n-                } else if (diffEl instanceof Removed) {\n-                    Removed removed = (Removed)diffEl;\n-                    if ((removed.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n-                        ChildTextElement actualChild = (ChildTextElement)nodeTextEl;\n+                } else if (diffElement instanceof Removed) {\n+                    Removed removed = (Removed)diffElement;\n+                    if ((removed.element instanceof CsmChild) && givenElement instanceof ChildTextElement) {\n+                        ChildTextElement actualChild = (ChildTextElement)givenElement;\n                         if (actualChild.isComment()) {\n                             CsmChild csmChild = (CsmChild)removed.element;\n                             // We expected to remove a proper node but we found a comment in between.\n                             // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                             Comment comment = (Comment)actualChild.getChild();\n                             if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(csmChild.getChild())) {\n-                                nodeText.removeElement(nodeTextIndex);\n+                                nodeText.removeElement(givenIndex);\n                             } else {\n-                                nodeTextIndex++;\n+                                givenIndex++;\n                             }\n                         } else {\n-                            nodeText.removeElement(nodeTextIndex);\n-                            if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n-                                nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n+                            nodeText.removeElement(givenIndex);\n+                            if (givenIndex < givenElements.size() && givenElements.get(givenIndex).isNewline()) {\n+                                givenIndex = considerCleaningTheLine(nodeText, givenIndex);\n                             } else {\n                                 if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n-                                    nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n+                                    givenIndex = considerEnforcingIndentation(nodeText, givenIndex);\n                                 }\n                                 // If in front we have one space and before also we had space let's drop one space\n-                                if (nodeText.getElements().size() > nodeTextIndex && nodeTextIndex > 0) {\n-                                    if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n-                                            && nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n+                                if (givenElements.size() > givenIndex && givenIndex > 0) {\n+                                    if (givenElements.get(givenIndex).isWhiteSpace()\n+                                            && givenElements.get(givenIndex - 1).isWhiteSpace()) {\n                                         // However we do not want to do that when we are about to adding or removing elements\n-                                        if ((diffIndex + 1) == this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n-                                            nodeText.getElements().remove(nodeTextIndex--);\n+                                        if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n+                                            givenElements.remove(givenIndex--);\n                                         }\n                                     }\n                                 }\n                             }\n                             diffIndex++;\n                         }\n-                    } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n-                            && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n-                        nodeText.removeElement(nodeTextIndex);\n+                    } else if ((removed.element instanceof CsmToken) && givenElement instanceof TokenTextElement\n+                            && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)givenElement).getTokenKind()) {\n+                        nodeText.removeElement(givenIndex);\n                         diffIndex++;\n-                    } else if (nodeTextEl instanceof TokenTextElement\n-                            && nodeTextEl.isWhiteSpaceOrComment()) {\n-                        nodeTextIndex++;\n+                    } else if (givenElement instanceof TokenTextElement\n+                            && givenElement.isWhiteSpaceOrComment()) {\n+                        givenIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             && ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n-                        if (isPrimitiveType(nodeTextEl)) {\n-                            nodeText.removeElement(nodeTextIndex);\n+                        if (isPrimitiveType(givenElement)) {\n+                            nodeText.removeElement(givenIndex);\n                             diffIndex++;\n                         } else {\n-                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n+                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n-                    } else if (nodeTextEl.isWhiteSpace()) {\n-                        nodeTextIndex++;\n+                    } else if (givenElement.isWhiteSpace()) {\n+                        givenIndex++;\n                     } else {\n-                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n+                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + givenElement);\n                     }\n-                } else if (diffEl instanceof Reshuffled) {\n+                } else if (diffElement instanceof Reshuffled) {\n \n                     // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n-                    Reshuffled reshuffled = (Reshuffled)diffEl;\n+                    Reshuffled reshuffled = (Reshuffled)diffElement;\n                     CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder = reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n \n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         boolean found = false;\n                         CsmElement ne = elementsFromNextOrder.getElements().get(ni);\n                         for (int pi=0;pi<elementsFromPreviousOrder.getElements().size() && !found;pi++) {\n                             CsmElement pe = elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                     && matching(ne, pe)) {\n                                 found = true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n-                    final int startNodeTextIndex = nodeTextIndex;\n+                    final int startNodeTextIndex = givenIndex;\n                     List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, startNodeTextIndex, node);\n \n                     Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                     for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                         int value = nodeTextIndexOfPreviousElements.get(i);\n                         if (value != -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                     Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let's see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex = -1;\n                             for (int nj=ni + 1;nj<elementsFromNextOrder.getElements().size() && originalCsmIndex==-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex == -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator = diffIndex;\n                     if (lastNodeTextIndex != -1) {\n                         for (int ntIndex = startNodeTextIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n-                                        elements.add(diffElIterator++, new Added(elementToAdd));\n+                                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n-                                    elements.add(diffElIterator++, new Kept(originalCSMElement));\n+                                    diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n-                                    elements.add(diffElIterator++, new Removed(originalCSMElement));\n+                                    diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             }\n                             // else we have a simple node text element, without associated csm element, just keep ignore it\n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n-                        elements.add(diffElIterator++, new Added(elementToAdd));\n+                        diffElements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n-                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n+                    throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + givenElement);\n                 }\n             }\n-        } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n+        } while (diffIndex < diffElements.size() || givenIndex < givenElements.size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5123e075b8411953473b23c82e64d8d23edb9181": {
			"type": "Ybodychange",
			"commitMessage": "Fixed issue 1461 - wrong identation when adding new annotation\n",
			"commitDate": "2018-05-10, 7:47 PM",
			"commitName": "5123e075b8411953473b23c82e64d8d23edb9181",
			"commitAuthor": "Thomas Leu",
			"commitDateOld": "2018-03-11, 11:38 AM",
			"commitNameOld": "98e6c2f915a109d3157bed8cc2b775b430894535",
			"commitAuthorOld": "Danny van Bruggen",
			"daysBetweenCommits": 60.34,
			"commitsBetweenForRepo": 74,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,314 +1,313 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = LexicalPreservingPrinter.findIndentation(node);\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement = ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement = toTextElement(addedElement);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent = (diffIndex + 1) < elements.size()\n                                 && elements.get(diffIndex + 1).isAdded()\n                                 && elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if (nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (nodeTextEl.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild = (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do, beside considering indentation\n                         diffIndex++;\n                         for (int i = 0; i < STANDARD_INDENTATION_SIZE && nodeTextIndex >= 1 && nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         ChildTextElement actualChild = (ChildTextElement)nodeTextEl;\n                         if (actualChild.isComment()) {\n                             CsmChild csmChild = (CsmChild)removed.element;\n                             // We expected to remove a proper node but we found a comment in between.\n                             // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                             Comment comment = (Comment)actualChild.getChild();\n                             if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(csmChild.getChild())) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             nodeText.removeElement(nodeTextIndex);\n                             if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                                 nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                             } else {\n                                 if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                     nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                                 }\n                                 // If in front we have one space and before also we had space let's drop one space\n                                 if (nodeText.getElements().size() > nodeTextIndex && nodeTextIndex > 0) {\n                                     if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                             && nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                         // However we do not want to do that when we are about to adding or removing elements\n                                         if ((diffIndex + 1) == this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                             nodeText.getElements().remove(nodeTextIndex--);\n                                         }\n                                     }\n                                 }\n                             }\n                             diffIndex++;\n                         }\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             && ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled = (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder = reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n+\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         boolean found = false;\n                         CsmElement ne = elementsFromNextOrder.getElements().get(ni);\n                         for (int pi=0;pi<elementsFromPreviousOrder.getElements().size() && !found;pi++) {\n                             CsmElement pe = elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                     && matching(ne, pe)) {\n                                 found = true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex = nodeTextIndex;\n-                    final Set<Integer> usedIndexes = new HashSet<>();\n-                    List<Integer> nodeTextIndexOfPreviousElements = elementsFromPreviousOrder.getElements().stream()\n-                            .map(it -> findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n-                            .collect(Collectors.toList());\n+                    List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, startNodeTextIndex, node);\n+\n                     Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                     for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                         int value = nodeTextIndexOfPreviousElements.get(i);\n                         if (value != -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                     Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let's see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex = -1;\n                             for (int nj=ni + 1;nj<elementsFromNextOrder.getElements().size() && originalCsmIndex==-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex == -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator = diffIndex;\n                     if (lastNodeTextIndex != -1) {\n                         for (int ntIndex = startNodeTextIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             }\n                             // else we have a simple node text element, without associated csm element, just keep ignore it\n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"478b82aa16242a7324a16ffc9df8811309228234": {
			"type": "Ybodychange",
			"commitMessage": "improve how comments are handled by LexicalPreservingPrinter #1297\n",
			"commitDate": "2018-01-13, 6:14 AM",
			"commitName": "478b82aa16242a7324a16ffc9df8811309228234",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-11-13, 12:21 PM",
			"commitNameOld": "3a31705ba43ab2968ab2f113272b2462c91027bb",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 60.75,
			"commitsBetweenForRepo": 112,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,314 +1,314 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = LexicalPreservingPrinter.findIndentation(node);\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement = ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement = toTextElement(addedElement);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent = (diffIndex + 1) < elements.size()\n                                 && elements.get(diffIndex + 1).isAdded()\n                                 && elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n-                    if ((kept.element instanceof CsmChild) && nodeTextEl.isComment()) {\n+                    if (nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (nodeTextEl.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild = (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do, beside considering indentation\n                         diffIndex++;\n                         for (int i = 0; i < STANDARD_INDENTATION_SIZE && nodeTextIndex >= 1 && nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         ChildTextElement actualChild = (ChildTextElement)nodeTextEl;\n                         if (actualChild.isComment()) {\n                             CsmChild csmChild = (CsmChild)removed.element;\n                             // We expected to remove a proper node but we found a comment in between.\n                             // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                             Comment comment = (Comment)actualChild.getChild();\n                             if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(csmChild.getChild())) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             nodeText.removeElement(nodeTextIndex);\n                             if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                                 nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                             } else {\n                                 if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                     nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                                 }\n                                 // If in front we have one space and before also we had space let's drop one space\n                                 if (nodeText.getElements().size() > nodeTextIndex && nodeTextIndex > 0) {\n                                     if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                             && nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                         // However we do not want to do that when we are about to adding or removing elements\n                                         if ((diffIndex + 1) == this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n                                             nodeText.getElements().remove(nodeTextIndex--);\n                                         }\n                                     }\n                                 }\n                             }\n                             diffIndex++;\n                         }\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             && ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled = (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder = reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         boolean found = false;\n                         CsmElement ne = elementsFromNextOrder.getElements().get(ni);\n                         for (int pi=0;pi<elementsFromPreviousOrder.getElements().size() && !found;pi++) {\n                             CsmElement pe = elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                     && matching(ne, pe)) {\n                                 found = true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex = nodeTextIndex;\n                     final Set<Integer> usedIndexes = new HashSet<>();\n                     List<Integer> nodeTextIndexOfPreviousElements = elementsFromPreviousOrder.getElements().stream()\n                             .map(it -> findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                     for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                         int value = nodeTextIndexOfPreviousElements.get(i);\n                         if (value != -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                     Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let's see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex = -1;\n                             for (int nj=ni + 1;nj<elementsFromNextOrder.getElements().size() && originalCsmIndex==-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex == -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator = diffIndex;\n                     if (lastNodeTextIndex != -1) {\n                         for (int ntIndex = startNodeTextIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             }\n                             // else we have a simple node text element, without associated csm element, just keep ignore it\n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3a31705ba43ab2968ab2f113272b2462c91027bb": {
			"type": "Ybodychange",
			"commitMessage": "delete comments associated to nodes to be deleted #1244\n",
			"commitDate": "2017-11-13, 12:21 PM",
			"commitName": "3a31705ba43ab2968ab2f113272b2462c91027bb",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-09-20, 9:39 AM",
			"commitNameOld": "6149218487aac50fad2256c8723639671747d7bb",
			"commitAuthorOld": "Danny van Bruggen",
			"daysBetweenCommits": 54.15,
			"commitsBetweenForRepo": 156,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,301 +1,314 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = LexicalPreservingPrinter.findIndentation(node);\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement = ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement = toTextElement(addedElement);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent = (diffIndex + 1) < elements.size()\n                                 && elements.get(diffIndex + 1).isAdded()\n                                 && elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (nodeTextEl.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild = (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do, beside considering indentation\n                         diffIndex++;\n                         for (int i = 0; i < STANDARD_INDENTATION_SIZE && nodeTextIndex >= 1 && nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n-                        nodeText.removeElement(nodeTextIndex);\n-                        if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n-                            nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n-                        } else {\n-                            if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n-                                nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n+                        ChildTextElement actualChild = (ChildTextElement)nodeTextEl;\n+                        if (actualChild.isComment()) {\n+                            CsmChild csmChild = (CsmChild)removed.element;\n+                            // We expected to remove a proper node but we found a comment in between.\n+                            // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n+                            Comment comment = (Comment)actualChild.getChild();\n+                            if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(csmChild.getChild())) {\n+                                nodeText.removeElement(nodeTextIndex);\n+                            } else {\n+                                nodeTextIndex++;\n                             }\n-                            // If in front we have one space and before also we had space let's drop one space\n-                            if (nodeText.getElements().size() > nodeTextIndex && nodeTextIndex > 0) {\n-                                if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n-                                        && nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n-                                    // However we do not want to do that when we are about to adding or removing elements\n-                                    if ((diffIndex + 1 )== this.elements.size() || (elements.get(diffIndex +1 ) instanceof Kept)) {\n-                                        nodeText.getElements().remove(nodeTextIndex--);\n+                        } else {\n+                            nodeText.removeElement(nodeTextIndex);\n+                            if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n+                                nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n+                            } else {\n+                                if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n+                                    nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n+                                }\n+                                // If in front we have one space and before also we had space let's drop one space\n+                                if (nodeText.getElements().size() > nodeTextIndex && nodeTextIndex > 0) {\n+                                    if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n+                                            && nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n+                                        // However we do not want to do that when we are about to adding or removing elements\n+                                        if ((diffIndex + 1) == this.elements.size() || (elements.get(diffIndex + 1) instanceof Kept)) {\n+                                            nodeText.getElements().remove(nodeTextIndex--);\n+                                        }\n                                     }\n                                 }\n                             }\n+                            diffIndex++;\n                         }\n-                        diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             && ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled = (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder = reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         boolean found = false;\n                         CsmElement ne = elementsFromNextOrder.getElements().get(ni);\n                         for (int pi=0;pi<elementsFromPreviousOrder.getElements().size() && !found;pi++) {\n                             CsmElement pe = elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                     && matching(ne, pe)) {\n                                 found = true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex = nodeTextIndex;\n                     final Set<Integer> usedIndexes = new HashSet<>();\n                     List<Integer> nodeTextIndexOfPreviousElements = elementsFromPreviousOrder.getElements().stream()\n                             .map(it -> findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                     for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                         int value = nodeTextIndexOfPreviousElements.get(i);\n                         if (value != -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                     Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let's see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex = -1;\n                             for (int nj=ni + 1;nj<elementsFromNextOrder.getElements().size() && originalCsmIndex==-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex == -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator = diffIndex;\n                     if (lastNodeTextIndex != -1) {\n                         for (int ntIndex = startNodeTextIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             }\n                             // else we have a simple node text element, without associated csm element, just keep ignore it\n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6149218487aac50fad2256c8723639671747d7bb": {
			"type": "Ybodychange",
			"commitMessage": "Remove dependency on LPP for finding nodetext\n",
			"commitDate": "2017-09-20, 9:39 AM",
			"commitName": "6149218487aac50fad2256c8723639671747d7bb",
			"commitAuthor": "Danny van Bruggen",
			"commitDateOld": "2017-08-12, 4:08 PM",
			"commitNameOld": "23226e3befe168df74edef0272ab2a562810074b",
			"commitAuthorOld": "Danny van Bruggen",
			"daysBetweenCommits": 38.73,
			"commitsBetweenForRepo": 108,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,301 +1,301 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n-        List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n+        List<TokenTextElement> indentation = LexicalPreservingPrinter.findIndentation(node);\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n-                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n+                    nodeText.addElement(nodeTextIndex, toTextElement(((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement = ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n-                    TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n+                    TextElement textElement = toTextElement(addedElement);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent = (diffIndex + 1) < elements.size()\n                                 && elements.get(diffIndex + 1).isAdded()\n                                 && elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (nodeTextEl.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild = (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do, beside considering indentation\n                         diffIndex++;\n                         for (int i = 0; i < STANDARD_INDENTATION_SIZE && nodeTextIndex >= 1 && nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                             // If in front we have one space and before also we had space let's drop one space\n                             if (nodeText.getElements().size() > nodeTextIndex && nodeTextIndex > 0) {\n                                 if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                         && nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                     // However we do not want to do that when we are about to adding or removing elements\n                                     if ((diffIndex + 1 )== this.elements.size() || (elements.get(diffIndex +1 ) instanceof Kept)) {\n                                         nodeText.getElements().remove(nodeTextIndex--);\n                                     }\n                                 }\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             && ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled = (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder = reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         boolean found = false;\n                         CsmElement ne = elementsFromNextOrder.getElements().get(ni);\n                         for (int pi=0;pi<elementsFromPreviousOrder.getElements().size() && !found;pi++) {\n                             CsmElement pe = elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                     && matching(ne, pe)) {\n                                 found = true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex = nodeTextIndex;\n                     final Set<Integer> usedIndexes = new HashSet<>();\n                     List<Integer> nodeTextIndexOfPreviousElements = elementsFromPreviousOrder.getElements().stream()\n                             .map(it -> findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                     for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                         int value = nodeTextIndexOfPreviousElements.get(i);\n                         if (value != -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                     Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let's see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex = -1;\n                             for (int nj=ni + 1;nj<elementsFromNextOrder.getElements().size() && originalCsmIndex==-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex == -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator = diffIndex;\n                     if (lastNodeTextIndex != -1) {\n                         for (int ntIndex = startNodeTextIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             }\n                             // else we have a simple node text element, without associated csm element, just keep ignore it\n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"516947a3d4eda478d20dcbb4216d6c52cf11d169": {
			"type": "Ybodychange",
			"commitMessage": "cleanup following IDEA suggestions #1001\n",
			"commitDate": "2017-07-19, 9:34 AM",
			"commitName": "516947a3d4eda478d20dcbb4216d6c52cf11d169",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-07-19, 9:19 AM",
			"commitNameOld": "b83b81211f26f9259b032b188bb2482aa390df0d",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,303 +1,301 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement = ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent = (diffIndex + 1) < elements.size()\n                                 && elements.get(diffIndex + 1).isAdded()\n                                 && elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (nodeTextEl.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild = (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do, beside considering indentation\n                         diffIndex++;\n                         for (int i = 0; i < STANDARD_INDENTATION_SIZE && nodeTextIndex >= 1 && nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                             // If in front we have one space and before also we had space let's drop one space\n                             if (nodeText.getElements().size() > nodeTextIndex && nodeTextIndex > 0) {\n                                 if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                         && nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                     // However we do not want to do that when we are about to adding or removing elements\n                                     if ((diffIndex + 1 )== this.elements.size() || (elements.get(diffIndex +1 ) instanceof Kept)) {\n                                         nodeText.getElements().remove(nodeTextIndex--);\n                                     }\n                                 }\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             && ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled = (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder = reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         boolean found = false;\n                         CsmElement ne = elementsFromNextOrder.getElements().get(ni);\n                         for (int pi=0;pi<elementsFromPreviousOrder.getElements().size() && !found;pi++) {\n                             CsmElement pe = elementsFromPreviousOrder.getElements().get(pi);\n-                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n+                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pi)\n                                     && matching(ne, pe)) {\n                                 found = true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex = nodeTextIndex;\n                     final Set<Integer> usedIndexes = new HashSet<>();\n                     List<Integer> nodeTextIndexOfPreviousElements = elementsFromPreviousOrder.getElements().stream()\n                             .map(it -> findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                     for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                         int value = nodeTextIndexOfPreviousElements.get(i);\n                         if (value != -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                     Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let's see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex = -1;\n                             for (int nj=ni + 1;nj<elementsFromNextOrder.getElements().size() && originalCsmIndex==-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex == -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator = diffIndex;\n                     if (lastNodeTextIndex != -1) {\n                         for (int ntIndex = startNodeTextIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n-                            } else {\n-                                // simple node text element, without associated csm element, just keep ignore it\n                             }\n-\n+                            // else we have a simple node text element, without associated csm element, just keep ignore it\n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6a1ee724c337694ee28b2a09af41c236b880ba66": {
			"type": "Ybodychange",
			"commitMessage": "Take TokenType into consideration\n",
			"commitDate": "2017-07-18, 1:42 PM",
			"commitName": "6a1ee724c337694ee28b2a09af41c236b880ba66",
			"commitAuthor": "Danny van Bruggen",
			"commitDateOld": "2017-07-12, 10:46 AM",
			"commitNameOld": "c3f372b0c7c8ca4bed1261e7f1d3f17ed01b4889",
			"commitAuthorOld": "Danny van Bruggen",
			"daysBetweenCommits": 6.12,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,303 +1,303 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement = ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n-                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n+                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent = (diffIndex + 1) < elements.size()\n                                 && elements.get(diffIndex + 1).isAdded()\n                                 && elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (nodeTextEl.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild = (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do, beside considering indentation\n                         diffIndex++;\n                         for (int i = 0; i < STANDARD_INDENTATION_SIZE && nodeTextIndex >= 1 && nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                             // If in front we have one space and before also we had space let's drop one space\n                             if (nodeText.getElements().size() > nodeTextIndex && nodeTextIndex > 0) {\n                                 if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                         && nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                     // However we do not want to do that when we are about to adding or removing elements\n                                     if ((diffIndex + 1 )== this.elements.size() || (elements.get(diffIndex +1 ) instanceof Kept)) {\n                                         nodeText.getElements().remove(nodeTextIndex--);\n                                     }\n                                 }\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             && ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled = (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder = reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         boolean found = false;\n                         CsmElement ne = elementsFromNextOrder.getElements().get(ni);\n                         for (int pi=0;pi<elementsFromPreviousOrder.getElements().size() && !found;pi++) {\n                             CsmElement pe = elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                     && matching(ne, pe)) {\n                                 found = true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex = nodeTextIndex;\n                     final Set<Integer> usedIndexes = new HashSet<>();\n                     List<Integer> nodeTextIndexOfPreviousElements = elementsFromPreviousOrder.getElements().stream()\n                             .map(it -> findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                     for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                         int value = nodeTextIndexOfPreviousElements.get(i);\n                         if (value != -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                     Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let's see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex = -1;\n                             for (int nj=ni + 1;nj<elementsFromNextOrder.getElements().size() && originalCsmIndex==-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex == -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator = diffIndex;\n                     if (lastNodeTextIndex != -1) {\n                         for (int ntIndex = startNodeTextIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             } else {\n                                 // simple node text element, without associated csm element, just keep ignore it\n                             }\n \n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c3f372b0c7c8ca4bed1261e7f1d3f17ed01b4889": {
			"type": "Ybodychange",
			"commitMessage": "A lot more intellij inspection results\n",
			"commitDate": "2017-07-12, 10:46 AM",
			"commitName": "c3f372b0c7c8ca4bed1261e7f1d3f17ed01b4889",
			"commitAuthor": "Danny van Bruggen",
			"commitDateOld": "2017-05-21, 5:34 AM",
			"commitNameOld": "7d55cf4c1cac9c2f8a3a917cfadfaf921e11e2b2",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 52.22,
			"commitsBetweenForRepo": 69,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,303 +1,303 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement = ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent = (diffIndex + 1) < elements.size()\n                                 && elements.get(diffIndex + 1).isAdded()\n                                 && elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof TokenTextElement) {\n-                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n+                        if (nodeTextEl.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild = (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do, beside considering indentation\n                         diffIndex++;\n                         for (int i = 0; i < STANDARD_INDENTATION_SIZE && nodeTextIndex >= 1 && nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                             // If in front we have one space and before also we had space let's drop one space\n                             if (nodeText.getElements().size() > nodeTextIndex && nodeTextIndex > 0) {\n                                 if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                         && nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                     // However we do not want to do that when we are about to adding or removing elements\n                                     if ((diffIndex + 1 )== this.elements.size() || (elements.get(diffIndex +1 ) instanceof Kept)) {\n                                         nodeText.getElements().remove(nodeTextIndex--);\n                                     }\n                                 }\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             && ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled = (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder = reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         boolean found = false;\n                         CsmElement ne = elementsFromNextOrder.getElements().get(ni);\n                         for (int pi=0;pi<elementsFromPreviousOrder.getElements().size() && !found;pi++) {\n                             CsmElement pe = elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                     && matching(ne, pe)) {\n                                 found = true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex = nodeTextIndex;\n                     final Set<Integer> usedIndexes = new HashSet<>();\n                     List<Integer> nodeTextIndexOfPreviousElements = elementsFromPreviousOrder.getElements().stream()\n                             .map(it -> findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                     for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                         int value = nodeTextIndexOfPreviousElements.get(i);\n                         if (value != -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                     Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let's see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex = -1;\n                             for (int nj=ni + 1;nj<elementsFromNextOrder.getElements().size() && originalCsmIndex==-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex == -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator = diffIndex;\n                     if (lastNodeTextIndex != -1) {\n                         for (int ntIndex = startNodeTextIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             } else {\n                                 // simple node text element, without associated csm element, just keep ignore it\n                             }\n \n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7d55cf4c1cac9c2f8a3a917cfadfaf921e11e2b2": {
			"type": "Ybodychange",
			"commitMessage": "cleaning up PR 932\n",
			"commitDate": "2017-05-21, 5:34 AM",
			"commitName": "7d55cf4c1cac9c2f8a3a917cfadfaf921e11e2b2",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-05-21, 5:26 AM",
			"commitNameOld": "a3359354bf46a3459c2262ba520c95ba4bf02a58",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,313 +1,303 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement = ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent = (diffIndex + 1) < elements.size()\n                                 && elements.get(diffIndex + 1).isAdded()\n                                 && elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild = (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n-                        // Nothing to do\n+                        // Nothing to do, beside considering indentation\n                         diffIndex++;\n                         for (int i = 0; i < STANDARD_INDENTATION_SIZE && nodeTextIndex >= 1 && nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                             // If in front we have one space and before also we had space let's drop one space\n                             if (nodeText.getElements().size() > nodeTextIndex && nodeTextIndex > 0) {\n                                 if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                         && nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                     // However we do not want to do that when we are about to adding or removing elements\n                                     if ((diffIndex + 1 )== this.elements.size() || (elements.get(diffIndex +1 ) instanceof Kept)) {\n                                         nodeText.getElements().remove(nodeTextIndex--);\n                                     }\n                                 }\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             && ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled = (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder = reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         boolean found = false;\n                         CsmElement ne = elementsFromNextOrder.getElements().get(ni);\n                         for (int pi=0;pi<elementsFromPreviousOrder.getElements().size() && !found;pi++) {\n                             CsmElement pe = elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                     && matching(ne, pe)) {\n                                 found = true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex = nodeTextIndex;\n                     final Set<Integer> usedIndexes = new HashSet<>();\n                     List<Integer> nodeTextIndexOfPreviousElements = elementsFromPreviousOrder.getElements().stream()\n                             .map(it -> findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                     for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                         int value = nodeTextIndexOfPreviousElements.get(i);\n                         if (value != -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                     Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let's see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex = -1;\n                             for (int nj=ni + 1;nj<elementsFromNextOrder.getElements().size() && originalCsmIndex==-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex == -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator = diffIndex;\n                     if (lastNodeTextIndex != -1) {\n                         for (int ntIndex = startNodeTextIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             } else {\n                                 // simple node text element, without associated csm element, just keep ignore it\n                             }\n \n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n-\n-                    // Check if the last thing we added is a space\n-                    //if (diffElIterator > startIndex\n-                    //        && elements.get(diffElIterator - 1).isAdded()\n-                    //        && elements.get(diffElIterator - 1).getElement() instanceof TokenTextElement\n-                    //        && ((TokenTextElement)elements.get(diffElIterator - 1).getElement()).isWhiteSpace()) {\n-                    //\n-                    //}\n-                    int v= 0;\n-\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a3359354bf46a3459c2262ba520c95ba4bf02a58": {
			"type": "Ybodychange",
			"commitMessage": "correct space merging to work only when there is a kept\n",
			"commitDate": "2017-05-21, 5:26 AM",
			"commitName": "a3359354bf46a3459c2262ba520c95ba4bf02a58",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-05-21, 5:26 AM",
			"commitNameOld": "1a0ffde702735e1e1deda6d092e92eee2305bd14",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,313 +1,313 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement = ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent = (diffIndex + 1) < elements.size()\n                                 && elements.get(diffIndex + 1).isAdded()\n                                 && elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild = (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do\n                         diffIndex++;\n                         for (int i = 0; i < STANDARD_INDENTATION_SIZE && nodeTextIndex >= 1 && nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                             // If in front we have one space and before also we had space let's drop one space\n                             if (nodeText.getElements().size() > nodeTextIndex && nodeTextIndex > 0) {\n                                 if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                         && nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n-                                    // However we do not want to do that when we are doing a replacement\n-                                    if ((diffIndex + 1 )== this.elements.size() || !(elements.get(diffIndex +1 ) instanceof Added)) {\n+                                    // However we do not want to do that when we are about to adding or removing elements\n+                                    if ((diffIndex + 1 )== this.elements.size() || (elements.get(diffIndex +1 ) instanceof Kept)) {\n                                         nodeText.getElements().remove(nodeTextIndex--);\n                                     }\n                                 }\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             && ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled = (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder = reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         boolean found = false;\n                         CsmElement ne = elementsFromNextOrder.getElements().get(ni);\n                         for (int pi=0;pi<elementsFromPreviousOrder.getElements().size() && !found;pi++) {\n                             CsmElement pe = elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                     && matching(ne, pe)) {\n                                 found = true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex = nodeTextIndex;\n                     final Set<Integer> usedIndexes = new HashSet<>();\n                     List<Integer> nodeTextIndexOfPreviousElements = elementsFromPreviousOrder.getElements().stream()\n                             .map(it -> findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                     for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                         int value = nodeTextIndexOfPreviousElements.get(i);\n                         if (value != -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                     Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let's see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex = -1;\n                             for (int nj=ni + 1;nj<elementsFromNextOrder.getElements().size() && originalCsmIndex==-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex == -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator = diffIndex;\n                     if (lastNodeTextIndex != -1) {\n                         for (int ntIndex = startNodeTextIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             } else {\n                                 // simple node text element, without associated csm element, just keep ignore it\n                             }\n \n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n \n                     // Check if the last thing we added is a space\n                     //if (diffElIterator > startIndex\n                     //        && elements.get(diffElIterator - 1).isAdded()\n                     //        && elements.get(diffElIterator - 1).getElement() instanceof TokenTextElement\n                     //        && ((TokenTextElement)elements.get(diffElIterator - 1).getElement()).isWhiteSpace()) {\n                     //\n                     //}\n                     int v= 0;\n \n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cbf3d3d09837a5648602ac7ececc3322144e68f0": {
			"type": "Ybodychange",
			"commitMessage": "fix CsmMix.prettyPrint\n",
			"commitDate": "2017-05-21, 5:26 AM",
			"commitName": "cbf3d3d09837a5648602ac7ececc3322144e68f0",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-05-21, 5:26 AM",
			"commitNameOld": "74dc0e58a9a6aa10a2c41bf121af592df43c30fe",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,304 +1,313 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement = ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent = (diffIndex + 1) < elements.size()\n                                 && elements.get(diffIndex + 1).isAdded()\n                                 && elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild = (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do\n                         diffIndex++;\n                         for (int i = 0; i < STANDARD_INDENTATION_SIZE && nodeTextIndex >= 1 && nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                             // If in front we have one space and before also we had space let's drop one space\n                             if (nodeText.getElements().size() > nodeTextIndex && nodeTextIndex > 0) {\n                                 if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n                                         && nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n                                     // However we do not want to do that when we are doing a replacement\n                                     if ((diffIndex + 1 )== this.elements.size() || !(elements.get(diffIndex +1 ) instanceof Added)) {\n                                         nodeText.getElements().remove(nodeTextIndex--);\n                                     }\n                                 }\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             && ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled = (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder = reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         boolean found = false;\n                         CsmElement ne = elementsFromNextOrder.getElements().get(ni);\n                         for (int pi=0;pi<elementsFromPreviousOrder.getElements().size() && !found;pi++) {\n                             CsmElement pe = elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                     && matching(ne, pe)) {\n                                 found = true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex = nodeTextIndex;\n                     final Set<Integer> usedIndexes = new HashSet<>();\n                     List<Integer> nodeTextIndexOfPreviousElements = elementsFromPreviousOrder.getElements().stream()\n                             .map(it -> findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                     for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                         int value = nodeTextIndexOfPreviousElements.get(i);\n                         if (value != -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                     Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let's see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex = -1;\n                             for (int nj=ni + 1;nj<elementsFromNextOrder.getElements().size() && originalCsmIndex==-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex == -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator = diffIndex;\n                     if (lastNodeTextIndex != -1) {\n                         for (int ntIndex = startNodeTextIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             } else {\n                                 // simple node text element, without associated csm element, just keep ignore it\n                             }\n \n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n \n+                    // Check if the last thing we added is a space\n+                    //if (diffElIterator > startIndex\n+                    //        && elements.get(diffElIterator - 1).isAdded()\n+                    //        && elements.get(diffElIterator - 1).getElement() instanceof TokenTextElement\n+                    //        && ((TokenTextElement)elements.get(diffElIterator - 1).getElement()).isWhiteSpace()) {\n+                    //\n+                    //}\n+                    int v= 0;\n+\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"74dc0e58a9a6aa10a2c41bf121af592df43c30fe": {
			"type": "Ybodychange",
			"commitMessage": "working on whitespace reconciliation\n",
			"commitDate": "2017-05-21, 5:26 AM",
			"commitName": "74dc0e58a9a6aa10a2c41bf121af592df43c30fe",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-05-21, 5:26 AM",
			"commitNameOld": "e9796ac7c5a26db2e4a8b37b781b1c5933b8c1fd",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,294 +1,304 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement = ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent = (diffIndex + 1) < elements.size()\n                                 && elements.get(diffIndex + 1).isAdded()\n                                 && elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild = (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do\n                         diffIndex++;\n                         for (int i = 0; i < STANDARD_INDENTATION_SIZE && nodeTextIndex >= 1 && nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n+                            // If in front we have one space and before also we had space let's drop one space\n+                            if (nodeText.getElements().size() > nodeTextIndex && nodeTextIndex > 0) {\n+                                if (nodeText.getElements().get(nodeTextIndex).isWhiteSpace()\n+                                        && nodeText.getElements().get(nodeTextIndex - 1).isWhiteSpace()) {\n+                                    // However we do not want to do that when we are doing a replacement\n+                                    if ((diffIndex + 1 )== this.elements.size() || !(elements.get(diffIndex +1 ) instanceof Added)) {\n+                                        nodeText.getElements().remove(nodeTextIndex--);\n+                                    }\n+                                }\n+                            }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             && ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled = (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder = reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         boolean found = false;\n                         CsmElement ne = elementsFromNextOrder.getElements().get(ni);\n                         for (int pi=0;pi<elementsFromPreviousOrder.getElements().size() && !found;pi++) {\n                             CsmElement pe = elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                     && matching(ne, pe)) {\n                                 found = true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex = nodeTextIndex;\n                     final Set<Integer> usedIndexes = new HashSet<>();\n                     List<Integer> nodeTextIndexOfPreviousElements = elementsFromPreviousOrder.getElements().stream()\n                             .map(it -> findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                     for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                         int value = nodeTextIndexOfPreviousElements.get(i);\n                         if (value != -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                     Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let's see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex = -1;\n                             for (int nj=ni + 1;nj<elementsFromNextOrder.getElements().size() && originalCsmIndex==-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex == -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator = diffIndex;\n                     if (lastNodeTextIndex != -1) {\n                         for (int ntIndex = startNodeTextIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             } else {\n                                 // simple node text element, without associated csm element, just keep ignore it\n                             }\n \n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n \n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7c051d8316c3c9270f191bae4a5323b92f283420": {
			"type": "Ybodychange",
			"commitMessage": "removing dead code #866\n",
			"commitDate": "2017-05-21, 5:26 AM",
			"commitName": "7c051d8316c3c9270f191bae4a5323b92f283420",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-05-21, 5:26 AM",
			"commitNameOld": "f8d5e2fda0aedca5f9a9cb726f7787286bbfd05e",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,314 +1,293 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement = ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent = (diffIndex + 1) < elements.size()\n                                 && elements.get(diffIndex + 1).isAdded()\n                                 && elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof CsmChild) {\n                                 CsmChild keptChild = (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do\n                         diffIndex++;\n                         for (int i = 0; i < STANDARD_INDENTATION_SIZE && nodeTextIndex >= 1 && nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmChild\n                             && ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Reshuffled) {\n \n                     // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                     Reshuffled reshuffled = (Reshuffled)diffEl;\n                     CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n                     CsmMix elementsFromNextOrder = reshuffled.element;\n \n                     // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                     Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         boolean found = false;\n                         CsmElement ne = elementsFromNextOrder.getElements().get(ni);\n                         for (int pi=0;pi<elementsFromPreviousOrder.getElements().size() && !found;pi++) {\n                             CsmElement pe = elementsFromPreviousOrder.getElements().get(pi);\n                             if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n                                     && matching(ne, pe)) {\n                                 found = true;\n                                 correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n                             }\n                         }\n                     }\n \n                     // We now find out which Node Text elements corresponds to the elements in the original CSM\n                     final int startNodeTextIndex = nodeTextIndex;\n                     final Set<Integer> usedIndexes = new HashSet<>();\n                     List<Integer> nodeTextIndexOfPreviousElements = elementsFromPreviousOrder.getElements().stream()\n                             .map(it -> findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n                             .collect(Collectors.toList());\n                     Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                     for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n                         int value = nodeTextIndexOfPreviousElements.get(i);\n                         if (value != -1) {\n                             nodeTextIndexToPreviousCSMIndex.put(value, i);\n                         }\n                     }\n                     int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n \n                     // Elements to be added at the end\n                     List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                     Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                     for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n                         // If it has a mapping, then it is kept\n                         if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                             // Ok, it is something new. Where to put it? Let's see what is the first following\n                             // element that has a mapping\n                             int originalCsmIndex = -1;\n                             for (int nj=ni + 1;nj<elementsFromNextOrder.getElements().size() && originalCsmIndex==-1;nj++) {\n                                 if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                     originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                     if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n                                         elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                     }\n                                     elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n                                 }\n                             }\n                             // it does not preceed anything, so it goes at the end\n                             if (originalCsmIndex == -1) {\n                                 elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n                             }\n                         }\n                     }\n \n-\n-\n-                    //Map<Integer, List<CsmElement>> elementsToAddBeforeGivenNodeTextIndex = new HashMap<>();\n-                    //List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n-                    //Set<Integer> nodeTextElementsToKeep = new HashSet<>();\n-\n-                    // Let's figure out which ones of the existing tokens are going to be removed\n-\n-                    // Now I should translate all of this to a sequence of additions and deletions\n-                    // and then just add these differences to the diff to be treated normally\n-\n-//                    // Now let's understand how the new elements are positioned w.r.t. to the kept elements\n-//                    if (nodeTextIndexOfPreviousElements.isEmpty()) {\n-//                        // They are all just following the sequence in the new mix\n-//                        for (CsmElement csmElement : reshuffled.getElement().getElements()) {\n-//                            nodeText.addElement(nodeTextIndex++, toTextElement());\n-//                        }\n-//                    } else {\n-//                        throw new UnsupportedOperationException();\n-//                    }\n-\n                     // We go over the original node text elements, in the order they appear in the NodeText.\n                     // Considering an original node text element (ONE)\n                     // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                     //   we find the correspond OCE (Original CSM Element)\n                     // * we first add new elements that are marked to be added before OCE\n                     // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                     //   otherwise we add a removed element\n \n                     this.getElements().remove(diffIndex);\n                     int diffElIterator = diffIndex;\n                     if (lastNodeTextIndex != -1) {\n                         for (int ntIndex = startNodeTextIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n \n                             if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                                 int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                                 if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                     for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                         elements.add(diffElIterator++, new Added(elementToAdd));\n                                     }\n                                 }\n \n                                 CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                                 boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                                 if (toBeKept) {\n                                     elements.add(diffElIterator++, new Kept(originalCSMElement));\n                                 } else {\n                                     elements.add(diffElIterator++, new Removed(originalCSMElement));\n                                 }\n                             } else {\n                                 // simple node text element, without associated csm element, just keep ignore it\n                             }\n \n                         }\n                     }\n \n                     // Finally we look for the remaining new elements that were not yet added and\n                     // add all of them\n                     for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                         elements.add(diffElIterator++, new Added(elementToAdd));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f8d5e2fda0aedca5f9a9cb726f7787286bbfd05e": {
			"type": "Ybodychange",
			"commitMessage": "new approach based on rewriting Difference based on NodeText on encountering a CsmMix #866\n",
			"commitDate": "2017-05-21, 5:26 AM",
			"commitName": "f8d5e2fda0aedca5f9a9cb726f7787286bbfd05e",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-05-21, 5:26 AM",
			"commitNameOld": "9e91a1d76dbfb28f2bc7c32028fe459b073ee861",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,191 +1,314 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement = ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent = (diffIndex + 1) < elements.size()\n                                 && elements.get(diffIndex + 1).isAdded()\n                                 && elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n-                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl.isComment()) {\n+                    if ((kept.element instanceof CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n-                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n+                    } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n-                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n+                    } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n-                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n-                                LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n+                            if (kept.element instanceof CsmChild) {\n+                                CsmChild keptChild = (CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do\n                         diffIndex++;\n                         for (int i = 0; i < STANDARD_INDENTATION_SIZE && nodeTextIndex >= 1 && nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab(); i++) {\n                             nodeText.removeElement(--nodeTextIndex);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n-                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n+                    if ((removed.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n-                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n-                            && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n+                    } else if (removed.element instanceof CsmChild\n+                            && ((CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n+                } else if (diffEl instanceof Reshuffled) {\n+\n+                    // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n+                    Reshuffled reshuffled = (Reshuffled)diffEl;\n+                    CsmMix elementsFromPreviousOrder = reshuffled.previousOrder;\n+                    CsmMix elementsFromNextOrder = reshuffled.element;\n+\n+                    // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n+                    Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n+                    for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n+                        boolean found = false;\n+                        CsmElement ne = elementsFromNextOrder.getElements().get(ni);\n+                        for (int pi=0;pi<elementsFromPreviousOrder.getElements().size() && !found;pi++) {\n+                            CsmElement pe = elementsFromPreviousOrder.getElements().get(pi);\n+                            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(pe)\n+                                    && matching(ne, pe)) {\n+                                found = true;\n+                                correspondanceBetweenNextOrderAndPreviousOrder.put(ni, pi);\n+                            }\n+                        }\n+                    }\n+\n+                    // We now find out which Node Text elements corresponds to the elements in the original CSM\n+                    final int startNodeTextIndex = nodeTextIndex;\n+                    final Set<Integer> usedIndexes = new HashSet<>();\n+                    List<Integer> nodeTextIndexOfPreviousElements = elementsFromPreviousOrder.getElements().stream()\n+                            .map(it -> findIndexOfCorrespondingNodeTextElement(it, nodeText, startNodeTextIndex, usedIndexes, node))\n+                            .collect(Collectors.toList());\n+                    Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n+                    for (int i=0;i<nodeTextIndexOfPreviousElements.size();i++) {\n+                        int value = nodeTextIndexOfPreviousElements.get(i);\n+                        if (value != -1) {\n+                            nodeTextIndexToPreviousCSMIndex.put(value, i);\n+                        }\n+                    }\n+                    int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n+\n+                    // Elements to be added at the end\n+                    List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n+                    Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n+                    for (int ni=0;ni<elementsFromNextOrder.getElements().size();ni++) {\n+                        // If it has a mapping, then it is kept\n+                        if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n+                            // Ok, it is something new. Where to put it? Let's see what is the first following\n+                            // element that has a mapping\n+                            int originalCsmIndex = -1;\n+                            for (int nj=ni + 1;nj<elementsFromNextOrder.getElements().size() && originalCsmIndex==-1;nj++) {\n+                                if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n+                                    originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n+                                    if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)){\n+                                        elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n+                                    }\n+                                    elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(elementsFromNextOrder.getElements().get(ni));\n+                                }\n+                            }\n+                            // it does not preceed anything, so it goes at the end\n+                            if (originalCsmIndex == -1) {\n+                                elementsToBeAddedAtTheEnd.add(elementsFromNextOrder.getElements().get(ni));\n+                            }\n+                        }\n+                    }\n+\n+\n+\n+                    //Map<Integer, List<CsmElement>> elementsToAddBeforeGivenNodeTextIndex = new HashMap<>();\n+                    //List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n+                    //Set<Integer> nodeTextElementsToKeep = new HashSet<>();\n+\n+                    // Let's figure out which ones of the existing tokens are going to be removed\n+\n+                    // Now I should translate all of this to a sequence of additions and deletions\n+                    // and then just add these differences to the diff to be treated normally\n+\n+//                    // Now let's understand how the new elements are positioned w.r.t. to the kept elements\n+//                    if (nodeTextIndexOfPreviousElements.isEmpty()) {\n+//                        // They are all just following the sequence in the new mix\n+//                        for (CsmElement csmElement : reshuffled.getElement().getElements()) {\n+//                            nodeText.addElement(nodeTextIndex++, toTextElement());\n+//                        }\n+//                    } else {\n+//                        throw new UnsupportedOperationException();\n+//                    }\n+\n+                    // We go over the original node text elements, in the order they appear in the NodeText.\n+                    // Considering an original node text element (ONE)\n+                    // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n+                    //   we find the correspond OCE (Original CSM Element)\n+                    // * we first add new elements that are marked to be added before OCE\n+                    // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n+                    //   otherwise we add a removed element\n+\n+                    this.getElements().remove(diffIndex);\n+                    int diffElIterator = diffIndex;\n+                    if (lastNodeTextIndex != -1) {\n+                        for (int ntIndex = startNodeTextIndex; ntIndex<=lastNodeTextIndex; ntIndex++) {\n+\n+                            if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n+                                int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n+                                if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n+                                    for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n+                                        elements.add(diffElIterator++, new Added(elementToAdd));\n+                                    }\n+                                }\n+\n+                                CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n+                                boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n+                                if (toBeKept) {\n+                                    elements.add(diffElIterator++, new Kept(originalCSMElement));\n+                                } else {\n+                                    elements.add(diffElIterator++, new Removed(originalCSMElement));\n+                                }\n+                            } else {\n+                                // simple node text element, without associated csm element, just keep ignore it\n+                            }\n+\n+                        }\n+                    }\n+\n+                    // Finally we look for the remaining new elements that were not yet added and\n+                    // add all of them\n+                    for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n+                        elements.add(diffElIterator++, new Added(elementToAdd));\n+                    }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5689cad203e3ff4f51af7bc2b73f13ab03c91ca1": {
			"type": "Ybodychange",
			"commitMessage": "reconsider how CsmUnindent is handled in Difference.apply\n",
			"commitDate": "2017-05-21, 5:26 AM",
			"commitName": "5689cad203e3ff4f51af7bc2b73f13ab03c91ca1",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-05-21, 5:26 AM",
			"commitNameOld": "1a6665bb95b0e46cafdb19202274e6d6725ea464",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,188 +1,191 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement = ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent = (diffIndex + 1) < elements.size()\n                                 && elements.get(diffIndex + 1).isAdded()\n                                 && elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // Nothing to do\n                         diffIndex++;\n+                        for (int i=0;i<STANDARD_INDENTATION_SIZE && nodeTextIndex>=1 && nodeText.getTextElement(nodeTextIndex-1).isSpaceOrTab();i++) {\n+                            nodeText.removeElement(--nodeTextIndex);\n+                        }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1a6665bb95b0e46cafdb19202274e6d6725ea464": {
			"type": "Ybodychange",
			"commitMessage": "cleaning Difference\n",
			"commitDate": "2017-05-21, 5:26 AM",
			"commitName": "1a6665bb95b0e46cafdb19202274e6d6725ea464",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-05-21, 5:26 AM",
			"commitNameOld": "c624f15225df9442948dc1bb1c655e0114806ebb",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,188 +1,188 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement = ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent = (diffIndex + 1) < elements.size()\n                                 && elements.get(diffIndex + 1).isAdded()\n                                 && elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n-                        // FIXME\n+                        // Nothing to do\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n-                        // FIXME\n+                        // Nothing to do\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1555adc99a08f09e7f7ec40db7bd2535062e55af": {
			"type": "Ybodychange",
			"commitMessage": "progressing on unindent reconciliation\n",
			"commitDate": "2017-05-21, 5:26 AM",
			"commitName": "1555adc99a08f09e7f7ec40db7bd2535062e55af",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-05-21, 5:26 AM",
			"commitNameOld": "10508ce2a362ca01c7f29c39c7f98469233fce04",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,188 +1,188 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement = ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         boolean followedByUnindent = (diffIndex + 1) < elements.size()\n                                 && elements.get(diffIndex + 1).isAdded()\n                                 && elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n-                        nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent && !addedIndentation);\n+                        nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent/* && !addedIndentation*/);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // FIXME\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // FIXME\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"10508ce2a362ca01c7f29c39c7f98469233fce04": {
			"type": "Ybodychange",
			"commitMessage": "reconciliating unindent with existing indentation\n",
			"commitDate": "2017-05-21, 5:26 AM",
			"commitName": "10508ce2a362ca01c7f29c39c7f98469233fce04",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-05-21, 5:26 AM",
			"commitNameOld": "ad402162f98243c84e4f7c9693012633347a4829",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,185 +1,188 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         boolean addedIndentation = false;\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement = ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n                             indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n                         }\n                         addedIndentation = true;\n                         diffIndex++;\n                         continue;\n                     }\n                     if (addedElement instanceof CsmUnindent) {\n                         for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n                             indentation.remove(indentation.size() - 1);\n                         }\n                         addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         // Indentation is painful...\n                         // Sometimes we want to force indentation: this is the case when indentation was expected but\n                         // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n                         // not there, so when adding new elements we force it. However if the indentation has been\n                         // inserted by us in this transformation we do not want to insert it again\n                         if (!addedIndentation) {\n                             for (TextElement e : indentationBlock()) {\n                                 nodeText.addElement(nodeTextIndex++, e);\n                             }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n-                        nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex);\n+                        boolean followedByUnindent = (diffIndex + 1) < elements.size()\n+                                && elements.get(diffIndex + 1).isAdded()\n+                                && elements.get(diffIndex + 1).getElement() instanceof CsmUnindent;\n+                        nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex, followedByUnindent && !addedIndentation);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // FIXME\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // FIXME\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n-                            && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n+                            && nodeTextEl.isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ad402162f98243c84e4f7c9693012633347a4829": {
			"type": "Ybodychange",
			"commitMessage": "explaining why sometimes we force indentation\n",
			"commitDate": "2017-05-21, 5:26 AM",
			"commitName": "ad402162f98243c84e4f7c9693012633347a4829",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-05-21, 5:26 AM",
			"commitNameOld": "a31908d22bc52d1bf24e00d3bc1bc709224156fd",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,164 +1,185 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n+        boolean addedIndentation = false;\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement = ((Added) diffEl).element;\n-                    if (addedElement instanceof CsmIndent || addedElement instanceof CsmUnindent) {\n+                    if (addedElement instanceof CsmIndent) {\n+                        for (int i=0;i<STANDARD_INDENTATION_SIZE;i++){\n+                            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n+                        }\n+                        addedIndentation = true;\n+                        diffIndex++;\n+                        continue;\n+                    }\n+                    if (addedElement instanceof CsmUnindent) {\n+                        for (int i=0;i<STANDARD_INDENTATION_SIZE && !indentation.isEmpty();i++){\n+                            indentation.remove(indentation.size() - 1);\n+                        }\n+                        addedIndentation = false;\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n+                        // This remove the space in \"{ }\" when adding a new line\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n-                        for (TextElement e : indentationBlock()) {\n-                            nodeText.addElement(nodeTextIndex++, e);\n+                        // Indentation is painful...\n+                        // Sometimes we want to force indentation: this is the case when indentation was expected but\n+                        // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n+                        // not there, so when adding new elements we force it. However if the indentation has been\n+                        // inserted by us in this transformation we do not want to insert it again\n+                        if (!addedIndentation) {\n+                            for (TextElement e : indentationBlock()) {\n+                                nodeText.addElement(nodeTextIndex++, e);\n+                            }\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmIndent) {\n                         // FIXME\n                         diffIndex++;\n                     } else if (kept.element instanceof CsmUnindent) {\n                         // FIXME\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a31908d22bc52d1bf24e00d3bc1bc709224156fd": {
			"type": "Ybodychange",
			"commitMessage": "initial handling of indent/unindent in Difference\n",
			"commitDate": "2017-05-21, 5:26 AM",
			"commitName": "a31908d22bc52d1bf24e00d3bc1bc709224156fd",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-05-21, 5:26 AM",
			"commitNameOld": "488ccb1191c3b71644bdc9176712394220b9252b",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,158 +1,164 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     CsmElement addedElement = ((Added) diffEl).element;\n                     if (addedElement instanceof CsmIndent || addedElement instanceof CsmUnindent) {\n                         diffIndex++;\n                         continue;\n                     }\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n+                    } else if (kept.element instanceof CsmIndent) {\n+                        // FIXME\n+                        diffIndex++;\n+                    } else if (kept.element instanceof CsmUnindent) {\n+                        // FIXME\n+                        diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"488ccb1191c3b71644bdc9176712394220b9252b": {
			"type": "Ybodychange",
			"commitMessage": "propagating CsmIndent and CsmUnindent\n",
			"commitDate": "2017-05-21, 5:26 AM",
			"commitName": "488ccb1191c3b71644bdc9176712394220b9252b",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-05-21, 5:26 AM",
			"commitNameOld": "87b56cb1f18252c95d88b979a449f06d55def290",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,153 +1,158 @@\n     void apply(NodeText nodeText, Node node) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n-                    TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n+                    CsmElement addedElement = ((Added) diffEl).element;\n+                    if (addedElement instanceof CsmIndent || addedElement instanceof CsmUnindent) {\n+                        diffIndex++;\n+                        continue;\n+                    }\n+                    TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), addedElement);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"87b56cb1f18252c95d88b979a449f06d55def290": {
			"type": "Ybodychange",
			"commitMessage": "working on propagating the indentation to NodeText generated\n",
			"commitDate": "2017-05-21, 5:26 AM",
			"commitName": "87b56cb1f18252c95d88b979a449f06d55def290",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-03-06, 9:35 AM",
			"commitNameOld": "b29a465257afcf2cc720c9423c2ddedd1edd31a3",
			"commitAuthorOld": "Danny van Bruggen",
			"daysBetweenCommits": 75.79,
			"commitsBetweenForRepo": 214,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,153 +1,153 @@\n     void apply(NodeText nodeText, Node node) {\n-        List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n+        List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b29a465257afcf2cc720c9423c2ddedd1edd31a3": {
			"type": "Ybodychange",
			"commitMessage": "Move TokenConstants around\n",
			"commitDate": "2017-03-06, 9:35 AM",
			"commitName": "b29a465257afcf2cc720c9423c2ddedd1edd31a3",
			"commitAuthor": "Danny van Bruggen",
			"commitDateOld": "2017-03-06, 9:15 AM",
			"commitNameOld": "9192b9d17903947058b755b987d1c57a05821e58",
			"commitAuthorOld": "Danny van Bruggen",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,153 +1,153 @@\n     void apply(NodeText nodeText, Node node) {\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n-                        if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n+                        if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isNewline()) {\n                             used = true;\n                         }\n-                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenConstants.eolToken()));\n+                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenTypes.eolToken()));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n-                        } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n+                        } else if (TokenTypes.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9192b9d17903947058b755b987d1c57a05821e58": {
			"type": "Ybodychange",
			"commitMessage": "* explicitly match \\r\\n in the grammar\n* centralize token handling\n",
			"commitDate": "2017-03-06, 9:15 AM",
			"commitName": "9192b9d17903947058b755b987d1c57a05821e58",
			"commitAuthor": "Danny van Bruggen",
			"commitDateOld": "2017-03-06, 8:40 AM",
			"commitNameOld": "b1cd1afb0aaa19f370a169350318496ca7e541bb",
			"commitAuthorOld": "Danny van Bruggen",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,153 +1,153 @@\n     void apply(NodeText nodeText, Node node) {\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used = false;\n-                    if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(CARRIAGE_RETURN_TOKEN)) {\n+                    if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isNewline()) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n-                        if (textElement.isToken(CARRIAGE_RETURN_TOKEN)) {\n+                        if (textElement.isNewline()) {\n                             used = true;\n                         }\n-                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(CARRIAGE_RETURN_TOKEN));\n+                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(TokenConstants.eolToken()));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n-                        if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.CARRIAGE_RETURN_TOKEN)) {\n+                        if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isNewline()) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b1cd1afb0aaa19f370a169350318496ca7e541bb": {
			"type": "Ybodychange",
			"commitMessage": "Some attempts at getting \\r\\n recognized.\n",
			"commitDate": "2017-03-06, 8:40 AM",
			"commitName": "b1cd1afb0aaa19f370a169350318496ca7e541bb",
			"commitAuthor": "Danny van Bruggen",
			"commitDateOld": "2017-03-05, 3:02 AM",
			"commitNameOld": "adb78b277512189cc5f8ecb076d9bf8106f9e1e0",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 1.23,
			"commitsBetweenForRepo": 15,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,153 +1,153 @@\n     void apply(NodeText nodeText, Node node) {\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used = false;\n-                    if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n+                    if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(CARRIAGE_RETURN_TOKEN)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n-                        if (textElement.isToken(NEWLINE_TOKEN)) {\n+                        if (textElement.isToken(CARRIAGE_RETURN_TOKEN)) {\n                             used = true;\n                         }\n-                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n+                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(CARRIAGE_RETURN_TOKEN));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl.isComment()) {\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n-                        if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.NEWLINE_TOKEN)) {\n+                        if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.CARRIAGE_RETURN_TOKEN)) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"adb78b277512189cc5f8ecb076d9bf8106f9e1e0": {
			"type": "Ybodychange",
			"commitMessage": "issue823: distinguish between spaces and comments\n",
			"commitDate": "2017-03-05, 3:02 AM",
			"commitName": "adb78b277512189cc5f8ecb076d9bf8106f9e1e0",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-03-05, 2:50 AM",
			"commitNameOld": "0be8bb2b4275456c18bee064c5de2ccb12a33080",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,151 +1,153 @@\n     void apply(NodeText nodeText, Node node) {\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isToken(NEWLINE_TOKEN)) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n-                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n+                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl.isComment()) {\n+                        nodeTextIndex++;\n+                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.NEWLINE_TOKEN)) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0be8bb2b4275456c18bee064c5de2ccb12a33080": {
			"type": "Ybodychange",
			"commitMessage": "issue823: add TextElement.isWhiteSpaceOrComment\n",
			"commitDate": "2017-03-05, 2:50 AM",
			"commitName": "0be8bb2b4275456c18bee064c5de2ccb12a33080",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-27, 12:50 PM",
			"commitNameOld": "de2adb51f6f0465024755f034fe27de56c651ffd",
			"commitAuthorOld": "Danny van Bruggen",
			"daysBetweenCommits": 5.58,
			"commitsBetweenForRepo": 30,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,151 +1,151 @@\n     void apply(NodeText nodeText, Node node) {\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n-                if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n+                if (nodeTextEl.isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isToken(NEWLINE_TOKEN)) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.NEWLINE_TOKEN)) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n                             && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (nodeTextEl.isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"bd0af28e7b81048d9bda153b908c727304ca8a04": {
			"type": "Ybodychange",
			"commitMessage": "issue124: remove Tokens\n",
			"commitDate": "2017-02-23, 10:57 AM",
			"commitName": "bd0af28e7b81048d9bda153b908c727304ca8a04",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 10:39 AM",
			"commitNameOld": "15cb49e74025eb4011187f31735aa4772993fb5d",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,148 +1,151 @@\n     void apply(NodeText nodeText, Node node) {\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                     + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n                                 + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n                             + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isToken(NEWLINE_TOKEN)) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n-                        if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n+                        if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isToken(TokenConstants.NEWLINE_TOKEN)) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n-                    } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n-                        diffIndex++;\n-                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n+                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild\n+                            && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n+                    } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n+                        diffIndex++;\n+                    } else if (nodeTextEl.isWhiteSpace()) {\n+                        nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"15cb49e74025eb4011187f31735aa4772993fb5d": {
			"type": "Ymultichange(Ymodifierchange,Ybodychange)",
			"commitMessage": "issue124: final cleanup\n",
			"commitDate": "2017-02-23, 10:39 AM",
			"commitName": "15cb49e74025eb4011187f31735aa4772993fb5d",
			"commitAuthor": "Federico Tomassetti",
			"subchanges": [
				{
					"type": "Ymodifierchange",
					"commitMessage": "issue124: final cleanup\n",
					"commitDate": "2017-02-23, 10:39 AM",
					"commitName": "15cb49e74025eb4011187f31735aa4772993fb5d",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2017-02-23, 9:20 AM",
					"commitNameOld": "4b87b2b6b407077eb064ac949baaa2fbd0487986",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.06,
					"commitsBetweenForRepo": 7,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,145 +1,148 @@\n-    public void apply(NodeText nodeText, Node node) {\n+    void apply(NodeText nodeText, Node node) {\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n-                        if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n+                        if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n-                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n+                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n+                                    + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n-                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n+                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n+                                + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n-                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n+                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n+                            + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isToken(NEWLINE_TOKEN)) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n-                        } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n+                        } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[public]",
						"newValue": "[]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "issue124: final cleanup\n",
					"commitDate": "2017-02-23, 10:39 AM",
					"commitName": "15cb49e74025eb4011187f31735aa4772993fb5d",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2017-02-23, 9:20 AM",
					"commitNameOld": "4b87b2b6b407077eb064ac949baaa2fbd0487986",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.06,
					"commitsBetweenForRepo": 7,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,145 +1,148 @@\n-    public void apply(NodeText nodeText, Node node) {\n+    void apply(NodeText nodeText, Node node) {\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n-                        if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n+                        if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n-                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n+                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n+                                    + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n-                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n+                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \"\n+                                + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n-                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n+                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \"\n+                            + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isToken(NEWLINE_TOKEN)) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n-                        } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n+                        } else if (TokenConstants.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"4b87b2b6b407077eb064ac949baaa2fbd0487986": {
			"type": "Ybodychange",
			"commitMessage": "issue124: more cleanup\n",
			"commitDate": "2017-02-23, 9:20 AM",
			"commitName": "4b87b2b6b407077eb064ac949baaa2fbd0487986",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 9:20 AM",
			"commitNameOld": "a55cd517deae99d6bb32717af632cd9dc9f01928",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,145 +1,145 @@\n     public void apply(NodeText nodeText, Node node) {\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n-                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n+                    throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used = false;\n-                    if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n+                    if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(NEWLINE_TOKEN)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n-                        if (textElement.isToken(3)) {\n+                        if (textElement.isToken(NEWLINE_TOKEN)) {\n                             used = true;\n                         }\n-                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n+                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(NEWLINE_TOKEN));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n-                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n+                            throw new UnsupportedOperationException(\"Csm token \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a55cd517deae99d6bb32717af632cd9dc9f01928": {
			"type": "Ybodychange",
			"commitMessage": "issue124: clean up\n",
			"commitDate": "2017-02-23, 9:20 AM",
			"commitName": "a55cd517deae99d6bb32717af632cd9dc9f01928",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 9:19 AM",
			"commitNameOld": "7121d100d536b7b3df76c22ad3acc4c507be7bfe",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,160 +1,145 @@\n     public void apply(NodeText nodeText, Node node) {\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n-        boolean comingFromRemoved = false;\n-        boolean comingFromAdded = false;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n-                    comingFromRemoved = false;\n-                    comingFromAdded = false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n-                        //nodeTextIndex = removeWhiteSpaceAfterBrace(nodeText, nodeTextIndex);\n                         if (textElement.isToken(3)) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     if (textElement.isNewline()) {\n                         nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex);\n                     }\n                     diffIndex++;\n-                    comingFromRemoved = false;\n-                    comingFromAdded = true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n-                            //if (comingFromRemoved) {\n-                                //nodeText.removeElement(nodeTextIndex);\n-                            //} else {\n-                                nodeTextIndex++;\n-                            //}\n+                            nodeTextIndex++;\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n-                    comingFromRemoved = false;\n-                    comingFromAdded = false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n-                    comingFromRemoved = true;\n-                    comingFromAdded = false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7121d100d536b7b3df76c22ad3acc4c507be7bfe": {
			"type": "Ybodychange",
			"commitMessage": "issue124: adjusting indentation of following line\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "7121d100d536b7b3df76c22ad3acc4c507be7bfe",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 9:19 AM",
			"commitNameOld": "152592f7c8110f04ea6ca6e6c6d57360fd40ee16",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,157 +1,160 @@\n     public void apply(NodeText nodeText, Node node) {\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         boolean comingFromRemoved = false;\n         boolean comingFromAdded = false;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         //nodeTextIndex = removeWhiteSpaceAfterBrace(nodeText, nodeTextIndex);\n                         if (textElement.isToken(3)) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                         while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n                             nodeText.getElements().remove(nodeTextIndex);\n                         }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n+                    if (textElement.isNewline()) {\n+                        nodeTextIndex = adjustIndentation(indentation, nodeText, nodeTextIndex);\n+                    }\n                     diffIndex++;\n                     comingFromRemoved = false;\n                     comingFromAdded = true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             //if (comingFromRemoved) {\n                                 //nodeText.removeElement(nodeTextIndex);\n                             //} else {\n                                 nodeTextIndex++;\n                             //}\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = true;\n                     comingFromAdded = false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"152592f7c8110f04ea6ca6e6c6d57360fd40ee16": {
			"type": "Ybodychange",
			"commitMessage": "issue124: fix findIndentation\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "152592f7c8110f04ea6ca6e6c6d57360fd40ee16",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 9:19 AM",
			"commitNameOld": "e71e376b9542dd7fea6e973301d8d426f340d65b",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,153 +1,157 @@\n     public void apply(NodeText nodeText, Node node) {\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         boolean comingFromRemoved = false;\n         boolean comingFromAdded = false;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n+                        //nodeTextIndex = removeWhiteSpaceAfterBrace(nodeText, nodeTextIndex);\n                         if (textElement.isToken(3)) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n+                        while (nodeText.getElements().get(nodeTextIndex).isSpaceOrTab()) {\n+                            nodeText.getElements().remove(nodeTextIndex);\n+                        }\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     diffIndex++;\n                     comingFromRemoved = false;\n                     comingFromAdded = true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             //if (comingFromRemoved) {\n                                 //nodeText.removeElement(nodeTextIndex);\n                             //} else {\n                                 nodeTextIndex++;\n                             //}\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = true;\n                     comingFromAdded = false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e71e376b9542dd7fea6e973301d8d426f340d65b": {
			"type": "Ybodychange",
			"commitMessage": "issue124: specific support for replacement\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "e71e376b9542dd7fea6e973301d8d426f340d65b",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 9:19 AM",
			"commitNameOld": "ed7f4a6532043b5ac8c8da55923fbd91f72ec574",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,153 +1,153 @@\n     public void apply(NodeText nodeText, Node node) {\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         boolean comingFromRemoved = false;\n         boolean comingFromAdded = false;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n-                    } else if (isAfterLBrace(nodeText, nodeTextIndex)) {\n+                    } else if (isAfterLBrace(nodeText, nodeTextIndex) && !isAReplacement(diffIndex)) {\n                         if (textElement.isToken(3)) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     diffIndex++;\n                     comingFromRemoved = false;\n                     comingFromAdded = true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             //if (comingFromRemoved) {\n                                 //nodeText.removeElement(nodeTextIndex);\n                             //} else {\n                                 nodeTextIndex++;\n                             //}\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         } else {\n                             if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n                                 nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n                             }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = true;\n                     comingFromAdded = false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ed7f4a6532043b5ac8c8da55923fbd91f72ec574": {
			"type": "Ybodychange",
			"commitMessage": "issue124: special handling for replacement\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "ed7f4a6532043b5ac8c8da55923fbd91f72ec574",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 9:19 AM",
			"commitNameOld": "548fb9c5a72776ec009c5f2f92b1a4c480a05030",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,149 +1,153 @@\n     public void apply(NodeText nodeText, Node node) {\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         boolean comingFromRemoved = false;\n         boolean comingFromAdded = false;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (isAfterLBrace(nodeText, nodeTextIndex)) {\n                         if (textElement.isToken(3)) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     diffIndex++;\n                     comingFromRemoved = false;\n                     comingFromAdded = true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             //if (comingFromRemoved) {\n                                 //nodeText.removeElement(nodeTextIndex);\n                             //} else {\n                                 nodeTextIndex++;\n                             //}\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n+                        } else {\n+                            if (diffIndex + 1 >= this.getElements().size() || !(this.getElements().get(diffIndex + 1) instanceof Added)) {\n+                                nodeTextIndex = considerEnforcingIndentation(nodeText, nodeTextIndex);\n+                            }\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = true;\n                     comingFromAdded = false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"548fb9c5a72776ec009c5f2f92b1a4c480a05030": {
			"type": "Ybodychange",
			"commitMessage": "issue124: correct isAfterLBrace\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "548fb9c5a72776ec009c5f2f92b1a4c480a05030",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 9:19 AM",
			"commitNameOld": "f21322dd131f30bfcd809d2748a2366df7dc27d3",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,149 +1,149 @@\n     public void apply(NodeText nodeText, Node node) {\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         boolean comingFromRemoved = false;\n         boolean comingFromAdded = false;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n-                    } else if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n+                    } else if (isAfterLBrace(nodeText, nodeTextIndex)) {\n                         if (textElement.isToken(3)) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     diffIndex++;\n                     comingFromRemoved = false;\n                     comingFromAdded = true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             //if (comingFromRemoved) {\n                                 //nodeText.removeElement(nodeTextIndex);\n                             //} else {\n                                 nodeTextIndex++;\n                             //}\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = true;\n                     comingFromAdded = false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f21322dd131f30bfcd809d2748a2366df7dc27d3": {
			"type": "Ybodychange",
			"commitMessage": "issue124: minor bug\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "f21322dd131f30bfcd809d2748a2366df7dc27d3",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 9:19 AM",
			"commitNameOld": "882790065271126fc4b17a71bebb078b60ffe00c",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,149 +1,149 @@\n     public void apply(NodeText nodeText, Node node) {\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         boolean comingFromRemoved = false;\n         boolean comingFromAdded = false;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n                         if (textElement.isToken(3)) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     diffIndex++;\n                     comingFromRemoved = false;\n                     comingFromAdded = true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n                             //if (comingFromRemoved) {\n                                 //nodeText.removeElement(nodeTextIndex);\n                             //} else {\n                                 nodeTextIndex++;\n                             //}\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n-                        if (nodeTextIndex > nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n+                        if (nodeTextIndex < nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n                             nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n                         }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = true;\n                     comingFromAdded = false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"882790065271126fc4b17a71bebb078b60ffe00c": {
			"type": "Ybodychange",
			"commitMessage": "issue124: removing empty lines\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "882790065271126fc4b17a71bebb078b60ffe00c",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 9:19 AM",
			"commitNameOld": "572ea89397e9b3b35dc616d48176ab0d296612dd",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,146 +1,149 @@\n     public void apply(NodeText nodeText, Node node) {\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         boolean comingFromRemoved = false;\n         boolean comingFromAdded = false;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n-                if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n+                if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n                         if (textElement.isToken(3)) {\n                             used = true;\n                         }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n                     if (!used) {\n                         nodeText.addElement(nodeTextIndex, textElement);\n                         nodeTextIndex++;\n                     }\n                     diffIndex++;\n                     comingFromRemoved = false;\n                     comingFromAdded = true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n-                        if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n-                            if (comingFromRemoved) {\n-                                nodeText.removeElement(nodeTextIndex);\n-                            } else {\n+                        if (((TokenTextElement) nodeTextEl).isWhiteSpaceOrComment()) {\n+                            //if (comingFromRemoved) {\n+                                //nodeText.removeElement(nodeTextIndex);\n+                            //} else {\n                                 nodeTextIndex++;\n-                            }\n+                            //}\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n-                        } else if (nodeTextToken.isWhiteSpace()) {\n+                        } else if (nodeTextToken.isWhiteSpaceOrComment()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n+                        if (nodeTextIndex > nodeText.getElements().size() && nodeText.getElements().get(nodeTextIndex).isToken(3)) {\n+                            nodeTextIndex = considerCleaningTheLine(nodeText, nodeTextIndex);\n+                        }\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n-                            && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n+                            && ((TokenTextElement)nodeTextEl).isWhiteSpaceOrComment()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = true;\n                     comingFromAdded = false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"572ea89397e9b3b35dc616d48176ab0d296612dd": {
			"type": "Ybodychange",
			"commitMessage": "issue124: more newlines processing\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "572ea89397e9b3b35dc616d48176ab0d296612dd",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 9:19 AM",
			"commitNameOld": "48ac9477b3997592001fa0f44f98eb7481f7b9ea",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,140 +1,146 @@\n     public void apply(NodeText nodeText, Node node) {\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         boolean comingFromRemoved = false;\n         boolean comingFromAdded = false;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n+                    boolean used = false;\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     } else if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n+                        if (textElement.isToken(3)) {\n+                            used = true;\n+                        }\n                         nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                         for (TextElement e : indentationBlock()) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n                     }\n-                    nodeText.addElement(nodeTextIndex, textElement);\n-                    nodeTextIndex++;\n+                    if (!used) {\n+                        nodeText.addElement(nodeTextIndex, textElement);\n+                        nodeTextIndex++;\n+                    }\n                     diffIndex++;\n                     comingFromRemoved = false;\n                     comingFromAdded = true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                             if (comingFromRemoved) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpace()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = true;\n                     comingFromAdded = false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"48ac9477b3997592001fa0f44f98eb7481f7b9ea": {
			"type": "Ybodychange",
			"commitMessage": "issue124: improvements in processing indentation\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "48ac9477b3997592001fa0f44f98eb7481f7b9ea",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 9:19 AM",
			"commitNameOld": "5d76ede0db52033984e3d7908105c6f2f4380725",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,132 +1,140 @@\n     public void apply(NodeText nodeText, Node node) {\n         List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         boolean comingFromRemoved = false;\n         boolean comingFromAdded = false;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n                     if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n                         for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n                             nodeText.addElement(nodeTextIndex++, e);\n                         }\n+                    } else if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(ASTParserConstants.LBRACE)) {\n+                        nodeText.addElement(nodeTextIndex++, new TokenTextElement(3));\n+                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n+                            nodeText.addElement(nodeTextIndex++, e);\n+                        }\n+                        for (TextElement e : indentationBlock()) {\n+                            nodeText.addElement(nodeTextIndex++, e);\n+                        }\n                     }\n                     nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n                     diffIndex++;\n                     comingFromRemoved = false;\n                     comingFromAdded = true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                             if (comingFromRemoved) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpace()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = true;\n                     comingFromAdded = false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5d76ede0db52033984e3d7908105c6f2f4380725": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "issue124: consider indentation\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "5d76ede0db52033984e3d7908105c6f2f4380725",
			"commitAuthor": "Federico Tomassetti",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "issue124: consider indentation\n",
					"commitDate": "2017-02-23, 9:19 AM",
					"commitName": "5d76ede0db52033984e3d7908105c6f2f4380725",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2017-02-23, 9:19 AM",
					"commitNameOld": "26bf9b3ff36dbf0235adbbff1efeeb192f0d205f",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0,
					"commitsBetweenForRepo": 10,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,125 +1,132 @@\n-    public void apply(NodeText nodeText) {\n+    public void apply(NodeText nodeText, Node node) {\n+        List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         boolean comingFromRemoved = false;\n         boolean comingFromAdded = false;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n-                        if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n+                        if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n-                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n-                    diffIndex++;\n+                    TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n+                    if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n+                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n+                            nodeText.addElement(nodeTextIndex++, e);\n+                        }\n+                    }\n+                    nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n+                    diffIndex++;\n                     comingFromRemoved = false;\n                     comingFromAdded = true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                             if (comingFromRemoved) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n-                        } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n+                        } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpace()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = true;\n                     comingFromAdded = false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[nodeText-NodeText]",
						"newValue": "[nodeText-NodeText, node-Node]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "issue124: consider indentation\n",
					"commitDate": "2017-02-23, 9:19 AM",
					"commitName": "5d76ede0db52033984e3d7908105c6f2f4380725",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2017-02-23, 9:19 AM",
					"commitNameOld": "26bf9b3ff36dbf0235adbbff1efeeb192f0d205f",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0,
					"commitsBetweenForRepo": 10,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,125 +1,132 @@\n-    public void apply(NodeText nodeText) {\n+    public void apply(NodeText nodeText, Node node) {\n+        List<TokenTextElement> indentation = nodeText.getLexicalPreservingPrinter().findIndentation(node);\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         boolean comingFromRemoved = false;\n         boolean comingFromAdded = false;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n-                        if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n+                        if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n-                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n-                    diffIndex++;\n+                    TextElement textElement = toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element);\n+                    if (nodeTextIndex > 0 && nodeText.getElements().get(nodeTextIndex - 1).isToken(3)) {\n+                        for (TextElement e : processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1))) {\n+                            nodeText.addElement(nodeTextIndex++, e);\n+                        }\n+                    }\n+                    nodeText.addElement(nodeTextIndex, textElement);\n                     nodeTextIndex++;\n+                    diffIndex++;\n                     comingFromRemoved = false;\n                     comingFromAdded = true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                             if (comingFromRemoved) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n-                        } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n+                        } else if (LexicalDifferenceCalculator.isWhitespaceOrComment(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpace()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n                         if (isPrimitiveType(nodeTextEl)) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = true;\n                     comingFromAdded = false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"26bf9b3ff36dbf0235adbbff1efeeb192f0d205f": {
			"type": "Ybodychange",
			"commitMessage": "issue124: now changing the type of variable causes also the maxCommonType of the enclosing declaration to change\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "26bf9b3ff36dbf0235adbbff1efeeb192f0d205f",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 9:19 AM",
			"commitNameOld": "b2625a83a00b165c95bb7eddc9a1a4b65b4750aa",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,118 +1,125 @@\n     public void apply(NodeText nodeText) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         boolean comingFromRemoved = false;\n         boolean comingFromAdded = false;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     diffIndex++;\n                     nodeTextIndex++;\n                     comingFromRemoved = false;\n                     comingFromAdded = true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                             if (comingFromRemoved) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpace()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n+                    } else if (removed.element instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild)removed.element).getChild() instanceof PrimitiveType) {\n+                        if (isPrimitiveType(nodeTextEl)) {\n+                            nodeText.removeElement(nodeTextIndex);\n+                            diffIndex++;\n+                        } else {\n+                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n+                        }\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = true;\n                     comingFromAdded = false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b2625a83a00b165c95bb7eddc9a1a4b65b4750aa": {
			"type": "Ybodychange",
			"commitMessage": "issue124: added tollerance for Diff expecting to keep whitespace\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "b2625a83a00b165c95bb7eddc9a1a4b65b4750aa",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 9:19 AM",
			"commitNameOld": "a616b929f4a243fd5ed9097d399e7c6bbe79dfc1",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,116 +1,118 @@\n     public void apply(NodeText nodeText) {\n         if (nodeText == null) {\n             throw new NullPointerException();\n         }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         boolean comingFromRemoved = false;\n         boolean comingFromAdded = false;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     diffIndex++;\n                     nodeTextIndex++;\n                     comingFromRemoved = false;\n                     comingFromAdded = true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                             if (comingFromRemoved) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpace()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n+                    } else if ((kept.element instanceof CsmToken) && ((CsmToken) kept.element).isWhiteSpace()) {\n+                        diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = true;\n                     comingFromAdded = false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f0f313058c4389cd48052112e3fb906c060be30f": {
			"type": "Ybodychange",
			"commitMessage": "issue124: improving how JavadocComment is handled\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "f0f313058c4389cd48052112e3fb906c060be30f",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 9:19 AM",
			"commitNameOld": "b062cd703845b9a2d65e423e912d4e245f185ed4",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,111 +1,116 @@\n     public void apply(NodeText nodeText) {\n+        if (nodeText == null) {\n+            throw new NullPointerException();\n+        }\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         boolean comingFromRemoved = false;\n         boolean comingFromAdded = false;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     diffIndex++;\n                     nodeTextIndex++;\n                     comingFromRemoved = false;\n                     comingFromAdded = true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                             if (comingFromRemoved) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpace()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = false;\n                     comingFromAdded = false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                         nodeTextIndex++;\n+                    } else if (removed.element instanceof CsmToken && ((CsmToken)removed.element).isWhiteSpace()) {\n+                        diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = true;\n                     comingFromAdded = false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6c2c1abbfcee5a8874d805a58f08d7d21c20482c": {
			"type": "Ybodychange",
			"commitMessage": "issue124: difference now considering added whitespace\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "6c2c1abbfcee5a8874d805a58f08d7d21c20482c",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 9:19 AM",
			"commitNameOld": "566e84eb47ec36af0964ae8a3584460737917d73",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,106 +1,111 @@\n     public void apply(NodeText nodeText) {\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         boolean comingFromRemoved = false;\n+        boolean comingFromAdded = false;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved = false;\n+                    comingFromAdded = false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     diffIndex++;\n                     nodeTextIndex++;\n                     comingFromRemoved = false;\n+                    comingFromAdded = true;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                             if (comingFromRemoved) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpace()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = false;\n+                    comingFromAdded = false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if (nodeTextEl instanceof TokenTextElement\n                             && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = true;\n+                    comingFromAdded = false;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"566e84eb47ec36af0964ae8a3584460737917d73": {
			"type": "Ybodychange",
			"commitMessage": "issue124: added annotationDeclarationExampleWithModifierAdded\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "566e84eb47ec36af0964ae8a3584460737917d73",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 9:19 AM",
			"commitNameOld": "74000e047aaabc467031830b1d958b281cf28df9",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,103 +1,106 @@\n     public void apply(NodeText nodeText) {\n         int diffIndex = 0;\n         int nodeTextIndex = 0;\n         boolean comingFromRemoved = false;\n         do {\n             if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 if (diffEl instanceof Kept) {\n                     Kept kept = (Kept) diffEl;\n                     if (kept.element instanceof CsmToken) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                     } else {\n                         throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n                     comingFromRemoved = false;\n                 } else if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     nodeTextIndex++;\n                     diffIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                 }\n             } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                     nodeTextIndex++;\n                 } else {\n                     throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                 }\n             } else {\n                 DifferenceElement diffEl = elements.get(diffIndex);\n                 TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                 if (diffEl instanceof Added) {\n                     nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                     diffIndex++;\n                     nodeTextIndex++;\n                     comingFromRemoved = false;\n                 } else if (diffEl instanceof Kept) {\n                     Kept kept = (Kept)diffEl;\n                     if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n                     } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                         if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                             if (comingFromRemoved) {\n                                 nodeText.removeElement(nodeTextIndex);\n                             } else {\n                                 nodeTextIndex++;\n                             }\n                         } else {\n                             if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n                                 LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n                                 if (keptChild.getChild() instanceof PrimitiveType) {\n                                     nodeTextIndex++;\n                                     diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         }\n                     } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                         CsmToken csmToken = (CsmToken) kept.element;\n                         TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                         if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                             nodeTextIndex++;\n                             diffIndex++;\n                         } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n                         } else if (nodeTextToken.isWhiteSpace()) {\n                             nodeTextIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n                     } else {\n                         throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = false;\n                 } else if (diffEl instanceof Removed) {\n                     Removed removed = (Removed)diffEl;\n                     if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n                     } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                             && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                         nodeText.removeElement(nodeTextIndex);\n                         diffIndex++;\n+                    } else if (nodeTextEl instanceof TokenTextElement\n+                            && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n+                        nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                     }\n                     comingFromRemoved = true;\n                 } else {\n                     throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n             }\n         } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f415fb00bdcfe4931b43ca629ab4fb9bc3f67f16": {
			"type": "Ymultichange(Ymovefromfile,Ybodychange)",
			"commitMessage": "issue124: extract Difference\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "f415fb00bdcfe4931b43ca629ab4fb9bc3f67f16",
			"commitAuthor": "Federico Tomassetti",
			"subchanges": [
				{
					"type": "Ymovefromfile",
					"commitMessage": "issue124: extract Difference\n",
					"commitDate": "2017-02-23, 9:19 AM",
					"commitName": "f415fb00bdcfe4931b43ca629ab4fb9bc3f67f16",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2017-02-23, 9:19 AM",
					"commitNameOld": "ecefb777275fd26b37f10709f97810a3e6a69bb2",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,103 +1,103 @@\n-        public void apply(NodeText nodeText) {\n-            int diffIndex = 0;\n-            int nodeTextIndex = 0;\n-            boolean comingFromRemoved = false;\n-            do {\n-                if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n-                    DifferenceElement diffEl = elements.get(diffIndex);\n-                    if (diffEl instanceof Kept) {\n-                        Kept kept = (Kept) diffEl;\n-                        if (kept.element instanceof CsmToken) {\n-                            CsmToken csmToken = (CsmToken) kept.element;\n-                            if (isWhitespace(csmToken.getTokenType())) {\n-                                diffIndex++;\n-                            } else {\n-                                throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n-                            }\n+    public void apply(NodeText nodeText) {\n+        int diffIndex = 0;\n+        int nodeTextIndex = 0;\n+        boolean comingFromRemoved = false;\n+        do {\n+            if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n+                DifferenceElement diffEl = elements.get(diffIndex);\n+                if (diffEl instanceof Kept) {\n+                    Kept kept = (Kept) diffEl;\n+                    if (kept.element instanceof CsmToken) {\n+                        CsmToken csmToken = (CsmToken) kept.element;\n+                        if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n+                            diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n-                        comingFromRemoved = false;\n-                    } else if (diffEl instanceof Added) {\n-                        nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n-                        nodeTextIndex++;\n-                        diffIndex++;\n                     } else {\n-                        throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n+                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n-                } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n-                    TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n-                    if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n-                        nodeTextIndex++;\n-                    } else {\n-                        throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n-                    }\n+                    comingFromRemoved = false;\n+                } else if (diffEl instanceof Added) {\n+                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n+                    nodeTextIndex++;\n+                    diffIndex++;\n                 } else {\n-                    DifferenceElement diffEl = elements.get(diffIndex);\n-                    TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n-                    if (diffEl instanceof Added) {\n-                        nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n+                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n+                }\n+            } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n+                TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n+                if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n+                    nodeTextIndex++;\n+                } else {\n+                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n+                }\n+            } else {\n+                DifferenceElement diffEl = elements.get(diffIndex);\n+                TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n+                if (diffEl instanceof Added) {\n+                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n+                    diffIndex++;\n+                    nodeTextIndex++;\n+                    comingFromRemoved = false;\n+                } else if (diffEl instanceof Kept) {\n+                    Kept kept = (Kept)diffEl;\n+                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n-                        comingFromRemoved = false;\n-                    } else if (diffEl instanceof Kept) {\n-                        Kept kept = (Kept)diffEl;\n-                        if ((kept.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n-                            diffIndex++;\n-                            nodeTextIndex++;\n-                        } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof TokenTextElement) {\n-                            if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n-                                if (comingFromRemoved) {\n-                                    nodeText.removeElement(nodeTextIndex);\n-                                } else {\n-                                    nodeTextIndex++;\n-                                }\n+                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n+                        if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n+                            if (comingFromRemoved) {\n+                                nodeText.removeElement(nodeTextIndex);\n                             } else {\n-                                if (kept.element instanceof CsmChild) {\n-                                    CsmChild keptChild = (CsmChild)kept.element;\n-                                    if (keptChild.child instanceof PrimitiveType) {\n-                                        nodeTextIndex++;\n-                                        diffIndex++;\n-                                    } else {\n-                                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n-                                    }\n+                                nodeTextIndex++;\n+                            }\n+                        } else {\n+                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n+                                LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n+                                if (keptChild.getChild() instanceof PrimitiveType) {\n+                                    nodeTextIndex++;\n+                                    diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n-                            }\n-                        } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n-                            CsmToken csmToken = (CsmToken) kept.element;\n-                            TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n-                            if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n-                                nodeTextIndex++;\n-                                diffIndex++;\n-                            } else if (isWhitespace(csmToken.getTokenType())) {\n-                                diffIndex++;\n-                            } else if (nodeTextToken.isWhiteSpace()) {\n-                                nodeTextIndex++;\n                             } else {\n-                                throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n+                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n-                        } else {\n-                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n-                        comingFromRemoved = false;\n-                    } else if (diffEl instanceof Removed) {\n-                        Removed removed = (Removed)diffEl;\n-                        if ((removed.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n-                            nodeText.removeElement(nodeTextIndex);\n+                    } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n+                        CsmToken csmToken = (CsmToken) kept.element;\n+                        TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n+                        if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n+                            nodeTextIndex++;\n                             diffIndex++;\n-                        } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n-                                && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n-                            nodeText.removeElement(nodeTextIndex);\n+                        } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n+                        } else if (nodeTextToken.isWhiteSpace()) {\n+                            nodeTextIndex++;\n                         } else {\n-                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n+                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n-                        comingFromRemoved = true;\n                     } else {\n-                        throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n+                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n+                    comingFromRemoved = false;\n+                } else if (diffEl instanceof Removed) {\n+                    Removed removed = (Removed)diffEl;\n+                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n+                        nodeText.removeElement(nodeTextIndex);\n+                        diffIndex++;\n+                    } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n+                            && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n+                        nodeText.removeElement(nodeTextIndex);\n+                        diffIndex++;\n+                    } else {\n+                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n+                    }\n+                    comingFromRemoved = true;\n+                } else {\n+                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n-            } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n-        }\n\\ No newline at end of file\n+            }\n+        } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n+    }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldPath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java",
						"newPath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
						"oldMethodName": "apply",
						"newMethodName": "apply"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "issue124: extract Difference\n",
					"commitDate": "2017-02-23, 9:19 AM",
					"commitName": "f415fb00bdcfe4931b43ca629ab4fb9bc3f67f16",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2017-02-23, 9:19 AM",
					"commitNameOld": "ecefb777275fd26b37f10709f97810a3e6a69bb2",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,103 +1,103 @@\n-        public void apply(NodeText nodeText) {\n-            int diffIndex = 0;\n-            int nodeTextIndex = 0;\n-            boolean comingFromRemoved = false;\n-            do {\n-                if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n-                    DifferenceElement diffEl = elements.get(diffIndex);\n-                    if (diffEl instanceof Kept) {\n-                        Kept kept = (Kept) diffEl;\n-                        if (kept.element instanceof CsmToken) {\n-                            CsmToken csmToken = (CsmToken) kept.element;\n-                            if (isWhitespace(csmToken.getTokenType())) {\n-                                diffIndex++;\n-                            } else {\n-                                throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n-                            }\n+    public void apply(NodeText nodeText) {\n+        int diffIndex = 0;\n+        int nodeTextIndex = 0;\n+        boolean comingFromRemoved = false;\n+        do {\n+            if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n+                DifferenceElement diffEl = elements.get(diffIndex);\n+                if (diffEl instanceof Kept) {\n+                    Kept kept = (Kept) diffEl;\n+                    if (kept.element instanceof CsmToken) {\n+                        CsmToken csmToken = (CsmToken) kept.element;\n+                        if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n+                            diffIndex++;\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n-                        comingFromRemoved = false;\n-                    } else if (diffEl instanceof Added) {\n-                        nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n-                        nodeTextIndex++;\n-                        diffIndex++;\n                     } else {\n-                        throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n+                        throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                     }\n-                } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n-                    TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n-                    if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n-                        nodeTextIndex++;\n-                    } else {\n-                        throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n-                    }\n+                    comingFromRemoved = false;\n+                } else if (diffEl instanceof Added) {\n+                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n+                    nodeTextIndex++;\n+                    diffIndex++;\n                 } else {\n-                    DifferenceElement diffEl = elements.get(diffIndex);\n-                    TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n-                    if (diffEl instanceof Added) {\n-                        nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n+                    throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n+                }\n+            } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n+                TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n+                if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n+                    nodeTextIndex++;\n+                } else {\n+                    throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n+                }\n+            } else {\n+                DifferenceElement diffEl = elements.get(diffIndex);\n+                TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n+                if (diffEl instanceof Added) {\n+                    nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n+                    diffIndex++;\n+                    nodeTextIndex++;\n+                    comingFromRemoved = false;\n+                } else if (diffEl instanceof Kept) {\n+                    Kept kept = (Kept)diffEl;\n+                    if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                         diffIndex++;\n                         nodeTextIndex++;\n-                        comingFromRemoved = false;\n-                    } else if (diffEl instanceof Kept) {\n-                        Kept kept = (Kept)diffEl;\n-                        if ((kept.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n-                            diffIndex++;\n-                            nodeTextIndex++;\n-                        } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof TokenTextElement) {\n-                            if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n-                                if (comingFromRemoved) {\n-                                    nodeText.removeElement(nodeTextIndex);\n-                                } else {\n-                                    nodeTextIndex++;\n-                                }\n+                    } else if ((kept.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof TokenTextElement) {\n+                        if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n+                            if (comingFromRemoved) {\n+                                nodeText.removeElement(nodeTextIndex);\n                             } else {\n-                                if (kept.element instanceof CsmChild) {\n-                                    CsmChild keptChild = (CsmChild)kept.element;\n-                                    if (keptChild.child instanceof PrimitiveType) {\n-                                        nodeTextIndex++;\n-                                        diffIndex++;\n-                                    } else {\n-                                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n-                                    }\n+                                nodeTextIndex++;\n+                            }\n+                        } else {\n+                            if (kept.element instanceof LexicalDifferenceCalculator.CsmChild) {\n+                                LexicalDifferenceCalculator.CsmChild keptChild = (LexicalDifferenceCalculator.CsmChild)kept.element;\n+                                if (keptChild.getChild() instanceof PrimitiveType) {\n+                                    nodeTextIndex++;\n+                                    diffIndex++;\n                                 } else {\n                                     throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                                 }\n-                            }\n-                        } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n-                            CsmToken csmToken = (CsmToken) kept.element;\n-                            TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n-                            if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n-                                nodeTextIndex++;\n-                                diffIndex++;\n-                            } else if (isWhitespace(csmToken.getTokenType())) {\n-                                diffIndex++;\n-                            } else if (nodeTextToken.isWhiteSpace()) {\n-                                nodeTextIndex++;\n                             } else {\n-                                throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n+                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n-                        } else {\n-                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n-                        comingFromRemoved = false;\n-                    } else if (diffEl instanceof Removed) {\n-                        Removed removed = (Removed)diffEl;\n-                        if ((removed.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n-                            nodeText.removeElement(nodeTextIndex);\n+                    } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n+                        CsmToken csmToken = (CsmToken) kept.element;\n+                        TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n+                        if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n+                            nodeTextIndex++;\n                             diffIndex++;\n-                        } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n-                                && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n-                            nodeText.removeElement(nodeTextIndex);\n+                        } else if (LexicalDifferenceCalculator.isWhitespace(csmToken.getTokenType())) {\n                             diffIndex++;\n+                        } else if (nodeTextToken.isWhiteSpace()) {\n+                            nodeTextIndex++;\n                         } else {\n-                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n+                            throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                         }\n-                        comingFromRemoved = true;\n                     } else {\n-                        throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n+                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                     }\n+                    comingFromRemoved = false;\n+                } else if (diffEl instanceof Removed) {\n+                    Removed removed = (Removed)diffEl;\n+                    if ((removed.element instanceof LexicalDifferenceCalculator.CsmChild) && nodeTextEl instanceof ChildTextElement) {\n+                        nodeText.removeElement(nodeTextIndex);\n+                        diffIndex++;\n+                    } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n+                            && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n+                        nodeText.removeElement(nodeTextIndex);\n+                        diffIndex++;\n+                    } else {\n+                        throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n+                    }\n+                    comingFromRemoved = true;\n+                } else {\n+                    throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                 }\n-            } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n-        }\n\\ No newline at end of file\n+            }\n+        } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n+    }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"ecefb777275fd26b37f10709f97810a3e6a69bb2": {
			"type": "Ybodychange",
			"commitMessage": "issue124: addressing a few more cases\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "ecefb777275fd26b37f10709f97810a3e6a69bb2",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 9:19 AM",
			"commitNameOld": "670f643e671ee92ed35db80bb96e28fc5250866d",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,93 +1,103 @@\n         public void apply(NodeText nodeText) {\n             int diffIndex = 0;\n             int nodeTextIndex = 0;\n             boolean comingFromRemoved = false;\n             do {\n                 if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                     DifferenceElement diffEl = elements.get(diffIndex);\n                     if (diffEl instanceof Kept) {\n                         Kept kept = (Kept) diffEl;\n                         if (kept.element instanceof CsmToken) {\n                             CsmToken csmToken = (CsmToken) kept.element;\n                             if (isWhitespace(csmToken.getTokenType())) {\n                                 diffIndex++;\n                             } else {\n                                 throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                             }\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                         comingFromRemoved = false;\n                     } else if (diffEl instanceof Added) {\n                         nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                         nodeTextIndex++;\n                         diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                     }\n                 } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                     TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                     if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                     }\n                 } else {\n                     DifferenceElement diffEl = elements.get(diffIndex);\n                     TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                     if (diffEl instanceof Added) {\n                         nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                         diffIndex++;\n                         nodeTextIndex++;\n                         comingFromRemoved = false;\n                     } else if (diffEl instanceof Kept) {\n                         Kept kept = (Kept)diffEl;\n                         if ((kept.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                             diffIndex++;\n                             nodeTextIndex++;\n                         } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                             if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                                 if (comingFromRemoved) {\n                                     nodeText.removeElement(nodeTextIndex);\n                                 } else {\n                                     nodeTextIndex++;\n                                 }\n                             } else {\n-                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                                if (kept.element instanceof CsmChild) {\n+                                    CsmChild keptChild = (CsmChild)kept.element;\n+                                    if (keptChild.child instanceof PrimitiveType) {\n+                                        nodeTextIndex++;\n+                                        diffIndex++;\n+                                    } else {\n+                                        throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                                    }\n+                                } else {\n+                                    throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                                }\n                             }\n                         } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n                             CsmToken csmToken = (CsmToken) kept.element;\n                             TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                             if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n                             } else if (isWhitespace(csmToken.getTokenType())) {\n                                 diffIndex++;\n                             } else if (nodeTextToken.isWhiteSpace()) {\n                                 nodeTextIndex++;\n                             } else {\n                                 throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                         comingFromRemoved = false;\n                     } else if (diffEl instanceof Removed) {\n                         Removed removed = (Removed)diffEl;\n                         if ((removed.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n                                 && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                         comingFromRemoved = true;\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                     }\n                 }\n             } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n         }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"01e9c90792e879eca937a12b6bb30b31e51aee53": {
			"type": "Ybodychange",
			"commitMessage": "issue124: expanding the cases covered\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "01e9c90792e879eca937a12b6bb30b31e51aee53",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 9:19 AM",
			"commitNameOld": "f4ce6ce924ffbd03518c64cea9b830d04f75b849",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,81 +1,93 @@\n         public void apply(NodeText nodeText) {\n             int diffIndex = 0;\n             int nodeTextIndex = 0;\n             boolean comingFromRemoved = false;\n             do {\n                 if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                     DifferenceElement diffEl = elements.get(diffIndex);\n                     if (diffEl instanceof Kept) {\n-                        Kept kept = (Kept)diffEl;\n+                        Kept kept = (Kept) diffEl;\n                         if (kept.element instanceof CsmToken) {\n-                            CsmToken csmToken = (CsmToken)kept.element;\n+                            CsmToken csmToken = (CsmToken) kept.element;\n                             if (isWhitespace(csmToken.getTokenType())) {\n                                 diffIndex++;\n                             } else {\n                                 throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                             }\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                         comingFromRemoved = false;\n+                    } else if (diffEl instanceof Added) {\n+                        nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n+                        nodeTextIndex++;\n+                        diffIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                     }\n                 } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                     TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                     if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n                         nodeTextIndex++;\n                     } else {\n                         throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n                     }\n                 } else {\n                     DifferenceElement diffEl = elements.get(diffIndex);\n                     TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                     if (diffEl instanceof Added) {\n                         nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                         diffIndex++;\n                         nodeTextIndex++;\n                         comingFromRemoved = false;\n                     } else if (diffEl instanceof Kept) {\n                         Kept kept = (Kept)diffEl;\n                         if ((kept.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                             diffIndex++;\n                             nodeTextIndex++;\n                         } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                             if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                                 if (comingFromRemoved) {\n                                     nodeText.removeElement(nodeTextIndex);\n                                 } else {\n                                     nodeTextIndex++;\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n-                            CsmToken csmToken = (CsmToken)kept.element;\n-                            TokenTextElement nodeTextToken = (TokenTextElement)nodeTextEl;\n+                            CsmToken csmToken = (CsmToken) kept.element;\n+                            TokenTextElement nodeTextToken = (TokenTextElement) nodeTextEl;\n                             if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n                                 nodeTextIndex++;\n                                 diffIndex++;\n+                            } else if (isWhitespace(csmToken.getTokenType())) {\n+                                diffIndex++;\n+                            } else if (nodeTextToken.isWhiteSpace()) {\n+                                nodeTextIndex++;\n                             } else {\n-                                throw new UnsupportedOperationException();\n+                                throw new UnsupportedOperationException(\"CSM TOKEN \" + csmToken + \" NodeText TOKEN \" + nodeTextToken);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                         comingFromRemoved = false;\n                     } else if (diffEl instanceof Removed) {\n                         Removed removed = (Removed)diffEl;\n                         if ((removed.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n+                        } else if ((removed.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement\n+                                && ((CsmToken)removed.element).getTokenType() == ((TokenTextElement)nodeTextEl).getTokenKind()) {\n+                            nodeText.removeElement(nodeTextIndex);\n+                            diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                         comingFromRemoved = true;\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                     }\n                 }\n             } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n         }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f4ce6ce924ffbd03518c64cea9b830d04f75b849": {
			"type": "Ybodychange",
			"commitMessage": "issue124: array creation level support using CSM\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "f4ce6ce924ffbd03518c64cea9b830d04f75b849",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 9:19 AM",
			"commitNameOld": "6f102302a83146e02d13ff476f39fc8a86710e38",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,68 +1,81 @@\n         public void apply(NodeText nodeText) {\n             int diffIndex = 0;\n             int nodeTextIndex = 0;\n             boolean comingFromRemoved = false;\n             do {\n                 if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                     DifferenceElement diffEl = elements.get(diffIndex);\n                     if (diffEl instanceof Kept) {\n                         Kept kept = (Kept)diffEl;\n                         if (kept.element instanceof CsmToken) {\n                             CsmToken csmToken = (CsmToken)kept.element;\n                             if (isWhitespace(csmToken.getTokenType())) {\n                                 diffIndex++;\n                             } else {\n                                 throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                             }\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n                         comingFromRemoved = false;\n                     } else {\n                         throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                     }\n                 } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n-                    nodeTextIndex++;\n-                    throw new UnsupportedOperationException(\"B\");\n+                    TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n+                    if ((nodeTextEl instanceof TokenTextElement) && ((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n+                        nodeTextIndex++;\n+                    } else {\n+                        throw new UnsupportedOperationException(\"B \" + nodeText + \". Difference: \" + this + \" \" + nodeTextEl);\n+                    }\n                 } else {\n                     DifferenceElement diffEl = elements.get(diffIndex);\n                     TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                     if (diffEl instanceof Added) {\n                         nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                         diffIndex++;\n                         nodeTextIndex++;\n                         comingFromRemoved = false;\n                     } else if (diffEl instanceof Kept) {\n                         Kept kept = (Kept)diffEl;\n                         if ((kept.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                             diffIndex++;\n                             nodeTextIndex++;\n                         } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof TokenTextElement) {\n-                            if (((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n+                            if (((TokenTextElement) nodeTextEl).isWhiteSpace()) {\n                                 if (comingFromRemoved) {\n                                     nodeText.removeElement(nodeTextIndex);\n                                 } else {\n                                     nodeTextIndex++;\n                                 }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n+                        } else if ((kept.element instanceof CsmToken) && nodeTextEl instanceof TokenTextElement) {\n+                            CsmToken csmToken = (CsmToken)kept.element;\n+                            TokenTextElement nodeTextToken = (TokenTextElement)nodeTextEl;\n+                            if (csmToken.getTokenType() == nodeTextToken.getTokenKind()) {\n+                                nodeTextIndex++;\n+                                diffIndex++;\n+                            } else {\n+                                throw new UnsupportedOperationException();\n+                            }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n                         comingFromRemoved = false;\n                     } else if (diffEl instanceof Removed) {\n                         Removed removed = (Removed)diffEl;\n                         if ((removed.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n                         comingFromRemoved = true;\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                     }\n                 }\n             } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n         }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6f102302a83146e02d13ff476f39fc8a86710e38": {
			"type": "Ybodychange",
			"commitMessage": "issue124: lexical preservation based on CSM implemented for CompilationUnit\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "6f102302a83146e02d13ff476f39fc8a86710e38",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 9:19 AM",
			"commitNameOld": "cc13f68e3655ea43b56dd13ee55a81f3a2d37fee",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,59 +1,68 @@\n         public void apply(NodeText nodeText) {\n             int diffIndex = 0;\n             int nodeTextIndex = 0;\n+            boolean comingFromRemoved = false;\n             do {\n                 if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n                     DifferenceElement diffEl = elements.get(diffIndex);\n                     if (diffEl instanceof Kept) {\n                         Kept kept = (Kept)diffEl;\n                         if (kept.element instanceof CsmToken) {\n                             CsmToken csmToken = (CsmToken)kept.element;\n                             if (isWhitespace(csmToken.getTokenType())) {\n                                 diffIndex++;\n                             } else {\n                                 throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                             }\n                         } else {\n                             throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n                         }\n+                        comingFromRemoved = false;\n                     } else {\n                         throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n                     }\n                 } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n                     nodeTextIndex++;\n                     throw new UnsupportedOperationException(\"B\");\n                 } else {\n                     DifferenceElement diffEl = elements.get(diffIndex);\n                     TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n                     if (diffEl instanceof Added) {\n                         nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n                         diffIndex++;\n                         nodeTextIndex++;\n+                        comingFromRemoved = false;\n                     } else if (diffEl instanceof Kept) {\n                         Kept kept = (Kept)diffEl;\n                         if ((kept.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                             diffIndex++;\n                             nodeTextIndex++;\n                         } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof TokenTextElement) {\n                             if (((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n-                                nodeTextIndex++;\n+                                if (comingFromRemoved) {\n+                                    nodeText.removeElement(nodeTextIndex);\n+                                } else {\n+                                    nodeTextIndex++;\n+                                }\n                             } else {\n                                 throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                             }\n                         } else {\n                             throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n                         }\n+                        comingFromRemoved = false;\n                     } else if (diffEl instanceof Removed) {\n                         Removed removed = (Removed)diffEl;\n                         if ((removed.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n                             nodeText.removeElement(nodeTextIndex);\n                             diffIndex++;\n                         } else {\n                             throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n                         }\n+                        comingFromRemoved = true;\n                     } else {\n                         throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n                     }\n                 }\n             } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n         }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cc13f68e3655ea43b56dd13ee55a81f3a2d37fee": {
			"type": "Ybodychange",
			"commitMessage": "issue124: applying differences\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "cc13f68e3655ea43b56dd13ee55a81f3a2d37fee",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-02-23, 9:19 AM",
			"commitNameOld": "c73ae5d79b62de91209477538b45ab5216fb108e",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,3 +1,59 @@\n         public void apply(NodeText nodeText) {\n-\n+            int diffIndex = 0;\n+            int nodeTextIndex = 0;\n+            do {\n+                if (diffIndex < this.elements.size() && nodeTextIndex >= nodeText.getElements().size()) {\n+                    DifferenceElement diffEl = elements.get(diffIndex);\n+                    if (diffEl instanceof Kept) {\n+                        Kept kept = (Kept)diffEl;\n+                        if (kept.element instanceof CsmToken) {\n+                            CsmToken csmToken = (CsmToken)kept.element;\n+                            if (isWhitespace(csmToken.getTokenType())) {\n+                                diffIndex++;\n+                            } else {\n+                                throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n+                            }\n+                        } else {\n+                            throw new IllegalStateException(\"Cannot keep element because we reached the end of nodetext: \" + nodeText + \". Difference: \" + this);\n+                        }\n+                    } else {\n+                        throw new UnsupportedOperationException(diffEl.getClass().getSimpleName());\n+                    }\n+                } else if (diffIndex >= this.elements.size() && nodeTextIndex < nodeText.getElements().size()) {\n+                    nodeTextIndex++;\n+                    throw new UnsupportedOperationException(\"B\");\n+                } else {\n+                    DifferenceElement diffEl = elements.get(diffIndex);\n+                    TextElement nodeTextEl = nodeText.getElements().get(nodeTextIndex);\n+                    if (diffEl instanceof Added) {\n+                        nodeText.addElement(nodeTextIndex, toTextElement(nodeText.getLexicalPreservingPrinter(), ((Added) diffEl).element));\n+                        diffIndex++;\n+                        nodeTextIndex++;\n+                    } else if (diffEl instanceof Kept) {\n+                        Kept kept = (Kept)diffEl;\n+                        if ((kept.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n+                            diffIndex++;\n+                            nodeTextIndex++;\n+                        } else if ((kept.element instanceof CsmChild) && nodeTextEl instanceof TokenTextElement) {\n+                            if (((TokenTextElement)nodeTextEl).isWhiteSpace()) {\n+                                nodeTextIndex++;\n+                            } else {\n+                                throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                            }\n+                        } else {\n+                            throw new UnsupportedOperationException(\"kept \" + kept.element + \" vs \" + nodeTextEl);\n+                        }\n+                    } else if (diffEl instanceof Removed) {\n+                        Removed removed = (Removed)diffEl;\n+                        if ((removed.element instanceof CsmChild) && nodeTextEl instanceof ChildTextElement) {\n+                            nodeText.removeElement(nodeTextIndex);\n+                            diffIndex++;\n+                        } else {\n+                            throw new UnsupportedOperationException(\"removed \" + removed.element + \" vs \" + nodeTextEl);\n+                        }\n+                    } else {\n+                        throw new UnsupportedOperationException(\"\" + diffEl + \" vs \" + nodeTextEl);\n+                    }\n+                }\n+            } while (diffIndex < this.elements.size() || nodeTextIndex < nodeText.getElements().size());\n         }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c73ae5d79b62de91209477538b45ab5216fb108e": {
			"type": "Yintroduced",
			"commitMessage": "issue124: working on calculate the CSM difference before and after a property change\n",
			"commitDate": "2017-02-23, 9:19 AM",
			"commitName": "c73ae5d79b62de91209477538b45ab5216fb108e",
			"commitAuthor": "Federico Tomassetti"
		}
	},
	"sha": "97555053af3025556efe1a168fd7943dac28a2a6"
}