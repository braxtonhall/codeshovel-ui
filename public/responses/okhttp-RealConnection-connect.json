{
	"repo": "https://github.com/square/okhttp.git",
	"file": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
	"method": {
		"longName": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, Call call, EventListener eventListener);",
		"startLine": 130,
		"methodName": "connect",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"db18f0e404ab35c7b23e8ecc27913d717e96eb84": {
			"type": "Ybodychange",
			"commitMessage": "Rename H2C to H2_PRIOR_KNOWLEDGE. (#3996)\n\nThe string h2c is used with cleartext upgrades. We're not doing those here,\r\nso that identifier isn't appropriate.",
			"commitDate": "2018-05-12, 1:29 AM",
			"commitName": "db18f0e404ab35c7b23e8ecc27913d717e96eb84",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2018-02-26, 3:55 PM",
			"commitNameOld": "9a6f88dc34cb68d341ec1a7e4c79546fa1c18c96",
			"commitAuthorOld": "Jaye Pitzeruse",
			"daysBetweenCommits": 74.36,
			"commitsBetweenForRepo": 14,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,72 +1,77 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       int pingIntervalMillis, boolean connectionRetryEnabled, Call call,\n       EventListener eventListener) {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() == null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host = route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n+    } else {\n+      if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {\n+        throw new RouteException(new UnknownServiceException(\n+            \"H2_PRIOR_KNOWLEDGE cannot be used with HTTPS\"));\n+      }\n     }\n \n     while (true) {\n       try {\n         if (route.requiresTunnel()) {\n           connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n           if (rawSocket == null) {\n             // We were unable to connect the tunnel but properly closed down our resources.\n             break;\n           }\n         } else {\n           connectSocket(connectTimeout, readTimeout, call, eventListener);\n         }\n         establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);\n         eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n         break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket = null;\n         rawSocket = null;\n         source = null;\n         sink = null;\n         handshake = null;\n         protocol = null;\n         http2Connection = null;\n \n         eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n \n     if (route.requiresTunnel() && rawSocket == null) {\n       ProtocolException exception = new ProtocolException(\"Too many tunnel connections attempted: \"\n           + MAX_TUNNEL_ATTEMPTS);\n       throw new RouteException(exception);\n     }\n \n     if (http2Connection != null) {\n       synchronized (connectionPool) {\n         allocationLimit = http2Connection.maxConcurrentStreams();\n       }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"abb0a790802996d1039c35424b70b0f3f06b94b7": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "First step towards HTTP/2 automatic pings. (#3874)\n\nThis changes the executor services in HTTP/2 connection to split up\r\nlistener executors (of which there may be many threads) from writer\r\nexecutors (of which there is one per connection).\r\n\r\nThis adds a scheduled executor job to send pings on an interval. We\r\ndon't yet fail the connection if pongs are not received.\r\n\r\nFor follow-up there's some work to remove exising APIs to send pings\r\nthrough the HTTP/2 APIs. These are unused and make it awkard to\r\nconfirm that only the automatic pings are being replied to.\r\n\r\nSee https://github.com/square/okhttp/issues/3261",
			"commitDate": "2018-02-21, 5:17 PM",
			"commitName": "abb0a790802996d1039c35424b70b0f3f06b94b7",
			"commitAuthor": "Jesse Wilson",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "First step towards HTTP/2 automatic pings. (#3874)\n\nThis changes the executor services in HTTP/2 connection to split up\r\nlistener executors (of which there may be many threads) from writer\r\nexecutors (of which there is one per connection).\r\n\r\nThis adds a scheduled executor job to send pings on an interval. We\r\ndon't yet fail the connection if pongs are not received.\r\n\r\nFor follow-up there's some work to remove exising APIs to send pings\r\nthrough the HTTP/2 APIs. These are unused and make it awkard to\r\nconfirm that only the automatic pings are being replied to.\r\n\r\nSee https://github.com/square/okhttp/issues/3261",
					"commitDate": "2018-02-21, 5:17 PM",
					"commitName": "abb0a790802996d1039c35424b70b0f3f06b94b7",
					"commitAuthor": "Jesse Wilson",
					"commitDateOld": "2018-02-17, 2:24 AM",
					"commitNameOld": "19726969aabbd0791d315994384a0cc46bf41648",
					"commitAuthorOld": "Yuri Schimke",
					"daysBetweenCommits": 4.62,
					"commitsBetweenForRepo": 13,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,71 +1,72 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n-      boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n+      int pingIntervalMillis, boolean connectionRetryEnabled, Call call,\n+      EventListener eventListener) {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() == null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host = route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n     }\n \n     while (true) {\n       try {\n         if (route.requiresTunnel()) {\n           connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n           if (rawSocket == null) {\n             // We were unable to connect the tunnel but properly closed down our resources.\n             break;\n           }\n         } else {\n           connectSocket(connectTimeout, readTimeout, call, eventListener);\n         }\n-        establishProtocol(connectionSpecSelector, call, eventListener);\n+        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);\n         eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n         break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket = null;\n         rawSocket = null;\n         source = null;\n         sink = null;\n         handshake = null;\n         protocol = null;\n         http2Connection = null;\n \n         eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n \n     if (route.requiresTunnel() && rawSocket == null) {\n       ProtocolException exception = new ProtocolException(\"Too many tunnel connections attempted: \"\n           + MAX_TUNNEL_ATTEMPTS);\n       throw new RouteException(exception);\n     }\n \n     if (http2Connection != null) {\n       synchronized (connectionPool) {\n         allocationLimit = http2Connection.maxConcurrentStreams();\n       }\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, connectionRetryEnabled-boolean, call-Call, eventListener-EventListener]",
						"newValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, pingIntervalMillis-int, connectionRetryEnabled-boolean, call-Call, eventListener-EventListener]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "First step towards HTTP/2 automatic pings. (#3874)\n\nThis changes the executor services in HTTP/2 connection to split up\r\nlistener executors (of which there may be many threads) from writer\r\nexecutors (of which there is one per connection).\r\n\r\nThis adds a scheduled executor job to send pings on an interval. We\r\ndon't yet fail the connection if pongs are not received.\r\n\r\nFor follow-up there's some work to remove exising APIs to send pings\r\nthrough the HTTP/2 APIs. These are unused and make it awkard to\r\nconfirm that only the automatic pings are being replied to.\r\n\r\nSee https://github.com/square/okhttp/issues/3261",
					"commitDate": "2018-02-21, 5:17 PM",
					"commitName": "abb0a790802996d1039c35424b70b0f3f06b94b7",
					"commitAuthor": "Jesse Wilson",
					"commitDateOld": "2018-02-17, 2:24 AM",
					"commitNameOld": "19726969aabbd0791d315994384a0cc46bf41648",
					"commitAuthorOld": "Yuri Schimke",
					"daysBetweenCommits": 4.62,
					"commitsBetweenForRepo": 13,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,71 +1,72 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n-      boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n+      int pingIntervalMillis, boolean connectionRetryEnabled, Call call,\n+      EventListener eventListener) {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() == null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host = route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n     }\n \n     while (true) {\n       try {\n         if (route.requiresTunnel()) {\n           connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n           if (rawSocket == null) {\n             // We were unable to connect the tunnel but properly closed down our resources.\n             break;\n           }\n         } else {\n           connectSocket(connectTimeout, readTimeout, call, eventListener);\n         }\n-        establishProtocol(connectionSpecSelector, call, eventListener);\n+        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);\n         eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n         break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket = null;\n         rawSocket = null;\n         source = null;\n         sink = null;\n         handshake = null;\n         protocol = null;\n         http2Connection = null;\n \n         eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n \n     if (route.requiresTunnel() && rawSocket == null) {\n       ProtocolException exception = new ProtocolException(\"Too many tunnel connections attempted: \"\n           + MAX_TUNNEL_ATTEMPTS);\n       throw new RouteException(exception);\n     }\n \n     if (http2Connection != null) {\n       synchronized (connectionPool) {\n         allocationLimit = http2Connection.maxConcurrentStreams();\n       }\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"1c98464839434a0fe7c7581cdae44bd3f2e6edd3": {
			"type": "Ybodychange",
			"commitMessage": "Move all failures into connectFailed and callFailed. (#3550)\n\nI think applications might be simple by tracking successful events\r\nseparately from failure events.",
			"commitDate": "2017-08-29, 1:14 PM",
			"commitName": "1c98464839434a0fe7c7581cdae44bd3f2e6edd3",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2017-08-28, 9:35 AM",
			"commitNameOld": "cdc48ba8b0e4bdfccc208985bfef200220096d9d",
			"commitAuthorOld": "Yuri Schimke",
			"daysBetweenCommits": 1.15,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,71 +1,71 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() == null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host = route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n     }\n \n     while (true) {\n       try {\n         if (route.requiresTunnel()) {\n           connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n           if (rawSocket == null) {\n             // We were unable to connect the tunnel but properly closed down our resources.\n             break;\n           }\n         } else {\n           connectSocket(connectTimeout, readTimeout, call, eventListener);\n         }\n         establishProtocol(connectionSpecSelector, call, eventListener);\n-        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol, null);\n+        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n         break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket = null;\n         rawSocket = null;\n         source = null;\n         sink = null;\n         handshake = null;\n         protocol = null;\n         http2Connection = null;\n \n-        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null, e);\n+        eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n \n     if (route.requiresTunnel() && rawSocket == null) {\n       ProtocolException exception = new ProtocolException(\"Too many tunnel connections attempted: \"\n           + MAX_TUNNEL_ATTEMPTS);\n       throw new RouteException(exception);\n     }\n \n     if (http2Connection != null) {\n       synchronized (connectionPool) {\n         allocationLimit = http2Connection.maxConcurrentStreams();\n       }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"29267ac4e8eae099064483dc4c4b246690a92009": {
			"type": "Ybodychange",
			"commitMessage": "Fill out documentation for EventListener (#3475)\n\n* Fill out documentation for EventListener\r\n\r\n* rename connectionFound\r\n\r\n* tests for connectionFound updated\r\n\r\n* cleanup\r\n\r\n* address comment on body calls\r\n\r\n* Update EventListener.java\r\n\r\n* connect end event added a Proxy to match against start event\r\n",
			"commitDate": "2017-07-29, 7:32 AM",
			"commitName": "29267ac4e8eae099064483dc4c4b246690a92009",
			"commitAuthor": "Yuri Schimke",
			"commitDateOld": "2017-07-23, 3:59 PM",
			"commitNameOld": "1d8233ddb7a0dfa490a340a06433909148f21610",
			"commitAuthorOld": "ericaschulz",
			"daysBetweenCommits": 5.65,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,71 +1,71 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() == null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host = route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n     }\n \n     while (true) {\n       try {\n         if (route.requiresTunnel()) {\n           connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n           if (rawSocket == null) {\n             // We were unable to connect the tunnel but properly closed down our resources.\n             break;\n           }\n         } else {\n           connectSocket(connectTimeout, readTimeout, call, eventListener);\n         }\n         establishProtocol(connectionSpecSelector, call, eventListener);\n-        eventListener.connectEnd(call, route.socketAddress(), protocol, null);\n+        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol, null);\n         break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket = null;\n         rawSocket = null;\n         source = null;\n         sink = null;\n         handshake = null;\n         protocol = null;\n         http2Connection = null;\n \n-        eventListener.connectEnd(call, route.socketAddress(), null, e);\n+        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null, e);\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n \n     if (route.requiresTunnel() && rawSocket == null) {\n       ProtocolException exception = new ProtocolException(\"Too many tunnel connections attempted: \"\n           + MAX_TUNNEL_ATTEMPTS);\n       throw new RouteException(exception);\n     }\n \n     if (http2Connection != null) {\n       synchronized (connectionPool) {\n         allocationLimit = http2Connection.maxConcurrentStreams();\n       }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c7d508b79c9e201c91ec23f5eec47c18be206567": {
			"type": "Ybodychange",
			"commitMessage": "Add support for connect start/end events. (#3434)\n\n",
			"commitDate": "2017-07-06, 6:55 AM",
			"commitName": "c7d508b79c9e201c91ec23f5eec47c18be206567",
			"commitAuthor": "Dave Roberge",
			"commitDateOld": "2017-07-02, 7:10 AM",
			"commitNameOld": "a32b1044a480aabbf4716d5c90b907c5ec46056c",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 3.99,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,58 +1,71 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() == null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host = route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n     }\n \n     while (true) {\n       try {\n         if (route.requiresTunnel()) {\n-          connectTunnel(connectTimeout, readTimeout, writeTimeout);\n+          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n+          if (rawSocket == null) {\n+            // We were unable to connect the tunnel but properly closed down our resources.\n+            break;\n+          }\n         } else {\n-          connectSocket(connectTimeout, readTimeout);\n+          connectSocket(connectTimeout, readTimeout, call, eventListener);\n         }\n         establishProtocol(connectionSpecSelector, call, eventListener);\n+        eventListener.connectEnd(call, route.socketAddress(), protocol, null);\n         break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket = null;\n         rawSocket = null;\n         source = null;\n         sink = null;\n         handshake = null;\n         protocol = null;\n         http2Connection = null;\n \n+        eventListener.connectEnd(call, route.socketAddress(), null, e);\n+\n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n \n+    if (route.requiresTunnel() && rawSocket == null) {\n+      ProtocolException exception = new ProtocolException(\"Too many tunnel connections attempted: \"\n+          + MAX_TUNNEL_ATTEMPTS);\n+      throw new RouteException(exception);\n+    }\n+\n     if (http2Connection != null) {\n       synchronized (connectionPool) {\n         allocationLimit = http2Connection.maxConcurrentStreams();\n       }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5fb5ab50a77efc761489493d4a0b8b9de85feec7": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Added support for secure connect events.\n\nhttps://github.com/square/okhttp/issues/270\n",
			"commitDate": "2017-06-20, 6:14 AM",
			"commitName": "5fb5ab50a77efc761489493d4a0b8b9de85feec7",
			"commitAuthor": "Dave Roberge",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Added support for secure connect events.\n\nhttps://github.com/square/okhttp/issues/270\n",
					"commitDate": "2017-06-20, 6:14 AM",
					"commitName": "5fb5ab50a77efc761489493d4a0b8b9de85feec7",
					"commitAuthor": "Dave Roberge",
					"commitDateOld": "2017-05-11, 3:53 PM",
					"commitNameOld": "b8a0352d524b3d339e71a83b04c63eee8aa3f291",
					"commitAuthorOld": "Kasra Bigdeli",
					"daysBetweenCommits": 39.6,
					"commitsBetweenForRepo": 20,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,58 +1,58 @@\n-  public void connect(\n-      int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {\n+  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n+      boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() == null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host = route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n     }\n \n     while (true) {\n       try {\n         if (route.requiresTunnel()) {\n           connectTunnel(connectTimeout, readTimeout, writeTimeout);\n         } else {\n           connectSocket(connectTimeout, readTimeout);\n         }\n-        establishProtocol(connectionSpecSelector);\n+        establishProtocol(connectionSpecSelector, call, eventListener);\n         break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket = null;\n         rawSocket = null;\n         source = null;\n         sink = null;\n         handshake = null;\n         protocol = null;\n         http2Connection = null;\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n \n     if (http2Connection != null) {\n       synchronized (connectionPool) {\n         allocationLimit = http2Connection.maxConcurrentStreams();\n       }\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, connectionRetryEnabled-boolean]",
						"newValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, connectionRetryEnabled-boolean, call-Call, eventListener-EventListener]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Added support for secure connect events.\n\nhttps://github.com/square/okhttp/issues/270\n",
					"commitDate": "2017-06-20, 6:14 AM",
					"commitName": "5fb5ab50a77efc761489493d4a0b8b9de85feec7",
					"commitAuthor": "Dave Roberge",
					"commitDateOld": "2017-05-11, 3:53 PM",
					"commitNameOld": "b8a0352d524b3d339e71a83b04c63eee8aa3f291",
					"commitAuthorOld": "Kasra Bigdeli",
					"daysBetweenCommits": 39.6,
					"commitsBetweenForRepo": 20,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,58 +1,58 @@\n-  public void connect(\n-      int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {\n+  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n+      boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() == null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host = route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n     }\n \n     while (true) {\n       try {\n         if (route.requiresTunnel()) {\n           connectTunnel(connectTimeout, readTimeout, writeTimeout);\n         } else {\n           connectSocket(connectTimeout, readTimeout);\n         }\n-        establishProtocol(connectionSpecSelector);\n+        establishProtocol(connectionSpecSelector, call, eventListener);\n         break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket = null;\n         rawSocket = null;\n         source = null;\n         sink = null;\n         handshake = null;\n         protocol = null;\n         http2Connection = null;\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n \n     if (http2Connection != null) {\n       synchronized (connectionPool) {\n         allocationLimit = http2Connection.maxConcurrentStreams();\n       }\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"98443a9ca8ca9ad82d5fb9b05b32f180bb510601": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Release duplicated multiplexed connections.\n\nIf we make concurrent requests to an HTTP/2 server, close all but\nthe first connection. Creating multiple connections and then later\nreleasing them is somewhat pessimistic; it's also much safer for\nawkward cases like connect attempts being canceled.\n\nCloses: https://github.com/square/okhttp/issues/373\n",
			"commitDate": "2017-01-07, 11:15 AM",
			"commitName": "98443a9ca8ca9ad82d5fb9b05b32f180bb510601",
			"commitAuthor": "jwilson",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Release duplicated multiplexed connections.\n\nIf we make concurrent requests to an HTTP/2 server, close all but\nthe first connection. Creating multiple connections and then later\nreleasing them is somewhat pessimistic; it's also much safer for\nawkward cases like connect attempts being canceled.\n\nCloses: https://github.com/square/okhttp/issues/373\n",
					"commitDate": "2017-01-07, 11:15 AM",
					"commitName": "98443a9ca8ca9ad82d5fb9b05b32f180bb510601",
					"commitAuthor": "jwilson",
					"commitDateOld": "2017-01-02, 9:36 AM",
					"commitNameOld": "8331b2d75a51631bee622daf2175854fe49ce29a",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 5.07,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,57 +1,58 @@\n-  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n-      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) {\n+  public void connect(\n+      int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n+    List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() == null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host = route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n     }\n \n     while (true) {\n       try {\n         if (route.requiresTunnel()) {\n           connectTunnel(connectTimeout, readTimeout, writeTimeout);\n         } else {\n           connectSocket(connectTimeout, readTimeout);\n         }\n         establishProtocol(connectionSpecSelector);\n         break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket = null;\n         rawSocket = null;\n         source = null;\n         sink = null;\n         handshake = null;\n         protocol = null;\n         http2Connection = null;\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n \n     if (http2Connection != null) {\n       synchronized (connectionPool) {\n         allocationLimit = http2Connection.maxConcurrentStreams();\n       }\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, connectionSpecs-List<ConnectionSpec>, connectionRetryEnabled-boolean]",
						"newValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, connectionRetryEnabled-boolean]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Release duplicated multiplexed connections.\n\nIf we make concurrent requests to an HTTP/2 server, close all but\nthe first connection. Creating multiple connections and then later\nreleasing them is somewhat pessimistic; it's also much safer for\nawkward cases like connect attempts being canceled.\n\nCloses: https://github.com/square/okhttp/issues/373\n",
					"commitDate": "2017-01-07, 11:15 AM",
					"commitName": "98443a9ca8ca9ad82d5fb9b05b32f180bb510601",
					"commitAuthor": "jwilson",
					"commitDateOld": "2017-01-02, 9:36 AM",
					"commitNameOld": "8331b2d75a51631bee622daf2175854fe49ce29a",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 5.07,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,57 +1,58 @@\n-  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n-      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) {\n+  public void connect(\n+      int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n+    List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() == null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host = route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n     }\n \n     while (true) {\n       try {\n         if (route.requiresTunnel()) {\n           connectTunnel(connectTimeout, readTimeout, writeTimeout);\n         } else {\n           connectSocket(connectTimeout, readTimeout);\n         }\n         establishProtocol(connectionSpecSelector);\n         break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket = null;\n         rawSocket = null;\n         source = null;\n         sink = null;\n         handshake = null;\n         protocol = null;\n         http2Connection = null;\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n \n     if (http2Connection != null) {\n       synchronized (connectionPool) {\n         allocationLimit = http2Connection.maxConcurrentStreams();\n       }\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"8331b2d75a51631bee622daf2175854fe49ce29a": {
			"type": "Ybodychange",
			"commitMessage": "Fix RealConnection to guard allocationLimit by connectionPool.\n\nI'm working towards making OkHttp limit itself to a single HTTP/2 connection\nto a single host. In this work I found we're not sufficiently safe on\nallocationLimit - connections are added to the pool when this is 0, and\nthe value is updated without any synchronization.\n\nThis change also reduces the visibility of some connection fields in\nRealConnection and organizes the fields into two sets: those that are\nimmutable after connect and those that are guarded by connectionPool.\n\nhttps://github.com/square/okhttp/issues/373\n",
			"commitDate": "2017-01-02, 9:36 AM",
			"commitName": "8331b2d75a51631bee622daf2175854fe49ce29a",
			"commitAuthor": "jwilson",
			"commitDateOld": "2016-12-26, 5:24 PM",
			"commitNameOld": "a589b8170333476233d48476587a1d4363c90bd0",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 6.68,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,49 +1,57 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() == null) {\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication not enabled for client\"));\n       }\n       String host = route.address().url().host();\n       if (!Platform.get().isCleartextTrafficPermitted(host)) {\n         throw new RouteException(new UnknownServiceException(\n             \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n       }\n     }\n \n-    while (protocol == null) {\n+    while (true) {\n       try {\n         if (route.requiresTunnel()) {\n-          buildTunneledConnection(connectTimeout, readTimeout, writeTimeout,\n-              connectionSpecSelector);\n+          connectTunnel(connectTimeout, readTimeout, writeTimeout);\n         } else {\n-          buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n+          connectSocket(connectTimeout, readTimeout);\n         }\n+        establishProtocol(connectionSpecSelector);\n+        break;\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket = null;\n         rawSocket = null;\n         source = null;\n         sink = null;\n         handshake = null;\n         protocol = null;\n+        http2Connection = null;\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n+\n+    if (http2Connection != null) {\n+      synchronized (connectionPool) {\n+        allocationLimit = http2Connection.maxConcurrentStreams();\n+      }\n+    }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1f58b14bd18565b3dc4aaf15c072033e68b69660": {
			"type": "Ybodychange",
			"commitMessage": "Always pass a host to NetworkSecurityPolicy.isCleartextTrafficPermitted().\n\nPreviously we were misinterpretting which hosts this method applied to.\nSuppose an Android app was configured to require TLS for bank.com and\nnot for any other address. The NetworkSecurityPolicy.isCleartextTrafficPermitted()\nmethod would return false because cleartext traffic wasn't universally\npermitted. And OkHttp would incorrectly forbid cleartext communication\nto other hosts like puppies.com.\n\nCloses: https://github.com/square/okhttp/issues/2640\n",
			"commitDate": "2016-07-02, 10:39 AM",
			"commitName": "1f58b14bd18565b3dc4aaf15c072033e68b69660",
			"commitAuthor": "jwilson",
			"commitDateOld": "2016-06-26, 8:04 PM",
			"commitNameOld": "c5187583bbfe93fe58db80f95b5b478c84180c29",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 5.61,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,43 +1,49 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n \n-    if (route.address().sslSocketFactory() == null\n-        && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n-      throw new RouteException(new UnknownServiceException(\n-          \"CLEARTEXT communication not supported: \" + connectionSpecs));\n+    if (route.address().sslSocketFactory() == null) {\n+      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n+        throw new RouteException(new UnknownServiceException(\n+            \"CLEARTEXT communication not enabled for client\"));\n+      }\n+      String host = route.address().url().host();\n+      if (!Platform.get().isCleartextTrafficPermitted(host)) {\n+        throw new RouteException(new UnknownServiceException(\n+            \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n+      }\n     }\n \n     while (protocol == null) {\n       try {\n         if (route.requiresTunnel()) {\n           buildTunneledConnection(connectTimeout, readTimeout, writeTimeout,\n               connectionSpecSelector);\n         } else {\n           buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n         }\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket = null;\n         rawSocket = null;\n         source = null;\n         sink = null;\n         handshake = null;\n         protocol = null;\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c5187583bbfe93fe58db80f95b5b478c84180c29": {
			"type": "Yfilerename",
			"commitMessage": "Add connection, cache, and platform subpackages.\n",
			"commitDate": "2016-06-26, 8:04 PM",
			"commitName": "c5187583bbfe93fe58db80f95b5b478c84180c29",
			"commitAuthor": "jwilson",
			"commitDateOld": "2016-06-26, 6:10 PM",
			"commitNameOld": "81b3a99aea8571942e5fb18b5c189c4596087076",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 0.08,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "okhttp/src/main/java/okhttp3/internal/io/RealConnection.java",
				"newPath": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java"
			}
		},
		"576408374d58a3e9a63714b6f7761cb42a315102": {
			"type": "Yexceptionschange",
			"commitMessage": "Begin to fold together parts of RealCall and HttpEngine.\n\nPreviously we had an awkward, arbitrary separation because RealCall contained\nthe stuff that wasn't in HttpURLConnection, and HttpEngine contained everything\nthat was shared.\n\nIt was also awkward because HttpEngine could be interrupted in various parts\nof the HttpURLConnection flow: after connecting, while transmitting the request\nbody, etc. With this change we no longer need to handle API calls while we're\nin these intermediate states, which means we can reduce the scope of certain\nthings from fields to local variables.\n\nThere's still a way to go here but this is more easy wins.\n",
			"commitDate": "2016-06-23, 7:54 PM",
			"commitName": "576408374d58a3e9a63714b6f7761cb42a315102",
			"commitAuthor": "jwilson",
			"commitDateOld": "2016-04-10, 12:02 PM",
			"commitNameOld": "c9ad163e92fe252f23b743d694f68967a29eae7c",
			"commitAuthorOld": "",
			"daysBetweenCommits": 74.33,
			"commitsBetweenForRepo": 46,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,43 +1,43 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n-      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n+      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n \n     if (route.address().sslSocketFactory() == null\n         && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol == null) {\n       try {\n         if (route.requiresTunnel()) {\n           buildTunneledConnection(connectTimeout, readTimeout, writeTimeout,\n               connectionSpecSelector);\n         } else {\n           buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n         }\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket = null;\n         rawSocket = null;\n         source = null;\n         sink = null;\n         handshake = null;\n         protocol = null;\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[RouteException]",
				"newValue": "[]"
			}
		},
		"03a840de533b1f1c201aa4e99f95f42f9a8269a4": {
			"type": "Ybodychange",
			"commitMessage": "Accommodate tunneling proxies that close the connection after an auth challenge.\n",
			"commitDate": "2016-04-08, 4:56 AM",
			"commitName": "03a840de533b1f1c201aa4e99f95f42f9a8269a4",
			"commitAuthor": "Dave Roberge",
			"commitDateOld": "2016-02-21, 9:13 PM",
			"commitNameOld": "7ceaa2387f0be853222f5a1496f1f743fa6f8c6d",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 46.28,
			"commitsBetweenForRepo": 22,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,43 +1,43 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n-    Proxy proxy = route.proxy();\n-    Address address = route.address();\n \n     if (route.address().sslSocketFactory() == null\n         && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol == null) {\n       try {\n-        rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP\n-            ? address.socketFactory().createSocket()\n-            : new Socket(proxy);\n-        connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n+        if (route.requiresTunnel()) {\n+          buildTunneledConnection(connectTimeout, readTimeout, writeTimeout,\n+              connectionSpecSelector);\n+        } else {\n+          buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n+        }\n       } catch (IOException e) {\n         closeQuietly(socket);\n         closeQuietly(rawSocket);\n         socket = null;\n         rawSocket = null;\n         source = null;\n         sink = null;\n         handshake = null;\n         protocol = null;\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c9a89876de476983f273edbf108c365127c18c5e": {
			"type": "Ymultichange(Ymovefromfile,Ybodychange)",
			"commitMessage": "Rename com.squareup.okhttp to okhttp3\n\nMaven group changes will come in follow up.\n",
			"commitDate": "2015-12-15, 10:34 PM",
			"commitName": "c9a89876de476983f273edbf108c365127c18c5e",
			"commitAuthor": "jwilson",
			"subchanges": [
				{
					"type": "Ymovefromfile",
					"commitMessage": "Rename com.squareup.okhttp to okhttp3\n\nMaven group changes will come in follow up.\n",
					"commitDate": "2015-12-15, 10:34 PM",
					"commitName": "c9a89876de476983f273edbf108c365127c18c5e",
					"commitAuthor": "jwilson",
					"commitDateOld": "2015-12-15, 6:36 PM",
					"commitNameOld": "54dc2df914f2aae37fb48cc2c2f7560ee664bc2b",
					"commitAuthorOld": "Jake Wharton",
					"daysBetweenCommits": 0.17,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,43 +1,43 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy = route.proxy();\n     Address address = route.address();\n \n     if (route.address().sslSocketFactory() == null\n         && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol == null) {\n       try {\n         rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP\n             ? address.socketFactory().createSocket()\n             : new Socket(proxy);\n         connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n       } catch (IOException e) {\n-        Util.closeQuietly(socket);\n-        Util.closeQuietly(rawSocket);\n+        closeQuietly(socket);\n+        closeQuietly(rawSocket);\n         socket = null;\n         rawSocket = null;\n         source = null;\n         sink = null;\n         handshake = null;\n         protocol = null;\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldPath": "okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java",
						"newPath": "okhttp/src/main/java/okhttp3/internal/io/RealConnection.java",
						"oldMethodName": "connect",
						"newMethodName": "connect"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Rename com.squareup.okhttp to okhttp3\n\nMaven group changes will come in follow up.\n",
					"commitDate": "2015-12-15, 10:34 PM",
					"commitName": "c9a89876de476983f273edbf108c365127c18c5e",
					"commitAuthor": "jwilson",
					"commitDateOld": "2015-12-15, 6:36 PM",
					"commitNameOld": "54dc2df914f2aae37fb48cc2c2f7560ee664bc2b",
					"commitAuthorOld": "Jake Wharton",
					"daysBetweenCommits": 0.17,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,43 +1,43 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy = route.proxy();\n     Address address = route.address();\n \n     if (route.address().sslSocketFactory() == null\n         && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol == null) {\n       try {\n         rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP\n             ? address.socketFactory().createSocket()\n             : new Socket(proxy);\n         connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n       } catch (IOException e) {\n-        Util.closeQuietly(socket);\n-        Util.closeQuietly(rawSocket);\n+        closeQuietly(socket);\n+        closeQuietly(rawSocket);\n         socket = null;\n         rawSocket = null;\n         source = null;\n         sink = null;\n         handshake = null;\n         protocol = null;\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"b63841d3a3922440c258098190371f1e17d977c1": {
			"type": "Ybodychange",
			"commitMessage": "Drop 'get' prefixed on Address value type.\n",
			"commitDate": "2015-12-14, 9:57 PM",
			"commitName": "b63841d3a3922440c258098190371f1e17d977c1",
			"commitAuthor": "Jake Wharton",
			"commitDateOld": "2015-12-14, 9:45 PM",
			"commitNameOld": "71ae4df298f42039579fd6e3c6d9d9060ac91214",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,43 +1,43 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy = route.proxy();\n     Address address = route.address();\n \n-    if (route.address().getSslSocketFactory() == null\n+    if (route.address().sslSocketFactory() == null\n         && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol == null) {\n       try {\n         rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP\n-            ? address.getSocketFactory().createSocket()\n+            ? address.socketFactory().createSocket()\n             : new Socket(proxy);\n         connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n       } catch (IOException e) {\n         Util.closeQuietly(socket);\n         Util.closeQuietly(rawSocket);\n         socket = null;\n         rawSocket = null;\n         source = null;\n         sink = null;\n         handshake = null;\n         protocol = null;\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"71ae4df298f42039579fd6e3c6d9d9060ac91214": {
			"type": "Ybodychange",
			"commitMessage": "Drop 'get' prefixed on Route value type.\n",
			"commitDate": "2015-12-14, 9:45 PM",
			"commitName": "71ae4df298f42039579fd6e3c6d9d9060ac91214",
			"commitAuthor": "Jake Wharton",
			"commitDateOld": "2015-12-14, 12:11 PM",
			"commitNameOld": "93d547dcdaecddfa456aee0571131db2342e5abb",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 0.4,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,43 +1,43 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n-    Proxy proxy = route.getProxy();\n-    Address address = route.getAddress();\n+    Proxy proxy = route.proxy();\n+    Address address = route.address();\n \n-    if (route.getAddress().getSslSocketFactory() == null\n+    if (route.address().getSslSocketFactory() == null\n         && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol == null) {\n       try {\n         rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP\n             ? address.getSocketFactory().createSocket()\n             : new Socket(proxy);\n         connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n       } catch (IOException e) {\n         Util.closeQuietly(socket);\n         Util.closeQuietly(rawSocket);\n         socket = null;\n         rawSocket = null;\n         source = null;\n         sink = null;\n         handshake = null;\n         protocol = null;\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c5f58e45454d1ffc621c65e377cb91345018e087": {
			"type": "Ybodychange",
			"commitMessage": "Honor the max concurrent streams setting.\n\nCloses https://github.com/square/okhttp/issues/1484\n",
			"commitDate": "2015-12-02, 9:44 AM",
			"commitName": "c5f58e45454d1ffc621c65e377cb91345018e087",
			"commitAuthor": "jwilson",
			"commitDateOld": "2015-11-30, 7:57 PM",
			"commitNameOld": "7fc2993c427ef7c36430a4efa5d5c1d5dd5e0dc9",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 1.57,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,44 +1,43 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy = route.getProxy();\n     Address address = route.getAddress();\n \n     if (route.getAddress().getSslSocketFactory() == null\n         && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol == null) {\n       try {\n         rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP\n             ? address.getSocketFactory().createSocket()\n             : new Socket(proxy);\n         connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n       } catch (IOException e) {\n         Util.closeQuietly(socket);\n         Util.closeQuietly(rawSocket);\n         socket = null;\n         rawSocket = null;\n         source = null;\n         sink = null;\n         handshake = null;\n         protocol = null;\n-        framedConnection = null;\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ee87f8036f99fdfd63f8ef145f4478907682db29": {
			"type": "Ybodychange",
			"commitMessage": "Change async cancel to cancel the raw socket only.\n\nPreviously we could close an SSL socket which does synchronous I/O. This\nmade it unreasonable to cancel a call on a UI thread.\n\nCloses: https://github.com/square/okhttp/issues/1592\n",
			"commitDate": "2015-11-29, 7:58 PM",
			"commitName": "ee87f8036f99fdfd63f8ef145f4478907682db29",
			"commitAuthor": "jwilson",
			"commitDateOld": "2015-11-28, 6:36 AM",
			"commitNameOld": "c358656c8799d30fd422448153e99a5dd37e298a",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 1.56,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,42 +1,44 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy = route.getProxy();\n     Address address = route.getAddress();\n \n     if (route.getAddress().getSslSocketFactory() == null\n         && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol == null) {\n       try {\n-        socket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP\n+        rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP\n             ? address.getSocketFactory().createSocket()\n             : new Socket(proxy);\n         connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n       } catch (IOException e) {\n         Util.closeQuietly(socket);\n+        Util.closeQuietly(rawSocket);\n         socket = null;\n+        rawSocket = null;\n         source = null;\n         sink = null;\n         handshake = null;\n         protocol = null;\n         framedConnection = null;\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c358656c8799d30fd422448153e99a5dd37e298a": {
			"type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
			"commitMessage": "First draft of the new new stream allocations model.\n",
			"commitDate": "2015-11-28, 6:36 AM",
			"commitName": "c358656c8799d30fd422448153e99a5dd37e298a",
			"commitAuthor": "jwilson",
			"subchanges": [
				{
					"type": "Ymovefromfile",
					"commitMessage": "First draft of the new new stream allocations model.\n",
					"commitDate": "2015-11-28, 6:36 AM",
					"commitName": "c358656c8799d30fd422448153e99a5dd37e298a",
					"commitAuthor": "jwilson",
					"commitDateOld": "2015-11-26, 8:28 PM",
					"commitNameOld": "e0d34ebdd7aba18149d195804075a87b97f3c02d",
					"commitAuthorOld": "Jake Wharton",
					"daysBetweenCommits": 1.42,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,41 +1,42 @@\n-  void connect(int connectTimeout, int readTimeout, int writeTimeout,\n+  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy = route.getProxy();\n     Address address = route.getAddress();\n \n-    if (route.address.getSslSocketFactory() == null\n+    if (route.getAddress().getSslSocketFactory() == null\n         && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol == null) {\n       try {\n         socket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP\n             ? address.getSocketFactory().createSocket()\n             : new Socket(proxy);\n         connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n       } catch (IOException e) {\n         Util.closeQuietly(socket);\n         socket = null;\n+        source = null;\n+        sink = null;\n         handshake = null;\n         protocol = null;\n-        httpConnection = null;\n         framedConnection = null;\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldPath": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
						"newPath": "okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java",
						"oldMethodName": "connect",
						"newMethodName": "connect"
					}
				},
				{
					"type": "Ymodifierchange",
					"commitMessage": "First draft of the new new stream allocations model.\n",
					"commitDate": "2015-11-28, 6:36 AM",
					"commitName": "c358656c8799d30fd422448153e99a5dd37e298a",
					"commitAuthor": "jwilson",
					"commitDateOld": "2015-11-26, 8:28 PM",
					"commitNameOld": "e0d34ebdd7aba18149d195804075a87b97f3c02d",
					"commitAuthorOld": "Jake Wharton",
					"daysBetweenCommits": 1.42,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,41 +1,42 @@\n-  void connect(int connectTimeout, int readTimeout, int writeTimeout,\n+  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy = route.getProxy();\n     Address address = route.getAddress();\n \n-    if (route.address.getSslSocketFactory() == null\n+    if (route.getAddress().getSslSocketFactory() == null\n         && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol == null) {\n       try {\n         socket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP\n             ? address.getSocketFactory().createSocket()\n             : new Socket(proxy);\n         connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n       } catch (IOException e) {\n         Util.closeQuietly(socket);\n         socket = null;\n+        source = null;\n+        sink = null;\n         handshake = null;\n         protocol = null;\n-        httpConnection = null;\n         framedConnection = null;\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[]",
						"newValue": "[public]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "First draft of the new new stream allocations model.\n",
					"commitDate": "2015-11-28, 6:36 AM",
					"commitName": "c358656c8799d30fd422448153e99a5dd37e298a",
					"commitAuthor": "jwilson",
					"commitDateOld": "2015-11-26, 8:28 PM",
					"commitNameOld": "e0d34ebdd7aba18149d195804075a87b97f3c02d",
					"commitAuthorOld": "Jake Wharton",
					"daysBetweenCommits": 1.42,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,41 +1,42 @@\n-  void connect(int connectTimeout, int readTimeout, int writeTimeout,\n+  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy = route.getProxy();\n     Address address = route.getAddress();\n \n-    if (route.address.getSslSocketFactory() == null\n+    if (route.getAddress().getSslSocketFactory() == null\n         && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (protocol == null) {\n       try {\n         socket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP\n             ? address.getSocketFactory().createSocket()\n             : new Socket(proxy);\n         connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n       } catch (IOException e) {\n         Util.closeQuietly(socket);\n         socket = null;\n+        source = null;\n+        sink = null;\n         handshake = null;\n         protocol = null;\n-        httpConnection = null;\n         framedConnection = null;\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"529c4a36bb21b3fb7717c27f8a31c39c1b603e9d": {
			"type": "Ybodychange",
			"commitMessage": "Stop returning HTTP/1.0 from Connection.getProtocol().\n\nThis was updating the protocol as a side-effect of an HTTP/1.0 response.\nThis made the protocol field mutable, and the code more difficult to\ntrace.\n\nOne consequence of this change is that OkHttp will attempt HTTP/1.1 for\nall requests, even if a server returns HTTP/1.0 from the first response.\nThis is closer to our implementation anyway.\n",
			"commitDate": "2015-11-17, 9:01 PM",
			"commitName": "529c4a36bb21b3fb7717c27f8a31c39c1b603e9d",
			"commitAuthor": "jwilson",
			"commitDateOld": "2015-11-14, 7:28 PM",
			"commitNameOld": "457fb428a729c50c562822571ea9b13e689648f3",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 3.06,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,39 +1,41 @@\n   void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n-    if (connected) throw new IllegalStateException(\"already connected\");\n+    if (protocol != null) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy = route.getProxy();\n     Address address = route.getAddress();\n \n     if (route.address.getSslSocketFactory() == null\n         && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n-    while (!connected) {\n+    while (protocol == null) {\n       try {\n         socket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP\n             ? address.getSocketFactory().createSocket()\n             : new Socket(proxy);\n-        connectSocket(connectTimeout, readTimeout, writeTimeout,\n-            connectionSpecSelector);\n-        connected = true; // Success!\n+        connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n       } catch (IOException e) {\n         Util.closeQuietly(socket);\n         socket = null;\n+        handshake = null;\n+        protocol = null;\n+        httpConnection = null;\n+        framedConnection = null;\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"457fb428a729c50c562822571ea9b13e689648f3": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Don't use the request to build the proxy tunnel.\n\nThe tunnel is shared between requests, and it's awkward to build that with the\nfirst request that needs it.\n",
			"commitDate": "2015-11-14, 7:28 PM",
			"commitName": "457fb428a729c50c562822571ea9b13e689648f3",
			"commitAuthor": "jwilson",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Don't use the request to build the proxy tunnel.\n\nThe tunnel is shared between requests, and it's awkward to build that with the\nfirst request that needs it.\n",
					"commitDate": "2015-11-14, 7:28 PM",
					"commitName": "457fb428a729c50c562822571ea9b13e689648f3",
					"commitAuthor": "jwilson",
					"commitDateOld": "2015-08-24, 7:43 PM",
					"commitNameOld": "ebaaf10ec1f861b2d4b455e01d3118568f4c6f51",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 82.03,
					"commitsBetweenForRepo": 61,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,39 +1,39 @@\n-  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,\n+  void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy = route.getProxy();\n     Address address = route.getAddress();\n \n     if (route.address.getSslSocketFactory() == null\n         && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (!connected) {\n       try {\n         socket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP\n             ? address.getSocketFactory().createSocket()\n             : new Socket(proxy);\n-        connectSocket(connectTimeout, readTimeout, writeTimeout, request,\n+        connectSocket(connectTimeout, readTimeout, writeTimeout,\n             connectionSpecSelector);\n         connected = true; // Success!\n       } catch (IOException e) {\n         Util.closeQuietly(socket);\n         socket = null;\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, request-Request, connectionSpecs-List<ConnectionSpec>, connectionRetryEnabled-boolean]",
						"newValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, connectionSpecs-List<ConnectionSpec>, connectionRetryEnabled-boolean]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Don't use the request to build the proxy tunnel.\n\nThe tunnel is shared between requests, and it's awkward to build that with the\nfirst request that needs it.\n",
					"commitDate": "2015-11-14, 7:28 PM",
					"commitName": "457fb428a729c50c562822571ea9b13e689648f3",
					"commitAuthor": "jwilson",
					"commitDateOld": "2015-08-24, 7:43 PM",
					"commitNameOld": "ebaaf10ec1f861b2d4b455e01d3118568f4c6f51",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 82.03,
					"commitsBetweenForRepo": 61,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,39 +1,39 @@\n-  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,\n+  void connect(int connectTimeout, int readTimeout, int writeTimeout,\n       List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     RouteException routeException = null;\n     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy = route.getProxy();\n     Address address = route.getAddress();\n \n     if (route.address.getSslSocketFactory() == null\n         && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n       throw new RouteException(new UnknownServiceException(\n           \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n     while (!connected) {\n       try {\n         socket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP\n             ? address.getSocketFactory().createSocket()\n             : new Socket(proxy);\n-        connectSocket(connectTimeout, readTimeout, writeTimeout, request,\n+        connectSocket(connectTimeout, readTimeout, writeTimeout,\n             connectionSpecSelector);\n         connected = true; // Success!\n       } catch (IOException e) {\n         Util.closeQuietly(socket);\n         socket = null;\n \n         if (routeException == null) {\n           routeException = new RouteException(e);\n         } else {\n           routeException.addConnectException(e);\n         }\n \n         if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n           throw routeException;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"b42e73f497eafe147667117202267ec756adff26": {
			"type": "Ybodychange",
			"commitMessage": "Make call canceling more reliable.\n\nWe had a bug where the socket-being-connected wasn't being closed when the\napplication used Call.cancel(). The problem is that the SocketConnector model\nassumes the Connection doesn't want a Socket instance until it's fully\nconnected.\n\nThis moves the SocketConnector code back into Connection, removes a lot of\nnested try/catch blocks, and assigns a Socket instance as soon as its created.\n\nThis also likely fixes some bugs where sockets weren't being closed when\nan IOException or RouteException was thrown during connection. Now we always\nclose at the top level of connect() unless the connection is successful.\n\nhttps://github.com/square/okhttp/issues/1779\n",
			"commitDate": "2015-08-01, 4:54 PM",
			"commitName": "b42e73f497eafe147667117202267ec756adff26",
			"commitAuthor": "jwilson",
			"commitDateOld": "2015-06-17, 3:40 PM",
			"commitNameOld": "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 45.05,
			"commitsBetweenForRepo": 15,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,39 +1,39 @@\n   void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,\n       List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n-    SocketConnector socketConnector = new SocketConnector(this, pool);\n-    SocketConnector.ConnectedSocket connectedSocket;\n-    if (route.address.getSslSocketFactory() != null) {\n-      // https:// communication\n-      connectedSocket = socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout,\n-          request, route, connectionSpecs, connectionRetryEnabled);\n-    } else {\n-      // http:// communication.\n-      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n-        throw new RouteException(\n-            new UnknownServiceException(\n-                \"CLEARTEXT communication not supported: \" + connectionSpecs));\n-      }\n-      connectedSocket = socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n+    RouteException routeException = null;\n+    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);\n+    Proxy proxy = route.getProxy();\n+    Address address = route.getAddress();\n+\n+    if (route.address.getSslSocketFactory() == null\n+        && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n+      throw new RouteException(new UnknownServiceException(\n+          \"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n \n-    socket = connectedSocket.socket;\n-    handshake = connectedSocket.handshake;\n-    protocol = connectedSocket.alpnProtocol == null\n-        ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n+    while (!connected) {\n+      try {\n+        socket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP\n+            ? address.getSocketFactory().createSocket()\n+            : new Socket(proxy);\n+        connectSocket(connectTimeout, readTimeout, writeTimeout, request,\n+            connectionSpecSelector);\n+        connected = true; // Success!\n+      } catch (IOException e) {\n+        Util.closeQuietly(socket);\n+        socket = null;\n \n-    try {\n-      if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {\n-        socket.setSoTimeout(0); // Framed connection timeouts are set per-stream.\n-        framedConnection = new FramedConnection.Builder(route.address.uriHost, true, socket)\n-            .protocol(protocol).build();\n-        framedConnection.sendConnectionPreface();\n-      } else {\n-        httpConnection = new HttpConnection(pool, this, socket);\n+        if (routeException == null) {\n+          routeException = new RouteException(e);\n+        } else {\n+          routeException.addConnectException(e);\n+        }\n+\n+        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n+          throw routeException;\n+        }\n       }\n-    } catch (IOException e) {\n-      throw new RouteException(e);\n     }\n-    connected = true;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c753d2e41ba667f9b5a31451a16ecbaecdc65d80": {
			"type": "Ybodychange",
			"commitMessage": "Rename 'spdy' references to 'framed' where appropriate.\n",
			"commitDate": "2015-06-17, 3:40 PM",
			"commitName": "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
			"commitAuthor": "Jake Wharton",
			"commitDateOld": "2015-04-20, 7:09 PM",
			"commitNameOld": "b0b000e29668517d21c37c696100bc8331117516",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 57.85,
			"commitsBetweenForRepo": 56,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,39 +1,39 @@\n   void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,\n       List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     SocketConnector socketConnector = new SocketConnector(this, pool);\n     SocketConnector.ConnectedSocket connectedSocket;\n     if (route.address.getSslSocketFactory() != null) {\n       // https:// communication\n       connectedSocket = socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout,\n           request, route, connectionSpecs, connectionRetryEnabled);\n     } else {\n       // http:// communication.\n       if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(\n             new UnknownServiceException(\n                 \"CLEARTEXT communication not supported: \" + connectionSpecs));\n       }\n       connectedSocket = socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n     }\n \n     socket = connectedSocket.socket;\n     handshake = connectedSocket.handshake;\n     protocol = connectedSocket.alpnProtocol == null\n         ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n \n     try {\n       if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {\n-        socket.setSoTimeout(0); // SPDY timeouts are set per-stream.\n-        spdyConnection = new SpdyConnection.Builder(route.address.uriHost, true, socket)\n+        socket.setSoTimeout(0); // Framed connection timeouts are set per-stream.\n+        framedConnection = new FramedConnection.Builder(route.address.uriHost, true, socket)\n             .protocol(protocol).build();\n-        spdyConnection.sendConnectionPreface();\n+        framedConnection.sendConnectionPreface();\n       } else {\n         httpConnection = new HttpConnection(pool, this, socket);\n       }\n     } catch (IOException e) {\n       throw new RouteException(e);\n     }\n     connected = true;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"60f5406dcc094d0431420139bd002e8bdd4ea5d5": {
			"type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
			"commitMessage": "Move TLS retries / fallback into Connection.\n\nAPI changes:\n1) Added: Address.getCertificatePinner()\n2) Incompatible API change: Address constructor no longer\nincludes ConnectionSpecs. Removed getConnectionSpecs().\n3) Added: ConnectionSpec.isCompatible(SSLSocket)\n4) Added: TlsVersion.javaName()\n\nImplicit / semantic / internal changes:\n\n1) Connection now handles all attempts to connect via a route\n(effectively a {proxy, socket address} pair), rather than just\none attempt. i.e. Connection now handles all the TLS negotiation\nfallbacks internally.\n\n2) Route no longer deals with TLS versions. Individual TLS\nfailures are not counted against a Route. If no connection\nattempts to a route were successful the failure is counted\nagainst the route.\n\n3) The code makes a distinction between when various\nIOExceptions occur, with the intention making retries a bit\nsmarter. It is now more obvious which exceptions happen during\nsetup (RequestException), connection (RouteException),\nHTTP communication and thus which can be retried and whether\nthe request might have been sent.\n",
			"commitDate": "2015-03-18, 8:59 AM",
			"commitName": "60f5406dcc094d0431420139bd002e8bdd4ea5d5",
			"commitAuthor": "Neil Fuller",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Move TLS retries / fallback into Connection.\n\nAPI changes:\n1) Added: Address.getCertificatePinner()\n2) Incompatible API change: Address constructor no longer\nincludes ConnectionSpecs. Removed getConnectionSpecs().\n3) Added: ConnectionSpec.isCompatible(SSLSocket)\n4) Added: TlsVersion.javaName()\n\nImplicit / semantic / internal changes:\n\n1) Connection now handles all attempts to connect via a route\n(effectively a {proxy, socket address} pair), rather than just\none attempt. i.e. Connection now handles all the TLS negotiation\nfallbacks internally.\n\n2) Route no longer deals with TLS versions. Individual TLS\nfailures are not counted against a Route. If no connection\nattempts to a route were successful the failure is counted\nagainst the route.\n\n3) The code makes a distinction between when various\nIOExceptions occur, with the intention making retries a bit\nsmarter. It is now more obvious which exceptions happen during\nsetup (RequestException), connection (RouteException),\nHTTP communication and thus which can be retried and whether\nthe request might have been sent.\n",
					"commitDate": "2015-03-18, 8:59 AM",
					"commitName": "60f5406dcc094d0431420139bd002e8bdd4ea5d5",
					"commitAuthor": "Neil Fuller",
					"commitDateOld": "2015-02-09, 8:30 PM",
					"commitNameOld": "cc94dea6d7fad79e531ee723c31e2d92fb7ccf98",
					"commitAuthorOld": "Kirill Boyarshinov",
					"daysBetweenCommits": 36.48,
					"commitsBetweenForRepo": 41,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,20 +1,39 @@\n-  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)\n-      throws IOException {\n+  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,\n+      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n-    if (route.proxy.type() == Proxy.Type.DIRECT || route.proxy.type() == Proxy.Type.HTTP) {\n-      socket = route.address.socketFactory.createSocket();\n+    SocketConnector socketConnector = new SocketConnector(this, pool);\n+    SocketConnector.ConnectedSocket connectedSocket;\n+    if (route.address.getSslSocketFactory() != null) {\n+      // https:// communication\n+      connectedSocket = socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout,\n+          request, route, connectionSpecs, connectionRetryEnabled);\n     } else {\n-      socket = new Socket(route.proxy);\n+      // http:// communication.\n+      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n+        throw new RouteException(\n+            new UnknownServiceException(\n+                \"CLEARTEXT communication not supported: \" + connectionSpecs));\n+      }\n+      connectedSocket = socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n     }\n \n-    socket.setSoTimeout(readTimeout);\n-    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n+    socket = connectedSocket.socket;\n+    handshake = connectedSocket.handshake;\n+    protocol = connectedSocket.alpnProtocol == null\n+        ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n \n-    if (route.address.sslSocketFactory != null) {\n-      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n-    } else {\n-      httpConnection = new HttpConnection(pool, this, socket);\n+    try {\n+      if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {\n+        socket.setSoTimeout(0); // SPDY timeouts are set per-stream.\n+        spdyConnection = new SpdyConnection.Builder(route.address.uriHost, true, socket)\n+            .protocol(protocol).build();\n+        spdyConnection.sendConnectionPreface();\n+      } else {\n+        httpConnection = new HttpConnection(pool, this, socket);\n+      }\n+    } catch (IOException e) {\n+      throw new RouteException(e);\n     }\n     connected = true;\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, tunnelRequest-Request]",
						"newValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, request-Request, connectionSpecs-List<ConnectionSpec>, connectionRetryEnabled-boolean]"
					}
				},
				{
					"type": "Yexceptionschange",
					"commitMessage": "Move TLS retries / fallback into Connection.\n\nAPI changes:\n1) Added: Address.getCertificatePinner()\n2) Incompatible API change: Address constructor no longer\nincludes ConnectionSpecs. Removed getConnectionSpecs().\n3) Added: ConnectionSpec.isCompatible(SSLSocket)\n4) Added: TlsVersion.javaName()\n\nImplicit / semantic / internal changes:\n\n1) Connection now handles all attempts to connect via a route\n(effectively a {proxy, socket address} pair), rather than just\none attempt. i.e. Connection now handles all the TLS negotiation\nfallbacks internally.\n\n2) Route no longer deals with TLS versions. Individual TLS\nfailures are not counted against a Route. If no connection\nattempts to a route were successful the failure is counted\nagainst the route.\n\n3) The code makes a distinction between when various\nIOExceptions occur, with the intention making retries a bit\nsmarter. It is now more obvious which exceptions happen during\nsetup (RequestException), connection (RouteException),\nHTTP communication and thus which can be retried and whether\nthe request might have been sent.\n",
					"commitDate": "2015-03-18, 8:59 AM",
					"commitName": "60f5406dcc094d0431420139bd002e8bdd4ea5d5",
					"commitAuthor": "Neil Fuller",
					"commitDateOld": "2015-02-09, 8:30 PM",
					"commitNameOld": "cc94dea6d7fad79e531ee723c31e2d92fb7ccf98",
					"commitAuthorOld": "Kirill Boyarshinov",
					"daysBetweenCommits": 36.48,
					"commitsBetweenForRepo": 41,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,20 +1,39 @@\n-  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)\n-      throws IOException {\n+  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,\n+      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n-    if (route.proxy.type() == Proxy.Type.DIRECT || route.proxy.type() == Proxy.Type.HTTP) {\n-      socket = route.address.socketFactory.createSocket();\n+    SocketConnector socketConnector = new SocketConnector(this, pool);\n+    SocketConnector.ConnectedSocket connectedSocket;\n+    if (route.address.getSslSocketFactory() != null) {\n+      // https:// communication\n+      connectedSocket = socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout,\n+          request, route, connectionSpecs, connectionRetryEnabled);\n     } else {\n-      socket = new Socket(route.proxy);\n+      // http:// communication.\n+      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n+        throw new RouteException(\n+            new UnknownServiceException(\n+                \"CLEARTEXT communication not supported: \" + connectionSpecs));\n+      }\n+      connectedSocket = socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n     }\n \n-    socket.setSoTimeout(readTimeout);\n-    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n+    socket = connectedSocket.socket;\n+    handshake = connectedSocket.handshake;\n+    protocol = connectedSocket.alpnProtocol == null\n+        ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n \n-    if (route.address.sslSocketFactory != null) {\n-      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n-    } else {\n-      httpConnection = new HttpConnection(pool, this, socket);\n+    try {\n+      if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {\n+        socket.setSoTimeout(0); // SPDY timeouts are set per-stream.\n+        spdyConnection = new SpdyConnection.Builder(route.address.uriHost, true, socket)\n+            .protocol(protocol).build();\n+        spdyConnection.sendConnectionPreface();\n+      } else {\n+        httpConnection = new HttpConnection(pool, this, socket);\n+      }\n+    } catch (IOException e) {\n+      throw new RouteException(e);\n     }\n     connected = true;\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[IOException]",
						"newValue": "[RouteException]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Move TLS retries / fallback into Connection.\n\nAPI changes:\n1) Added: Address.getCertificatePinner()\n2) Incompatible API change: Address constructor no longer\nincludes ConnectionSpecs. Removed getConnectionSpecs().\n3) Added: ConnectionSpec.isCompatible(SSLSocket)\n4) Added: TlsVersion.javaName()\n\nImplicit / semantic / internal changes:\n\n1) Connection now handles all attempts to connect via a route\n(effectively a {proxy, socket address} pair), rather than just\none attempt. i.e. Connection now handles all the TLS negotiation\nfallbacks internally.\n\n2) Route no longer deals with TLS versions. Individual TLS\nfailures are not counted against a Route. If no connection\nattempts to a route were successful the failure is counted\nagainst the route.\n\n3) The code makes a distinction between when various\nIOExceptions occur, with the intention making retries a bit\nsmarter. It is now more obvious which exceptions happen during\nsetup (RequestException), connection (RouteException),\nHTTP communication and thus which can be retried and whether\nthe request might have been sent.\n",
					"commitDate": "2015-03-18, 8:59 AM",
					"commitName": "60f5406dcc094d0431420139bd002e8bdd4ea5d5",
					"commitAuthor": "Neil Fuller",
					"commitDateOld": "2015-02-09, 8:30 PM",
					"commitNameOld": "cc94dea6d7fad79e531ee723c31e2d92fb7ccf98",
					"commitAuthorOld": "Kirill Boyarshinov",
					"daysBetweenCommits": 36.48,
					"commitsBetweenForRepo": 41,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,20 +1,39 @@\n-  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)\n-      throws IOException {\n+  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,\n+      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n-    if (route.proxy.type() == Proxy.Type.DIRECT || route.proxy.type() == Proxy.Type.HTTP) {\n-      socket = route.address.socketFactory.createSocket();\n+    SocketConnector socketConnector = new SocketConnector(this, pool);\n+    SocketConnector.ConnectedSocket connectedSocket;\n+    if (route.address.getSslSocketFactory() != null) {\n+      // https:// communication\n+      connectedSocket = socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout,\n+          request, route, connectionSpecs, connectionRetryEnabled);\n     } else {\n-      socket = new Socket(route.proxy);\n+      // http:// communication.\n+      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n+        throw new RouteException(\n+            new UnknownServiceException(\n+                \"CLEARTEXT communication not supported: \" + connectionSpecs));\n+      }\n+      connectedSocket = socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n     }\n \n-    socket.setSoTimeout(readTimeout);\n-    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n+    socket = connectedSocket.socket;\n+    handshake = connectedSocket.handshake;\n+    protocol = connectedSocket.alpnProtocol == null\n+        ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n \n-    if (route.address.sslSocketFactory != null) {\n-      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n-    } else {\n-      httpConnection = new HttpConnection(pool, this, socket);\n+    try {\n+      if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {\n+        socket.setSoTimeout(0); // SPDY timeouts are set per-stream.\n+        spdyConnection = new SpdyConnection.Builder(route.address.uriHost, true, socket)\n+            .protocol(protocol).build();\n+        spdyConnection.sendConnectionPreface();\n+      } else {\n+        httpConnection = new HttpConnection(pool, this, socket);\n+      }\n+    } catch (IOException e) {\n+      throw new RouteException(e);\n     }\n     connected = true;\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"6d9f9cbdf8069e504cb58908db23b4f327d1826c": {
			"type": "Ybodychange",
			"commitMessage": "Use the socket factory for direct connections as well.\n\nCurrently, the passed-in socket factory is only used for\nconnections to HTTP proxies. I think this was not the intent of\nthe original socket factory change, because the commit message\nsaid that the \"socket factory will be used for all non-proxy\nconnections and HTTP proxy connections\".  So use it for DIRECT\nconnections as well.\n\nAlso add a test to check that a socket factory is used if\nspecified.\n\nChange-Id: I811b08442d1c80be1a0a268eb51c9aa365febf00\n",
			"commitDate": "2014-07-21, 12:34 PM",
			"commitName": "6d9f9cbdf8069e504cb58908db23b4f327d1826c",
			"commitAuthor": "Lorenzo Colitti",
			"commitDateOld": "2014-06-28, 7:57 AM",
			"commitNameOld": "7bb06e78bac05e0e24c6ea81b34aa11f498ad61f",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 23.19,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,20 +1,20 @@\n   void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n-    if (route.proxy.type() != Proxy.Type.HTTP) {\n-      socket = new Socket(route.proxy);\n-    } else {\n+    if (route.proxy.type() == Proxy.Type.DIRECT || route.proxy.type() == Proxy.Type.HTTP) {\n       socket = route.address.socketFactory.createSocket();\n+    } else {\n+      socket = new Socket(route.proxy);\n     }\n \n     socket.setSoTimeout(readTimeout);\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n \n     if (route.address.sslSocketFactory != null) {\n       upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n     } else {\n       httpConnection = new HttpConnection(pool, this, socket);\n     }\n     connected = true;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1044d9eea21d8be54c195fff75ca0a7b9bba79b3": {
			"type": "Ymodifierchange",
			"commitMessage": "Hide more APIs with Internal.access.\n\nThe callsite is uglier but the API is neater. I think overall\nit's a small win.\n",
			"commitDate": "2014-04-30, 6:36 PM",
			"commitName": "1044d9eea21d8be54c195fff75ca0a7b9bba79b3",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2014-04-30, 9:16 AM",
			"commitNameOld": "853b4e35f1ddbf3c5db1d91c7ff02c2d979da86f",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 0.39,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,20 +1,20 @@\n-  public void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)\n+  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     if (route.proxy.type() != Proxy.Type.HTTP) {\n       socket = new Socket(route.proxy);\n     } else {\n       socket = route.address.socketFactory.createSocket();\n     }\n \n     socket.setSoTimeout(readTimeout);\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n \n     if (route.address.sslSocketFactory != null) {\n       upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n     } else {\n       httpConnection = new HttpConnection(pool, this, socket);\n     }\n     connected = true;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[public]",
				"newValue": "[]"
			}
		},
		"b60875421b0f67575970b6b63582b7e5e31c4a06": {
			"type": "Ybodychange",
			"commitMessage": "Update Okio timeouts when recycling connections.\n",
			"commitDate": "2014-04-20, 8:49 AM",
			"commitName": "b60875421b0f67575970b6b63582b7e5e31c4a06",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2014-04-20, 7:10 AM",
			"commitNameOld": "da484932625ab15681e469c1680b6371b8f67080",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 0.07,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,20 +1,20 @@\n   public void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     if (route.proxy.type() != Proxy.Type.HTTP) {\n       socket = new Socket(route.proxy);\n     } else {\n       socket = route.address.socketFactory.createSocket();\n     }\n \n     socket.setSoTimeout(readTimeout);\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n \n     if (route.address.sslSocketFactory != null) {\n       upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n     } else {\n-      httpConnection = new HttpConnection(pool, this, socket, readTimeout, writeTimeout);\n+      httpConnection = new HttpConnection(pool, this, socket);\n     }\n     connected = true;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"da484932625ab15681e469c1680b6371b8f67080": {
			"type": "Yparameterchange",
			"commitMessage": "Replace TunnelRequest with a regular Request.\n",
			"commitDate": "2014-04-20, 7:10 AM",
			"commitName": "da484932625ab15681e469c1680b6371b8f67080",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2014-04-20, 12:27 AM",
			"commitNameOld": "a9b4ec6bb771472136fb86562ab4a3d9baee0390",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 0.28,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,20 +1,20 @@\n-  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n-      TunnelRequest tunnelRequest) throws IOException {\n+  public void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)\n+      throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     if (route.proxy.type() != Proxy.Type.HTTP) {\n       socket = new Socket(route.proxy);\n     } else {\n       socket = route.address.socketFactory.createSocket();\n     }\n \n     socket.setSoTimeout(readTimeout);\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n \n     if (route.address.sslSocketFactory != null) {\n       upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n     } else {\n       httpConnection = new HttpConnection(pool, this, socket, readTimeout, writeTimeout);\n     }\n     connected = true;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, tunnelRequest-TunnelRequest]",
				"newValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, tunnelRequest-Request]"
			}
		},
		"41aa4b6805141369d614964152d329a686aabdb8": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Implement write timeouts for HTTP/1.1 streams.\n",
			"commitDate": "2014-04-18, 2:06 PM",
			"commitName": "41aa4b6805141369d614964152d329a686aabdb8",
			"commitAuthor": "Jesse Wilson",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Implement write timeouts for HTTP/1.1 streams.\n",
					"commitDate": "2014-04-18, 2:06 PM",
					"commitName": "41aa4b6805141369d614964152d329a686aabdb8",
					"commitAuthor": "Jesse Wilson",
					"commitDateOld": "2014-04-15, 12:53 AM",
					"commitNameOld": "ff5390d6dcaf79ef09a3ef94dbb7e8ac39572a7f",
					"commitAuthorOld": "Jake Wharton",
					"daysBetweenCommits": 3.55,
					"commitsBetweenForRepo": 18,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,20 +1,20 @@\n-  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n-      throws IOException {\n+  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n+      TunnelRequest tunnelRequest) throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     if (route.proxy.type() != Proxy.Type.HTTP) {\n       socket = new Socket(route.proxy);\n     } else {\n       socket = route.address.socketFactory.createSocket();\n     }\n \n     socket.setSoTimeout(readTimeout);\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n \n     if (route.address.sslSocketFactory != null) {\n-      upgradeToTls(tunnelRequest);\n+      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n     } else {\n-      httpConnection = new HttpConnection(pool, this, socket);\n+      httpConnection = new HttpConnection(pool, this, socket, readTimeout, writeTimeout);\n     }\n     connected = true;\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[connectTimeout-int, readTimeout-int, tunnelRequest-TunnelRequest]",
						"newValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, tunnelRequest-TunnelRequest]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Implement write timeouts for HTTP/1.1 streams.\n",
					"commitDate": "2014-04-18, 2:06 PM",
					"commitName": "41aa4b6805141369d614964152d329a686aabdb8",
					"commitAuthor": "Jesse Wilson",
					"commitDateOld": "2014-04-15, 12:53 AM",
					"commitNameOld": "ff5390d6dcaf79ef09a3ef94dbb7e8ac39572a7f",
					"commitAuthorOld": "Jake Wharton",
					"daysBetweenCommits": 3.55,
					"commitsBetweenForRepo": 18,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,20 +1,20 @@\n-  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n-      throws IOException {\n+  public void connect(int connectTimeout, int readTimeout, int writeTimeout,\n+      TunnelRequest tunnelRequest) throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     if (route.proxy.type() != Proxy.Type.HTTP) {\n       socket = new Socket(route.proxy);\n     } else {\n       socket = route.address.socketFactory.createSocket();\n     }\n \n     socket.setSoTimeout(readTimeout);\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n \n     if (route.address.sslSocketFactory != null) {\n-      upgradeToTls(tunnelRequest);\n+      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n     } else {\n-      httpConnection = new HttpConnection(pool, this, socket);\n+      httpConnection = new HttpConnection(pool, this, socket, readTimeout, writeTimeout);\n     }\n     connected = true;\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"ff5390d6dcaf79ef09a3ef94dbb7e8ac39572a7f": {
			"type": "Ybodychange",
			"commitMessage": "Allow specifying a socket factory for connections.\n\nThis socket factory will be used for all non-proxy connections and HTTP proxy connections.\n",
			"commitDate": "2014-04-15, 12:53 AM",
			"commitName": "ff5390d6dcaf79ef09a3ef94dbb7e8ac39572a7f",
			"commitAuthor": "Jake Wharton",
			"commitDateOld": "2014-03-30, 5:09 PM",
			"commitNameOld": "6c57d76915a7e79cc8b8f743ccd8ecc35889ce7c",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 15.32,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,15 +1,20 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n-    socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n-    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n+    if (route.proxy.type() != Proxy.Type.HTTP) {\n+      socket = new Socket(route.proxy);\n+    } else {\n+      socket = route.address.socketFactory.createSocket();\n+    }\n+\n     socket.setSoTimeout(readTimeout);\n+    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n \n     if (route.address.sslSocketFactory != null) {\n       upgradeToTls(tunnelRequest);\n     } else {\n       httpConnection = new HttpConnection(pool, this, socket);\n     }\n     connected = true;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8d78da7ce7e60d93fe8e299a83b963cd220a60ad": {
			"type": "Ybodychange",
			"commitMessage": "Push Socket into HttpConnection/SpdyConnection.\n",
			"commitDate": "2014-03-11, 9:20 PM",
			"commitName": "8d78da7ce7e60d93fe8e299a83b963cd220a60ad",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2014-03-02, 11:14 PM",
			"commitNameOld": "98f60cc9f0b1af08803dde269386877b9cf1c7d3",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 8.88,
			"commitsBetweenForRepo": 38,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,18 +1,15 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n-    in = socket.getInputStream();\n-    out = socket.getOutputStream();\n \n     if (route.address.sslSocketFactory != null) {\n       upgradeToTls(tunnelRequest);\n     } else {\n-      initSourceAndSink();\n-      httpConnection = new HttpConnection(pool, this, source, sink);\n+      httpConnection = new HttpConnection(pool, this, socket);\n     }\n     connected = true;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c16436f8b2020e4bb2cbdddbd0eddd5ae5c528c4": {
			"type": "Ybodychange",
			"commitMessage": "Use BufferedSink in HttpConnection.\n",
			"commitDate": "2014-02-23, 9:55 AM",
			"commitName": "c16436f8b2020e4bb2cbdddbd0eddd5ae5c528c4",
			"commitAuthor": "jwilson",
			"commitDateOld": "2014-02-23, 8:42 AM",
			"commitNameOld": "ab78dadb4bb94db74770e179e04e2ed791c4a51e",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 0.05,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,18 +1,18 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in = socket.getInputStream();\n     out = socket.getOutputStream();\n \n     if (route.address.sslSocketFactory != null) {\n       upgradeToTls(tunnelRequest);\n     } else {\n-      streamWrapper(true);\n-      httpConnection = new HttpConnection(pool, this, source, out);\n+      initSourceAndSink();\n+      httpConnection = new HttpConnection(pool, this, source, sink);\n     }\n     connected = true;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ab78dadb4bb94db74770e179e04e2ed791c4a51e": {
			"type": "Ybodychange",
			"commitMessage": "Use BufferedSink in SPDY and HTTP/2.\n",
			"commitDate": "2014-02-23, 8:42 AM",
			"commitName": "ab78dadb4bb94db74770e179e04e2ed791c4a51e",
			"commitAuthor": "jwilson",
			"commitDateOld": "2014-02-22, 1:08 PM",
			"commitNameOld": "095448552ee41e62e58994be0f424df750c6822f",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 0.82,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,18 +1,18 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in = socket.getInputStream();\n     out = socket.getOutputStream();\n \n     if (route.address.sslSocketFactory != null) {\n       upgradeToTls(tunnelRequest);\n     } else {\n-      streamWrapper();\n+      streamWrapper(true);\n       httpConnection = new HttpConnection(pool, this, source, out);\n     }\n     connected = true;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a669069599893a774748181a238e0b009a4f3e87": {
			"type": "Ybodychange",
			"commitMessage": "Use OkBuffer+Source in HttpEngine.\n",
			"commitDate": "2014-02-17, 11:33 PM",
			"commitName": "a669069599893a774748181a238e0b009a4f3e87",
			"commitAuthor": "jwilson",
			"commitDateOld": "2014-02-15, 3:44 PM",
			"commitNameOld": "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 2.33,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,18 +1,18 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in = socket.getInputStream();\n     out = socket.getOutputStream();\n \n     if (route.address.sslSocketFactory != null) {\n       upgradeToTls(tunnelRequest);\n     } else {\n       streamWrapper();\n-      httpConnection = new HttpConnection(pool, this, in, out);\n+      httpConnection = new HttpConnection(pool, this, source, out);\n     }\n     connected = true;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3": {
			"type": "Ybodychange",
			"commitMessage": "Move connection pooling logic.\n\nPreviously we had this ugly, awkward release() method that\nattempted to manage connection pooling, discarding streams\nfor caching, and closing broken streams.\n\nMove connection reuse to HttpConnection, with policy informed\nby HttpEngine. It specifies what to do when the connection\nbecomes idle: pool, close or hold. The connection does what\nit's told.\n",
			"commitDate": "2014-02-15, 3:44 PM",
			"commitName": "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3",
			"commitAuthor": "jwilson",
			"commitDateOld": "2014-02-15, 10:30 AM",
			"commitNameOld": "322e9f3700be4b9ebcf8b004d82868da71f919c5",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 0.22,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,18 +1,18 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in = socket.getInputStream();\n     out = socket.getOutputStream();\n \n     if (route.address.sslSocketFactory != null) {\n       upgradeToTls(tunnelRequest);\n     } else {\n       streamWrapper();\n-      httpConnection = new HttpConnection(in, out);\n+      httpConnection = new HttpConnection(pool, this, in, out);\n     }\n     connected = true;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"504b9cf55afd9d642e2a5323e18f79db607ad1a9": {
			"type": "Ybodychange",
			"commitMessage": "Split HttpTransport in two.\n\nThe new (awkwardly-named) HttpConnection class now owns the\nsocket, and stays around between HTTP requests. It matches\nSpdyConnection in lifecycle: it is tied to the socket.\n\nThe HTTP transport class is a dumb adapter that adapts the\nprotocol-specific decisions (chunked-encoding, content-length\nstuff).\n\nThis should make it possible to make significant simplifications\nto how connection recycling works: in a follow up change the\nHttpConnection class will know when it can be recycled and take\nthat action automatically.\n",
			"commitDate": "2014-02-14, 1:23 PM",
			"commitName": "504b9cf55afd9d642e2a5323e18f79db607ad1a9",
			"commitAuthor": "jwilson",
			"commitDateOld": "2014-01-26, 3:09 PM",
			"commitNameOld": "32a2b1d8d000a19d4a340cc1d77a68973a9d65dc",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 18.93,
			"commitsBetweenForRepo": 33,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,17 +1,18 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n     socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in = socket.getInputStream();\n     out = socket.getOutputStream();\n \n     if (route.address.sslSocketFactory != null) {\n       upgradeToTls(tunnelRequest);\n     } else {\n       streamWrapper();\n+      httpConnection = new HttpConnection(in, out);\n     }\n     connected = true;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ed2ee02570bac36b89bd93836e200840cb8fa59d": {
			"type": "Ybodychange",
			"commitMessage": "Connected after everything is initialized\n",
			"commitDate": "2014-01-08, 7:10 PM",
			"commitName": "ed2ee02570bac36b89bd93836e200840cb8fa59d",
			"commitAuthor": "lingming.yb",
			"commitDateOld": "2014-01-05, 3:56 PM",
			"commitNameOld": "656bca2dc8bc9f2f13b8aa42e0bdd3b94202f527",
			"commitAuthorOld": "Adrian Cole",
			"daysBetweenCommits": 3.13,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,17 +1,17 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) throw new IllegalStateException(\"already connected\");\n \n-    connected = true;\n     socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in = socket.getInputStream();\n     out = socket.getOutputStream();\n \n     if (route.address.sslSocketFactory != null) {\n       upgradeToTls(tunnelRequest);\n     } else {\n       streamWrapper();\n     }\n+    connected = true;\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dbca0acc6f8c188dfa48f07bb5886606bec8d28f": {
			"type": "Ybodychange",
			"commitMessage": "Kill the Policy interface.\n\nThis interface was necessary while cleaning up the delicate\nintertwined relationship between HttpURLConnection and HttpEngine.\nWith this change HttpEngine no longer has a reverse dependency\non HttpURLConnection.\n",
			"commitDate": "2014-01-01, 7:30 AM",
			"commitName": "dbca0acc6f8c188dfa48f07bb5886606bec8d28f",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-12-31, 5:52 PM",
			"commitNameOld": "957537774b319bb0109819258a11af78a98bcb97",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 0.57,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,18 +1,17 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n-    if (connected) {\n-      throw new IllegalStateException(\"already connected\");\n-    }\n+    if (connected) throw new IllegalStateException(\"already connected\");\n+\n     connected = true;\n     socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in = socket.getInputStream();\n     out = socket.getOutputStream();\n \n     if (route.address.sslSocketFactory != null) {\n       upgradeToTls(tunnelRequest);\n     } else {\n       streamWrapper();\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"35ead0f5d17b0c53610b0947aa9bd8fee6da50fa": {
			"type": "Ybodychange",
			"commitMessage": "extract a method\n",
			"commitDate": "2013-12-23, 1:02 AM",
			"commitName": "35ead0f5d17b0c53610b0947aa9bd8fee6da50fa",
			"commitAuthor": "lingming.yb",
			"commitDateOld": "2013-12-21, 7:22 PM",
			"commitNameOld": "13c06879f4e98c86436bdca765046ef815e34838",
			"commitAuthorOld": "lingming.yb",
			"daysBetweenCommits": 1.24,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,24 +1,19 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) {\n       throw new IllegalStateException(\"already connected\");\n     }\n     connected = true;\n     socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in = socket.getInputStream();\n     out = socket.getOutputStream();\n \n     if (route.address.sslSocketFactory != null) {\n       upgradeToTls(tunnelRequest);\n     }\n     else{\n-      // Use MTU-sized buffers to send fewer packets.\n-      int mtu = Platform.get().getMtu(socket);\n-      if (mtu < 1024) mtu = 1024;\n-      if (mtu > 8192) mtu = 8192;\n-      in = new BufferedInputStream(in, mtu);\n-      out = new BufferedOutputStream(out, mtu);\n+      streamWrapper();\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"13c06879f4e98c86436bdca765046ef815e34838": {
			"type": "Ybodychange",
			"commitMessage": "Buffered Stream wrapper should be taken place before SpdyConnection build.\n",
			"commitDate": "2013-12-21, 7:22 PM",
			"commitName": "13c06879f4e98c86436bdca765046ef815e34838",
			"commitAuthor": "lingming.yb",
			"commitDateOld": "2013-09-29, 1:08 PM",
			"commitNameOld": "29ab48bf0dfbac1b249f2233de08fa948bad11d8",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 83.3,
			"commitsBetweenForRepo": 17,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,23 +1,24 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) {\n       throw new IllegalStateException(\"already connected\");\n     }\n     connected = true;\n     socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in = socket.getInputStream();\n     out = socket.getOutputStream();\n \n     if (route.address.sslSocketFactory != null) {\n       upgradeToTls(tunnelRequest);\n     }\n-\n-    // Use MTU-sized buffers to send fewer packets.\n-    int mtu = Platform.get().getMtu(socket);\n-    if (mtu < 1024) mtu = 1024;\n-    if (mtu > 8192) mtu = 8192;\n-    in = new BufferedInputStream(in, mtu);\n-    out = new BufferedOutputStream(out, mtu);\n+    else{\n+      // Use MTU-sized buffers to send fewer packets.\n+      int mtu = Platform.get().getMtu(socket);\n+      if (mtu < 1024) mtu = 1024;\n+      if (mtu > 8192) mtu = 8192;\n+      in = new BufferedInputStream(in, mtu);\n+      out = new BufferedOutputStream(out, mtu);\n+    }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d66810bf0efbfad5c2afb9b304e1091ac6107a65": {
			"type": "Ybodychange",
			"commitMessage": "Catch SecurityExceptions from socket connects.\n\nVersions of android prior to 4.3 would throw RTEs\nif the underlying socket threw an EACCES error.\n\nSee change 50144 on the Android Open Source Project.\n",
			"commitDate": "2013-07-11, 3:39 AM",
			"commitName": "d66810bf0efbfad5c2afb9b304e1091ac6107a65",
			"commitAuthor": "Narayan Kamath",
			"commitDateOld": "2013-05-10, 6:06 AM",
			"commitNameOld": "3ba54eed34c9d5e41965587660a76a06806180a0",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 61.9,
			"commitsBetweenForRepo": 15,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,23 +1,23 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) {\n       throw new IllegalStateException(\"already connected\");\n     }\n     connected = true;\n     socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n-    socket.connect(route.inetSocketAddress, connectTimeout);\n+    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in = socket.getInputStream();\n     out = socket.getOutputStream();\n \n     if (route.address.sslSocketFactory != null) {\n       upgradeToTls(tunnelRequest);\n     }\n \n     // Use MTU-sized buffers to send fewer packets.\n     int mtu = Platform.get().getMtu(socket);\n     if (mtu < 1024) mtu = 1024;\n     if (mtu > 8192) mtu = 8192;\n     in = new BufferedInputStream(in, mtu);\n     out = new BufferedOutputStream(out, mtu);\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3ba54eed34c9d5e41965587660a76a06806180a0": {
			"type": "Ybodychange",
			"commitMessage": "Bump the minimum MTU up to 1KiB.\n\nIf anyone is getting -1 from getMtu, we should give them a more\nreasonable default.\n",
			"commitDate": "2013-05-10, 6:06 AM",
			"commitName": "3ba54eed34c9d5e41965587660a76a06806180a0",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-05-10, 5:53 AM",
			"commitNameOld": "bb1b1a2c5c6c93df75526a2d5bf5c19817402fbc",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,23 +1,23 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) {\n       throw new IllegalStateException(\"already connected\");\n     }\n     connected = true;\n     socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     socket.connect(route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in = socket.getInputStream();\n     out = socket.getOutputStream();\n \n     if (route.address.sslSocketFactory != null) {\n       upgradeToTls(tunnelRequest);\n     }\n \n     // Use MTU-sized buffers to send fewer packets.\n     int mtu = Platform.get().getMtu(socket);\n-    if (mtu < 256) mtu = 256;\n+    if (mtu < 1024) mtu = 1024;\n     if (mtu > 8192) mtu = 8192;\n     in = new BufferedInputStream(in, mtu);\n     out = new BufferedOutputStream(out, mtu);\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"bb1b1a2c5c6c93df75526a2d5bf5c19817402fbc": {
			"type": "Ybodychange",
			"commitMessage": "Clamp the MTU to a reasonable range.\n\nhttps://github.com/square/okhttp/issues/183\n",
			"commitDate": "2013-05-10, 5:53 AM",
			"commitName": "bb1b1a2c5c6c93df75526a2d5bf5c19817402fbc",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-05-03, 4:36 PM",
			"commitNameOld": "aee4bff8044f4189eedacb78be37d48cc7ef226f",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 6.55,
			"commitsBetweenForRepo": 30,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,21 +1,23 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) {\n       throw new IllegalStateException(\"already connected\");\n     }\n     connected = true;\n     socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     socket.connect(route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in = socket.getInputStream();\n     out = socket.getOutputStream();\n \n     if (route.address.sslSocketFactory != null) {\n       upgradeToTls(tunnelRequest);\n     }\n \n     // Use MTU-sized buffers to send fewer packets.\n     int mtu = Platform.get().getMtu(socket);\n+    if (mtu < 256) mtu = 256;\n+    if (mtu > 8192) mtu = 8192;\n     in = new BufferedInputStream(in, mtu);\n     out = new BufferedOutputStream(out, mtu);\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"13d8b5f7bfc73c8f4064a57f634b6155991eb961": {
			"type": "Ybodychange",
			"commitMessage": "Use an MTU-sized buffer for socket access.\n\nPreviously we attempted to avoid buffers in some situations\nand create aggressive buffers in other situations. This was\na bad policy, and meant we had some subtle performance bugs.\nThe one that prompted this is that chunked uploads make\nseparate network writes for the chunk size, chunk, and newline\nseparators.\n\nThis avoids that problem and the corresponding complexity.\nUnfortunately getting the MTU isn't a standard API until\nJava 6 / Gingerbread. I tested my own networks and saw 1500\nin use (for 3G and WiFi) and 1400 (for VPN over WiFi).\n",
			"commitDate": "2013-04-21, 8:10 PM",
			"commitName": "13d8b5f7bfc73c8f4064a57f634b6155991eb961",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-04-15, 6:42 AM",
			"commitNameOld": "242be7e5781be67fc0b570f02adaa522e48ee49a",
			"commitAuthorOld": "Marcelo Cortes",
			"daysBetweenCommits": 6.56,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,22 +1,21 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) {\n       throw new IllegalStateException(\"already connected\");\n     }\n     connected = true;\n     socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     socket.connect(route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in = socket.getInputStream();\n     out = socket.getOutputStream();\n \n     if (route.address.sslSocketFactory != null) {\n       upgradeToTls(tunnelRequest);\n     }\n \n-    // Buffer the socket stream to permit efficient parsing of HTTP headers and chunk sizes.\n-    if (!isSpdy()) {\n-      int bufferSize = 128;\n-      in = new BufferedInputStream(in, bufferSize);\n-    }\n+    // Use MTU-sized buffers to send fewer packets.\n+    int mtu = Platform.get().getMtu(socket);\n+    in = new BufferedInputStream(in, mtu);\n+    out = new BufferedOutputStream(out, mtu);\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1ece746c815a26782042b1fca6069eb527d1029b": {
			"type": "Ybodychange",
			"commitMessage": "RouteSelector tries previously failed routes last #106\n",
			"commitDate": "2013-04-10, 3:19 PM",
			"commitName": "1ece746c815a26782042b1fca6069eb527d1029b",
			"commitAuthor": "Marcelo Cortes",
			"commitDateOld": "2013-03-25, 8:04 PM",
			"commitNameOld": "7ccbf48838b7cfe42759c67790636d442ea5daa3",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 15.8,
			"commitsBetweenForRepo": 10,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,22 +1,22 @@\n   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n       throws IOException {\n     if (connected) {\n       throw new IllegalStateException(\"already connected\");\n     }\n     connected = true;\n-    socket = (proxy.type() != Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n-    socket.connect(inetSocketAddress, connectTimeout);\n+    socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n+    socket.connect(route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in = socket.getInputStream();\n     out = socket.getOutputStream();\n \n-    if (address.sslSocketFactory != null) {\n+    if (route.address.sslSocketFactory != null) {\n       upgradeToTls(tunnelRequest);\n     }\n \n     // Buffer the socket stream to permit efficient parsing of HTTP headers and chunk sizes.\n     if (!isSpdy()) {\n       int bufferSize = 128;\n       in = new BufferedInputStream(in, bufferSize);\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7ccbf48838b7cfe42759c67790636d442ea5daa3": {
			"type": "Yfilerename",
			"commitMessage": "Move library into a module. Introduce sample module with simple GitHub client.\n",
			"commitDate": "2013-03-25, 8:04 PM",
			"commitName": "7ccbf48838b7cfe42759c67790636d442ea5daa3",
			"commitAuthor": "Jake Wharton",
			"commitDateOld": "2013-03-15, 7:39 AM",
			"commitNameOld": "ba2b7432cb9fabfc725b09a9f14878cb128ef208",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 10.52,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/com/squareup/okhttp/Connection.java",
				"newPath": "okhttp/src/main/java/com/squareup/okhttp/Connection.java"
			}
		},
		"194290e5f3819bf91d87c5d08c152946b6aa3509": {
			"type": "Ybodychange",
			"commitMessage": "Improve SPDY+HTTP integration.\n\nWriting tests shook out a few bugs:\n - Pooling wasn't working well. We were trying to connect\n   after already having been connected.\n - We weren't writing response bodies to the cache.\n - We weren't capturing the request time for the cache.\n - MockSpdyServer wasn't trimming headers.\n\nNew files in this change aren't new, they're just inner classes promoted\nto top-level classes for better sharing.\n",
			"commitDate": "2013-01-22, 1:14 PM",
			"commitName": "194290e5f3819bf91d87c5d08c152946b6aa3509",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-01-06, 3:30 PM",
			"commitNameOld": "06579c5bfb6a051a9fbca5be2d15a52fcf77f38c",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 15.91,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,20 +1,24 @@\n     public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n             throws IOException {\n+        if (connected) {\n+            throw new IllegalStateException(\"already connected\");\n+        }\n+        connected = true;\n         socket = (proxy.type() != Proxy.Type.HTTP)\n                 ? new Socket(proxy)\n                 : new Socket();\n         socket.connect(inetSocketAddress, connectTimeout);\n         socket.setSoTimeout(readTimeout);\n         in = socket.getInputStream();\n         out = socket.getOutputStream();\n \n         if (address.sslSocketFactory != null) {\n             upgradeToTls(tunnelRequest);\n         }\n \n         // Buffer the socket stream to permit efficient parsing of HTTP headers and chunk sizes.\n         if (!isSpdy()) {\n             int bufferSize = 128;\n             in = new BufferedInputStream(in, bufferSize);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"78c6624b11d5f33504dae8211b4592383468343e": {
			"type": "Ymultichange(Yfilerename,Ybodychange,Yparameterchange)",
			"commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
			"commitDate": "2012-12-23, 9:39 PM",
			"commitName": "78c6624b11d5f33504dae8211b4592383468343e",
			"commitAuthor": "jwilson",
			"subchanges": [
				{
					"type": "Yfilerename",
					"commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
					"commitDate": "2012-12-23, 9:39 PM",
					"commitName": "78c6624b11d5f33504dae8211b4592383468343e",
					"commitAuthor": "jwilson",
					"commitDateOld": "2012-12-23, 1:38 PM",
					"commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
					"commitAuthorOld": "Jake Wharton",
					"daysBetweenCommits": 0.33,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,24 +1,20 @@\n-    public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig)\n+    public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n             throws IOException {\n         socket = (proxy.type() != Proxy.Type.HTTP)\n                 ? new Socket(proxy)\n                 : new Socket();\n         socket.connect(inetSocketAddress, connectTimeout);\n         socket.setSoTimeout(readTimeout);\n         in = socket.getInputStream();\n         out = socket.getOutputStream();\n \n         if (address.sslSocketFactory != null) {\n-            upgradeToTls(tunnelConfig);\n+            upgradeToTls(tunnelRequest);\n         }\n \n-        /*\n-         * Buffer the socket stream to permit efficient parsing of HTTP headers\n-         * and chunk sizes. This also masks SSL InputStream's degenerate\n-         * available() implementation. That way we can read the end of a chunked\n-         * response without blocking and will recycle connections more reliably.\n-         * http://code.google.com/p/android/issues/detail?id=38817\n-         */\n-        int bufferSize = 128;\n-        in = new BufferedInputStream(in, bufferSize);\n+        // Buffer the socket stream to permit efficient parsing of HTTP headers and chunk sizes.\n+        if (!isSpdy()) {\n+            int bufferSize = 128;\n+            in = new BufferedInputStream(in, bufferSize);\n+        }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldPath": "src/main/java/com/squareup/okhttp/internal/net/http/HttpConnection.java",
						"newPath": "src/main/java/com/squareup/okhttp/Connection.java"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
					"commitDate": "2012-12-23, 9:39 PM",
					"commitName": "78c6624b11d5f33504dae8211b4592383468343e",
					"commitAuthor": "jwilson",
					"commitDateOld": "2012-12-23, 1:38 PM",
					"commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
					"commitAuthorOld": "Jake Wharton",
					"daysBetweenCommits": 0.33,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,24 +1,20 @@\n-    public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig)\n+    public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n             throws IOException {\n         socket = (proxy.type() != Proxy.Type.HTTP)\n                 ? new Socket(proxy)\n                 : new Socket();\n         socket.connect(inetSocketAddress, connectTimeout);\n         socket.setSoTimeout(readTimeout);\n         in = socket.getInputStream();\n         out = socket.getOutputStream();\n \n         if (address.sslSocketFactory != null) {\n-            upgradeToTls(tunnelConfig);\n+            upgradeToTls(tunnelRequest);\n         }\n \n-        /*\n-         * Buffer the socket stream to permit efficient parsing of HTTP headers\n-         * and chunk sizes. This also masks SSL InputStream's degenerate\n-         * available() implementation. That way we can read the end of a chunked\n-         * response without blocking and will recycle connections more reliably.\n-         * http://code.google.com/p/android/issues/detail?id=38817\n-         */\n-        int bufferSize = 128;\n-        in = new BufferedInputStream(in, bufferSize);\n+        // Buffer the socket stream to permit efficient parsing of HTTP headers and chunk sizes.\n+        if (!isSpdy()) {\n+            int bufferSize = 128;\n+            in = new BufferedInputStream(in, bufferSize);\n+        }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				},
				{
					"type": "Yparameterchange",
					"commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
					"commitDate": "2012-12-23, 9:39 PM",
					"commitName": "78c6624b11d5f33504dae8211b4592383468343e",
					"commitAuthor": "jwilson",
					"commitDateOld": "2012-12-23, 1:38 PM",
					"commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
					"commitAuthorOld": "Jake Wharton",
					"daysBetweenCommits": 0.33,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,24 +1,20 @@\n-    public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig)\n+    public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)\n             throws IOException {\n         socket = (proxy.type() != Proxy.Type.HTTP)\n                 ? new Socket(proxy)\n                 : new Socket();\n         socket.connect(inetSocketAddress, connectTimeout);\n         socket.setSoTimeout(readTimeout);\n         in = socket.getInputStream();\n         out = socket.getOutputStream();\n \n         if (address.sslSocketFactory != null) {\n-            upgradeToTls(tunnelConfig);\n+            upgradeToTls(tunnelRequest);\n         }\n \n-        /*\n-         * Buffer the socket stream to permit efficient parsing of HTTP headers\n-         * and chunk sizes. This also masks SSL InputStream's degenerate\n-         * available() implementation. That way we can read the end of a chunked\n-         * response without blocking and will recycle connections more reliably.\n-         * http://code.google.com/p/android/issues/detail?id=38817\n-         */\n-        int bufferSize = 128;\n-        in = new BufferedInputStream(in, bufferSize);\n+        // Buffer the socket stream to permit efficient parsing of HTTP headers and chunk sizes.\n+        if (!isSpdy()) {\n+            int bufferSize = 128;\n+            in = new BufferedInputStream(in, bufferSize);\n+        }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[connectTimeout-int, readTimeout-int, tunnelConfig-TunnelConfig]",
						"newValue": "[connectTimeout-int, readTimeout-int, tunnelRequest-TunnelRequest]"
					}
				}
			]
		},
		"50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d": {
			"type": "Yfilerename",
			"commitMessage": "Move out of the libcore package.\n\nTo promote the code into AOSP, we'll keep this package as-is\nand do the jarjar in Android instead.\n",
			"commitDate": "2012-12-15, 1:55 PM",
			"commitName": "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d",
			"commitAuthor": "jwilson",
			"commitDateOld": "2012-12-15, 1:17 PM",
			"commitNameOld": "7f7aa90bc5d41d8f818fc988d2a91d22393c7329",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/libcore/net/http/HttpConnection.java",
				"newPath": "src/main/java/com/squareup/okhttp/internal/net/http/HttpConnection.java"
			}
		},
		"3355d0c99bb946a6441f08fe6fd1c9881a9ea96a": {
			"type": "Ymultichange(Yparameterchange,Yreturntypechange,Ymodifierchange,Ybodychange)",
			"commitMessage": "New route selector to support multiple routes.\n",
			"commitDate": "2012-11-10, 1:05 PM",
			"commitName": "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
			"commitAuthor": "Jesse Wilson",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "New route selector to support multiple routes.\n",
					"commitDate": "2012-11-10, 1:05 PM",
					"commitName": "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
					"commitAuthor": "Jesse Wilson",
					"commitDateOld": "2012-11-07, 2:18 PM",
					"commitNameOld": "e5b78cabad22ffdfbbe2755fece9c6c535438cdc",
					"commitAuthorOld": "Jesse Wilson",
					"daysBetweenCommits": 2.95,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,8 +1,24 @@\n-    public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n-            HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout,\n-            TunnelConfig tunnelConfig) throws IOException {\n-        HttpConnection result = getConnection(uri, sslSocketFactory, hostnameVerifier, proxy,\n-                connectTimeout, tunnelConfig);\n-        result.socket.setSoTimeout(readTimeout);\n-        return result;\n+    public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig)\n+            throws IOException {\n+        socket = (proxy.type() != Proxy.Type.HTTP)\n+                ? new Socket(proxy)\n+                : new Socket();\n+        socket.connect(inetSocketAddress, connectTimeout);\n+        socket.setSoTimeout(readTimeout);\n+        in = socket.getInputStream();\n+        out = socket.getOutputStream();\n+\n+        if (address.sslSocketFactory != null) {\n+            upgradeToTls(tunnelConfig);\n+        }\n+\n+        /*\n+         * Buffer the socket stream to permit efficient parsing of HTTP headers\n+         * and chunk sizes. This also masks SSL InputStream's degenerate\n+         * available() implementation. That way we can read the end of a chunked\n+         * response without blocking and will recycle connections more reliably.\n+         * http://code.google.com/p/android/issues/detail?id=38817\n+         */\n+        int bufferSize = 128;\n+        in = new BufferedInputStream(in, bufferSize);\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[uri-URI, sslSocketFactory-SSLSocketFactory, hostnameVerifier-HostnameVerifier, proxy-Proxy, connectTimeout-int, readTimeout-int, tunnelConfig-TunnelConfig]",
						"newValue": "[connectTimeout-int, readTimeout-int, tunnelConfig-TunnelConfig]"
					}
				},
				{
					"type": "Yreturntypechange",
					"commitMessage": "New route selector to support multiple routes.\n",
					"commitDate": "2012-11-10, 1:05 PM",
					"commitName": "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
					"commitAuthor": "Jesse Wilson",
					"commitDateOld": "2012-11-07, 2:18 PM",
					"commitNameOld": "e5b78cabad22ffdfbbe2755fece9c6c535438cdc",
					"commitAuthorOld": "Jesse Wilson",
					"daysBetweenCommits": 2.95,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,8 +1,24 @@\n-    public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n-            HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout,\n-            TunnelConfig tunnelConfig) throws IOException {\n-        HttpConnection result = getConnection(uri, sslSocketFactory, hostnameVerifier, proxy,\n-                connectTimeout, tunnelConfig);\n-        result.socket.setSoTimeout(readTimeout);\n-        return result;\n+    public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig)\n+            throws IOException {\n+        socket = (proxy.type() != Proxy.Type.HTTP)\n+                ? new Socket(proxy)\n+                : new Socket();\n+        socket.connect(inetSocketAddress, connectTimeout);\n+        socket.setSoTimeout(readTimeout);\n+        in = socket.getInputStream();\n+        out = socket.getOutputStream();\n+\n+        if (address.sslSocketFactory != null) {\n+            upgradeToTls(tunnelConfig);\n+        }\n+\n+        /*\n+         * Buffer the socket stream to permit efficient parsing of HTTP headers\n+         * and chunk sizes. This also masks SSL InputStream's degenerate\n+         * available() implementation. That way we can read the end of a chunked\n+         * response without blocking and will recycle connections more reliably.\n+         * http://code.google.com/p/android/issues/detail?id=38817\n+         */\n+        int bufferSize = 128;\n+        in = new BufferedInputStream(in, bufferSize);\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "HttpConnection",
						"newValue": "void"
					}
				},
				{
					"type": "Ymodifierchange",
					"commitMessage": "New route selector to support multiple routes.\n",
					"commitDate": "2012-11-10, 1:05 PM",
					"commitName": "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
					"commitAuthor": "Jesse Wilson",
					"commitDateOld": "2012-11-07, 2:18 PM",
					"commitNameOld": "e5b78cabad22ffdfbbe2755fece9c6c535438cdc",
					"commitAuthorOld": "Jesse Wilson",
					"daysBetweenCommits": 2.95,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,8 +1,24 @@\n-    public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n-            HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout,\n-            TunnelConfig tunnelConfig) throws IOException {\n-        HttpConnection result = getConnection(uri, sslSocketFactory, hostnameVerifier, proxy,\n-                connectTimeout, tunnelConfig);\n-        result.socket.setSoTimeout(readTimeout);\n-        return result;\n+    public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig)\n+            throws IOException {\n+        socket = (proxy.type() != Proxy.Type.HTTP)\n+                ? new Socket(proxy)\n+                : new Socket();\n+        socket.connect(inetSocketAddress, connectTimeout);\n+        socket.setSoTimeout(readTimeout);\n+        in = socket.getInputStream();\n+        out = socket.getOutputStream();\n+\n+        if (address.sslSocketFactory != null) {\n+            upgradeToTls(tunnelConfig);\n+        }\n+\n+        /*\n+         * Buffer the socket stream to permit efficient parsing of HTTP headers\n+         * and chunk sizes. This also masks SSL InputStream's degenerate\n+         * available() implementation. That way we can read the end of a chunked\n+         * response without blocking and will recycle connections more reliably.\n+         * http://code.google.com/p/android/issues/detail?id=38817\n+         */\n+        int bufferSize = 128;\n+        in = new BufferedInputStream(in, bufferSize);\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[public, static]",
						"newValue": "[public]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "New route selector to support multiple routes.\n",
					"commitDate": "2012-11-10, 1:05 PM",
					"commitName": "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
					"commitAuthor": "Jesse Wilson",
					"commitDateOld": "2012-11-07, 2:18 PM",
					"commitNameOld": "e5b78cabad22ffdfbbe2755fece9c6c535438cdc",
					"commitAuthorOld": "Jesse Wilson",
					"daysBetweenCommits": 2.95,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,8 +1,24 @@\n-    public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n-            HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout,\n-            TunnelConfig tunnelConfig) throws IOException {\n-        HttpConnection result = getConnection(uri, sslSocketFactory, hostnameVerifier, proxy,\n-                connectTimeout, tunnelConfig);\n-        result.socket.setSoTimeout(readTimeout);\n-        return result;\n+    public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig)\n+            throws IOException {\n+        socket = (proxy.type() != Proxy.Type.HTTP)\n+                ? new Socket(proxy)\n+                : new Socket();\n+        socket.connect(inetSocketAddress, connectTimeout);\n+        socket.setSoTimeout(readTimeout);\n+        in = socket.getInputStream();\n+        out = socket.getOutputStream();\n+\n+        if (address.sslSocketFactory != null) {\n+            upgradeToTls(tunnelConfig);\n+        }\n+\n+        /*\n+         * Buffer the socket stream to permit efficient parsing of HTTP headers\n+         * and chunk sizes. This also masks SSL InputStream's degenerate\n+         * available() implementation. That way we can read the end of a chunked\n+         * response without blocking and will recycle connections more reliably.\n+         * http://code.google.com/p/android/issues/detail?id=38817\n+         */\n+        int bufferSize = 128;\n+        in = new BufferedInputStream(in, bufferSize);\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"40ff76547064c3fb5acb9047a6f679dd4379a4d0": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Make HttpConnection.connect return full working connections.\n\nPreviously the returned connections required the caller to\ndo extra work: setting up tunnels (which could require auth)\nand performing an SSL handshake. With this change we make a\ncomplete working connection in HttpConnection.connect().\n\nThis will make it easier to fix fallback when a single domain\nhas multiple IP addresses and some of those addresses are not\nreachable.\n\nThis will also make it easier to do SPDY through HTTP proxies.\n",
			"commitDate": "2012-11-05, 8:25 PM",
			"commitName": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
			"commitAuthor": "Jesse Wilson",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Make HttpConnection.connect return full working connections.\n\nPreviously the returned connections required the caller to\ndo extra work: setting up tunnels (which could require auth)\nand performing an SSL handshake. With this change we make a\ncomplete working connection in HttpConnection.connect().\n\nThis will make it easier to fix fallback when a single domain\nhas multiple IP addresses and some of those addresses are not\nreachable.\n\nThis will also make it easier to do SPDY through HTTP proxies.\n",
					"commitDate": "2012-11-05, 8:25 PM",
					"commitName": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
					"commitAuthor": "Jesse Wilson",
					"commitDateOld": "2012-10-25, 9:03 AM",
					"commitNameOld": "2f5e25e4dcac2f7d62a4ac5ee8d49e92de005866",
					"commitAuthorOld": "Jesse Wilson",
					"daysBetweenCommits": 11.52,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,40 +1,8 @@\n     public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n-            Proxy proxy, int connectTimeout) throws IOException {\n-        /*\n-         * Try an explicitly-specified proxy.\n-         */\n-        if (proxy != null) {\n-            Address address = (proxy.type() == Proxy.Type.DIRECT)\n-                    ? new Address(uri, sslSocketFactory)\n-                    : new Address(uri, sslSocketFactory, proxy);\n-            return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n-        }\n-\n-        /*\n-         * Try connecting to each of the proxies provided by the ProxySelector\n-         * until a connection succeeds.\n-         */\n-        ProxySelector selector = ProxySelector.getDefault();\n-        List<Proxy> proxyList = selector.select(uri);\n-        if (proxyList != null) {\n-            for (Proxy selectedProxy : proxyList) {\n-                if (selectedProxy.type() == Proxy.Type.DIRECT) {\n-                    // the same as NO_PROXY\n-                    // TODO: if the selector recommends a direct connection, attempt that?\n-                    continue;\n-                }\n-                try {\n-                    Address address = new Address(uri, sslSocketFactory, selectedProxy);\n-                    return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n-                } catch (IOException e) {\n-                    // failed to connect, tell it to the selector\n-                    selector.connectFailed(uri, selectedProxy.address(), e);\n-                }\n-            }\n-        }\n-\n-        /*\n-         * Try a direct connection. If this fails, this method will throw.\n-         */\n-        return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n+            HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout,\n+            TunnelConfig tunnelConfig) throws IOException {\n+        HttpConnection result = getConnection(uri, sslSocketFactory, hostnameVerifier, proxy,\n+                connectTimeout, tunnelConfig);\n+        result.socket.setSoTimeout(readTimeout);\n+        return result;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[uri-URI, sslSocketFactory-SSLSocketFactory, proxy-Proxy, connectTimeout-int]",
						"newValue": "[uri-URI, sslSocketFactory-SSLSocketFactory, hostnameVerifier-HostnameVerifier, proxy-Proxy, connectTimeout-int, readTimeout-int, tunnelConfig-TunnelConfig]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Make HttpConnection.connect return full working connections.\n\nPreviously the returned connections required the caller to\ndo extra work: setting up tunnels (which could require auth)\nand performing an SSL handshake. With this change we make a\ncomplete working connection in HttpConnection.connect().\n\nThis will make it easier to fix fallback when a single domain\nhas multiple IP addresses and some of those addresses are not\nreachable.\n\nThis will also make it easier to do SPDY through HTTP proxies.\n",
					"commitDate": "2012-11-05, 8:25 PM",
					"commitName": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
					"commitAuthor": "Jesse Wilson",
					"commitDateOld": "2012-10-25, 9:03 AM",
					"commitNameOld": "2f5e25e4dcac2f7d62a4ac5ee8d49e92de005866",
					"commitAuthorOld": "Jesse Wilson",
					"daysBetweenCommits": 11.52,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,40 +1,8 @@\n     public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n-            Proxy proxy, int connectTimeout) throws IOException {\n-        /*\n-         * Try an explicitly-specified proxy.\n-         */\n-        if (proxy != null) {\n-            Address address = (proxy.type() == Proxy.Type.DIRECT)\n-                    ? new Address(uri, sslSocketFactory)\n-                    : new Address(uri, sslSocketFactory, proxy);\n-            return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n-        }\n-\n-        /*\n-         * Try connecting to each of the proxies provided by the ProxySelector\n-         * until a connection succeeds.\n-         */\n-        ProxySelector selector = ProxySelector.getDefault();\n-        List<Proxy> proxyList = selector.select(uri);\n-        if (proxyList != null) {\n-            for (Proxy selectedProxy : proxyList) {\n-                if (selectedProxy.type() == Proxy.Type.DIRECT) {\n-                    // the same as NO_PROXY\n-                    // TODO: if the selector recommends a direct connection, attempt that?\n-                    continue;\n-                }\n-                try {\n-                    Address address = new Address(uri, sslSocketFactory, selectedProxy);\n-                    return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n-                } catch (IOException e) {\n-                    // failed to connect, tell it to the selector\n-                    selector.connectFailed(uri, selectedProxy.address(), e);\n-                }\n-            }\n-        }\n-\n-        /*\n-         * Try a direct connection. If this fails, this method will throw.\n-         */\n-        return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n+            HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout,\n+            TunnelConfig tunnelConfig) throws IOException {\n+        HttpConnection result = getConnection(uri, sslSocketFactory, hostnameVerifier, proxy,\n+                connectTimeout, tunnelConfig);\n+        result.socket.setSoTimeout(readTimeout);\n+        return result;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"5aa2456a145883f6688c6ee325635ed0c6339076": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Fix TLS requiresTunnel which was being computed incorrectly.\n\nWe were only returning 'true' once we were already in a tunnel.\nThis was bogus. In theory a TLS tunnel sending extra data could\nbe corrupted due to this bug.\n\nAlso migrate one of the TLS tunnel tests to use SslContextBuilder\ninstead of TestSSLContext.\n",
			"commitDate": "2012-09-20, 1:01 PM",
			"commitName": "5aa2456a145883f6688c6ee325635ed0c6339076",
			"commitAuthor": "Jesse Wilson",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Fix TLS requiresTunnel which was being computed incorrectly.\n\nWe were only returning 'true' once we were already in a tunnel.\nThis was bogus. In theory a TLS tunnel sending extra data could\nbe corrupted due to this bug.\n\nAlso migrate one of the TLS tunnel tests to use SslContextBuilder\ninstead of TestSSLContext.\n",
					"commitDate": "2012-09-20, 1:01 PM",
					"commitName": "5aa2456a145883f6688c6ee325635ed0c6339076",
					"commitAuthor": "Jesse Wilson",
					"commitDateOld": "2012-09-19, 12:48 PM",
					"commitNameOld": "faeff7f10548151cb2310351b3975f719037f217",
					"commitAuthorOld": "Jesse Wilson",
					"daysBetweenCommits": 1.01,
					"commitsBetweenForRepo": 6,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,41 +1,40 @@\n     public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n-            Proxy proxy, boolean requiresTunnel, int connectTimeout) throws IOException {\n+            Proxy proxy, int connectTimeout) throws IOException {\n         /*\n          * Try an explicitly-specified proxy.\n          */\n         if (proxy != null) {\n             Address address = (proxy.type() == Proxy.Type.DIRECT)\n                     ? new Address(uri, sslSocketFactory)\n-                    : new Address(uri, sslSocketFactory, proxy, requiresTunnel);\n+                    : new Address(uri, sslSocketFactory, proxy);\n             return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n         }\n \n         /*\n          * Try connecting to each of the proxies provided by the ProxySelector\n          * until a connection succeeds.\n          */\n         ProxySelector selector = ProxySelector.getDefault();\n         List<Proxy> proxyList = selector.select(uri);\n         if (proxyList != null) {\n             for (Proxy selectedProxy : proxyList) {\n                 if (selectedProxy.type() == Proxy.Type.DIRECT) {\n                     // the same as NO_PROXY\n                     // TODO: if the selector recommends a direct connection, attempt that?\n                     continue;\n                 }\n                 try {\n-                    Address address = new Address(uri, sslSocketFactory,\n-                            selectedProxy, requiresTunnel);\n+                    Address address = new Address(uri, sslSocketFactory, selectedProxy);\n                     return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n                 } catch (IOException e) {\n                     // failed to connect, tell it to the selector\n                     selector.connectFailed(uri, selectedProxy.address(), e);\n                 }\n             }\n         }\n \n         /*\n          * Try a direct connection. If this fails, this method will throw.\n          */\n         return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[uri-URI, sslSocketFactory-SSLSocketFactory, proxy-Proxy, requiresTunnel-boolean, connectTimeout-int]",
						"newValue": "[uri-URI, sslSocketFactory-SSLSocketFactory, proxy-Proxy, connectTimeout-int]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Fix TLS requiresTunnel which was being computed incorrectly.\n\nWe were only returning 'true' once we were already in a tunnel.\nThis was bogus. In theory a TLS tunnel sending extra data could\nbe corrupted due to this bug.\n\nAlso migrate one of the TLS tunnel tests to use SslContextBuilder\ninstead of TestSSLContext.\n",
					"commitDate": "2012-09-20, 1:01 PM",
					"commitName": "5aa2456a145883f6688c6ee325635ed0c6339076",
					"commitAuthor": "Jesse Wilson",
					"commitDateOld": "2012-09-19, 12:48 PM",
					"commitNameOld": "faeff7f10548151cb2310351b3975f719037f217",
					"commitAuthorOld": "Jesse Wilson",
					"daysBetweenCommits": 1.01,
					"commitsBetweenForRepo": 6,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,41 +1,40 @@\n     public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n-            Proxy proxy, boolean requiresTunnel, int connectTimeout) throws IOException {\n+            Proxy proxy, int connectTimeout) throws IOException {\n         /*\n          * Try an explicitly-specified proxy.\n          */\n         if (proxy != null) {\n             Address address = (proxy.type() == Proxy.Type.DIRECT)\n                     ? new Address(uri, sslSocketFactory)\n-                    : new Address(uri, sslSocketFactory, proxy, requiresTunnel);\n+                    : new Address(uri, sslSocketFactory, proxy);\n             return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n         }\n \n         /*\n          * Try connecting to each of the proxies provided by the ProxySelector\n          * until a connection succeeds.\n          */\n         ProxySelector selector = ProxySelector.getDefault();\n         List<Proxy> proxyList = selector.select(uri);\n         if (proxyList != null) {\n             for (Proxy selectedProxy : proxyList) {\n                 if (selectedProxy.type() == Proxy.Type.DIRECT) {\n                     // the same as NO_PROXY\n                     // TODO: if the selector recommends a direct connection, attempt that?\n                     continue;\n                 }\n                 try {\n-                    Address address = new Address(uri, sslSocketFactory,\n-                            selectedProxy, requiresTunnel);\n+                    Address address = new Address(uri, sslSocketFactory, selectedProxy);\n                     return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n                 } catch (IOException e) {\n                     // failed to connect, tell it to the selector\n                     selector.connectFailed(uri, selectedProxy.address(), e);\n                 }\n             }\n         }\n \n         /*\n          * Try a direct connection. If this fails, this method will throw.\n          */\n         return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"ea63463c2ff8a67f63e541036f0d5998b5bb1f3e": {
			"type": "Yintroduced",
			"commitMessage": "Initial import.\n\nThis is a fork of okhttp from http://code.google.com/p/okhttp.\nI'm moving it to Github since that's where my code reviewers\nare. I've renamed the core package from com.google.okhttp to\ncom.squareup.okhttp because Square is where I expect ongoing\ndevelopment of this project to take place.\n\nAll code in this project is subject to be contributed upstream\nto AOSP. In particular, all code in the libcore package is\nderived from AOSP and intended to be contributed back to AOSP\non an ongoing basis.\n",
			"commitDate": "2012-07-23, 7:02 AM",
			"commitName": "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e",
			"commitAuthor": "Jesse Wilson",
			"diff": "@@ -0,0 +1,41 @@\n+    public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n+            Proxy proxy, boolean requiresTunnel, int connectTimeout) throws IOException {\n+        /*\n+         * Try an explicitly-specified proxy.\n+         */\n+        if (proxy != null) {\n+            Address address = (proxy.type() == Proxy.Type.DIRECT)\n+                    ? new Address(uri, sslSocketFactory)\n+                    : new Address(uri, sslSocketFactory, proxy, requiresTunnel);\n+            return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n+        }\n+\n+        /*\n+         * Try connecting to each of the proxies provided by the ProxySelector\n+         * until a connection succeeds.\n+         */\n+        ProxySelector selector = ProxySelector.getDefault();\n+        List<Proxy> proxyList = selector.select(uri);\n+        if (proxyList != null) {\n+            for (Proxy selectedProxy : proxyList) {\n+                if (selectedProxy.type() == Proxy.Type.DIRECT) {\n+                    // the same as NO_PROXY\n+                    // TODO: if the selector recommends a direct connection, attempt that?\n+                    continue;\n+                }\n+                try {\n+                    Address address = new Address(uri, sslSocketFactory,\n+                            selectedProxy, requiresTunnel);\n+                    return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n+                } catch (IOException e) {\n+                    // failed to connect, tell it to the selector\n+                    selector.connectFailed(uri, selectedProxy.address(), e);\n+                }\n+            }\n+        }\n+\n+        /*\n+         * Try a direct connection. If this fails, this method will throw.\n+         */\n+        return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n+    }\n\\ No newline at end of file\n"
		}
	},
	"sha": "5224f3045ba9b171fce521777edf389f9206173c"
}